;; Transcriber export by stm.tcl,v 1.19 on Tue Dec 18 16:58:27 CET 2018 with encoding ISO-8859-1
;; transcribed by , version 4 of 170621
;;
;; CATEGORY "0" "" ""
;; LABEL "O" "Overall" "Overall"
;;
;; CATEGORY "1" "Hub4 Focus Conditions" ""
;; LABEL "F0" "Baseline//Broadcast//Speech" ""
;; LABEL "F1" "Spontaneous//Broadcast//Speech" ""
;; LABEL "F2" "Speech Over//Telephone//Channels" ""
;; LABEL "F3" "Speech in the//Presence of//Background Music" ""
;; LABEL "F4" "Speech Under//Degraded//Acoustic Conditions" ""
;; LABEL "F5" "Speech from//Non-Native//Speakers" ""
;; LABEL "FX" "All other speech" ""
;; CATEGORY "2" "Speaker Sex" ""
;; LABEL "female" "Female" ""
;; LABEL "male"   "Male" ""
;; LABEL "unknown"   "Unknown" ""
20131025 1 inter_segment_gap 0.000 0.490 <o,f0,>
20131025 1 20131025_Locuteur_1 0.490 3.579 <o,f4,male> alors bon() bonjour à tous
20131025 1 20131025_Locuteur_1 3.579 7.745 <o,f4,male> si vous êtes là aujourd'hui, c'est pour entendre parler de cryptographie
20131025 1 20131025_Locuteur_1 7.745 10.511 <o,f4,male> donc la cryptographie, c'est la science du secret
20131025 1 20131025_Locuteur_1 10.511 15.095 <o,f4,male> mais on prétend pas, en une heure vingt, faire un cours de cryptographie mais euh
20131025 1 20131025_Locuteur_1 15.095 19.181 <o,f4,male> ce qu'on va essayer de de voir aujourd'hui, c'est euh quelques bases
20131025 1 20131025_Locuteur_1 19.181 22.924 <o,f4,male> de ce qu'on appelle la cryptographie, d'un certain nombre d'exemples
20131025 1 20131025_Locuteur_1 22.924 26.381 <o,f4,male> euh de de protocoles cryptographiques
20131025 1 20131025_Locuteur_1 26.381 30.840 <o,f4,male> qui ont été inventés euh il y a très longtemps, depuis l'antiquité
20131025 1 20131025_Locuteur_1 30.840 33.516 <o,f4,male> et euh qu'on continue à inventer aujourd'hui.
20131025 1 20131025_Locuteur_1 33.516 38.440 <o,f4,male> voilà. on va faire un petit panorama historique de ce que () ce qu'on appelle la cryptographie
20131025 1 20131025_Locuteur_1 38.440 41.059 <o,f4,male> mais avant de commencer
20131025 1 20131025_Locuteur_1 41.059 42.560 <o,f4,male> on va voir
20131025 1 20131025_Locuteur_1 42.560 44.600 <o,f4,male> avant de commencer, on va
20131025 1 20131025_Locuteur_1 44.600 53.013 <o,f4,male> on va voir dans quel cadre s'inscrit la cryptographie. donc la cryptogaphie ça s'inscrit dans le cadre de ce qu'on appelle la théorie de l'information
20131025 1 20131025_Locuteur_1 53.013 54.007 <o,f4,male> un peu de silence !
20131025 1 20131025_Locuteur_1 54.007 58.501 <o,f4,male> en théorie de l'information, ce qu'on cherche à faire, c'est coder l'information
20131025 1 20131025_Locuteur_1 58.501 61.720 <o,f4,male> et étudier l'information qu'on a codée.
20131025 1 20131025_Locuteur_1 61.720 66.875 <o,f4,male> alors le premier transparent, ça sert à à faire quelques rap() quelques rappels du premier cours que vous avez eu
20131025 1 20131025_Locuteur_1 66.875 68.740 <o,f4,male> sur comment on fait pour coder l'information.
20131025 1 20131025_Locuteur_1 68.740 71.427 <o,f4,male> en mémoire, l'information est codée sous forme de
20131025 1 20131025_Locuteur_1 71.427 74.810 <o,f4,male> de suites binaires, donc on peut en mémoire euh
20131025 1 20131025_Locuteur_1 74.810 78.795 <o,f4,male> stocker que des que des nombres zéros ou uns [pi] interrupteurs
20131025 1 20131025_Locuteur_1 78.795 81.200 <o,f4,male> euh grossièrement.
20131025 1 20131025_Locuteur_1 81.200 85.193 <o,f4,male> donc la première information qu'on va vouloir stocker en mémoire, ce seront les entiers
20131025 1 20131025_Locuteur_1 85.193 88.913 <o,f4,male> et les entiers, vous avez tous vu comment on les stockait.
20131025 1 20131025_Locuteur_1 88.913 92.359 <o,f4,male> pour stocker un entier, il suffit de prendre sa décomposition binaire
20131025 1 20131025_Locuteur_1 92.359 99.108 <o,f4,male> donc vous avez un exemple ici : la décomposition binaire de cent trente-cinq, c'est un zéro zéro zéro zéro un un un
20131025 1 20131025_Locuteur_1 99.108 104.550 <o,f4,male> donc un interrupteur allumé, quatre interrupteurs éteints, trois interrupteurs allumés
20131025 1 20131025_Locuteur_1 104.550 108.470 <o,f4,male> qui représentent donc le nombre cent trente-cinq puisque on pourra le réécrire
20131025 1 20131025_Locuteur_1 108.470 111.130 <o,f4,male> en utilisant des puissances de deux
20131025 1 20131025_Locuteur_1 111.130 112.830 <o,f4,male> donc le nombre cent trente-cinq, c'est
20131025 1 20131025_Locuteur_1 112.830 117.849 <o,f4,male> un fois deux à la puissance sept plus
20131025 1 20131025_Locuteur_1 117.849 125.651 <o,f4,male> un fois deux à la puissance six [pi] plus zéro [pi] deux à la puissance six, et cetera et cetera. donc ça c'est le passage de l'écriture binaire à l'écriture décimale.
20131025 1 20131025_Locuteur_1 125.651 129.769 <o,f4,male> vous avez certainement vu ça en [pi] en cours de mathématiques
20131025 1 20131025_Locuteur_1 129.769 132.830 <o,f4,male> alors une fois qu'on a des entiers, on peut s() on peut faire plein de choses
20131025 1 20131025_Locuteur_1 132.830 138.169 <o,f4,male> une fois qu'on a des entiers, on peut stocker des des réels. des réels informatiques, ce qu'on appelle les flottants
20131025 1 20131025_Locuteur_1 138.169 140.904 <o,f4,male> en utilisant la notation ingénieur.
20131025 1 20131025_Locuteur_1 140.904 143.433 <o,f4,male> ça, on a vu ça en cours la la première fois
20131025 1 20131025_Locuteur_1 143.433 146.071 <o,f4,male> pour stocker un réel, ben il suffit
20131025 1 20131025_Locuteur_1 146.071 149.913 <o,f4,male> de définir deux entiers, qu'on appellera mantisse et exposant
20131025 1 20131025_Locuteur_1 149.913 152.314 <o,f4,male> et chaque nombre réel peut s'écrire
20131025 1 20131025_Locuteur_1 152.314 154.733 <o,f4,male> [pi] peut s'écrire
20131025 1 20131025_Locuteur_1 154.733 159.222 <o,f4,male> douze () mille deux cent quarante-sept exposant moins deux.
20131025 1 20131025_Locuteur_1 159.222 160.901 <o,f4,male> exposant moins deux
20131025 1 20131025_Locuteur_1 160.901 162.299 <o,f4,male> donc avec
20131025 1 20131025_Locuteur_1 162.299 164.454 <o,f4,male> deux entiers.
20131025 1 20131025_Locuteur_1 164.454 169.859 <o,f4,male> une fois qu'on sait coder des entiers, on sait aussi coder des caractères. ça encore, on l'a vu au premier cours.
20131025 1 20131025_Locuteur_1 169.859 175.520 <o,f4,male> il suffit d'utiliser une table de correspondance entre des caractères et des entiers ; cette table, on l'appelle la table ascii
20131025 1 20131025_Locuteur_1 175.520 182.663 <o,f4,male> ou euh ou la table unicode que vous *verrez que vous verrez un peu plus tard dans le cours du () dans le cours de traitement automatique des langues naturelles.
20131025 1 20131025_Locuteur_1 182.663 184.982 <o,f4,male> donc à chaque caractère s'associe un entier.
20131025 1 20131025_Locuteur_1 184.982 190.546 <o,f4,male> et c'est donc () chaque caractère, on peut le coder en mémoire ; on peut coder des textes en mémoire.
20131025 1 20131025_Locuteur_1 190.546 195.177 <o,f4,male> pour de l'information un peu plus compliquée, bah on va utiliser des petits stratagèmes
20131025 1 20131025_Locuteur_1 195.177 196.570 <o,f4,male> euh
20131025 1 20131025_Locuteur_1 196.570 198.939 <o,f4,male> pour coder une couleur, par exemple
20131025 1 20131025_Locuteur_1 198.939 200.660 <o,f4,male> un point d'une image
20131025 1 20131025_Locuteur_1 200.660 207.240 <o,f4,male> on va utiliser un codage de cette couleur sous forme d'une décomposition en composantes de rouge, de vert et de bleu
20131025 1 20131025_Locuteur_1 207.240 213.670 <o,f4,male> et [pi] un certain nombre de niveaux de couleurs pour chaque euh composante de rouge, de vert et de bleu.
20131025 1 20131025_Locuteur_1 213.670 216.041 <o,f4,male> donc ici, ça va coder couleur
20131025 1 20131025_Locuteur_1 216.041 218.918 <o,f4,male> dont la composante est
20131025 1 20131025_Locuteur_1 218.918 220.598 <o,f4,male> du rouge moyen
20131025 1 20131025_Locuteur_1 220.598 226.473 <o,f4,male> le nombre qu'on peut mettre, c'est un nombre entre zéro et deux cent cinquante-cinq, donc cent vingt-six c'est le () c'est au milieu
20131025 1 20131025_Locuteur_1 226.473 230.314 <o,f4,male> un peu plus de vert et euh un peu plus de bleu ; donc ça va être un un gris.
20131025 1 20131025_Locuteur_1 230.314 234.290 <o,f4,male> une sorte de gris [pi]
20131025 1 20131025_Locuteur_1 234.290 239.212 <o,f4,male> donc euh les les couleurs [pi] voilà, les couleurs
20131025 1 20131025_Locuteur_1 239.212 240.440 <o,f4,male> hop
20131025 1 20131025_Locuteur_1 240.440 249.090 <o,f4,male> on peut on peut euh stocker n'importe quelle couleur de ce type-là ; on peut définir n'importe quelle couleur de ce type-là [pi] rien qu'avec des composantes de rouge, de vert et de bleu.
20131025 1 20131025_Locuteur_1 249.090 252.563 <o,f4,male> et pour la petite histoire, ça c'est () ça a été fait grâce à l'interface
20131025 1 20131025_Locuteur_1 252.563 257.719 <o,f4,male> en utilisant le petit code que vous avez là, et que vous retrouverez évidemment en ligne.
20131025 1 20131025_Locuteur_1 257.719 259.938 <o,f4,male> pour stocker du son,
20131025 1 20131025_Locuteur_1 259.938 262.347 <o,f4,male> ben le son c'est euh
20131025 1 20131025_Locuteur_1 262.347 268.859 <o,f4,male> un son c'est euh un signal électrique qui permet de faire se () de faire vibrer une membrane, la membrane de votre euh
20131025 1 20131025_Locuteur_1 268.859 270.570 <o,f4,male> de votre haut-parleur.
20131025 1 20131025_Locuteur_1 270.570 274.549 <o,f4,male> donc il faut être capable de stocker un signal électrique
20131025 1 20131025_Locuteur_1 274.549 276.731 <o,f4,male> un peu sinusoïdal
20131025 1 20131025_Locuteur_1 276.731 278.580 <o,f4,male> en mémoire.
20131025 1 20131025_Locuteur_1 278.580 282.158 <o,f4,male> donc ça aussi, on pourra le faire avec des entiers
20131025 1 20131025_Locuteur_1 282.158 283.730 <o,f4,male> par exemple
20131025 1 20131025_Locuteur_1 283.730 289.944 <o,f4,male> en en décomposant le le son, en coupant le son par petites bandes, on appellera ça l'échantillonnage
20131025 1 20131025_Locuteur_1 289.944 294.180 <o,f4,male> et puis en permettant que chaque bande fasse une hauteur
20131025 1 20131025_Locuteur_1 294.180 295.821 <o,f4,male> entière
20131025 1 20131025_Locuteur_1 295.821 299.931 <o,f4,male> voilà. le signal sinusoïdal que vous avez là,
20131025 1 20131025_Locuteur_1 299.931 302.713 <o,f4,male> on peut le réécrire
20131025 1 20131025_Locuteur_1 302.713 305.590 <o,f4,male> euh sous forme de petites bandes
20131025 1 20131025_Locuteur_1 305.590 308.090 <o,f4,male> chaque bande aura une hauteur entière
20131025 1 20131025_Locuteur_1 308.090 312.918 <o,f4,male> correspondant quasiment à la hauteur qu'on souhaite dans le signal analogique,
20131025 1 20131025_Locuteur_1 312.918 317.621 <o,f4,male> mais ce sera un s() euh codé par un tableau de () d'entiers.
20131025 1 20131025_Locuteur_1 317.621 320.090 <o,f4,male> voilà, donc un son on peut le stocker par un tableau d'entiers.
20131025 1 20131025_Locuteur_1 320.090 329.688 <o,f4,male> si les images et les sons, on peut les stocker sous forme entière comme ça, sous forme [pi] c'est parce que l'oeil et l'oreille ne sont pas capables de discerner des sons extrêmement précis.
20131025 1 20131025_Locuteur_1 329.688 337.218 <o,f4,male> donc on on peut se permettre de perdre un peu d'information quand on stocke des des images ou quand on stocke des sons.
20131025 1 20131025_Locuteur_1 337.218 341.219 <o,f4,male> voilà, donc au final du point de vue de la machine, l'information c'est une suite de bits
20131025 1 20131025_Locuteur_1 341.219 344.595 <o,f4,male> et puis on traitera cette suite de bits.
20131025 1 20131025_Locuteur_1 344.595 350.955 <o,f4,male> la théorie de l'information, c'est euh la science qui traite ces suites de bits d'information.
20131025 1 20131025_Locuteur_1 350.955 353.330 <o,f4,male> stop
20131025 1 20131025_Locuteur_1 353.330 355.192 <o,f4,male> voilà
20131025 1 20131025_Locuteur_1 355.192 360.028 <o,f4,male> alors quand on veut traiter cette suite euh cette information, on a trois préoccupations
20131025 1 20131025_Locuteur_1 360.028 361.467 <o,f4,male> en théorie de l'information.
20131025 1 20131025_Locuteur_1 361.467 363.670 <o,f4,male> la première préoccupation
20131025 1 20131025_Locuteur_1 363.670 365.970 <o,f4,male> va consister à ce que l'information
20131025 1 20131025_Locuteur_1 365.970 367.970 <o,f4,male> qu'on envoie sur un
20131025 1 20131025_Locuteur_1 367.970 370.996 <o,f4,male> sur un canal téléphonique
20131025 1 20131025_Locuteur_1 370.996 374.137 <o,f4,male> soit la même que celle qu'on reçoit.
20131025 1 20131025_Locuteur_1 374.137 377.200 <o,f4,male> et ça, c'est compliqué parce que euh il y a de la perte
20131025 1 20131025_Locuteur_1 377.200 383.135 <o,f4,male> sur les sur les canaux téléphoniques, dans les fils électriques il y a de la perte, il y a des
20131025 1 20131025_Locuteur_1 383.135 385.229 <o,f4,male> des perturbations du signal
20131025 1 20131025_Locuteur_1 385.229 387.479 <o,f4,male> euh c'est encore pire quand euh
20131025 1 20131025_Locuteur_1 387.479 392.110 <o,f4,male> quand on envoie euh par satellite des des des communications
20131025 1 20131025_Locuteur_1 392.110 398.885 <o,f4,male> et c'est encore pire quand on les stocke sur un support comme un cd, puisque le support peut typiquement être rayé.
20131025 1 20131025_Locuteur_1 398.885 403.580 <o,f4,male> alors voilà, il y a une première préoccupation, c'est euh si on perd de l'information
20131025 1 20131025_Locuteur_1 403.580 406.551 <o,f4,male> comment on fait pour retrouver cette information perdue ?
20131025 1 20131025_Locuteur_1 406.551 410.070 <o,f4,male> le signal il est gravé, quand même
20131025 1 20131025_Locuteur_1 410.070 412.101 <o,f4,male> alors pour ça
20131025 1 20131025_Locuteur_1 412.101 418.560 <o,f4,male> on va utiliser ce qu'on appelle des codes détecteurs d'erreurs ou des codes correcteurs d'erreurs.
20131025 1 20131025_Locuteur_1 418.560 420.824 <o,f4,male> alors le principe est très très simple :
20131025 1 20131025_Locuteur_1 420.824 426.720 <o,f4,male> un exemple de code correcteur d'erreurs, c'est ce qu'on appelle le bit de parité.
20131025 1 20131025_Locuteur_1 426.720 429.770 <o,f4,male> ce bit de parité [pi] ça prend des petits blocs
20131025 1 20131025_Locuteur_1 429.770 431.500 <o,f4,male> de sept bits
20131025 1 20131025_Locuteur_1 431.500 436.060 <o,f4,male> de rajouter un () de rajouter un bit supplémentaire au signal qu'on envoie
20131025 1 20131025_Locuteur_1 436.060 439.586 <o,f4,male> qui sera la somme modulo deux de tous les
20131025 1 20131025_Locuteur_1 439.586 442.258 <o,f4,male> de tous les bits qui précèdent, donc des sept bits qui précèdent.
20131025 1 20131025_Locuteur_1 442.258 445.664 <o,f4,male> donc si on regarde ce qu'il y a là, on a un zéro plus un
20131025 1 20131025_Locuteur_1 445.664 450.603 <o,f4,male> ça fait un, plus zéro ça reste un, plus un ça fait zéro modulo deux
20131025 1 20131025_Locuteur_1 450.603 454.572 <o,f4,male> plus un, plus zéro, plus un, le tout ça fait zéro modulo deux, on met zéro.
20131025 1 20131025_Locuteur_1 454.572 455.806 <o,f4,male> et on ajoute
20131025 1 20131025_Locuteur_1 455.806 458.951 <o,f4,male> tous les sept bits, on ajoute un bit de parité.
20131025 1 20131025_Locuteur_1 458.951 460.848 <o,f4,male> donc qu'est-ce que ça permet, ça ?
20131025 1 20131025_Locuteur_1 460.848 463.690 <o,f4,male> ben ça permet que lorsque l'information est transmise
20131025 1 20131025_Locuteur_1 463.690 467.013 <o,f4,male> avec erreurs, ben les erreurs on va les retrouver ici :
20131025 1 20131025_Locuteur_1 467.013 471.232 <o,f4,male> il y en a il y en a une qui s'est produite ici, ça [pi] on a un.
20131025 1 20131025_Locuteur_1 471.232 474.420 <o,f4,male> il y en a une qui s'est produite ici, qui transforme un un en zéro ;
20131025 1 20131025_Locuteur_1 474.420 477.349 <o,f4,male> ben cette information-là, on pourra la détecter
20131025 1 20131025_Locuteur_1 477.349 478.975 <o,f4,male> grâce au bit de parité
20131025 1 20131025_Locuteur_1 478.975 480.147 <o,f4,male> puisque euh
20131025 1 20131025_Locuteur_1 480.147 481.610 <o,f4,male> ça va changer la
20131025 1 20131025_Locuteur_1 481.610 484.485 <o,f4,male> si on change un zéro en un un ici, ben la somme est plus la même
20131025 1 inter_segment_gap 484.485 485.640 <o,f4,>
20131025 1 20131025_Locuteur_1 485.640 489.283 <o,f4,male> comme la somme est plus la même, on peut dire que avant il y a une erreur ;
20131025 1 20131025_Locuteur_1 489.283 492.934 <o,f4,male> on détecte l'erreur.
20131025 1 20131025_Locuteur_1 492.934 497.710 <o,f4,male> alors ça permet donc l() ici on détecte des erreurs de complétion dans deux blocs
20131025 1 20131025_Locuteur_1 497.710 501.070 <o,f4,male> et ce qu'on voit, c'est qu'en ajoutant un bit tous les sept bits,
20131025 1 20131025_Locuteur_1 501.070 505.055 <o,f4,male> donc on a on a [pi] la taille du signal de quatorze pour cent
20131025 1 20131025_Locuteur_1 505.055 507.618 <o,f4,male> on est capable de détecter
20131025 1 20131025_Locuteur_1 507.618 511.070 <o,f4,male> une erreur sous les blocs de sept bits.
20131025 1 20131025_Locuteur_1 511.070 518.427 <o,f4,male> l'action des codes détecteurs d'erreurs, c'est de définir des nouveaux codes correcteurs qui permettent non seulement de détecter une erreur
20131025 1 20131025_Locuteur_1 518.427 522.442 <o,f4,male> mais de détecter où est l'erreur et de la corriger
20131025 1 20131025_Locuteur_1 522.442 527.286 <o,f4,male> en ajoutant évidemment beaucoup plus d'informations que quatorze pour cent. en général c'est () on multiplie le
20131025 1 20131025_Locuteur_1 527.286 530.348 <o,f4,male> le signal par trois ; donc il faut ajouter trois fois
20131025 1 20131025_Locuteur_1 530.348 534.731 <o,f4,male> euh la taille du signal pour être capable de corriger le signal,
20131025 1 20131025_Locuteur_1 534.731 535.805 <o,f4,male> mais ça fonctionne.
20131025 1 20131025_Locuteur_1 535.805 538.492 <o,f4,male> ça fonctionne, puisque vous êtes capables d'écouter un cd rayé
20131025 1 20131025_Locuteur_1 538.492 541.053 <o,f4,male> jusqu'à un certain point.
20131025 1 20131025_Locuteur_1 541.053 546.370 <o,f4,male> la deuxième préoccupation, c'est que l'information se transmette rapidement
20131025 1 20131025_Locuteur_1 546.370 553.040 <o,f4,male> alors rapidement dans le sens où euh maintenant on veut envoyer () avant on on était euh raisonnable
20131025 1 20131025_Locuteur_1 553.040 561.180 <o,f4,male> on voulait s'envoyer des textes pendant les années soixante-dix, dans les années euh quatre-vingts, quatre-vingt-dix on a voulu s'envoyer des textes et des images
20131025 1 20131025_Locuteur_1 561.180 570.470 <o,f4,male> maintenant on en est à vouloir s'envoyer des signaux euh on v() on veut s'envoyer de la télévision sur internet, donc à chaque fois on veut s'envoyer des très très gros euh fichiers
20131025 1 20131025_Locuteur_1 570.470 572.173 <o,f4,male> et si ça
20131025 1 20131025_Locuteur_1 572.173 574.570 <o,f4,male> la qualité des des canaux
20131025 1 20131025_Locuteur_1 574.570 576.280 <o,f4,male> s'améliore
20131025 1 20131025_Locuteur_1 576.280 580.184 <o,f4,male> mais l'amélioration des canaux n'est pas suffisante pour euh
20131025 1 20131025_Locuteur_1 580.184 583.590 <o,f4,male> l'usage qu'on a envie d'en faire.
20131025 1 20131025_Locuteur_1 583.590 584.240 <o,f4,male> donc
20131025 1 20131025_Locuteur_1 584.240 586.780 <o,f4,male> pour envoyer plus d'information,
20131025 1 20131025_Locuteur_1 586.780 591.470 <o,f4,male> une manière de faire, c'est de compresser l'information, donc de la rendre plus petite.
20131025 1 20131025_Locuteur_1 591.470 595.900 <o,f4,male> on va prendre un petit exemple.
20131025 1 20131025_Locuteur_1 595.900 601.060 <o,f4,male> alors un petit calcul autour de la vidéo haute définition
20131025 1 20131025_Locuteur_1 601.060 611.319 <o,f4,male> une image de vidéo haute définition, c'est une image qui fait une taille de mille vingt-quatre euh pixels de large et mille quatre-vingts pixels de haut.
20131025 1 20131025_Locuteur_1 611.319 615.997 <o,f4,male> comme on a vu, pour pour coder une image, il faut trois
20131025 1 20131025_Locuteur_1 615.997 617.146 <o,f4,male> trois nombres
20131025 1 20131025_Locuteur_1 617.146 620.027 <o,f4,male> trois nombres de huit bits.
20131025 1 20131025_Locuteur_1 620.027 622.154 <o,f4,male> au final, donc, pour coder
20131025 1 20131025_Locuteur_1 622.154 625.916 <o,f4,male> une ima() une image en haute définition, il faut
20131025 1 20131025_Locuteur_1 625.916 629.510 <o,f4,male> trente-trois millions de bits par image
20131025 1 20131025_Locuteur_1 629.510 632.886 <o,f4,male> des images, on va en transmettre beaucoup quand on fait une vidéo :
20131025 1 20131025_Locuteur_1 632.886 636.020 <o,f4,male> la vidéo, elle se transmet à trente images par seconde.
20131025 1 20131025_Locuteur_1 636.020 641.977 <o,f4,male> donc si on fait un petit calcul, il faut un mil() il faut être capable d'envoyer un milliard de bits par seconde pour transmettre
20131025 1 20131025_Locuteur_1 641.977 643.350 <o,f4,male> une seconde de
20131025 1 20131025_Locuteur_1 643.350 645.542 <o,f4,male> pour transmettre une vidéo.
20131025 1 20131025_Locuteur_1 645.542 651.320 <o,f4,male> un milliard de bits par seconde, ça fait à peu près cent vingt-cinq mégaoctets par seconde.
20131025 1 20131025_Locuteur_1 651.320 657.420 <o,f4,male> voilà. quand on veut stocker une vidéo hd, on veut stocker cent vingt-cinq mégaoctets par seconde.
20131025 1 20131025_Locuteur_1 657.420 662.555 <o,f4,male> si on souhaitait la stocker sur un cd, un cd dont la capacité c'est sept cents mégaoctets
20131025 1 20131025_Locuteur_1 662.555 669.978 <o,f4,male> alors on stockerait environ cinq secondes de vidéo sur un cd.
20131025 1 20131025_Locuteur_1 669.978 674.040 <o,f4,male> si on voulait la stocker sur un dvd, c'est une forme moderne
20131025 1 20131025_Locuteur_1 674.040 675.986 <o,f4,male> dont la capacité est de huit gigaoctets,
20131025 1 20131025_Locuteur_1 675.986 681.427 <o,f4,male> on serait capable de stocker à peu près une minute de vidéo non compressée.
20131025 1 20131025_Locuteur_1 681.427 683.149 <o,f4,male> alors euh
20131025 1 20131025_Locuteur_1 683.149 686.660 <o,f4,male> ça ça vous parle peut-être pas, mais euh prenons un film
20131025 1 20131025_Locuteur_1 686.660 689.647 <o,f4,male> le film le parrain
20131025 1 20131025_Locuteur_1 689.647 694.484 <o,f4,male> qui fait cent soixante-huit minutes, ben si on voulait stocker le parrain sur des dvd, il en faudrait cent soixante-huit
20131025 1 20131025_Locuteur_1 694.484 696.307 <o,f4,male> toutes les minutes faut changer de dvd.
20131025 1 20131025_Locuteur_1 696.307 701.850 <o,f4,male> donc évidemment, vous vous doutez bien que c'est pas comme ça que ça marche.
20131025 1 20131025_Locuteur_1 701.850 704.584 <o,f4,male> parce que le parrain
20131025 1 20131025_Locuteur_1 704.584 708.212 <o,f4,male> vous savez très bien ce qu'il y a sur un dvd
20131025 1 20131025_Locuteur_1 708.212 710.053 <o,f4,male> et puisque vous faites
20131025 1 20131025_Locuteur_1 710.053 712.310 <o,f4,male> vous ne téléchargez pas sur internet et euh
20131025 1 20131025_Locuteur_1 712.310 714.000 <o,f4,male> vous av() vous savez que ça existe
20131025 1 20131025_Locuteur_1 714.000 716.119 <o,f4,male> et vous savez que le parrain
20131025 1 20131025_Locuteur_1 716.119 718.272 <o,f4,male> on peut même le faire tenir sur un cd
20131025 1 20131025_Locuteur_1 718.272 722.552 <o,f4,male> à condition de le compresser dans un bon format.
20131025 1 20131025_Locuteur_1 722.552 726.130 <o,f4,male> donc la compression, ça ça consiste à réduire la taille
20131025 1 20131025_Locuteur_1 726.130 727.604 <o,f4,male> des fichiers,
20131025 1 20131025_Locuteur_1 727.604 729.633 <o,f4,male> tout en préservant la qualité
20131025 1 20131025_Locuteur_1 729.633 730.740 <o,f4,male> des fichiers.
20131025 1 20131025_Locuteur_1 730.740 736.511 <o,f4,male> [pi] le le fait que ça stocke quand même un film.
20131025 1 20131025_Locuteur_1 736.511 739.758 <o,f4,male> donc j'arrête là les les calculs.
20131025 1 20131025_Locuteur_1 739.758 742.796 <o,f4,male> ce qui va nous intéresser aujourd'hui, c'est la troisième préoccupation
20131025 1 20131025_Locuteur_1 742.796 745.180 <o,f4,male> c'est la préoccupation que certaines informations
20131025 1 20131025_Locuteur_1 745.180 748.375 <o,f4,male> sont importantes, et on n'a pas envie qu'elles soient divulguées
20131025 1 20131025_Locuteur_1 748.375 753.631 <o,f4,male> donc on a envie de transmettre l'information mais de manière protégée.
20131025 1 20131025_Locuteur_1 753.631 762.095 <o,f4,male> donc par exemple on veut euh en() on veut être sûr que le code de notre carte bleue, il circule pas euh de manière claire sur le réseau, il peut pas être intercepté.
20131025 1 20131025_Locuteur_1 762.095 764.703 <o,f4,male> on a envie que certaines conversations
20131025 1 20131025_Locuteur_1 764.703 769.280 <o,f4,male> typiquement euh ça ça ça c'est d'actualité hein euh vous avez entendu parler de la [pi]
20131025 1 20131025_Locuteur_1 769.280 772.938 <o,f4,male> on a envie () on n'a pas envie que ça arrive.
20131025 1 20131025_Locuteur_1 772.938 774.290 <o,f4,male> donc pour
20131025 1 20131025_Locuteur_1 774.290 775.799 <o,f4,male> que
20131025 1 20131025_Locuteur_1 775.799 780.683 <o,f4,male> pour mettre en en oeuvre ces protocoles euh de sécurité
20131025 1 20131025_Locuteur_1 780.683 789.361 <o,f4,male> on parle euh on utilise des techniques de cryptographie, et c'est ce dont je vais vous parler aujourd'hui.u
20131025 1 20131025_Locuteur_1 789.361 791.120 <o,f4,male> dans ces trois choses
20131025 1 20131025_Locuteur_1 791.120 796.140 <o,f4,male> il y a un terme qui est important, qui s'appelle la redondance. alors qu'est-ce que c'est que la redondance ?
20131025 1 20131025_Locuteur_1 796.140 798.560 <o,f4,male> euh ben la redondance, c'est euh
20131025 1 20131025_Locuteur_1 798.560 803.570 <o,f4,male> c'est le fait que s() un certain nombre de caractères ne soient pas utiles. par exemple, si je vous écris :
20131025 1 20131025_Locuteur_1 803.570 806.460 <o,f4,male> mon nom est yves puis j'oublie des lettres
20131025 1 20131025_Locuteur_1 806.460 808.560 <o,f4,male> parce qu'elles ont été effacées,
20131025 1 20131025_Locuteur_1 808.560 812.186 <o,f4,male> vous êtes tous capables de de le retrouver, mon nom
20131025 1 20131025_Locuteur_1 812.186 814.560 <o,f4,male> parce que vous avez un certain nombre d'informations.
20131025 1 20131025_Locuteur_1 814.560 817.019 <o,f4,male> les lettres que j'ai enlevées, elles ne servent pas,
20131025 1 20131025_Locuteur_1 817.019 818.744 <o,f4,male> elles sont redondantes.
20131025 1 20131025_Locuteur_1 818.744 820.632 <o,f4,male> si je voulais compresser mon nom,
20131025 1 20131025_Locuteur_1 820.632 824.773 <o,f4,male> il suffirait d'enlever un certain nombre de lettres et vous () à partir du moment où vous êtes capable
20131025 1 20131025_Locuteur_1 824.773 828.725 <o,f4,male> de retrouver ce que j'ai enlevé, c'est que ce que j'ai enlevé ne servait pas.
20131025 1 20131025_Locuteur_1 828.725 830.652 <o,f4,male> c'est redondant.
20131025 1 20131025_Locuteur_1 830.652 837.640 <o,f4,male> alors toutes les lettres n'ont pas le même statut de redondance, par exemple si je vous donne mon numéro de téléphone
20131025 1 20131025_Locuteur_1 837.640 839.873 <o,f4,male> le premier caractère que je vais enlever,
20131025 1 20131025_Locuteur_1 839.873 841.590 <o,f4,male> vous savez lequel c'est
20131025 1 20131025_Locuteur_1 841.590 843.780 <o,f4,male> c'est un zéro, forcément.
20131025 1 20131025_Locuteur_1 843.780 846.165 <o,f4,male> mais par contre celui que j'ai enlevé ici,
20131025 1 20131025_Locuteur_1 846.165 848.014 <o,f4,male> vous êtes pas capables de le retrouver
20131025 1 20131025_Locuteur_1 848.014 851.026 <o,f4,male> sans faire dix essais.
20131025 1 20131025_Locuteur_1 851.026 852.044 <o,f4,male> donc
20131025 1 20131025_Locuteur_1 852.044 853.894 <o,f4,male> le premier est redondant,
20131025 1 20131025_Locuteur_1 853.894 856.087 <o,f4,male> celui-là ne l'est pas.
20131025 1 20131025_Locuteur_1 856.087 857.480 <o,f4,male> voilà
20131025 1 20131025_Locuteur_1 857.480 863.646 <o,f4,male> donc qu'est-ce qu'on va faire en théorie de l'information ? on va retirer de la redondance pour compresser
20131025 1 20131025_Locuteur_1 863.646 865.369 <o,f4,male> mais par contre
20131025 1 20131025_Locuteur_1 865.369 868.212 <o,f4,male> si on veut repérer des erreurs et les détecter
20131025 1 20131025_Locuteur_1 868.212 869.966 <o,f4,male> il faut en ajouter, de la redondance
20131025 1 20131025_Locuteur_1 869.966 872.036 <o,f4,male> je vous ai dit, ça peut aller jusqu'à euh
20131025 1 20131025_Locuteur_1 872.036 875.991 <o,f4,male> multiplier la taille du signal par trois.
20131025 1 20131025_Locuteur_1 875.991 879.974 <o,f4,male> et puis euh on va utiliser de la redondance
20131025 1 20131025_Locuteur_1 879.974 883.770 <o,f4,male> quand on cherchera à dé() attaquer un un protocole cryptographique
20131025 1 20131025_Locuteur_1 883.770 886.630 <o,f4,male> on se *servira on se servira du fait que le
20131025 1 20131025_Locuteur_1 886.630 889.963 <o,f4,male> le texte codé on sait que c'est du français, par exemple.
20131025 1 20131025_Locuteur_1 889.963 894.477 <o,f4,male> du français avec toutes les redondances qu'il y a dans le français
20131025 1 20131025_Locuteur_1 894.477 899.542 <o,f4,male> d'accord ? donc voilà, le terme important c'est la redondance.
20131025 1 20131025_Locuteur_1 899.542 903.899 <o,f4,male> le plan du cours d'aujourd'hui, donc ça c'était l'introduction, le plan du cours d'aujourd'hui
20131025 1 20131025_Locuteur_1 903.899 909.939 <o,f4,male> ça va être euh il va s() ça va se dérouler en deux parties. une première partie avec un grand zi() un grand historique de tout ce qui s'est fait
20131025 1 20131025_Locuteur_1 909.939 915.436 <o,f4,male> de l'antiquité jusque dans les années euh soixante, soixante-dix
20131025 1 20131025_Locuteur_1 915.436 918.910 <o,f4,male> où la cryptographie était plutôt militaire,
20131025 1 20131025_Locuteur_1 918.910 922.782 <o,f4,male> et puis ensuite on parlera de cryptographie moderne
20131025 1 20131025_Locuteur_1 922.782 931.969 <o,f4,male> alors un cer() on présentera un certain nombre de protocoles cryptographiques.
20131025 1 20131025_Locuteur_1 931.969 934.261 <o,f4,male> [pi] très rapidement
20131025 1 20131025_Locuteur_1 934.261 936.460 <o,f4,male> pourquoi on fait de la cryptographie ?
20131025 1 20131025_Locuteur_1 936.460 939.270 <o,f4,male> ben on fait de la cryptographie pour protéger des messages.
20131025 1 20131025_Locuteur_1 939.270 941.296 <o,f4,male> la cryptographie était militaire
20131025 1 20131025_Locuteur_1 941.296 944.000 <o,f4,male> entre l'antiquité jusqu'à la seconde guerre mondiale
20131025 1 20131025_Locuteur_1 944.000 945.701 <o,f4,male> voi() jusque () voire jusqu'à la guerre froide
20131025 1 20131025_Locuteur_1 945.701 948.770 <o,f4,male> c'était une cryptographie militaire.
20131025 1 20131025_Locuteur_1 948.770 951.970 <o,f4,male> depuis que l'informatique personnelle se développe,
20131025 1 20131025_Locuteur_1 951.970 955.978 <o,f4,male> euh les besoins cryptographiques se développent aussi
20131025 1 20131025_Locuteur_1 955.978 964.010 <o,f4,male> et donc de plus en plus, on a on a besoin d'une cryptographie domestique. on a besoin de payer avec sa carte bleue sur internet,
20131025 1 20131025_Locuteur_1 964.010 965.711 <o,f4,male> on a besoin de signer
20131025 1 20131025_Locuteur_1 965.711 970.772 <o,f4,male> sa déclaration d'impôts de manière électronique, on a besoin de faire des choses comme ça.
20131025 1 20131025_Locuteur_1 970.772 975.656 <o,f4,male> donc on va s'adapter à des nouvelles () la cryptographie doit s'adapter à des nouvelles applications
20131025 1 20131025_Locuteur_1 975.656 976.639 <o,f4,male> pour
20131025 1 20131025_Locuteur_1 976.639 977.960 <o,f4,male> coder des textes,
20131025 1 20131025_Locuteur_1 977.960 983.638 <o,f4,male> pour signer, pour coder des images, pour coder des vidéos.
20131025 1 20131025_Locuteur_1 983.638 987.890 <o,f4,male> le signal canal plus qui est diffusé sur la tnt est crypté
20131025 1 20131025_Locuteur_1 987.890 992.067 <o,f4,male> par un protocole crypto() euh cryptographique.
20131025 1 20131025_Locuteur_1 992.067 994.320 <o,f4,male> et puis évidemment
20131025 1 20131025_Locuteur_1 994.320 996.740 <o,f4,male> vous avez euh
20131025 1 20131025_Locuteur_1 996.740 1000.713 <o,f4,male> c'est tout à fait d'actualité : on pensait qu'on était protégés parce que euh
20131025 1 20131025_Locuteur_1 1000.713 1005.870 <o,f4,male> les protocoles cryptographiques ce sont des protocoles sécurisés mais
20131025 1 20131025_Locuteur_1 1005.870 1012.836 <o,f4,male> c'est plus tout à fait le cas, puisque il y a une croissance exponentielle des ma() des moyens informatiques mis à disposition des
20131025 1 20131025_Locuteur_1 1012.836 1014.269 <o,f4,male> des personnes malveillantes.
20131025 1 20131025_Locuteur_1 1014.269 1015.888 <o,f4,male> donc il faut tenir compte
20131025 1 20131025_Locuteur_1 1015.888 1025.560 <o,f4,male> de cette euh croissance exponentielle de la puissance de calcul quand on définit un protocole cryptographique. on on reviendra dessus
20131025 1 20131025_Locuteur_1 1025.560 1028.960 <o,f4,male> alors petit schéma général de cryptographie :
20131025 1 20131025_Locuteur_1 1028.960 1034.508 <o,f4,male> la cryptographie concerne deux personnes qui veulent communiquer
20131025 1 20131025_Locuteur_1 1034.508 1039.300 <o,f4,male> alors un petit garçon et une petite fille qui veulent communiquer dans la salle de classe
20131025 1 20131025_Locuteur_1 1039.300 1041.820 <o,f4,male> et pour communiquer dans la salle de classe,
20131025 1 20131025_Locuteur_1 1041.820 1046.200 <o,f4,male> la méthode simple, c'est d'écrire le message sur un petit bout de papier et de se l'envoyer
20131025 1 20131025_Locuteur_1 1046.200 1048.599 <o,f4,male> à l'é() verticalement
20131025 1 20131025_Locuteur_1 1048.599 1050.124 <o,f4,male> voilà
20131025 1 20131025_Locuteur_1 1050.124 1053.836 <o,f4,male> donc le message est envoyé, il est reçu, il est lu
20131025 1 20131025_Locuteur_1 1053.836 1057.391 <o,f4,male> le seul problème, c'est que il y a le () il y a le prof dans la salle
20131025 1 20131025_Locuteur_1 1057.391 1061.185 <o,f4,male> et le prof, il est pas con() il est pas il est pas très sympa
20131025 1 20131025_Locuteur_1 1061.185 1063.480 <o,f4,male> donc ce que fait le prof,
20131025 1 20131025_Locuteur_1 1063.480 1066.560 <o,f4,male> c'est qu'il est capable d'intercepter l'avion.
20131025 1 20131025_Locuteur_1 1066.560 1069.720 <o,f4,male> si le message n'est pas crypté, il lit le message
20131025 1 20131025_Locuteur_1 1069.720 1073.615 <o,f4,male> et évidemment, le petit garçon doit apprendre à protéger ses messages.
20131025 1 20131025_Locuteur_1 1073.615 1077.465 <o,f4,male> donc la leçon qu'il a reçue, c'est ça.
20131025 1 20131025_Locuteur_1 1077.465 1079.800 <o,f4,male> comment il fait pour protéger ses messages ?
20131025 1 20131025_Locuteur_1 1079.800 1081.890 <o,f4,male> ben les protocoles cryptographiques
20131025 1 20131025_Locuteur_1 1081.890 1084.560 <o,f4,male> tous les protocoles cryptographiques vont reposer sur
20131025 1 20131025_Locuteur_1 1084.560 1086.910 <o,f4,male> une clé
20131025 1 20131025_Locuteur_1 1086.910 1088.935 <o,f4,male> une clé qui doit être partagée
20131025 1 20131025_Locuteur_1 1088.935 1091.268 <o,f4,male> entre les deux personnes qui veulent communiquer.
20131025 1 20131025_Locuteur_1 1091.268 1094.098 <o,f4,male> ça c'est le premier élément du protocole cryptographique ;
20131025 1 20131025_Locuteur_1 1094.098 1096.541 <o,f4,male> le deuxième élément
20131025 1 20131025_Locuteur_1 1096.541 1098.220 <o,f4,male> c'est un coffre.
20131025 1 20131025_Locuteur_1 1098.220 1101.130 <o,f4,male> le message, au lieu de l'envoyer sur un papier
20131025 1 20131025_Locuteur_1 1101.130 1106.372 <o,f4,male> il va le () l'enfermer dans une sorte de coffre cryptographique fermé à clé.
20131025 1 20131025_Locuteur_1 1106.372 1107.684 <o,f4,male> la seule clé
20131025 1 20131025_Locuteur_1 1107.684 1110.577 <o,f4,male> qui peut ouvrir le coffre, c'est la clé qui est partagée.
20131025 1 20131025_Locuteur_1 1110.577 1112.210 <o,f4,male> en gros, on t'envoie le coffre
20131025 1 20131025_Locuteur_1 1112.210 1115.208 <o,f4,male> même si le coffre est intercepté, c'est pas grave
20131025 1 20131025_Locuteur_1 1115.208 1117.326 <o,f4,male> donc ce qui va être important c'est d'avoir une
20131025 1 20131025_Locuteur_1 1117.326 1118.658 <o,f4,male> une bonne clé.
20131025 1 20131025_Locuteur_1 1118.658 1121.388 <o,f4,male> qu'est-ce que ça veut dire, avoir une bonne clé ? ça veut dire
20131025 1 20131025_Locuteur_1 1121.388 1122.823 <o,f4,male> que pour ouvrir le coffre,
20131025 1 20131025_Locuteur_1 1122.823 1125.308 <o,f4,male> il suffit pas de laisser trois ou quatre clés.
20131025 1 20131025_Locuteur_1 1125.308 1129.797 <o,f4,male> il faut tester tellement de clés que on n'a pas le temps de le faire.
20131025 1 20131025_Locuteur_1 1129.797 1135.629 <o,f4,male> donc une clé de bonne qualité, c'est une clé qui est sur un trousseau de plusieurs milliards de clés,
20131025 1 20131025_Locuteur_1 1135.629 1138.190 <o,f4,male> impossibles à tester par un être humain
20131025 1 20131025_Locuteur_1 1138.190 1140.956 <o,f4,male> en le temps qui lui est imparti.
20131025 1 20131025_Locuteur_1 1140.956 1144.971 <o,f4,male> la deuxième préoccupation, c'est que le coffre soit de bonne qualité.
20131025 1 20131025_Locuteur_1 1144.971 1150.995 <o,f4,male> un coffre de bonne qualité, c'est pas un coffre qu'il suffit de dévisser pour ouvri() pour l'ouvrir, voilà.
20131025 1 20131025_Locuteur_1 1150.995 1154.660 <o,f4,male> donc on l'ou() on l'ouvre pas avec un marteau ; si on veut l'ouvrir, c'est euh
20131025 1 20131025_Locuteur_1 1154.660 1159.220 <o,f4,male> il faut y mettre les moyens,
20131025 1 20131025_Locuteur_1 1159.220 1164.299 <o,f4,male> les moyens qu'on ne peut pas mettre en oeuvre en un temps raisonnable.
20131025 1 20131025_Locuteur_1 1164.299 1168.617 <o,f4,male> voilà. et puis la troisième préoccupation, c'est euh j'ai dit : c'est bien beau, il suffit de s'échanger une clé.
20131025 1 20131025_Locuteur_1 1168.617 1170.545 <o,f4,male> ben ça c'est un vrai problème
20131025 1 20131025_Locuteur_1 1170.545 1173.438 <o,f4,male> euh quand on cherche à
20131025 1 20131025_Locuteur_1 1173.438 1176.982 <o,f4,male> à définir un protocole cryptographique, c'est comment on fait pour s'échanger une clé
20131025 1 20131025_Locuteur_1 1176.982 1179.412 <o,f4,male> sachant qu'évidemment, on peut pas se l'envoyer
20131025 1 20131025_Locuteur_1 1179.412 1182.811 <o,f4,male> d'un bout à l'autre de la salle, sinon elle pourrait être interceptée.
20131025 1 20131025_Locuteur_1 1182.811 1184.039 <o,f4,male> faut mettre en oeuvre
20131025 1 20131025_Locuteur_1 1184.039 1187.561 <o,f4,male> ces protocoles d'échange de clés.
20131025 1 20131025_Locuteur_1 1187.561 1190.066 <o,f4,male> voilà
20131025 1 20131025_Locuteur_1 1190.066 1192.926 <o,f4,male> on va voir maintenant un certain nombre d'exemples
20131025 1 20131025_Locuteur_1 1192.926 1195.060 <o,f4,male> de protocoles cryptographiques.
20131025 1 inter_segment_gap 1195.060 1197.494 <o,f4,>
20131025 1 20131025_Locuteur_1 1197.494 1201.880 <o,f4,male> on retourne très loin en arrière, puisqu'on retourne euh cinq cents avant jésus-christ
20131025 1 20131025_Locuteur_1 1201.880 1206.730 <o,f4,male> on va parler d'un protocole cryptographique mis au point par les grecs
20131025 1 20131025_Locuteur_1 1206.730 1215.260 <o,f4,male> euh le but était de () étant de communiquer entre plusieurs unités euh de l'armée grecque.
20131025 1 20131025_Locuteur_1 1215.260 1219.130 <o,f4,male> ce protocole cryptographique porte le nom de transcodage ; c'est
20131025 1 20131025_Locuteur_1 1219.130 1224.680 <o,f4,male> c'est une technique qui consiste à mélanger les lettres du message : je prends un message, je mélange les lettres
20131025 1 20131025_Locuteur_1 1224.680 1227.257 <o,f4,male> et j'obtiens un nouveau message codé.
20131025 1 20131025_Locuteur_1 1227.257 1228.930 <o,f4,male> si la personne
20131025 1 20131025_Locuteur_1 1228.930 1232.187 <o,f4,male> sait comment j'ai mélangé les lettres, elle est capable de les redémélanger
20131025 1 20131025_Locuteur_1 1232.187 1235.760 <o,f4,male> et de de relire le message.
20131025 1 20131025_Locuteur_1 1235.760 1238.815 <o,f4,male> alors ça peut paraître très général, mais les grecs avaient inventé ça
20131025 1 20131025_Locuteur_1 1238.815 1241.388 <o,f4,male> comme ça, ils ils procédaient comme ça.
20131025 1 20131025_Locuteur_1 1241.388 1243.048 <o,f4,male> ils avaient un cylindre
20131025 1 20131025_Locuteur_1 1243.048 1244.410 <o,f4,male> d'un certain diamètre
20131025 1 20131025_Locuteur_1 1244.410 1247.285 <o,f4,male> ils avaient une bande de papier
20131025 1 20131025_Locuteur_1 1247.285 1248.773 <o,f4,male> pour coder le message,
20131025 1 20131025_Locuteur_1 1248.773 1252.092 <o,f4,male> il suffisait d'enrouler la bande de papier autour du cylindre,
20131025 1 20131025_Locuteur_1 1252.092 1256.787 <o,f4,male> d'écrire le message sur la bande de papier, dans le sens vertical
20131025 1 20131025_Locuteur_1 1256.787 1264.310 <o,f4,male> et quand on redépliait la bande de papier, évidemment les lettres étaient mélangées.
20131025 1 20131025_Locuteur_1 1264.310 1266.507 <o,f4,male> donc ici, il y a une clé ;
20131025 1 20131025_Locuteur_1 1266.507 1269.131 <o,f4,male> la clé c'est le t() c'est le tuyau
20131025 1 20131025_Locuteur_1 1269.131 1272.290 <o,f4,male> qui doit être commun entre les deux personnes
20131025 1 20131025_Locuteur_1 1272.290 1276.686 <o,f4,male> *enfin le les () c'était pas vraiment le tuyau, mais c'était euh plus précisément
20131025 1 20131025_Locuteur_1 1276.686 1281.646 <o,f4,male> le nombre de lettres qu'on doit passer quand on est en train de relire le message.
20131025 1 20131025_Locuteur_1 1281.646 1283.123 <o,f4,male> donc ça, c'est la clé.
20131025 1 20131025_Locuteur_1 1283.123 1290.160 <o,f4,male> la clé du transcodage à la grecque, c'est le nombre de lettres qu'on passe pour pouvoir lire le message.
20131025 1 20131025_Locuteur_1 1290.160 1293.190 <o,f4,male> alors est-ce que c'est un bon protocole cryptographique ?
20131025 1 20131025_Locuteur_1 1293.190 1295.054 <o,f4,male> la réponse est plutôt non
20131025 1 20131025_Locuteur_1 1295.054 1298.941 <o,f4,male> dans le cas d'un [pi] , puisque des clés possibles il y en a pas tant que ça.
20131025 1 20131025_Locuteur_1 1298.941 1306.270 <o,f4,male> si le message fait euh cinquante euh symboles, alors il y a cinquante clés à tester, cinquante écarts de lettres à tester
20131025 1 20131025_Locuteur_1 1306.270 1308.668 <o,f4,male> pour retrouver le message non codé.
20131025 1 20131025_Locuteur_1 1308.668 1311.507 <o,f4,male> c'est pas beaucoup, cinquante.
20131025 1 20131025_Locuteur_1 1311.507 1315.667 <o,f4,male> dans le cas d'un transcodage général, le principe va être de mélanger
20131025 1 20131025_Locuteur_1 1315.667 1320.281 <o,f4,male> selon une certaine permutation le nombre euh les les les symboles du message, alors
20131025 1 20131025_Locuteur_1 1320.281 1326.680 <o,f4,male> évidemment il y aura beaucoup plus de clés possibles, il y en aura le nombre de permutations de n symboles possibles.
20131025 1 20131025_Locuteur_1 1326.680 1332.958 <o,f4,male> c'est pas pour autant que ça en fait un bon cryptosystème.
20131025 1 20131025_Locuteur_1 1332.958 1333.720 <o,f4,male> voilà
20131025 1 20131025_Locuteur_1 1333.720 1336.689 <o,f4,male> alors si vous lisez un petit peu
20131025 1 20131025_Locuteur_1 1336.689 1341.463 <o,f4,male> et si vous lisez euh jules verne l'auteur euh nantais par excellence
20131025 1 20131025_Locuteur_1 1341.463 1344.390 <o,f4,male> il a écrit un livre qui s'appelle voyage au centre de la terre
20131025 1 20131025_Locuteur_1 1344.390 1345.620 <o,f4,male> où il fait un
20131025 1 20131025_Locuteur_1 1345.620 1348.672 <o,f4,male> où il a une énigme à base de transcodage
20131025 1 20131025_Locuteur_1 1348.672 1349.930 <o,f4,male> donc je vous laisse
20131025 1 20131025_Locuteur_1 1349.930 1357.466 <o,f4,male> pas le lire sur le tableau puisque il y a pas il y a pas d'intérêt, mais ça peut vous donner une idée de ce que vous pouvez lire pendant les vacances
20131025 1 20131025_Locuteur_1 1357.466 1361.000 <o,f4,male> voyage au centre de la terre.
20131025 1 20131025_Locuteur_1 1361.000 1365.130 <o,f4,male> donc typiquement, si la l() l'énigme à résoudre, c'est un transcodage
20131025 1 20131025_Locuteur_1 1365.130 1368.714 <o,f4,male> et euh évidemment le héros la résout et va explorer
20131025 1 20131025_Locuteur_1 1368.714 1372.780 <o,f4,male> le centre de la terre.
20131025 1 20131025_Locuteur_1 1372.780 1374.760 <o,f4,male> le deuxième codage
20131025 1 20131025_Locuteur_1 1374.760 1379.794 <o,f4,male> qu'on va présenter, c'est celui qu'on appelle le codage de césar ; donc là on revient à
20131025 1 20131025_Locuteur_1 1379.794 1384.125 <o,f4,male> à peu près cinquante avant jésus-christ, l'année d'astérix
20131025 1 20131025_Locuteur_1 1384.125 1386.050 <o,f4,male> le but de ce codage,
20131025 1 20131025_Locuteur_1 1386.050 1391.664 <o,f4,male> ça va plus être de mélanger les lettres du message, mais ça va être de mélanger les lettres de l'alphabet.
20131025 1 20131025_Locuteur_1 1391.664 1394.448 <o,f4,male> donc on commence à mélanger les lettres de l'alphabet ;
20131025 1 20131025_Locuteur_1 1394.448 1398.840 <o,f4,male> dans le codage de césar, c'est pas un mélange très compliqué, c'est un décalage.
20131025 1 20131025_Locuteur_1 1398.840 1402.550 <o,f4,male> on décale les lettres de l'alphabet d'un certain nombre de caractères
20131025 1 20131025_Locuteur_1 1402.550 1407.767 <o,f4,male> ici on met le un en bas du d, et puis on réécrit l'alphabet
20131025 1 20131025_Locuteur_1 1407.767 1409.416 <o,f4,male> pour coder le message
20131025 1 20131025_Locuteur_1 1409.416 1411.780 <o,f4,male> bah il suffit de prendre la lettre d'en haut
20131025 1 20131025_Locuteur_1 1411.780 1418.329 <o,f4,male> et d'écrire la lettre en bas. donc le message codé [pi] deviendra [pi] voilà
20131025 1 20131025_Locuteur_1 1418.329 1422.140 <o,f4,male> f, r euh d, h, u, et cetera, et cetera
20131025 1 20131025_Locuteur_1 1422.140 1426.330 <o,f4,male> si on l'appelle codage de césar, c'est parce qu'il a été décrit dans l'antiquité par euh
20131025 1 20131025_Locuteur_1 1426.330 1429.580 <o,f4,male> quelqu'un qui s'appelle suétone, un poète euh romain
20131025 1 20131025_Locuteur_1 1429.580 1434.190 <o,f4,male> dans un livre qui s'appelait "la vie des douze césars".
20131025 1 20131025_Locuteur_1 1434.190 1437.000 <o,f4,male> c'est une sécurité qui est faible, il y a pas beaucoup de clés
20131025 1 20131025_Locuteur_1 1437.000 1439.470 <o,f4,male> [pi] vingt-six
20131025 1 20131025_Locuteur_1 1439.470 1442.501 <o,f4,male> mais il est tellement simple d'utilisation
20131025 1 20131025_Locuteur_1 1442.501 1444.445 <o,f4,male> il est encore utilisé aujourd'hui
20131025 1 20131025_Locuteur_1 1444.445 1447.475 <o,f4,male> sur certains forums un peu spécialisés pour cacher des devinettes,
20131025 1 20131025_Locuteur_1 1447.475 1450.404 <o,f4,male> et il est utilisé aujourd'hui sous le nom de "rot treize"
20131025 1 20131025_Locuteur_1 1450.404 1452.174 <o,f4,male> rotation de treize symboles ;
20131025 1 20131025_Locuteur_1 1452.174 1455.707 <o,f4,male> donc le décalage est fixé à treize symboles.
20131025 1 20131025_Locuteur_1 1455.707 1457.222 <o,f4,male> donc ça, ça s'appelle
20131025 1 20131025_Locuteur_1 1457.222 1462.020 <o,f4,male> substitution ou codage monoalphabétique, donc c'est s() s() ce terme
20131025 1 20131025_Locuteur_1 1462.020 1464.590 <o,f4,male> décrit toutes les techniques
20131025 1 20131025_Locuteur_1 1464.590 1470.287 <o,f4,male> de cryptographie qui consistent à mélanger les lettres de l'alphabet.
20131025 1 20131025_Locuteur_1 1470.287 1472.623 <o,f4,male> alors je vous ai dit
20131025 1 20131025_Locuteur_1 1472.623 1477.779 <o,f4,male> son avantage et sa simplicité, c'est qu'il est indépendant de la taille du message, donc ça c'est important
20131025 1 20131025_Locuteur_1 1477.779 1483.620 <o,f4,male> quand on veut décrire un un cryptosystème, le fait que ce soit in() indépendant de la taille du message c'est bien
20131025 1 20131025_Locuteur_1 1483.620 1488.347 <o,f4,male> c'est pas un bon cryptosystème, le codage de césar c'est absolument pas un bon cryptosystème
20131025 1 20131025_Locuteur_1 1488.347 1491.048 <o,f4,male> vous, êtres humaines, vous êtes capables de
20131025 1 20131025_Locuteur_1 1491.048 1492.460 <o,f4,male> de lire vingt-six textes
20131025 1 20131025_Locuteur_1 1492.460 1495.390 <o,f4,male> et de trouver lequel est écrit en français
20131025 1 20131025_Locuteur_1 1495.390 1497.513 <o,f4,male> par une attaque euh
20131025 1 20131025_Locuteur_1 1497.513 1502.900 <o,f4,male> en testant toutes les clés vous êtes capables de le faire, vous êtes même *capables de le faire à la main sans ordinateur.
20131025 1 20131025_Locuteur_1 1502.900 1505.530 <o,f4,male> dans le cadre des substitutions générales,
20131025 1 20131025_Locuteur_1 1505.530 1510.719 <o,f4,male> c'est un peu plus compliqué puisque des permutations de l'alphabet, il y en a vingt-six factorielles.
20131025 1 20131025_Locuteur_1 1510.719 1512.952 <o,f4,male> donc ça, ça commence à faire beaucoup de clés euh
20131025 1 20131025_Locuteur_1 1512.952 1514.350 <o,f4,male> vingt-six factorielles, ça fait quatre
20131025 1 20131025_Locuteur_1 1514.350 1517.366 <o,f4,male> fois dix à la puissance vingt-six, ça fait pas mal, hein.
20131025 1 20131025_Locuteur_1 1517.366 1519.390 <o,f4,male> imaginons que vous, êtres hu()
20131025 1 20131025_Locuteur_1 1519.390 1524.858 <o,f4,male> êtres humains () en tant qu'êtres humains, vous êtes capables de tester cent mille clés par seconde.
20131025 1 20131025_Locuteur_1 1524.858 1528.209 <o,f4,male> je doute que vous soyez capables de le faire, mais imaginons que vous soyez capables de le faire :
20131025 1 20131025_Locuteur_1 1528.209 1529.442 <o,f4,male> vous lisez cent mille
20131025 1 20131025_Locuteur_1 1529.442 1534.990 <o,f4,male> textes par seconde et vous détectez, parmi ces cent mille, s'il y en a un qui est [pi] écrit en français.
20131025 1 20131025_Locuteur_1 1534.990 1540.730 <o,f4,male> alors même si vous étiez capables de faire ce travail, il vous faudrait dix à la puissance douze siècles
20131025 1 20131025_Locuteur_1 1540.730 1544.097 <o,f4,male> pour pouvoir déchiffrer un message codé par un
20131025 1 20131025_Locuteur_1 1544.097 1547.969 <o,f4,male> substitution monoalphabétique quelconque.
20131025 1 20131025_Locuteur_1 1547.969 1555.074 <o,f4,male> et dix à la puissance douze, c'est évidemment énorme puisque l'univers n'a que dix à la puissance huit siècles ;
20131025 1 20131025_Locuteur_1 1555.074 1558.518 <o,f4,male> n'imaginons même pas que vous soyez capables de le faire.
20131025 1 20131025_Locuteur_1 1558.518 1559.747 <o,f4,male> par contre
20131025 1 20131025_Locuteur_1 1559.747 1564.714 <o,f4,male> on sait très bien que c'est pas un bon cryptosystème, et on verra pourquoi c'est pas un bon cryptosystème un peu plus tard.
20131025 1 20131025_Locuteur_1 1564.714 1569.310 <o,f4,male> on verra comment attaquer ce cryptosystème.
20131025 1 20131025_Locuteur_1 1569.310 1575.806 <o,f4,male> alors il y a des généralisations du codage de césar ; ces généralisations sont connues sous le nom de codage de vigenère,
20131025 1 20131025_Locuteur_1 1575.806 1581.307 <o,f4,male> où le but ça va être d'enchaîner un certain nombre de codages de césar avec des clés différentes.
20131025 1 20131025_Locuteur_1 1581.307 1583.545 <o,f4,male> l'avantage du codage de césar, c'est que vous voyez :
20131025 1 20131025_Locuteur_1 1583.545 1585.290 <o,f4,male> la lettre qu'on met en face
20131025 1 20131025_Locuteur_1 1585.290 1590.474 <o,f4,male> du a, elle est importante et puis on peut l'utiliser pour écrire un message.
20131025 1 20131025_Locuteur_1 1590.474 1592.390 <o,f4,male> donc ici, la clé
20131025 1 20131025_Locuteur_1 1592.390 1594.252 <o,f4,male> sera représentée par un mot
20131025 1 20131025_Locuteur_1 1594.252 1596.200 <o,f4,male> le mot "feu"
20131025 1 20131025_Locuteur_1 1596.200 1600.261 <o,f4,male> et comment on utilise un codage de vigenère ? ben f() c'est simple
20131025 1 20131025_Locuteur_1 1600.261 1606.322 <o,f4,male> pour la première lettre qu'on utilise, on fait un codage de césar de la première lettre avec le premier cryptosystème de césar,
20131025 1 20131025_Locuteur_1 1606.322 1612.381 <o,f4,male> puis un codage de la deuxième lettre avec le deuxième, puis un codage de la troisième lettre avec le troisième
20131025 1 20131025_Locuteur_1 1612.381 1615.516 <o,f4,male> il y a trop de bruit, là-haut !
20131025 1 20131025_Locuteur_1 1615.516 1620.610 <o,f4,male> donc le mot bonjour sera codé par le mot [pi]
20131025 1 20131025_Locuteur_1 1620.610 1623.770 <o,f4,male> alors ici, ce qui est important, c'est la longueur de la clé.
20131025 1 20131025_Locuteur_1 1623.770 1628.310 <o,f4,male> je vous ai dit le cry() le codage de césar, c'est un mauvais cryptosystème
20131025 1 20131025_Locuteur_1 1628.310 1634.298 <o,f4,male> le codage de vigenère sera un mauvais cryptosystème si on connaît la longueur de la clé.
20131025 1 20131025_Locuteur_1 1634.298 1636.130 <o,f4,male> donc on verra un peu plus tard
20131025 1 20131025_Locuteur_1 1636.130 1639.120 <o,f4,male> quand on *présentera les attaques sur ces cryptosystèmes,
20131025 1 20131025_Locuteur_1 1639.120 1642.259 <o,f4,male> une technique qui permet de retrouver la longueur de la clé
20131025 1 20131025_Locuteur_1 1642.259 1646.973 <o,f4,male> d'avoir une idée de la longueur de la clé.
20131025 1 20131025_Locuteur_1 1646.973 1650.902 <o,f4,male> cette longueur de clé est importante, puisque même si c'est indépendant de la longueur du message,
20131025 1 20131025_Locuteur_1 1650.902 1655.461 <o,f4,male> le nombre de clés à tester dépend du de la longueur de la
20131025 1 20131025_Locuteur_1 1655.461 1656.417 <o,f4,male> clé
20131025 1 20131025_Locuteur_1 1656.417 1661.025 <o,f4,male> et il y en aura vingt-six à la puissance k dans le cas d'un codage de vigenère classique ;
20131025 1 20131025_Locuteur_1 1661.025 1663.995 <o,f4,male> si on mélange si on met plusieurs
20131025 1 20131025_Locuteur_1 1663.995 1665.790 <o,f4,male> codages euh
20131025 1 20131025_Locuteur_1 1665.790 1668.841 <o,f4,male> plusieurs substitutions monoalphabétiques
20131025 1 20131025_Locuteur_1 1668.841 1673.166 <o,f4,male> euh à la suite, on aura euh ce nombre-là qui est très très grand, mais euh
20131025 1 20131025_Locuteur_1 1673.166 1682.960 <o,f4,male> évidemment ça sera () ça ne fera pas un bon cryptosystème puisque le codage de césar ou les substitutions monoalphabétiques ne sont pas des bons cryptosystèmes.
20131025 1 20131025_Locuteur_1 1682.960 1688.831 <o,f4,male> donc le codage de vigenère fait partie de ce qu'on appelle les substitutions [pi] polyalphabétiques
20131025 1 20131025_Locuteur_1 1688.831 1693.256 <o,f4,male> plusieurs alphabets
20131025 1 20131025_Locuteur_1 1693.256 1695.079 <o,f4,male> on se rapproche
20131025 1 20131025_Locuteur_1 1695.079 1697.208 <o,f4,male> on est au moyen âge
20131025 1 20131025_Locuteur_1 1697.208 1704.590 <o,f4,male> et on va voir maintenant le troisième grand () la troisième grande famille de procédés cryptographiques qui s'appelle la stéganographie.
20131025 1 20131025_Locuteur_1 1704.590 1706.170 <o,f4,male> alors historiquement,
20131025 1 20131025_Locuteur_1 1706.170 1713.029 <o,f4,male> ce procédé stéganographique est important puisqu'il a été publié dans le premier ouvrage qui traite de de cryptographie.
20131025 1 20131025_Locuteur_1 1713.029 1716.507 <o,f4,male> écrit par euh l'abbé de trithème
20131025 1 20131025_Locuteur_1 1716.507 1720.000 <o,f4,male> en mille quatre cent quatre-vingt-dix-neuf
20131025 1 20131025_Locuteur_1 1720.000 1721.670 <o,f4,male> et cet abbé
20131025 1 20131025_Locuteur_1 1721.670 1726.006 <o,f4,male> dans son ouvrage introduit le principe de stéganographie ; qu'est-ce que c'est que ce principe ?
20131025 1 20131025_Locuteur_1 1726.006 1729.163 <o,f4,male> ben c'est tout simplement cacher une information
20131025 1 20131025_Locuteur_1 1729.163 1730.090 <o,f4,male> secrète
20131025 1 20131025_Locuteur_1 1730.090 1734.874 <o,f4,male> dans un document qui est a() a priori anodin.
20131025 1 20131025_Locuteur_1 1734.874 1737.660 <o,f4,male> alors voilà un petit exemple :
20131025 1 20131025_Locuteur_1 1737.660 1742.053 <o,f4,male> l'abbé de trithème écrivait des litanies
20131025 1 20131025_Locuteur_1 1742.053 1744.491 <o,f4,male> en voilà une
20131025 1 20131025_Locuteur_1 1744.491 1752.564 <o,f4,male> dans la félicité à perpétuité, dans son royaume à perpétuité, [pi] à perpétuité, et cetera, et cetera, et cetera ; c'est un petit poème
20131025 1 20131025_Locuteur_1 1752.564 1753.530 <o,f4,male> ça veut dire
20131025 1 20131025_Locuteur_1 1753.530 1756.400 <o,f4,male> ça veut pas forcément dire grand-chose, c'est une litanie
20131025 1 20131025_Locuteur_1 1756.400 1763.786 <o,f4,male> mais est-ce que vous pourrez retrouver le message qui est caché dans cette euh dans ce poème ? et comment il est caché ?
20131025 1 20131025_Locuteur_1 1763.786 1772.820 <o,f4,male> est-ce que vous avez une idée ?
20131025 1 20131025_Locuteur_1 1772.820 1774.662 <o,f4,male> est-ce que vous avez une idée ?
20131025 1 20131025_Locuteur_1 1774.662 1777.157 <o,f4,male> personne ?
20131025 1 20131025_Locuteur_1 1777.157 1779.655 <o,f4,male> alors il y a beaucoup de à perpétuité
20131025 1 20131025_Locuteur_1 1779.655 1781.960 <o,f4,male> c'est une très bonne idée
20131025 1 20131025_Locuteur_1 1781.960 1787.539 <o,f4,male> alors il y a beaucoup de à perpétuité, imaginons que à perpétuité je le remplace par un e
20131025 1 20131025_Locuteur_1 1787.539 1791.270 <o,f4,male> on les remplace tous par un e
20131025 1 20131025_Locuteur_1 1791.270 1797.352 <o,f4,male> imaginons que maintenant j'ai un alphabet qui m() qui me permet de remplacer des bouts de phrases par des lettres
20131025 1 20131025_Locuteur_1 1797.352 1802.320 <o,f4,male> j'ai un une table de correspondance entre des bouts de phrase et des lettres
20131025 1 20131025_Locuteur_1 1802.320 1805.717 <o,f4,male> voilà le le cryptosystème va reposer sur ces
20131025 1 20131025_Locuteur_1 1805.717 1807.534 <o,f4,male> sur cette table de correspondances.
20131025 1 20131025_Locuteur_1 1807.534 1812.819 <o,f4,male> ben dans ma table de correspondance, je verrai que dans la félicité, ça se remplace par un r
20131025 1 20131025_Locuteur_1 1812.819 1814.237 <o,f4,male> que euh
20131025 1 20131025_Locuteur_1 1814.237 1817.527 <o,f4,male> dans mon royaume ça se remplace par un t, et cetera et cetera
20131025 1 20131025_Locuteur_1 1817.527 1819.003 <o,f4,male> et quand on
20131025 1 20131025_Locuteur_1 1819.003 1822.270 <o,f4,male> on remplace tout ce qu'il faut, on obtient un message :
20131025 1 20131025_Locuteur_1 1822.270 1828.883 <o,f4,male> retenez bien les formules, c'est c'est un conseil que je vous donne.
20131025 1 20131025_Locuteur_1 1828.883 1835.279 <o,f4,male> alors je vais vous donner un () je vais vous donner un autre exemple maintenant
20131025 1 20131025_Locuteur_1 1835.279 1837.163 <o,f4,male> mais un exemple
20131025 1 20131025_Locuteur_1 1837.163 1838.779 <o,f4,male> voilà
20131025 1 20131025_Locuteur_1 1838.779 1842.587 <o,f4,male> celui-là
20131025 1 20131025_Locuteur_1 1842.587 1846.230 <o,f4,male> une autre manière de
20131025 1 20131025_Locuteur_1 1846.230 1847.581 <o,f4,male> euh [pi] problème
20131025 1 20131025_Locuteur_1 1847.581 1852.784 <o,f4,male> une autre manière de cacher des messages, c'est de les cacher dans une image.
20131025 1 20131025_Locuteur_1 1852.784 1855.250 <o,f4,male> est-ce que vous avez une idée ?
20131025 1 20131025_Locuteur_1 1855.250 1866.136 <o,f4,male> de comment on on va retrouver le message
20131025 1 20131025_Locuteur_1 1866.136 1878.590 <o,f4,male> vous avez une petite idée ?
20131025 1 20131025_Locuteur_1 1878.590 1884.404 <o,f4,male> si vous avez pas trouvé, c'est parce qu'il manquait [pi] des oiseaux.
20131025 1 20131025_Locuteur_1 1884.404 1888.130 <o,f4,male> voilà, là vous les avez tous
20131025 1 20131025_Locuteur_1 1888.130 1890.760 <o,f4,male> vous avez trouvé ?
20131025 1 20131025_Locuteur_1 1890.760 1894.154 <o,f4,male> il y a des () c'est avec les oiseaux
20131025 1 20131025_Locuteur_1 1894.154 1895.220 <o,f4,male> allez
20131025 1 20131025_Locuteur_1 1895.220 1896.560 <o,f4,male> je vous aide
20131025 1 20131025_Locuteur_1 1896.560 1898.500 <o,f4,male> hop
20131025 1 20131025_Locuteur_1 1898.500 1900.840 <o,f4,male> je fais descendre les choses
20131025 1 20131025_Locuteur_1 1900.840 1905.490 <o,f4,male> donc les petits les petits oiseaux ils sont pas placés n'importe comment
20131025 1 20131025_Locuteur_1 1905.490 1911.318 <o,f4,male> le premier le premier petit oiseau, celui qui est tout beau, il est sur la colonne du r
20131025 1 20131025_Locuteur_1 1911.318 1915.396 <o,f4,male> le deuxième il est sur la colonne du e, le troisième il est sur la colonne du n
20131025 1 20131025_Locuteur_1 1915.396 1917.977 <o,f4,male> et cetera, et cetera, et cetera.
20131025 1 20131025_Locuteur_1 1917.977 1921.284 <o,f4,male> donc si je laisse descendre
20131025 1 20131025_Locuteur_1 1921.284 1927.010 <o,f4,male> mes petits thèmes, ça va parcourir tous les oiseaux dans un ordre déterminé ; cet ordre
20131025 1 20131025_Locuteur_1 1927.010 1932.338 <o,f4,male> évidemment on le voit () vous le voyez pas, mais ça écrit le message : les renseignements arrivent.
20131025 1 20131025_Locuteur_1 1932.338 1938.380 <o,f4,male> donc on est capable aussi de cacher
20131025 1 20131025_Locuteur_1 1938.380 1945.530 <o,f4,male> on cache aussi
20131025 1 20131025_Locuteur_1 1945.530 1949.190 <o,f4,male> des i() des messages dans des textes, voilà.
20131025 1 20131025_Locuteur_1 1949.190 1953.170 <o,f4,male> le message était bien caché, vous l'avez là
20131025 1 20131025_Locuteur_1 1953.170 1958.020 <o,f4,male> la stéganographie consiste à cacher des messages dans des documents anodins ;
20131025 1 20131025_Locuteur_1 1958.020 1960.020 <o,f4,male> cette carte que vous auriez pu envoyer à votre grand-mère.
20131025 1 20131025_Locuteur_1 1960.020 1965.410 <o,f4,male> même si elle était interceptée, il était très difficile de retrouver le message codé.
20131025 1 20131025_Locuteur_1 1965.410 1971.776 <o,f4,male> évidemment c'est c'est évident de retrouver le message quand on connaît le principe qui a permis de le cacher.
20131025 1 20131025_Locuteur_1 1971.776 1974.220 <o,f4,male> donc c'est pas des bons cryptosystèmes dans le sens où
20131025 1 20131025_Locuteur_1 1974.220 1978.990 <o,f4,male> ça () leur secret ne repose pas sur la clé, ça ne repose que sur le coffre
20131025 1 20131025_Locuteur_1 1978.990 1981.287 <o,f4,male> ou sur la qualité du coffre.
20131025 1 20131025_Locuteur_1 1981.287 1987.020 <o,f4,male> il y a plein d'exemples comme ça dans la littérature.
20131025 1 20131025_Locuteur_1 1987.020 1988.850 <o,f4,male> allez, on a passé un grand
20131025 1 20131025_Locuteur_1 1988.850 1995.033 <o,f4,male> on a passé plusieurs siècles, là, et on arrive à la seconde guerre mondiale.
20131025 1 20131025_Locuteur_1 1995.033 2001.501 <o,f4,male> pour communiquer de manière sécurisée, les troupes allemandes avaient mis au point une machine, la première machine
20131025 1 20131025_Locuteur_1 2001.501 2002.933 <o,f4,male> à coder des messages.
20131025 1 20131025_Locuteur_1 2002.933 2005.863 <o,f4,male> cette machine s'appelait enigma.
20131025 1 20131025_Locuteur_1 2005.863 2008.140 <o,f4,male> ils en étaient très fiers
20131025 1 20131025_Locuteur_1 2008.140 2012.608 <o,f4,male> et ils s'envoyaient ils communiquaient de manière très fiable
20131025 1 20131025_Locuteur_1 2012.608 2016.031 <o,f4,male> à leur avis entre leurs troupes.
20131025 1 20131025_Locuteur_1 2016.031 2018.220 <o,f4,male> le seul souci
20131025 1 20131025_Locuteur_1 2018.220 2021.600 <o,f4,male> c'est que les les alliés ont ont volé une machine
20131025 1 20131025_Locuteur_1 2021.600 2022.888 <o,f4,male> ils l'ont démontée,
20131025 1 20131025_Locuteur_1 2022.888 2025.889 <o,f4,male> ont compris comment le coffre fonctionnait
20131025 1 20131025_Locuteur_1 2025.889 2031.410 <o,f4,male> et en comprenant comment le coffre fonctionnait, ils ont été capables de décoder les messages, des messages importants
20131025 1 20131025_Locuteur_1 2031.410 2033.528 <o,f4,male> et la petite histoire dit que c'est
20131025 1 20131025_Locuteur_1 2033.528 2035.531 <o,f4,male> parce que ils ont été capables de décoder
20131025 1 20131025_Locuteur_1 2035.531 2040.183 <o,f4,male> la plupart des communications allemandes que les les alliés ont gagné la guerre
20131025 1 20131025_Locuteur_1 2040.183 2042.696 <o,f4,male> ils l'ont gagnée plus vite.
20131025 1 20131025_Locuteur_1 2042.696 2047.153 <o,f4,male> alors à quoi ressemblait cette machine ? bah ça ressemblait à une machine à écrire
20131025 1 20131025_Locuteur_1 2047.153 2052.551 <o,f4,male> c'était euh une machine euh qui euh permettait d'envoyer des signaux électriques, don() donc qui
20131025 1 20131025_Locuteur_1 2052.551 2056.589 <o,f4,male> qui était à base de signaux électriques, il y avait pas de signaux électroniques
20131025 1 20131025_Locuteur_1 2056.589 2064.817 <o,f4,male> le principe, c'était euh [pi] le principe, c'était [pi]
20131025 1 20131025_Locuteur_1 2064.817 2068.650 <o,f4,male> excusez-moi
20131025 1 20131025_Locuteur_1 2068.650 2069.180 <o,f4,male> hop
20131025 1 20131025_Locuteur_1 2069.180 2074.300 <o,f4,male> le principe, c'était : on appuie sur une euh une lettre, sur une touche
20131025 1 20131025_Locuteur_1 2074.300 2077.288 <o,f4,male> et ça nous dit quelle lettre je dois écrire
20131025 1 20131025_Locuteur_1 2077.288 2080.686 <o,f4,male> en allumant une petite euh une petite ampoule ici.
20131025 1 20131025_Locuteur_1 2080.686 2084.496 <o,f4,male> donc on appuie sur une lettre, ça ça allume cette ampoule-là, ça veut dire que
20131025 1 20131025_Locuteur_1 2084.496 2088.178 <o,f4,male> si je tape un a, je dois écrire un i.
20131025 1 20131025_Locuteur_1 2088.178 2090.723 <o,f4,male> nan un [pi] c'est un i
20131025 1 20131025_Locuteur_1 2090.723 2093.189 <o,f4,male> et cetera () nan, c'est un i grec [pi]
20131025 1 20131025_Locuteur_1 2093.189 2095.323 <o,f4,male> et cetera, et cetera
20131025 1 20131025_Locuteur_1 2095.323 2097.820 <o,f4,male> nan, c'est un i
20131025 1 inter_segment_gap 2097.820 2099.654 <o,f4,>
20131025 1 20131025_Locuteur_1 2099.654 2100.351 <o,f4,male> c'est un ?
20131025 1 inter_segment_gap 2100.351 2101.118 <o,f4,>
20131025 1 20131025_Locuteur_1 2101.118 2102.202 <o,f4,male> c'est un z
20131025 1 20131025_Locuteur_1 2102.202 2103.353 <o,f4,male> merci
20131025 1 20131025_Locuteur_1 2103.353 2108.902 <o,f4,male> donc si je tape un a, je code par un z, il y a tout un tas de mécanismes qui se mettent à tourner
20131025 1 20131025_Locuteur_1 2108.902 2111.894 <o,f4,male> euh si bien que si je tape un a la fois suivante,
20131025 1 20131025_Locuteur_1 2111.894 2115.190 <o,f4,male> ce sera pas forcément un z, ce sera une autre lettre.
20131025 1 20131025_Locuteur_1 2115.190 2118.418 <o,f4,male> donc le principe de cette machine reposent sur des rotors
20131025 1 20131025_Locuteur_1 2118.418 2120.430 <o,f4,male> des rotors qu'on voit ici
20131025 1 20131025_Locuteur_1 2120.430 2126.360 <o,f4,male> [pi] c'est () les rotors qu'on voit ici, qui sont des des petits cylindres qui vont tourner
20131025 1 inter_segment_gap 2126.360 2130.921 <o,f4,>
20131025 1 20131025_Locuteur_1 2130.921 2131.970 <o,f4,male> voilà
20131025 1 20131025_Locuteur_1 2131.970 2134.452 <o,f4,male> donc ces rotors qui sont représentés ici
20131025 1 20131025_Locuteur_1 2134.452 2139.329 <o,f4,male> qui euh sont donc uniquement des petits euh contacts électriques entre
20131025 1 20131025_Locuteur_1 2139.329 2143.771 <o,f4,male> un bout d'un côté et une [pi] lettre de l'autre côté.
20131025 1 20131025_Locuteur_1 2143.771 2145.185 <o,f4,male> donc chaque rotor
20131025 1 20131025_Locuteur_1 2145.185 2149.872 <o,f4,male> si on regarde bien, c'est une substitution monoalphabétique fixée.
20131025 1 20131025_Locuteur_1 2149.872 2154.374 <o,f4,male> on en met plusieurs en série, dans la première version de la machine enigma il y en avait trois,
20131025 1 20131025_Locuteur_1 2154.374 2158.881 <o,f4,male> dans une version un peu plus tard, il y en avait euh six, mais c'était toujours des rotors
20131025 1 20131025_Locuteur_1 2158.881 2160.133 <o,f4,male> mis en série
20131025 1 20131025_Locuteur_1 2160.133 2161.284 <o,f4,male> et à chaque lettre
20131025 1 20131025_Locuteur_1 2161.284 2164.490 <o,f4,male> le rotor tourne et donc la substitution
20131025 1 20131025_Locuteur_1 2164.490 2169.460 <o,f4,male> que code le rotor change.
20131025 1 20131025_Locuteur_1 2169.460 2172.270 <o,f4,male> le principe de fonctionnement, c'était le suivant : donc
20131025 1 20131025_Locuteur_1 2172.270 2174.439 <o,f4,male> j'appuie sur la lettre a,
20131025 1 20131025_Locuteur_1 2174.439 2177.917 <o,f4,male> j'ai des contacts électriques qui se font, donc avec des
20131025 1 20131025_Locuteur_1 2177.917 2179.637 <o,f4,male> une première partie de connexion
20131025 1 20131025_Locuteur_1 2179.637 2181.773 <o,f4,male> mais la partie importante, c'est les rotors
20131025 1 20131025_Locuteur_1 2181.773 2185.450 <o,f4,male> donc mon signal électrique se balade dans les rotors
20131025 1 20131025_Locuteur_1 2185.450 2189.218 <o,f4,male> il est renvoyé par un réflecteur, il repasse dans les rotors
20131025 1 20131025_Locuteur_1 2189.218 2190.610 <o,f4,male> et puis hop
20131025 1 20131025_Locuteur_1 2190.610 2194.973 <o,f4,male> il envoie vers la petite ampoule c.
20131025 1 20131025_Locuteur_1 2194.973 2201.030 <o,f4,male> les rotors tournent et ça change les contacts électriques.
20131025 1 20131025_Locuteur_1 2201.030 2203.308 <o,f4,male> alors ce qui est important, c'est de savoir combien il y avait de
20131025 1 20131025_Locuteur_1 2203.308 2205.040 <o,f4,male> combien il y avait de clés à tester.
20131025 1 20131025_Locuteur_1 2205.040 2208.345 <o,f4,male> ben des clés, il y en avait quand même pas mal
20131025 1 20131025_Locuteur_1 2208.345 2213.470 <o,f4,male> puisque, si on regarde bien, il y avait donc une partie, un tableau de connexions avec des fiches
20131025 1 20131025_Locuteur_1 2213.470 2217.266 <o,f4,male> c'était une partie euh qu'on voyait en bas sur la photo.
20131025 1 20131025_Locuteur_1 2217.266 2220.089 <o,f4,male> donc ça, ça permettait de
20131025 1 20131025_Locuteur_1 2220.089 2222.539 <o,f4,male> définir une première partie de la clé de codage.
20131025 1 20131025_Locuteur_1 2222.539 2226.410 <o,f4,male> ensuite, il y avait l'ordre dans lequel on mettait les rotors,
20131025 1 20131025_Locuteur_1 2226.410 2230.053 <o,f4,male> ensuite il y avait la position initiale des rotors qui contribuait à
20131025 1 20131025_Locuteur_1 2230.053 2232.724 <o,f4,male> à définir la clé.
20131025 1 20131025_Locuteur_1 2232.724 2240.201 <o,f4,male> si on met tout ça bout à bout, ça faisait euh à peu près dix à la puissance seize clés. ça fait beaucoup, dix à la puissance seize clés
20131025 1 20131025_Locuteur_1 2240.201 2242.250 <o,f4,male> je vous rappelle que si vous étiez un humain
20131025 1 20131025_Locuteur_1 2242.250 2247.037 <o,f4,male> sans ordinateur, ce qui était à peu près le cas en () pendant la seconde guerre mondiale
20131025 1 20131025_Locuteur_1 2247.037 2249.764 <o,f4,male> a () au début de la seconde guerre mondiale d'ailleurs, plutôt
20131025 1 20131025_Locuteur_1 2249.764 2254.619 <o,f4,male> euh un être humain qui serait capable de tester un mil() euh cent mille clés par seconde
20131025 1 20131025_Locuteur_1 2254.619 2257.572 <o,f4,male> mettrait environ trente siècles pour toutes les tester.
20131025 1 20131025_Locuteur_1 2257.572 2262.893 <o,f4,male> et pourtant je vous ai dit, c'est grâce () c'est parce que le cryptosystème a été cassé
20131025 1 20131025_Locuteur_1 2262.893 2266.988 <o,f4,male> que les alliés ont pu euh ont pu facilement gagner la guerre
20131025 1 20131025_Locuteur_1 2266.988 2272.515 <o,f4,male> donc c'est pas un bon cryptosystème.
20131025 1 20131025_Locuteur_1 2272.515 2276.940 <o,f4,male> le seul bon cryptosystème inventé jusqu'à présent
20131025 1 20131025_Locuteur_1 2276.940 2283.332 <o,f4,male> et il y en a pas () et il y en a aucun de mieux que celui-là en termes de sécurité, c'est le cryptosystème de vernam
20131025 1 20131025_Locuteur_1 2283.332 2286.360 <o,f4,male> ou le codage ou ou le système de vernam
20131025 1 20131025_Locuteur_1 2286.360 2291.090 <o,f4,male> c'est celui qui était utilisé dans les années soixante, soixante-dix pour euh
20131025 1 20131025_Locuteur_1 2291.090 2294.046 <o,f4,male> dans le télépho() dans le téléphone rouge
20131025 1 20131025_Locuteur_1 2294.046 2297.175 <o,f4,male> donc euh son principe est extrêmement simple
20131025 1 20131025_Locuteur_1 2297.175 2298.690 <o,f4,male> on a un message
20131025 1 20131025_Locuteur_1 2298.690 2299.928 <o,f4,male> clair
20131025 1 20131025_Locuteur_1 2299.928 2302.010 <o,f4,male> qu'on écrit sous forme de de bits
20131025 1 20131025_Locuteur_1 2302.010 2305.650 <o,f4,male> on a une clé secrète qu'on écrit sous forme de bits
20131025 1 20131025_Locuteur_1 2305.650 2309.177 <o,f4,male> le texte chiffré, c'est l'addition modulo deux de [pi]
20131025 1 20131025_Locuteur_1 2309.177 2313.320 <o,f4,male> de la () du texte clair et de la clé.
20131025 1 20131025_Locuteur_1 2313.320 2321.370 <o,f4,male> pourquoi le cryptosystème est bon et est meilleur que les autres ? bah c'est tout simplement parce qu'on prend une clé qui est aussi longue que le message.
20131025 1 20131025_Locuteur_1 2321.370 2328.370 <o,f4,male> donc si on si on a cette clé aussi longue que la le message, et que cette clé est parfaitement aléatoire
20131025 1 20131025_Locuteur_1 2328.370 2330.506 <o,f4,male> alors on peut prouver
20131025 1 20131025_Locuteur_1 2330.506 2332.300 <o,f4,male> mathématiquement
20131025 1 20131025_Locuteur_1 2332.300 2338.420 <o,f4,male> ça, ça a été fait par euh un des théoriciens de la théorie de l'information qui s'appelle euh claude shannon,
20131025 1 20131025_Locuteur_1 2338.420 2340.121 <o,f4,male> on peut prouver qu'il est
20131025 1 20131025_Locuteur_1 2340.121 2343.135 <o,f4,male> qu'il est inconditionnellement sûr
20131025 1 20131025_Locuteur_1 2343.135 2347.600 <o,f4,male> à condition que la clé soit parfaitement aléatoire et ne soit utilisée qu'une seule fois.
20131025 1 20131025_Locuteur_1 2347.600 2349.875 <o,f4,male> et voilà, le le le piège est là :
20131025 1 20131025_Locuteur_1 2349.875 2354.470 <o,f4,male> c'est que des cryptosystèmes comme ça, on peut pas les mettre en oeuvre
20131025 1 20131025_Locuteur_1 2354.470 2362.170 <o,f4,male> ou alors on peut les mettre en oeuvre, mais dans des conditions très particulières ; bon c'était le cas du téléphone rouge
20131025 1 20131025_Locuteur_1 2362.170 2363.564 <o,f4,male> où dans ce cas-là
20131025 1 20131025_Locuteur_1 2363.564 2366.060 <o,f4,male> le problème, c'est l'échange de la clé.
20131025 1 20131025_Locuteur_1 2366.060 2368.150 <o,f4,male> si on veut se parler pendant une minute,
20131025 1 20131025_Locuteur_1 2368.150 2371.197 <o,f4,male> donc on va coder une une minute de signal
20131025 1 20131025_Locuteur_1 2371.197 2372.650 <o,f4,male> euh sonore
20131025 1 20131025_Locuteur_1 2372.650 2375.339 <o,f4,male> sur un téléphone, donc il en faut un paquet de
20131025 1 20131025_Locuteur_1 2375.339 2379.540 <o,f4,male> de zéros et de uns, donc il faut des très très longues clés.
20131025 1 20131025_Locuteur_1 2379.540 2383.080 <o,f4,male> ça ne pouvait être utilisé que à une échelle euh de président
20131025 1 20131025_Locuteur_1 2383.080 2385.170 <o,f4,male> euh américain et russe
20131025 1 20131025_Locuteur_1 2385.170 2388.934 <o,f4,male> et dans ce cas-là, la clé elle était transmise par valise diplomatique.
20131025 1 20131025_Locuteur_1 2388.934 2395.729 <o,f4,male> donc quand chaque président voulait se téléphoner, ils se () ils envoyaient un diplomate avec une valise remplie de zéros et de uns
20131025 1 20131025_Locuteur_1 2395.729 2401.360 <o,f4,male> pour pouvoir communiquer de manière chiffrée entre les deux.
20131025 1 20131025_Locuteur_1 2401.360 2403.910 <o,f4,male> voilà
20131025 1 20131025_Locuteur_1 2403.910 2411.160 <o,f4,male> faut savoir que le début de la cryptographie mo() de la recherche moderne en cryptographie, c'est parce qu'on voulait améliorer le système
20131025 1 20131025_Locuteur_1 2411.160 2414.530 <o,f4,male> qu'on a lancé euh des recherches en cryptographie
20131025 1 20131025_Locuteur_1 2414.530 2420.728 <o,f4,male> des recherches modernes en cryptographie.
20131025 1 20131025_Locuteur_1 2420.728 2425.220 <o,f4,male> et à cette époque, peu() peut-être un peu avant, on a défini d'un certain nombre de critères
20131025 1 20131025_Locuteur_1 2425.220 2429.930 <o,f4,male> que doit satisfaire un protocole cryptographique.
20131025 1 20131025_Locuteur_1 2429.930 2435.642 <o,f4,male> alors ces critères sont connus sous les noms de de principes de kerckhoffs
20131025 1 20131025_Locuteur_1 2435.642 2436.960 <o,f4,male> et il y en a sept :
20131025 1 20131025_Locuteur_1 2436.960 2441.100 <o,f4,male> donc le premier critère, c'est qu'une information codée
20131025 1 20131025_Locuteur_1 2441.100 2444.720 <o,f4,male> ne doit en aucun cas être décodée sans la clé.
20131025 1 20131025_Locuteur_1 2444.720 2446.970 <o,f4,male> ça élimine les principes de stéganographie
20131025 1 20131025_Locuteur_1 2446.970 2450.947 <o,f4,male> sté() la stéganographie n'est pas un bon cryptosystème.
20131025 1 20131025_Locuteur_1 2450.947 2452.771 <o,f4,male> deuxième principe :
20131025 1 20131025_Locuteur_1 2452.771 2458.030 <o,f4,male> les interlocuteurs ne doivent pas subir de dégâts au cas où le système de codage est dévoilé
20131025 1 20131025_Locuteur_1 2458.030 2463.010 <o,f4,male> ça élimine enigma.
20131025 1 20131025_Locuteur_1 2463.010 2468.060 <o,f4,male> troisième crypto() troisième principe : la clé doit être simple
20131025 1 20131025_Locuteur_1 2468.060 2469.800 <o,f4,male> et modifiable à souhait
20131025 1 20131025_Locuteur_1 2469.800 2474.551 <o,f4,male> ça élimine le cryptosystème de vernam.
20131025 1 20131025_Locuteur_1 2474.551 2479.680 <o,f4,male> les cryptogrammes doivent être transportables, c'est-à-dire télégraphiables
20131025 1 20131025_Locuteur_1 2479.680 2483.880 <o,f4,male> alors euh voilà télégraphiables parce que on était au dix-neuvième siècle
20131025 1 20131025_Locuteur_1 2483.880 2487.117 <o,f4,male> euh là on pourrait dire que les crypto() les
20131025 1 20131025_Locuteur_1 2487.117 2492.475 <o,f4,male> cryptogrammes doivent pouvoir être envoyés sur des signaux satellitaires,
20131025 1 20131025_Locuteur_1 2492.475 2494.230 <o,f4,male> pour être plus moderne.
20131025 1 20131025_Locuteur_1 2494.230 2499.620 <o,f4,male> mais le le la problématique est toujours là
20131025 1 20131025_Locuteur_1 2499.620 2506.610 <o,f4,male> l'appareil de codage et les documents doivent être transportables
20131025 1 20131025_Locuteur_1 2506.610 2508.395 <o,f4,male> ça, c'est encore d'actualité :
20131025 1 20131025_Locuteur_1 2508.395 2513.370 <o,f4,male> vous devez pouvoir intégrer un système de codage dans votre téléphone portable ;
20131025 1 20131025_Locuteur_1 2513.370 2514.231 <o,f4,male> c'est le cas.
20131025 1 20131025_Locuteur_1 2514.231 2518.587 <o,f4,male> vous avez des systèmes cryptographiques dans votre téléphone portable ;
20131025 1 20131025_Locuteur_1 2518.587 2521.970 <o,f4,male> vous l'avez sans le savoir, mais vous l'avez.
20131025 1 20131025_Locuteur_1 2521.970 2525.050 <o,f4,male> le système doit être simple d'utilisation
20131025 1 20131025_Locuteur_1 2525.050 2530.330 <o,f4,male> simplement parce que vous de() n'avez pas besoin d'être expert en cryptographie pour utiliser des protocoles cryptographiques.
20131025 1 20131025_Locuteur_1 2530.330 2531.910 <o,f4,male> ça doit être
20131025 1 20131025_Locuteur_1 2531.910 2536.087 <o,f4,male> les protocoles cryptographiques doivent être au service de la société.
20131025 1 20131025_Locuteur_1 2536.087 2540.431 <o,f4,male> on n'a pas besoin d'être expert pour coder un message
20131025 1 20131025_Locuteur_1 2540.431 2542.359 <o,f4,male> et évidemment
20131025 1 20131025_Locuteur_1 2542.359 2547.569 <o,f4,male> même si ce cryptosystème doit être utilisé par n'importe, il doit quand même être
20131025 1 20131025_Locuteur_1 2547.569 2550.460 <o,f4,male> vérifié par des experts.
20131025 1 20131025_Locuteur_1 2550.460 2552.408 <o,f4,male> donc ça, tout ça c'est d'actualité
20131025 1 20131025_Locuteur_1 2552.408 2555.256 <o,f4,male> même si ça a été initié dans les années euh
20131025 1 20131025_Locuteur_1 2555.256 2557.549 <o,f4,male> vers la fin du
20131025 1 20131025_Locuteur_1 2557.549 2561.279 <o,f4,male> du dix-neuvième siècle, c'est toujours d'actualité.
20131025 1 20131025_Locuteur_1 2561.279 2565.180 <o,f4,male> tous les cryptosystèmes modernes respectent ces principes
20131025 1 20131025_Locuteur_1 2565.180 2569.116 <o,f4,male> sauf éventuellement quelques cryptosystèmes militaire
20131025 1 20131025_Locuteur_1 2569.116 2572.008 <o,f4,male> qui sont par nature des *cryptosystèmes
20131025 1 20131025_Locuteur_1 2572.008 2576.624 <o,f4,male> validés par des experts militaires, mais qui sont absolument pas euh
20131025 1 20131025_Locuteur_1 2576.624 2580.150 <o,f4,male> amenés à être dévoilés.
20131025 1 20131025_Locuteur_1 2580.150 2583.710 <o,f4,male> donc il y avait une maxime de shannon qui disait : voilà
20131025 1 20131025_Locuteur_1 2583.710 2585.918 <o,f4,male> l'adversaire doit connaître
20131025 1 20131025_Locuteur_1 2585.918 2587.340 <o,f4,male> nos failles
20131025 1 20131025_Locuteur_1 2587.340 2594.000 <o,f4,male> on doit être conscient que l'adversaire connaît nos failles.
20131025 1 20131025_Locuteur_1 2594.000 2594.900 <o,f4,male> bon
20131025 1 20131025_Locuteur_1 2594.900 2597.424 <o,f4,male> alors je vous ai promis quelques petites attaques
20131025 1 20131025_Locuteur_1 2597.424 2598.816 <o,f4,male> on change de monde
20131025 1 20131025_Locuteur_1 2598.816 2600.460 <o,f4,male> on passe dans le monde des méchants
20131025 1 20131025_Locuteur_1 2600.460 2602.538 <o,f4,male> et on va voir comment on attaque
20131025 1 20131025_Locuteur_1 2602.538 2608.311 <o,f4,male> les cryptosystèmes quand on est quelqu'un de mal intentionné.
20131025 1 20131025_Locuteur_1 2608.311 2613.971 <o,f4,male> donc pourquoi ce que je vous ai présenté jusqu'à présent, ça ne prés() ce ne sont pas de bons cryptosystèmes ?
20131025 1 20131025_Locuteur_1 2613.971 2619.893 <o,f4,male> voilà ce qu'on va chercher à répondre euh là maintenant.
20131025 1 20131025_Locuteur_1 2619.893 2623.683 <o,f4,male> et on va définir un certain nombre d'attaques :
20131025 1 20131025_Locuteur_1 2623.683 2625.529 <o,f4,male> la première attaque,
20131025 1 20131025_Locuteur_1 2625.529 2629.357 <o,f4,male> c'est celle qui consiste à essayer toutes les clés.
20131025 1 20131025_Locuteur_1 2629.357 2631.856 <o,f4,male> donc on l'appelle l'attaque force brute
20131025 1 20131025_Locuteur_1 2631.856 2634.645 <o,f4,male> ou attaque exhaustive.
20131025 1 20131025_Locuteur_1 2634.645 2636.780 <o,f4,male> le principe, c'est voilà :
20131025 1 20131025_Locuteur_1 2636.780 2638.956 <o,f4,male> on sait qu'on n'a pas trop de clés à tester
20131025 1 20131025_Locuteur_1 2638.956 2644.640 <o,f4,male> on les teste toutes et puis on réussira bien à décoder le message.
20131025 1 20131025_Locuteur_1 2644.640 2650.079 <o,f4,male> donc ça nécessite d'être capable de reconnaître assez rapidement si un texte est écrit
20131025 1 20131025_Locuteur_1 2650.079 2652.710 <o,f4,male> dans un langage compréhensible ou non
20131025 1 20131025_Locuteur_1 2652.710 2655.058 <o,f4,male> mais en général, ça marche bien
20131025 1 20131025_Locuteur_1 2655.058 2657.190 <o,f4,male> sur les ordinateurs puisque
20131025 1 20131025_Locuteur_1 2657.190 2659.262 <o,f4,male> on sera capable de
20131025 1 20131025_Locuteur_1 2659.262 2664.953 <o,f4,male> de faire ce genre de () il y a () il existe des tests pour savoir si [pi] un texte est bien écrit en français ou pas.
20131025 1 20131025_Locuteur_1 2664.953 2666.312 <o,f4,male> donc on
20131025 1 20131025_Locuteur_1 2666.312 2670.480 <o,f4,male> on sera capable de de décoder assez facilement le codage de césar
20131025 1 20131025_Locuteur_1 2670.480 2672.080 <o,f4,male> en testant vingt-six clés
20131025 1 20131025_Locuteur_1 2672.080 2675.461 <o,f4,male> on sera capable de décoder le codage grec en testant euh
20131025 1 20131025_Locuteur_1 2675.461 2678.698 <o,f4,male> cent clés s'il le faut
20131025 1 20131025_Locuteur_1 2678.698 2682.797 <o,f4,male> si cent, c'est la longueur des messages parce que tout simplement il y a pas trop de clés à tester.
20131025 1 20131025_Locuteur_1 2682.797 2685.195 <o,f4,male> donc l'attaque force brute, ça marche bien
20131025 1 20131025_Locuteur_1 2685.195 2689.395 <o,f4,male> dans le cas où il y a pas trop de clés.
20131025 1 20131025_Locuteur_1 2689.395 2691.997 <o,f4,male> la deuxième attaque
20131025 1 20131025_Locuteur_1 2691.997 2695.183 <o,f4,male> c'est une attaque euh qui utilise la la faille
20131025 1 20131025_Locuteur_1 2695.183 2697.744 <o,f4,male> ou la redondance des messages.
20131025 1 20131025_Locuteur_1 2697.744 2700.630 <o,f4,male> le fait qu'un message soit écrit en français, c'est pas
20131025 1 20131025_Locuteur_1 2700.630 2704.240 <o,f4,male> le fait de savoir qu'un message est écrit a() en français, c'est pas anodin.
20131025 1 20131025_Locuteur_1 2704.240 2707.996 <o,f4,male> on a dit qu'on s'en moquait quand on définissait des cryptosystèmes
20131025 1 20131025_Locuteur_1 2707.996 2710.400 <o,f4,male> mais quand on attaque des cryptosystèmes
20131025 1 20131025_Locuteur_1 2710.400 2714.200 <o,f4,male> c'est une () c'est un élément qu'on peut prendre en compte.
20131025 1 20131025_Locuteur_1 2714.200 2717.685 <o,f4,male> et ce qui va se passer, c'est que s'il est écrit en français
20131025 1 20131025_Locuteur_1 2717.685 2720.324 <o,f4,male> alors on sait que il y a une lettre qui prédomine
20131025 1 20131025_Locuteur_1 2720.324 2721.718 <o,f4,male> c'est le e.
20131025 1 20131025_Locuteur_1 2721.718 2724.134 <o,f4,male> il y a à peu près vingt pour cent de e
20131025 1 20131025_Locuteur_1 2724.134 2726.020 <o,f4,male> dans les textes écrits en français.
20131025 1 20131025_Locuteur_1 2726.020 2731.389 <o,f4,male> c'est pour ça, tout à l'heure quand j'ai supprimé euh les e de jérémy, vous étiez quand même capables de relire jérémy
20131025 1 20131025_Locuteur_1 2731.389 2733.630 <o,f4,male> parce que des e, il y en a plein.
20131025 1 20131025_Locuteur_1 2733.630 2734.654 <o,f4,male> donc il y a
20131025 1 20131025_Locuteur_1 2734.654 2736.147 <o,f4,male> deux fois plus
20131025 1 20131025_Locuteur_1 2736.147 2737.274 <o,f4,male> de e
20131025 1 20131025_Locuteur_1 2737.274 2739.229 <o,f4,male> que la plus
20131025 1 20131025_Locuteur_1 2739.229 2741.805 <o,f4,male> que la seconde euh meilleure euh lettre
20131025 1 20131025_Locuteur_1 2741.805 2744.290 <o,f4,male> que la seconde lettre la plus représentée
20131025 1 20131025_Locuteur_1 2744.290 2745.868 <o,f4,male> voilà, qui est le a
20131025 1 20131025_Locuteur_1 2745.868 2749.050 <o,f4,male> le a, il y en a à peu près euh huit pour cent ;
20131025 1 20131025_Locuteur_1 2749.050 2751.240 <o,f4,male> des e, il y en a à peu près vingt pour cent
20131025 1 20131025_Locuteur_1 2751.240 2753.025 <o,f4,male> donc il y en a à peu près deux fois plus.
20131025 1 20131025_Locuteur_1 2753.025 2754.196 <o,f4,male> du coup
20131025 1 20131025_Locuteur_1 2754.196 2757.360 <o,f4,male> pour le codage de césar,
20131025 1 20131025_Locuteur_1 2757.360 2759.460 <o,f4,male> c'est un élément qui est très important, ça
20131025 1 20131025_Locuteur_1 2759.460 2762.305 <o,f4,male> puisqu'on doit savoir quelle est la lettre
20131025 1 20131025_Locuteur_1 2762.305 2764.640 <o,f4,male> qui se trouve en face du a
20131025 1 20131025_Locuteur_1 2764.640 2767.979 <o,f4,male> si on trouve la lettre qui est en face du e
20131025 1 20131025_Locuteur_1 2767.979 2769.640 <o,f4,male> s() ça () c'est pareil
20131025 1 20131025_Locuteur_1 2769.640 2775.123 <o,f4,male> il suffira de décaler de trois positions pour retrouver celle qui était en face du a et on aura décodé le codage de césar..
20131025 1 20131025_Locuteur_1 2775.123 2778.564 <o,f4,male> donc pour décoder un codage de césar,
20131025 1 20131025_Locuteur_1 2778.564 2781.537 <o,f4,male> on fait un tableau de fréquence des lettres
20131025 1 20131025_Locuteur_1 2781.537 2783.245 <o,f4,male> du message codé,
20131025 1 20131025_Locuteur_1 2783.245 2786.130 <o,f4,male> on trouve la lettre qui prédomine
20131025 1 20131025_Locuteur_1 2786.130 2791.400 <o,f4,male> et on sait que cette lettre qui prédomine est en face () est est la lettre qui code le e.
20131025 1 20131025_Locuteur_1 2791.400 2793.161 <o,f4,male> et ça, ça marche presque à tous les coups :
20131025 1 20131025_Locuteur_1 2793.161 2795.779 <o,f4,male> il suffit que le message soit suffisamment long
20131025 1 20131025_Locuteur_1 2795.779 2800.304 <o,f4,male> alors suffisamment long, c'est de l'ordre de vingt ou trente caractères hein
20131025 1 20131025_Locuteur_1 2800.304 2800.979 <o,f4,male> il y a une
20131025 1 20131025_Locuteur_1 2800.979 2805.470 <o,f4,male> très () tellement grande prédominance du e que vingt ou tr() un message de vingt ou trente caractères
20131025 1 20131025_Locuteur_1 2805.470 2817.074 <o,f4,male> euh aura déjà plus de e que toutes les autres lettres.
20131025 1 20131025_Locuteur_1 2817.074 2818.139 <o,f4,male> alors
20131025 1 20131025_Locuteur_1 2818.139 2819.630 <o,f4,male> dernier type d'attaque :
20131025 1 20131025_Locuteur_1 2819.630 2826.790 <o,f4,male> je vous ai dit la () dans le cas des codages de vigenère, la longueur de la clé c'est un élément important.
20131025 1 20131025_Locuteur_1 2826.790 2830.473 <o,f4,male> un des buts, ça va donc être de retrouver la longueur de cette clé
20131025 1 20131025_Locuteur_1 2830.473 2832.390 <o,f4,male> et on aura trois manières de
20131025 1 20131025_Locuteur_1 2832.390 2837.530 <o,f4,male> pour re() trois trois types de d'attaques qui permettront de retrouver la longueur de la clé.
20131025 1 20131025_Locuteur_1 2837.530 2841.600 <o,f4,male> la première attaque va consister à rechercher
20131025 1 20131025_Locuteur_1 2841.600 2844.210 <o,f4,male> des mots probables
20131025 1 20131025_Locuteur_1 2844.210 2847.880 <o,f4,male> le mot "les" en français est très souvent codé
20131025 1 20131025_Locuteur_1 2847.880 2849.640 <o,f4,male> est très s() est très présent.
20131025 1 20131025_Locuteur_1 2849.640 2851.908 <o,f4,male> donc il y a de grandes chances que
20131025 1 20131025_Locuteur_1 2851.908 2853.880 <o,f4,male> si on a un long texte
20131025 1 20131025_Locuteur_1 2853.880 2857.598 <o,f4,male> "les" soit toujours () soit souvent codé par les trois mêmes lettres.
20131025 1 20131025_Locuteur_1 2857.598 2859.710 <o,f4,male> donc on détecte
20131025 1 20131025_Locuteur_1 2859.710 2863.153 <o,f4,male> des des groupes de lettres qui se suivent, qui vont coder pour des mots
20131025 1 20131025_Locuteur_1 2863.153 2867.777 <o,f4,male> probables, et puis on [pi] on réussira à décoder des codages de vigenère comme ça,
20131025 1 20131025_Locuteur_1 2867.777 2870.787 <o,f4,male> en trouvant des mots probables.
20131025 1 20131025_Locuteur_1 2870.787 2872.570 <o,f4,male> le deuxième
20131025 1 20131025_Locuteur_1 2872.570 2878.960 <o,f4,male> test qui permet de cal() la deuxième attaque qui permet de calculer la longueur de la clé, ça s'appelle le test de friedman.
20131025 1 20131025_Locuteur_1 2878.960 2881.860 <o,f4,male> c'est un test qui, étant donné les fréquences d'apparition
20131025 1 20131025_Locuteur_1 2881.860 2884.001 <o,f4,male> des lettres dans un texte,
20131025 1 20131025_Locuteur_1 2884.001 2888.520 <o,f4,male> est capable de déterminer si c'est un texte en français ou si c'est un texte aléatoire.
20131025 1 20131025_Locuteur_1 2888.520 2892.584 <o,f4,male> donc pour trouver la longueur de la clé,
20131025 1 20131025_Locuteur_1 2892.584 2896.439 <o,f4,male> on va [pi] on va faire un tableau de fréquences en prenant toutes les lettres
20131025 1 20131025_Locuteur_1 2896.439 2901.103 <o,f4,male> les unes à la suite des autres, donc sans passer des s() sans passer de lettres
20131025 1 20131025_Locuteur_1 2901.103 2906.264 <o,f4,male> si c'est un texte qui ressemble à du français selon le test de friedman, alors c'est que la clé
20131025 1 20131025_Locuteur_1 2906.264 2908.290 <o,f4,male> sera de longueur un
20131025 1 20131025_Locuteur_1 2908.290 2910.380 <o,f4,male> sera un codage de césar
20131025 1 20131025_Locuteur_1 2910.380 2914.850 <o,f4,male> si ça ressemble plutôt à un texte aléatoire, c'est que la clé sera pas de longueur un, on teste la longueur deux
20131025 1 20131025_Locuteur_1 2914.850 2917.820 <o,f4,male> donc en prenant une lettre sur deux.
20131025 1 20131025_Locuteur_1 2917.820 2923.339 <o,f4,male> si le texte euh si le tableau de fréquences reta() ressemble à un tableau de fréquences de français,
20131025 1 20131025_Locuteur_1 2923.339 2928.480 <o,f4,male> alors euh c'est qu'on a trouvé la longueur de la clé, c'est deux ; sinon on teste la longueur trois, et cetera et cetera.
20131025 1 20131025_Locuteur_1 2928.480 2932.740 <o,f4,male> donc en faisant ça, c'est un test de friedman qui se calcule assez facilement
20131025 1 20131025_Locuteur_1 2932.740 2935.853 <o,f4,male> on sera capable de retrouver la longueur de la clé.
20131025 1 20131025_Locuteur_1 2935.853 2941.250 <o,f4,male> la troisième manière pour essayer de re() retrouver la longueur de la clé, c'est la méthode de pavel [pi]
20131025 1 20131025_Locuteur_1 2941.250 2942.395 <o,f4,male> qui, comme
20131025 1 20131025_Locuteur_1 2942.395 2948.044 <o,f4,male> la technique du du du mot probable, va rechercher des séquences de lettres qui se répètent dans le texte.
20131025 1 20131025_Locuteur_1 2948.044 2951.560 <o,f4,male> et si elles se répètent, elles vont avoir tendance à se répéter
20131025 1 20131025_Locuteur_1 2951.560 2955.360 <o,f4,male> en des longueurs multiples
20131025 1 20131025_Locuteur_1 2955.360 2958.281 <o,f4,male> de la longueur de la clé.
20131025 1 20131025_Locuteur_1 2958.281 2966.374 <o,f4,male> ensuite, si on s() si on trouve un certain nombre de de lettres, de suites de lettres qui se répètent comme ça, on peut [pi] le plus petit commun multiple [pi]
20131025 1 20131025_Locuteur_1 2966.374 2968.170 <o,f4,male> de toutes ces longueurs et on retrouve
20131025 1 20131025_Locuteur_1 2968.170 2970.863 <o,f4,male> on a de grandes chances de retrouver la longueur de la clé.
20131025 1 20131025_Locuteur_1 2970.863 2976.370 <o,f4,male> donc trois attaques qui permettent de retrouver la longueur de la clé d'un codage de vigenère ;
20131025 1 20131025_Locuteur_1 2976.370 2980.430 <o,f4,male> c'est pour ça que le codage de vigenère n'est pas un bon cryptosystème.
20131025 1 20131025_Locuteur_1 2980.430 2982.496 <o,f4,male> allez, on passe dans le monde euh des gentils
20131025 1 20131025_Locuteur_1 2982.496 2988.815 <o,f4,male> et on va parler de cryptographie moderne.
20131025 1 20131025_Locuteur_1 2988.815 2989.717 <o,f4,male> alors
20131025 1 20131025_Locuteur_1 2989.717 2998.544 <o,f4,male> dans la cryptographie moderne, on va distinguer deux choses : on va distinguer la cryptographie de ce qu'on appelle la cryptanalyse.
20131025 1 20131025_Locuteur_1 2998.544 3001.450 <o,f4,male> qu'est-ce que s() et et tout ça
20131025 1 20131025_Locuteur_1 3001.450 3005.053 <o,f4,male> ces deux termes représentent ce qu'on [pi] va appeler la cryptologie.
20131025 1 20131025_Locuteur_1 3005.053 3006.936 <o,f4,male> alors la cryptologie
20131025 1 20131025_Locuteur_1 3006.936 3008.532 <o,f4,male> c'est la science
20131025 1 20131025_Locuteur_1 3008.532 3009.638 <o,f4,male> du secret ;
20131025 1 20131025_Locuteur_1 3009.638 3011.810 <o,f4,male> science qui comporte deux branches :
20131025 1 20131025_Locuteur_1 3011.810 3014.807 <o,f4,male> la branche des gentils, la cryptographie
20131025 1 20131025_Locuteur_1 3014.807 3018.506 <o,f4,male> qui est euh la branche qui va concevoir des systèmes cryptographiques,
20131025 1 20131025_Locuteur_1 3018.506 3023.770 <o,f4,male> mettre en place des protocoles cryptographiques et mettre à disposition des services cryptographiques.
20131025 1 20131025_Locuteur_1 3023.770 3025.824 <o,f4,male> et puis il y aura le monde des méchants
20131025 1 20131025_Locuteur_1 3025.824 3027.468 <o,f4,male> la cryptanalyse
20131025 1 20131025_Locuteur_1 3027.468 3030.660 <o,f4,male> qui va chercher à à casser ces protocoles cryptographiques.
20131025 1 inter_segment_gap 3030.660 3033.329 <o,f4,>
20131025 1 20131025_Locuteur_1 3033.329 3035.788 <o,f4,male> vous retrouvez tous ces transparents en ligne sur madoc, hein
20131025 1 20131025_Locuteur_1 3035.788 3037.778 <o,f4,male> c'est pour ça que ça va () ça peut aller un peu vite
20131025 1 20131025_Locuteur_1 3037.778 3044.170 <o,f4,male> mais vous avez tout en ligne.
20131025 1 20131025_Locuteur_1 3044.170 3045.133 <o,f4,male> voilà donc
20131025 1 20131025_Locuteur_1 3045.133 3048.123 <o,f4,male> dans un cas, on est les gentils [pi]
20131025 1 20131025_Locuteur_1 3048.123 3052.096 <o,f4,male> on essaie de mettre au point des cryptosystèmes fiables, dans l'autre cas on est les méchants
20131025 1 20131025_Locuteur_1 3052.096 3053.489 <o,f4,male> et on utilise
20131025 1 20131025_Locuteur_1 3053.489 3054.513 <o,f4,male> tout
20131025 1 20131025_Locuteur_1 3054.513 3058.700 <o,f4,male> les informations à disposition pour essayer de casser le cryptosystème
20131025 1 20131025_Locuteur_1 3058.700 3063.824 <o,f4,male> y compris () on on utilise y compris la redondance ; c'est là qu'on l'utilise.
20131025 1 20131025_Locuteur_1 3063.824 3069.119 <o,f4,male> alors ça peut reposer sur un petit schéma comme ça
20131025 1 20131025_Locuteur_1 3069.119 3072.272 <o,f4,male> un petit schéma où en vert, vous avez la [pi]
20131025 1 20131025_Locuteur_1 3072.272 3076.612 <o,f4,male> en vert, vous avez la cryptographie et en jaune, vous avez la cryptanalyse.
20131025 1 20131025_Locuteur_1 3076.612 3078.783 <o,f4,male> en cryptographie,
20131025 1 20131025_Locuteur_1 3078.783 3080.870 <o,f4,male> on partira d'un message clair
20131025 1 20131025_Locuteur_1 3080.870 3083.730 <o,f4,male> et d'une clé de chiffrement
20131025 1 20131025_Locuteur_1 3083.730 3088.583 <o,f4,male> on aura une fonction en chiffrement ; c'est de l'algorithmique qu'il y a derrière tout ça, hein
20131025 1 20131025_Locuteur_1 3088.583 3090.750 <o,f4,male> ça a l'air caché, mais il y a de l'algorithmique derrière
20131025 1 20131025_Locuteur_1 3090.750 3093.120 <o,f4,male> il y a des fonctions qui permettent de faire le chiffrement,
20131025 1 20131025_Locuteur_1 3093.120 3095.744 <o,f4,male> il y a des fonctions qui permettent de faire le déchiffrement.
20131025 1 20131025_Locuteur_1 3095.744 3098.059 <o,f4,male> donc on a une fonction
20131025 1 20131025_Locuteur_1 3098.059 3099.300 <o,f4,male> qui chiffre,
20131025 1 20131025_Locuteur_1 3099.300 3101.470 <o,f4,male> qui permet d'obtenir un texte chiffré,
20131025 1 20131025_Locuteur_1 3101.470 3104.316 <o,f4,male> ce texte chiffré est envoyé sur le réseau
20131025 1 20131025_Locuteur_1 3104.316 3109.358 <o,f4,male> à une personne qui va essayer de le déchiffrer en ayant une [pi] clé de déchiffrement
20131025 1 20131025_Locuteur_1 3109.358 3113.702 <o,f4,male> et en utilisant une fonction de déchiffrement.
20131025 1 20131025_Locuteur_1 3113.702 3115.462 <o,f4,male> la cryptographie
20131025 1 20131025_Locuteur_1 3115.462 3125.164 <o,f4,male> une des tâches de la cryptographie, c'est de mettre au point ces fonctions de chiffrement et de déchiffrement, et de mettre au point des fonctions fiables.
20131025 1 20131025_Locuteur_1 3125.164 3128.450 <o,f4,male> la cryptanalyse, ça se passe ici
20131025 1 20131025_Locuteur_1 3128.450 3131.501 <o,f4,male> et ici on cherche à décrypter
20131025 1 20131025_Locuteur_1 3131.501 3134.190 <o,f4,male> le message codé sans connaître la clé.
20131025 1 20131025_Locuteur_1 3134.190 3138.690 <o,f4,male> il y a qu'un paramètre à la fonction de décryptement
20131025 1 20131025_Locuteur_1 3138.690 3148.570 <o,f4,male> et on va chercher à à décoder le message pour pouvoir trouver la clé.
20131025 1 20131025_Locuteur_1 3148.570 3152.017 <o,f4,male> quand on parle de sécurité et de chiffrement
20131025 1 20131025_Locuteur_1 3152.017 3155.414 <o,f4,male> les applications sont multiples
20131025 1 20131025_Locuteur_1 3155.414 3159.530 <o,f4,male> et on va di() on va distinguer deux choses : on va distinguer les services
20131025 1 20131025_Locuteur_1 3159.530 3161.970 <o,f4,male> de sécurité dont on a besoin
20131025 1 20131025_Locuteur_1 3161.970 3166.495 <o,f4,male> donc quand on parle de services, on parle de confidentialité ; on a envie
20131025 1 20131025_Locuteur_1 3166.495 3171.690 <o,f4,male> d'envoyer un message de manière confidentielle à un destinataire
20131025 1 20131025_Locuteur_1 3171.690 3173.532 <o,f4,male> on parle d'intégrité :
20131025 1 20131025_Locuteur_1 3173.532 3177.262 <o,f4,male> on a envie d'être sûr que le message qu'on a envoyé
20131025 1 20131025_Locuteur_1 3177.262 3179.775 <o,f4,male> ne () n'a pas pu être modifié
20131025 1 20131025_Locuteur_1 3179.775 3182.040 <o,f4,male> par un tiers.
20131025 1 20131025_Locuteur_1 3182.040 3185.833 <o,f4,male> une fois qui () une fois qu'on a signé un document, on signe pas une page blanche
20131025 1 20131025_Locuteur_1 3185.833 3187.923 <o,f4,male> on est sûr que le document qu'on a signé
20131025 1 20131025_Locuteur_1 3187.923 3193.640 <o,f4,male> ne pourra plus être modifié ; ça, ça s'appelle l'intégrité.
20131025 1 20131025_Locuteur_1 3193.640 3196.846 <o,f4,male> on a envie d'authentifier euh
20131025 1 20131025_Locuteur_1 3196.846 3199.612 <o,f4,male> l'origine des données ou l'origine d'un tiers donc
20131025 1 20131025_Locuteur_1 3199.612 3207.796 <o,f4,male> ça c'est un pr() c'est un principe de signature électronique ; on a envie de d'identifier la personne qui a signé
20131025 1 20131025_Locuteur_1 3207.796 3208.410 <o,f4,male> on
20131025 1 20131025_Locuteur_1 3208.410 3216.985 <o,f4,male> le terme non-répudiation, il est un petit peu plus compliqué euh à saisir puisque c'est pas quelque chose qu'on a l'habitude de faire
20131025 1 20131025_Locuteur_1 3216.985 3220.790 <o,f4,male> imaginons que vous ayez un chèque :
20131025 1 20131025_Locuteur_1 3220.790 3228.572 <o,f4,male> si quelqu'un signe votre chèque, vous pourrez toujours aller à la banque et dire : ah c'est pas moi qui ai signé le chèque !
20131025 1 20131025_Locuteur_1 3228.572 3230.580 <o,f4,male> si vous êtes pas très honnête,
20131025 1 20131025_Locuteur_1 3230.580 3233.691 <o,f4,male> vous pouvez signer un chèque
20131025 1 20131025_Locuteur_1 3233.691 3240.145 <o,f4,male> vous-même, et passer à la banque en disant : mais nan euh c'est pas () c'est jamais moi () c'est pas moi qui ai fait le chèque.
20131025 1 20131025_Locuteur_1 3240.145 3242.198 <o,f4,male> je vous assure, c'est pas moi qui ai fait le chèque.
20131025 1 20131025_Locuteur_1 3242.198 3243.762 <o,f4,male> vous pouvez être malhonnête.
20131025 1 20131025_Locuteur_1 3243.762 3249.300 <o,f4,male> ben le principe de non-répudiation, c'est qu'une fois que vous signez un document électronique avec une signature électronique,
20131025 1 20131025_Locuteur_1 3249.300 3251.130 <o,f4,male> il vous est impossible
20131025 1 20131025_Locuteur_1 3251.130 3253.449 <o,f4,male> de nier que vous avez signé le document
20131025 1 20131025_Locuteur_1 3253.449 3256.312 <o,f4,male> vous-même.
20131025 1 20131025_Locuteur_1 3256.312 3257.590 <o,f4,male> donc ça c'est
20131025 1 20131025_Locuteur_1 3257.590 3259.269 <o,f4,male> un des services qu'apportent
20131025 1 20131025_Locuteur_1 3259.269 3264.841 <o,f4,male> les protocoles cryptographiques, le principe de non-répudiation de de documents.
20131025 1 20131025_Locuteur_1 3264.841 3270.502 <o,f4,male> ces principes ces services de sécurité sont mis en place, mis en oeuvre par des mécanismes de sécurité
20131025 1 20131025_Locuteur_1 3270.502 3273.824 <o,f4,male> construits à partir d'outils cryptographiques
20131025 1 20131025_Locuteur_1 3273.824 3280.114 <o,f4,male> des outils cryptographiques qui sont des fonctions de chiffrement / déchiffrement, des algorithmes, des [pi] , des protocoles
20131025 1 20131025_Locuteur_1 3280.114 3282.930 <o,f4,male> de chiffrement, de signature
20131025 1 20131025_Locuteur_1 3282.930 3285.995 <o,f4,male> et euh d'échange de clés.
20131025 1 20131025_Locuteur_1 3285.995 3289.361 <o,f4,male> on va parler de tout ça maintenant.
20131025 1 20131025_Locuteur_1 3289.361 3294.760 <o,f4,male> donc les utilisations de la cryptographie mélangent en général plusieurs services.
20131025 1 20131025_Locuteur_1 3294.760 3298.610 <o,f4,male> vous avez un document que vous voulez transmettre de manière sécurisée et vous voulez le
20131025 1 20131025_Locuteur_1 3298.610 3300.002 <o,f4,male> le signer
20131025 1 20131025_Locuteur_1 3300.002 3302.746 <o,f4,male> de manière euh sécurisée aussi
20131025 1 20131025_Locuteur_1 3302.746 3309.440 <o,f4,male> donc ça mélange plusieurs services qui sont eux-mêmes basés sur plusieurs mécanismes de sécurité.
20131025 1 20131025_Locuteur_1 3309.440 3315.429 <o,f4,male> voilà, donc la cryptographie c'est un grand c'est un grand panier et on se sert dans le panier
20131025 1 20131025_Locuteur_1 3315.429 3318.495 <o,f4,male> donc ça c'est sur le [pi] parce que j'en ai déjà parlé
20131025 1 20131025_Locuteur_1 3318.495 3322.190 <o,f4,male> des mots () ça ça peut vous servir.
20131025 1 20131025_Locuteur_1 3322.190 3324.011 <o,f4,male> alors confidentialité
20131025 1 20131025_Locuteur_1 3324.011 3328.150 <o,f4,male> et algorithme de chiffrement. donc la la première tâche
20131025 1 20131025_Locuteur_1 3328.150 3331.262 <o,f4,male> ça va être ce que voulaient faire les militaires : communiquer entre eux
20131025 1 20131025_Locuteur_1 3331.262 3333.480 <o,f4,male> entre deux personnes de manière sécurisée.
20131025 1 20131025_Locuteur_1 3333.480 3336.515 <o,f4,male> c'est la tâche principale de la cryptographie
20131025 1 20131025_Locuteur_1 3336.515 3339.285 <o,f4,male> ou c'était la tâche principale de la cryptographie
20131025 1 20131025_Locuteur_1 3339.285 3340.718 <o,f4,male> très récemment.
20131025 1 20131025_Locuteur_1 3340.718 3347.230 <o,f4,male> et pour mettre en place ces communications sécurisées, il y a deux deux familles d'algorithmes
20131025 1 20131025_Locuteur_1 3347.230 3350.490 <o,f4,male> la première famille, qu'on appelle algorithmes symétriques
20131025 1 20131025_Locuteur_1 3350.490 3352.397 <o,f4,male> repose sur le principe que
20131025 1 20131025_Locuteur_1 3352.397 3354.106 <o,f4,male> il y a une clé qui est partagée
20131025 1 20131025_Locuteur_1 3354.106 3358.658 <o,f4,male> et c'est la même clé qui est partagée entre l'expéditeur et le récipiendaire
20131025 1 20131025_Locuteur_1 3358.658 3362.837 <o,f4,male> du message.
20131025 1 20131025_Locuteur_1 3362.837 3365.274 <o,f4,male> donc leurs avantages,
20131025 1 20131025_Locuteur_1 3365.274 3368.189 <o,f4,male> c'est qu'ils sont en général très rapides
20131025 1 20131025_Locuteur_1 3368.189 3371.919 <o,f4,male> ils sont tellement rapides que c'est ceux-là qu'on préférera pour envoyer des messages très longs
20131025 1 20131025_Locuteur_1 3371.919 3376.850 <o,f4,male> de manière sécurisée.
20131025 1 20131025_Locuteur_1 3376.850 3380.700 <o,f4,male> euh mais ils doivent a() ils doivent avoir des clés
20131025 1 20131025_Locuteur_1 3380.700 3383.660 <o,f4,male> qui résistent à à une attaque exhaustive
20131025 1 20131025_Locuteur_1 3383.660 3386.082 <o,f4,male> donc euh clés de
20131025 1 20131025_Locuteur_1 3386.082 3387.741 <o,f4,male> au moins cinquante-six bits
20131025 1 20131025_Locuteur_1 3387.741 3394.815 <o,f4,male> voire euh on en est plutôt à des à des euh clés de taille cent vingt-huit bits. alors cent vingt-huit bits, ça fait des [pi]
20131025 1 20131025_Locuteur_1 3394.815 3398.131 <o,f4,male> euh cent vingt-huit bits, c'est euh le mé()
20131025 1 20131025_Locuteur_1 3398.131 3403.824 <o,f4,male> c'est la clé que vous tapez quand vous saisissez votre clé web et que vous vous connectez sur le wi-fi.
20131025 1 20131025_Locuteur_1 3403.824 3408.164 <o,f4,male> quand vous vous connectez sur le wi-fi, vous communiquez de manière sécurisée entre votre routeur
20131025 1 20131025_Locuteur_1 3408.164 3410.635 <o,f4,male> et votre ordinateur
20131025 1 20131025_Locuteur_1 3410.635 3415.244 <o,f4,male> et cette communication sécurisée est protégée par un protocole cryptographique
20131025 1 20131025_Locuteur_1 3415.244 3420.529 <o,f4,male> basé sur un algorithme [pi]
20131025 1 20131025_Locuteur_1 3420.529 3422.759 <o,f4,male> euh il y a une autre famille
20131025 1 20131025_Locuteur_1 3422.759 3426.137 <o,f4,male> euh qui s'appelle les algorithmes euh asymétriques
20131025 1 20131025_Locuteur_1 3426.137 3429.272 <o,f4,male> ou à clé publique
20131025 1 20131025_Locuteur_1 3429.272 3432.040 <o,f4,male> alors ceux-là, ils sont moins rapides
20131025 1 20131025_Locuteur_1 3432.040 3434.609 <o,f4,male> mais ils permettent de s'échanger les clés secrètes
20131025 1 20131025_Locuteur_1 3434.609 3436.332 <o,f4,male> donc en général
20131025 1 20131025_Locuteur_1 3436.332 3438.238 <o,f4,male> bon euh je vais revenir dessus
20131025 1 20131025_Locuteur_1 3438.238 3440.203 <o,f4,male> euh
20131025 1 20131025_Locuteur_1 3440.203 3445.950 <o,f4,male> ils ont besoin de clés beaucoup plus grandes puisque il y a deux clés, cette fois-ci : une clé qui va être diffusée
20131025 1 20131025_Locuteur_1 3445.950 3448.740 <o,f4,male> et une clé qui va rester secrète
20131025 1 20131025_Locuteur_1 3448.740 3452.480 <o,f4,male> et comme il y a cette clé qui est diffusée euh
20131025 1 20131025_Locuteur_1 3452.480 3454.467 <o,f4,male> la qualité de la clé doit être supérieure
20131025 1 20131025_Locuteur_1 3454.467 3460.630 <o,f4,male> donc il y a besoin de clés beaucoup beaucoup plus grandes [pi]
20131025 1 20131025_Locuteur_1 3460.630 3462.865 <o,f4,male> quelle est la grande différence entre les deux
20131025 1 20131025_Locuteur_1 3462.865 3465.020 <o,f4,male> cryptosystèmes ?
20131025 1 20131025_Locuteur_1 3465.020 3469.150 <o,f4,male> dans un cas, on doit avoir une clé partagée entre deux personnes
20131025 1 20131025_Locuteur_1 3469.150 3473.120 <o,f4,male> pour chaque communication entre deux personnes, on doit avoir une clé partagée.
20131025 1 20131025_Locuteur_1 3473.120 3476.459 <o,f4,male> si mille personnes veulent communiquer avec mille personnes,
20131025 1 20131025_Locuteur_1 3476.459 3478.608 <o,f4,male> il faut
20131025 1 20131025_Locuteur_1 3478.608 3481.588 <o,f4,male> euh cin() à peu près cinq cent mille clés.
20131025 1 20131025_Locuteur_1 3481.588 3483.005 <o,f4,male> puisque chaque euh
20131025 1 20131025_Locuteur_1 3483.005 3486.954 <o,f4,male> paire de communication a besoin d'une clé partagée.
20131025 1 20131025_Locuteur_1 3486.954 3489.460 <o,f4,male> imaginons que ce soit faisable pour mille personnes
20131025 1 20131025_Locuteur_1 3489.460 3493.658 <o,f4,male> à l'échelle euh du monde entier, un milliard de personnes
20131025 1 20131025_Locuteur_1 3493.658 3497.418 <o,f4,male> euh c'est pas faisable puisqu'il faudrait à peu près cinq cent milliards de clés.
20131025 1 20131025_Locuteur_1 3497.418 3500.084 <o,f4,male> donc ça
20131025 1 20131025_Locuteur_1 3500.084 3503.150 <o,f4,male> ce ces protocoles cryptographiques
20131025 1 20131025_Locuteur_1 3503.150 3510.069 <o,f4,male> euh doivent être mis en oeuvre avec des () dans des conditions très particulières.
20131025 1 20131025_Locuteur_1 3510.069 3515.777 <o,f4,male> sur un réseau domestique, par exemple, où vous êtes très peu à vouloir communiquer.
20131025 1 20131025_Locuteur_1 3515.777 3517.770 <o,f4,male> la deuxième famille
20131025 1 20131025_Locuteur_1 3517.770 3522.210 <o,f4,male> c'est la famille des cryptosystèmes euh asymétriques où là, il y a
20131025 1 20131025_Locuteur_1 3522.210 3526.060 <o,f4,male> ce qui est euh quand une personne veut communiquer avec une autre personne,
20131025 1 20131025_Locuteur_1 3526.060 3531.860 <o,f4,male> il s() il suffit de récupérer une clé publique : la clé publique de la personne.
20131025 1 20131025_Locuteur_1 3531.860 3535.233 <o,f4,male> donc si mille personnes veulent communiquer avec mille personnes, il y a besoin de mille clés.
20131025 1 20131025_Locuteur_1 3535.233 3539.291 <o,f4,male> si un milliard de personnes veulent communiquer avec un milliard de personnes, il y a besoin d'un milliard de clés.
20131025 1 20131025_Locuteur_1 3539.291 3543.032 <o,f4,male> c'est pas euh un un milliard de [pi] c'est un milliard de clés.
20131025 1 inter_segment_gap 3543.032 3546.890 <o,f4,>
20131025 1 20131025_Locuteur_1 3546.890 3551.374 <o,f4,male> donc on va voir les () on va voir les deux fam() on on va voir en détail les deux familles de
20131025 1 20131025_Locuteur_1 3551.374 3555.011 <o,f4,male> d'algorithmes
20131025 1 20131025_Locuteur_1 3555.011 3556.772 <o,f4,male> on va commencer par les algorithmes
20131025 1 20131025_Locuteur_1 3556.772 3558.610 <o,f4,male> symétriques
20131025 1 20131025_Locuteur_1 3558.610 3562.976 <o,f4,male> [pi] le principe en deux en deux mots : quand on est en cryptographie,
20131025 1 20131025_Locuteur_1 3562.976 3567.272 <o,f4,male> les petits bonhommes que j'ai dessinés là en général ils s'appellent alice et bob
20131025 1 20131025_Locuteur_1 3567.272 3572.530 <o,f4,male> et puis le le méchant il s'appelle charlie.
20131025 1 20131025_Locuteur_1 3572.530 3575.010 <o,f4,male> donc alice veut communiquer avec bob.
20131025 1 20131025_Locuteur_1 3575.010 3577.510 <o,f4,male> pour communiquer avec bob,
20131025 1 20131025_Locuteur_1 3577.510 3579.047 <o,f4,male> elle a une clé
20131025 1 20131025_Locuteur_1 3579.047 3580.470 <o,f4,male> secrète
20131025 1 20131025_Locuteur_1 3580.470 3582.886 <o,f4,male> et bob a la même clé.
20131025 1 20131025_Locuteur_1 3582.886 3587.849 <o,f4,male> alice veut envoyer le message à bob
20131025 1 20131025_Locuteur_1 3587.849 3591.308 <o,f4,male> alors son travail, ça va être d'utiliser la fonction de chiffrement
20131025 1 20131025_Locuteur_1 3591.308 3593.271 <o,f4,male> je vais appeler en code cette fois-ci
20131025 1 20131025_Locuteur_1 3593.271 3597.040 <o,f4,male> qui va prendre le message, la clé et les s()
20131025 1 20131025_Locuteur_1 3597.040 3600.505 <o,f4,male> et euh calculer un message chiffré.
20131025 1 20131025_Locuteur_1 3600.505 3602.059 <o,f4,male> le message chiffré
20131025 1 20131025_Locuteur_1 3602.059 3608.138 <o,f4,male> est envoyé à bob, bob le reçoit et comme il a la fonction de déchiffrement, il est capable de retrouver le message
20131025 1 20131025_Locuteur_1 3608.138 3613.130 <o,f4,male> et il lit le message, voilà [pi]
20131025 1 20131025_Locuteur_1 3613.130 3618.254 <o,f4,male> ce sont les cryptosystèmes certainement les plus utilisés actuellement
20131025 1 20131025_Locuteur_1 3618.254 3619.580 <o,f4,male> euh
20131025 1 20131025_Locuteur_1 3619.580 3624.280 <o,f4,male> celui qui est le plus utilisé et qui est d'actualité, c'est le sys() le cryptosystème aes
20131025 1 20131025_Locuteur_1 3624.280 3629.779 <o,f4,male> avant les années deux mille, le cryptosystème utilisé c'était le s() le cryptosystème des
20131025 1 excluded_region 3629.779 3633.222 <o,,unknown> ignore_time_segment_in_scoring
20131025 1 excluded_region 3633.222 3636.138 <o,,unknown> ignore_time_segment_in_scoring
20131025 1 20131025_Locuteur_1 3636.138 3640.030 <o,f4,male> ce qui s'est passé, c'est que dans les années deux mille on s'est rendus compte que il y avait un problème
20131025 1 20131025_Locuteur_1 3640.030 3646.410 <o,f4,male> avec la taille des clés qui sont () voilà qui sont représentées par des chaînes de sept caractères
20131025 1 20131025_Locuteur_1 3646.410 3649.524 <o,f4,male> et on se () on s'est rendu compte que sept caractères c'était
20131025 1 20131025_Locuteur_1 3649.524 3651.090 <o,f4,male> c'était plus euh
20131025 1 20131025_Locuteur_1 3651.090 3655.425 <o,f4,male> c'était plus envisageable de continuer avec ça
20131025 1 20131025_Locuteur_1 3655.425 3660.968 <o,f4,male> tout simplement parce que imaginons qu'on soit capable de tester un milliard de clés par seconde
20131025 1 20131025_Locuteur_1 3660.968 3663.323 <o,f4,male> par [pi]
20131025 1 20131025_Locuteur_1 3663.323 3667.500 <o,f4,male> alors des clés il y en a di() deux à la puissance cinquante-six dans le cas de [pi]
20131025 1 20131025_Locuteur_1 3667.500 3672.522 <o,f4,male> donc euh décoder deux à la puissance cinquante-six clés, il faut deux mille deux cents ans
20131025 1 20131025_Locuteur_1 3672.522 3674.695 <o,f4,male> si on est capable de tester
20131025 1 20131025_Locuteur_1 3674.695 3676.758 <o,f4,male> un milliard de clés par seconde,
20131025 1 20131025_Locuteur_1 3676.758 3682.330 <o,f4,male> et deux mille deux cents ans pour un ordinateur capable de tester un milliard de clés par seconde
20131025 1 20131025_Locuteur_1 3682.330 3686.036 <o,f4,male> mais dans les a() années deux mille on s'est dit () on s'est rendu compte que euh
20131025 1 20131025_Locuteur_1 3686.036 3689.490 <o,f4,male> les ordinateurs on pouvait euh on peut en utiliser plusieurs
20131025 1 20131025_Locuteur_1 3689.490 3691.680 <o,f4,male> plusieurs en parallèle.
20131025 1 20131025_Locuteur_1 3691.680 3696.924 <o,f4,male> et euh par exemple, si on u() on utilise deux mille () dix mille en parallèle,
20131025 1 20131025_Locuteur_1 3696.924 3698.040 <o,f4,male> qui testent chacun
20131025 1 20131025_Locuteur_1 3698.040 3702.570 <o,f4,male> une partie de l'ensemble des clés, ben alors il faut plus que quatre-vingts jours.
20131025 1 20131025_Locuteur_1 3702.570 3704.411 <o,f4,male> si on en branche cent mille,
20131025 1 20131025_Locuteur_1 3704.411 3706.671 <o,f4,male> il faut plus que huit jours.
20131025 1 20131025_Locuteur_1 3706.671 3710.420 <o,f4,male> donc pour les crypto() pour les euh messages confidentiels qui avaient be()
20131025 1 20131025_Locuteur_1 3710.420 3714.634 <o,f4,male> besoin d'un haut degré confidentialité, des était plus adapté parce qu'on savait très bien
20131025 1 20131025_Locuteur_1 3714.634 3720.670 <o,f4,male> que des puissances étrangères, vous en connaissez, étaient capables de décoder ces messages
20131025 1 20131025_Locuteur_1 3720.670 3725.980 <o,f4,male> parce que ils disposaient d'une puissance de calcul suffisante pour brancher cent mille ordinateurs
20131025 1 20131025_Locuteur_1 3725.980 3730.933 <o,f4,male> pour faire travailler cent mille ordinateurs en en parallèle.
20131025 1 20131025_Locuteur_1 3730.933 3732.612 <o,f4,male> donc dans les années deux mille,
20131025 1 20131025_Locuteur_1 3732.612 3737.144 <o,f4,male> il y a eu un concours, un ap() un appel à à cryptosystèmes
20131025 1 20131025_Locuteur_1 3737.144 3743.794 <o,f4,male> avec une validation par des experts, et le cryptosystème qui a gagné, c'est le cryp() un cryptosystème qui s'appelle aes
20131025 1 20131025_Locuteur_1 3743.794 3751.292 <o,f4,male> sachez quand même qu'il y a des français qui avaient concouru, qui étaient pas () qu'étaient pas loin de de gagner : ils ont terminé ils ont terminé cinquièmes.
20131025 1 20131025_Locuteur_1 3751.292 3752.459 <o,f4,male> c'était pas si mal
20131025 1 20131025_Locuteur_1 3752.459 3755.633 <o,f4,male> mais ils ont pas gagné.
20131025 1 20131025_Locuteur_1 3755.633 3761.538 <o,f4,male> donc euh ce que vous tapez maintenant quand vous vous connectez en wpa, ce sont des z()
20131025 1 20131025_Locuteur_1 3761.538 3770.943 <o,f4,male> des messages de seize ou trente-deux caractères, parce que vous utilisez un cryptosystème avancé.
20131025 1 20131025_Locuteur_1 3770.943 3773.914 <o,f4,male> deuxième question importante, c'est : comment on fait pour s'échanger
20131025 1 20131025_Locuteur_1 3773.914 3776.980 <o,f4,male> les clés entre deux personnes ?
20131025 1 20131025_Locuteur_1 3776.980 3782.920 <o,f4,male> c'est compliqué : on veut co() on veut communiquer de manière sécurisée en ayant la même clé de chaque côté
20131025 1 20131025_Locuteur_1 3782.920 3785.070 <o,f4,male> mais on peut pas s'envoyer la clé
20131025 1 20131025_Locuteur_1 3785.070 3789.736 <o,f4,male> sur le réseau, parce que la clé elle risque d'être interceptée
20131025 1 20131025_Locuteur_1 3789.736 3791.810 <o,f4,male> donc on peut pas communiquer la clé en clair
20131025 1 20131025_Locuteur_1 3791.810 3794.035 <o,f4,male> et on peut pas la communiquer de manière
20131025 1 20131025_Locuteur_1 3794.035 3796.065 <o,f4,male> chiffrée, parce que elle serait
20131025 1 20131025_Locuteur_1 3796.065 3798.834 <o,f4,male> parce que il y aurait besoin d'avoir une clé partagée.
20131025 1 20131025_Locuteur_1 3798.834 3802.776 <o,f4,male> donc on tombe sur un problème euh de d'oeuf ou de poule, là.
20131025 1 20131025_Locuteur_1 3802.776 3805.621 <o,f4,male> comment on fait pour
20131025 1 20131025_Locuteur_1 3805.621 3806.965 <o,f4,male> partager une clé ?
20131025 1 20131025_Locuteur_1 3806.965 3808.024 <o,f4,male> voilà le problème
20131025 1 20131025_Locuteur_1 3808.024 3811.157 <o,f4,male> comment on fait pour partager une clé secrète ?
20131025 1 20131025_Locuteur_1 3811.157 3815.973 <o,f4,male> ben il y a un protocole qui s'appelle le protocole de [pi] , qui permet de faire ce travail
20131025 1 20131025_Locuteur_1 3815.973 3819.830 <o,f4,male> et il fonctionne comme ça :
20131025 1 20131025_Locuteur_1 3819.830 3823.800 <o,f4,male> alice et bob, qui veulent communiquer de manière sécurisée, se mettent d'accord
20131025 1 20131025_Locuteur_1 3823.800 3825.990 <o,f4,male> ils se mettent d'accord sur deux nombres
20131025 1 20131025_Locuteur_1 3825.990 3827.854 <o,f4,male> un grand nombre premier
20131025 1 20131025_Locuteur_1 3827.854 3829.909 <o,f4,male> p
20131025 1 20131025_Locuteur_1 3829.909 3832.420 <o,f4,male> il y a du () il y a du bruit, là !
20131025 1 20131025_Locuteur_1 3832.420 3835.187 <o,f4,male> un grand nombre premier, p
20131025 1 20131025_Locuteur_1 3835.187 3838.424 <o,f4,male> et un nombre g
20131025 1 20131025_Locuteur_1 3838.424 3840.719 <o,f4,male> qui est inférieur à p
20131025 1 20131025_Locuteur_1 3840.719 3842.290 <o,f4,male> voilà, deux nombres
20131025 1 20131025_Locuteur_1 3842.290 3843.613 <o,f4,male> p et g
20131025 1 20131025_Locuteur_1 3843.613 3849.904 <o,f4,male> premier () un un premier in() euh inférieur à au premier nombre
20131025 1 20131025_Locuteur_1 3849.904 3851.730 <o,f4,male> il faut que ce soit des grands nombres, hein
20131025 1 20131025_Locuteur_1 3851.730 3857.320 <o,f4,male> parce que euh [pi]
20131025 1 20131025_Locuteur_1 3857.320 3863.987 <o,f4,male> et ces nombres-là, ils se les échangent. et ça () ceux-là, ils peuvent se les envoyer de manière non sécurisée, c'est pas grave
20131025 1 20131025_Locuteur_1 3863.987 3867.062 <o,f4,male> donc p et g est partagé
20131025 1 20131025_Locuteur_1 3867.062 3868.287 <o,f4,male> ensuite
20131025 1 20131025_Locuteur_1 3868.287 3871.395 <o,f4,male> alice, qui veut communiquer avec bob, choisit un nombre à la fois
20131025 1 20131025_Locuteur_1 3871.395 3872.744 <o,f4,male> a
20131025 1 20131025_Locuteur_1 3872.744 3874.765 <o,f4,male> et elle calcule
20131025 1 20131025_Locuteur_1 3874.765 3876.040 <o,f4,male> une valeur
20131025 1 20131025_Locuteur_1 3876.040 3883.060 <o,f4,male> la valeur grand a, qui est égale à g à la puissance a modulo p
20131025 1 20131025_Locuteur_1 3883.060 3887.772 <o,f4,male> alice, une fois qu'elle a fait ce calcul, elle envoie a sur le réseau. a peut être () le grand a
20131025 1 20131025_Locuteur_1 3887.772 3891.710 <o,f4,male> elle envoie le grand a sur le réseau, grand a peut être connu par tout le monde.
20131025 1 20131025_Locuteur_1 3891.710 3894.560 <o,f4,male> hop, on envoie grand a à paul.
20131025 1 20131025_Locuteur_1 3894.560 3896.075 <o,f4,male> bob fait la même chose
20131025 1 20131025_Locuteur_1 3896.075 3899.433 <o,f4,male> il choisit un petit nombre euh un nombre, b
20131025 1 20131025_Locuteur_1 3899.433 3903.070 <o,f4,male> et il calcule g à la puissance b modulo p.
20131025 1 20131025_Locuteur_1 3903.070 3904.279 <o,f4,male> il obtient grand b
20131025 1 20131025_Locuteur_1 3904.279 3906.350 <o,f4,male> et il envoie grand b à alice.
20131025 1 20131025_Locuteur_1 3906.350 3912.038 <o,f4,male> grand b, c'est pas grave s'il est intercepté
20131025 1 20131025_Locuteur_1 3912.038 3913.330 <o,f4,male> et ensuite
20131025 1 20131025_Locuteur_1 3913.330 3915.900 <o,f4,male> ben il calcule une clé
20131025 1 20131025_Locuteur_1 3915.900 3919.031 <o,f4,male> la clé qui sera partagée, ce sera la clé
20131025 1 20131025_Locuteur_1 3919.031 3924.970 <o,f4,male> k, qui sera égale à g à la puissance a b modulo p.
20131025 1 20131025_Locuteur_1 3924.970 3929.140 <o,f4,male> et cette clé, alice peut la calculer, même sans connaître b
20131025 1 20131025_Locuteur_1 3929.140 3935.310 <o,f4,male> puisqu'il lui suffit de calculer b à la puissance a modulo p ; grand b à la puissance a modulo p
20131025 1 20131025_Locuteur_1 3935.310 3937.706 <o,f4,male> bob il est capable de la calculer
20131025 1 20131025_Locuteur_1 3937.706 3942.230 <o,f4,male> puisqu'il lui suffit de calculer grand a à la puissance b modulo p.
20131025 1 20131025_Locuteur_1 3942.230 3946.660 <o,f4,male> et on peut prouver qu'il est matériellement impossible
20131025 1 20131025_Locuteur_1 3946.660 3948.670 <o,f4,male> si p est suffisamment grand
20131025 1 20131025_Locuteur_1 3948.670 3950.686 <o,f4,male> parce que sinon on peut faire une attaque exhaustive,
20131025 1 20131025_Locuteur_1 3950.686 3953.250 <o,f4,male> si p est suffisamment grand, il est matériellement impossible
20131025 1 20131025_Locuteur_1 3953.250 3954.770 <o,f4,male> de calculer k
20131025 1 20131025_Locuteur_1 3954.770 3958.421 <o,f4,male> si on ne connaît ni a, ni b.
20131025 1 20131025_Locuteur_1 3958.421 3959.580 <o,f4,male> ça, on peut le prouver.
20131025 1 20131025_Locuteur_1 3959.580 3966.720 <o,f4,male> donc c'est un moyen de s'échanger une clé de manière sécurisée.
20131025 1 20131025_Locuteur_1 3966.720 3968.105 <o,f4,male> alors
20131025 1 20131025_Locuteur_1 3968.105 3968.928 <o,f4,male> tac
20131025 1 20131025_Locuteur_1 3968.928 3970.830 <o,f4,male> on va passer [pi]
20131025 1 20131025_Locuteur_1 3970.830 3977.930 <o,f4,male> on va maintenant présenter les la deuxième grande famille d'algorithmes de chiffrement, ça s'appelle les algorithmes de chiffrement asymétriques.
20131025 1 20131025_Locuteur_1 3977.930 3980.739 <o,f4,male> le principe de ces algorithmes, c'est qu'ils reposent
20131025 1 20131025_Locuteur_1 3980.739 3981.970 <o,f4,male> sur
20131025 1 20131025_Locuteur_1 3981.970 3986.251 <o,f4,male> une publication d'un couple de clés bah d'une clé euh
20131025 1 20131025_Locuteur_1 3986.251 3987.150 <o,f4,male> publique
20131025 1 20131025_Locuteur_1 3987.150 3991.641 <o,f4,male> donc le cryptosystème repose sur un couple de clé publique, clé privée.
20131025 1 20131025_Locuteur_1 3991.641 3993.976 <o,f4,male> chaque personne, donc alice
20131025 1 20131025_Locuteur_1 3993.976 3995.149 <o,f4,male> et bob
20131025 1 20131025_Locuteur_1 3995.149 3996.994 <o,f4,male> ont
20131025 1 20131025_Locuteur_1 3996.994 3998.642 <o,f4,male> un triplé
20131025 1 20131025_Locuteur_1 3998.642 4000.539 <o,f4,male> avec une clé publique
20131025 1 20131025_Locuteur_1 4000.539 4001.280 <o,f4,male> e
20131025 1 20131025_Locuteur_1 4001.280 4002.689 <o,f4,male> une clé privée, d
20131025 1 20131025_Locuteur_1 4002.689 4006.270 <o,f4,male> et n, qui est aussi une valeur publique.
20131025 1 20131025_Locuteur_1 4006.270 4012.899 <o,f4,male> bob a la même chose : une clé publique, une clé privée, une clé publique.
20131025 1 20131025_Locuteur_1 4012.899 4015.256 <o,f4,male> comme ces clés sont publiques, elles sont communiquées
20131025 1 20131025_Locuteur_1 4015.256 4017.657 <o,f4,male> elles s() elles sont dans un annuaire
20131025 1 20131025_Locuteur_1 4017.657 4019.617 <o,f4,male> consultables par tout le monde
20131025 1 20131025_Locuteur_1 4019.617 4021.340 <o,f4,male> donc l'annuaire euh
20131025 1 20131025_Locuteur_1 4021.340 4026.583 <o,f4,male> à la ligne alice, j'ai dans l'annuaire la clé publique d'alice et son grand n d'alice.
20131025 1 20131025_Locuteur_1 4026.583 4032.562 <o,f4,male> pour bob, j'ai la même chose, donc e de a et n () e de b et n de b, pardon.
20131025 1 20131025_Locuteur_1 4032.562 4033.522 <o,f4,male> euh
20131025 1 20131025_Locuteur_1 4033.522 4034.524 <o,f4,male> typographie
20131025 1 20131025_Locuteur_1 4034.524 4036.680 <o,f4,male> [pi] typographie
20131025 1 20131025_Locuteur_1 4036.680 4040.655 <o,f4,male> voilà, et comment on fait pour communiquer ensuite ?
20131025 1 20131025_Locuteur_1 4040.655 4045.381 <o,f4,male> eh bah () ah oui, pardon. avant de euh communiquer, en fait
20131025 1 20131025_Locuteur_1 4045.381 4047.009 <o,f4,male> vous communiquez
20131025 1 20131025_Locuteur_1 4047.009 4052.420 <o,f4,male> avec ces () v() vous connaissez ces annuaires, même s'ils sont un petit peu cachés dans firefox, vous les utilisez
20131025 1 20131025_Locuteur_1 4052.420 4054.930 <o,f4,male> pour les retrouver, ces annuaires
20131025 1 20131025_Locuteur_1 4054.930 4057.346 <o,f4,male> il vous suffit d'aller dans firefox
20131025 1 20131025_Locuteur_1 4057.346 4060.051 <o,f4,male> euh dans les euh
20131025 1 20131025_Locuteur_1 4060.051 4064.410 <o,f4,male> dans les euh paramètres avancés de firefox, je vais regarder ce qu'il y a dans chiffrement
20131025 1 20131025_Locuteur_1 4064.410 4069.856 <o,f4,male> euh à un endroit, vous voyez les certificats de sécurité, vous les affichez puis vous les avez là, les annuaires
20131025 1 20131025_Locuteur_1 4069.856 4071.352 <o,f4,male> des annuaires
20131025 1 20131025_Locuteur_1 4071.352 4072.364 <o,f4,male> qui s'appellent euh
20131025 1 20131025_Locuteur_1 4072.364 4076.385 <o,f4,male> ce sont euh des annuaires détenus par des sociétés
20131025 1 20131025_Locuteur_1 4076.385 4079.557 <o,f4,male> euh don() accréditées
20131025 1 20131025_Locuteur_1 4079.557 4083.308 <o,f4,male> qui s'appellent [pi] , qui s'appellent () vous en avez tout un tas.
20131025 1 20131025_Locuteur_1 4083.308 4086.089 <o,f4,male> chaque euh société possède un certain nombre euh
20131025 1 20131025_Locuteur_1 4086.089 4090.550 <o,f4,male> [pi] un certain nombre de personnes.
20131025 1 20131025_Locuteur_1 4090.550 4098.381 <o,f4,male> et toutes les sociétés ne peuvent pas posséder ces annuaires, évidemment
20131025 1 20131025_Locuteur_1 4098.381 4100.256 <o,f4,male> voilà, donc vous les avez, ces annuaires
20131025 1 20131025_Locuteur_1 4100.256 4102.959 <o,f4,male> euh même s'ils sont un peu cachés pour vous
20131025 1 20131025_Locuteur_1 4102.959 4107.697 <o,f4,male> vous faites beaucoup () on fait beaucoup de choses cachées en cryptographie, hein. il y a beaucoup de choses qui () qu'on ignore mais euh
20131025 1 20131025_Locuteur_1 4107.697 4110.235 <o,f4,male> les protocoles cryptographiques sont omniprésents.
20131025 1 20131025_Locuteur_1 4110.235 4113.950 <o,f4,male> alors alice veut veut parler à bob, donc elle récupère la paire
20131025 1 20131025_Locuteur_1 4113.950 4117.648 <o,f4,male> t euh [pi] de bob et n de bob.
20131025 1 20131025_Locuteur_1 4117.648 4120.860 <o,f4,male> et ce qu'elle en fait, c'est que () donc elle va vouloir envoyer un message clair
20131025 1 20131025_Locuteur_1 4120.860 4124.297 <o,f4,male> elle calcule le message *chiffré chiffré, qui sera
20131025 1 20131025_Locuteur_1 4124.297 4126.180 <o,f4,male> une fonction
20131025 1 20131025_Locuteur_1 4126.180 4130.399 <o,f4,male> du message et des clés publiques de bob.
20131025 1 20131025_Locuteur_1 4130.399 4133.380 <o,f4,male> elle l'envoie à bob
20131025 1 20131025_Locuteur_1 4133.380 4135.868 <o,f4,male> alors qu'est-ce que c'est que ce f, là ?
20131025 1 20131025_Locuteur_1 4135.868 4138.508 <o,f4,male> donc ça peut être un peu mystérieux, mais euh
20131025 1 20131025_Locuteur_1 4138.508 4142.570 <o,f4,male> f, c'est () il y en a plein, de fonctions f, qui permettent de le faire
20131025 1 20131025_Locuteur_1 4142.570 4144.024 <o,f4,male> c'est toute la famille
20131025 1 20131025_Locuteur_1 4144.024 4147.074 <o,f4,male> de () des fonctions qu'on appelle fonctions à trappe
20131025 1 20131025_Locuteur_1 4147.074 4153.776 <o,f4,male> une *fonction à trappe, c'est une fonction dont on peut [pi] dont on peut calculer facilement l'inverse quand on connaît la trappe
20131025 1 20131025_Locuteur_1 4153.776 4155.353 <o,f4,male> donc i c'est petit d
20131025 1 20131025_Locuteur_1 4155.353 4159.940 <o,f4,male> mais euh dont on peut difficilement calculer l'inverse quand on connaît pas la trappe.
20131025 1 20131025_Locuteur_1 4159.940 4163.240 <o,f4,male> et le cryptosystème qui est le plus utilisé
20131025 1 20131025_Locuteur_1 4163.240 4168.640 <o,f4,male> euh dans la famille des cryptosystèmes symétriques, c'est le cryptosystème rsa
20131025 1 20131025_Locuteur_1 4168.640 4170.970 <o,f4,male> pour lequel la fonction, elle est toute simple
20131025 1 20131025_Locuteur_1 4170.970 4173.569 <o,f4,male> la fonction, elle prend euh le message
20131025 1 20131025_Locuteur_1 4173.569 4178.033 <o,f4,male> elle met à la puissance deux modulo n
20131025 1 20131025_Locuteur_1 4178.033 4179.598 <o,f4,male> il faut qu'il y ait une relation
20131025 1 20131025_Locuteur_1 4179.598 4181.896 <o,f4,male> assez facile entre la clé de
20131025 1 20131025_Locuteur_1 4181.896 4182.770 <o,f4,male> de
20131025 1 20131025_Locuteur_1 4182.770 4185.740 <o,f4,male> la clé publique et la clé privé ; cette relation, c'est simple :
20131025 1 20131025_Locuteur_1 4185.740 4189.177 <o,f4,male> deux fois d, c'est égal à un modulo
20131025 1 20131025_Locuteur_1 4189.177 4193.333 <o,f4,male> [pi] qui s'appelle p
20131025 1 20131025_Locuteur_1 4193.333 4198.541 <o,f4,male> et euh ce qui se passe, c'est connaissant c, e, n, il est matériellement impossible de retrouver m
20131025 1 20131025_Locuteur_1 4198.541 4200.365 <o,f4,male> sauf si on connaît d.
20131025 1 20131025_Locuteur_1 4200.365 4201.717 <o,f4,male> si on connaît d
20131025 1 20131025_Locuteur_1 4201.717 4207.494 <o,f4,male> on a la clé de déchiffrement : pour inverser, il suffit de prendre c à la puissance d modulo m
20131025 1 20131025_Locuteur_1 4207.494 4212.889 <o,f4,male> et puis on se rend compte qu'on retrouve facilement le message.
20131025 1 20131025_Locuteur_1 4212.889 4216.340 <o,f4,male> donc connaissant
20131025 1 20131025_Locuteur_1 4216.340 4220.969 <o,f4,male> ne connaiss() quand on ne connaît pas d, on n'est pas capable de retrouver le message m à partir de c ;
20131025 1 20131025_Locuteur_1 4220.969 4224.272 <o,f4,male> quand on connaît d, c'est évident.
20131025 1 20131025_Locuteur_1 4224.272 4227.016 <o,f4,male> et il y en a d'autres, des cryptosystèmes euh
20131025 1 20131025_Locuteur_1 4227.016 4230.024 <o,f4,male> [pi] asymétriques.
20131025 1 20131025_Locuteur_1 4230.024 4230.960 <o,f4,male> voilà
20131025 1 20131025_Locuteur_1 4230.960 4233.738 <o,f4,male> donc on envoie c, on calcule f moins un
20131025 1 20131025_Locuteur_1 4233.738 4237.054 <o,f4,male> parce que c'est facile de le faire quand on connaît d
20131025 1 20131025_Locuteur_1 4237.054 4239.205 <o,f4,male> et puis voilà.
20131025 1 20131025_Locuteur_1 4239.205 4240.993 <o,f4,male> une () un des problèmes
20131025 1 20131025_Locuteur_1 4240.993 4243.001 <o,f4,male> qui se posent quand on
20131025 1 20131025_Locuteur_1 4243.001 4248.928 <o,f4,male> quand on s'intéresse à des cryptosystèmes comme ça, c'est de générer des paires de clés publiques et privées.
20131025 1 20131025_Locuteur_1 4248.928 4252.295 <o,f4,male> et dans le cas des rsa
20131025 1 20131025_Locuteur_1 4252.295 4257.620 <o,f4,male> la question qui va se poser, c'est : comment on fait pour générer un () une clé valide
20131025 1 20131025_Locuteur_1 4257.620 4264.670 <o,f4,male> valide dans le sens : qui vérifie la propriété e fois d est égal à un modulo pi de n
20131025 1 20131025_Locuteur_1 4264.670 4268.939 <o,f4,male> et qui soit valide dans le sens où euh il assure un bon chiffrement
20131025 1 20131025_Locuteur_1 4268.939 4273.540 <o,f4,male> donc un déchiffrement in() matériellement impossible.
20131025 1 20131025_Locuteur_1 4273.540 4277.067 <o,f4,male> alors pour ça, on tire au hasard deux très grands nombres premiers
20131025 1 20131025_Locuteur_1 4277.067 4282.588 <o,f4,male> tirer au hasard des très grands nombres premiers, c'est quelque chose qu'on fait classiquement en cryptographie
20131025 1 20131025_Locuteur_1 4282.588 4284.574 <o,f4,male> il y a beaucoup de bruit, là !
20131025 1 20131025_Locuteur_1 4284.574 4287.646 <o,f4,male> donc c'est quelque chose qu'il faut être capable de faire efficacement.
20131025 1 20131025_Locuteur_1 4287.646 4290.715 <o,f4,male> il faudra mettre au point des algorithmes efficaces
20131025 1 20131025_Locuteur_1 4290.715 4297.499 <o,f4,male> des al() l'algorithmique elle est là, en fait : [pi] des algorithmes efficaces pour tirer des très grands nombres premiers.
20131025 1 20131025_Locuteur_1 4297.499 4306.814 <o,f4,male> alors on tire des très grands nombres premiers p et q, alors des très grands nombres ça veut dire des nombres à peu près à () entre cent et deux cents chiffres
20131025 1 20131025_Locuteur_1 4306.814 4308.228 <o,f4,male> on pose
20131025 1 20131025_Locuteur_1 4308.228 4310.860 <o,f4,male> une fois qu'on connaît p et q
20131025 1 20131025_Locuteur_1 4310.860 4314.997 <o,f4,male> alors on peut poser : n égale p fois q.
20131025 1 20131025_Locuteur_1 4314.997 4319.059 <o,f4,male> n sera donc un très grand nombre
20131025 1 20131025_Locuteur_1 4319.059 4321.984 <o,f4,male> pi de n, en fait le pi de n qui était mystérieux
20131025 1 20131025_Locuteur_1 4321.984 4325.218 <o,f4,male> il est très facile à calculer
20131025 1 20131025_Locuteur_1 4325.218 4329.577 <o,f4,male> pi de n, c'est p moins un fois q moins un.
20131025 1 20131025_Locuteur_1 4329.577 4334.899 <o,f4,male> ensuite, il suffit de choisir un un nombre e au hasard
20131025 1 20131025_Locuteur_1 4334.899 4336.057 <o,f4,male> allez, un petit
20131025 1 20131025_Locuteur_1 4336.057 4338.639 <o,f4,male> un petit nombre entier
20131025 1 20131025_Locuteur_1 4338.639 4347.075 <o,f4,male> on doit juste s'assurer que le b d c d de e et q de n est égal à un, c'est ce qui va assurer que e fois d c'est égal à un modulo pi de n.
20131025 1 20131025_Locuteur_1 4347.075 4352.170 <o,f4,male> on prend le [pi] on prend un nombre premier avec euh pi de n
20131025 1 20131025_Locuteur_1 4352.170 4353.645 <o,f4,male> il y a trop de bruit, là-haut !
20131025 1 20131025_Locuteur_1 4353.645 4355.572 <o,f4,male> ça peut être par exemple trois
20131025 1 20131025_Locuteur_1 4355.572 4360.180 <o,f4,male> on n'est pas obligé de prendre une grande puissance de e
20131025 1 20131025_Locuteur_1 4360.180 4363.760 <o,f4,male> ensuite, on calcule d tel que euh
20131025 1 20131025_Locuteur_1 4363.760 4370.311 <o,f4,male> e d est égal à un modulo pi de n, ça ça se fait () c'est de l'algorithmique, ça se fait par l'algorithme d'euclide
20131025 1 20131025_Locuteur_1 4370.311 4374.150 <o,f4,male> calculer un [pi]
20131025 1 20131025_Locuteur_1 4374.150 4377.037 <o,f4,male> et toute la sécurité de rsa
20131025 1 20131025_Locuteur_1 4377.037 4379.007 <o,f4,male> va reposer sur le fait que
20131025 1 20131025_Locuteur_1 4379.007 4381.013 <o,f4,male> connaissant d,
20131025 1 20131025_Locuteur_1 4381.013 4386.055 <o,f4,male> il est impossible de retrouver le couple p et q.
20131025 1 20131025_Locuteur_1 4386.055 4389.939 <o,f4,male> ou connaissant n, il est impossible de retrouver p et q si n est très grand ;
20131025 1 20131025_Locuteur_1 4389.939 4394.181 <o,f4,male> c'est difficile de factoriser un nombre très grand.
20131025 1 20131025_Locuteur_1 4394.181 4396.167 <o,f4,male> tout le secret de rsa repose là-dessus :
20131025 1 20131025_Locuteur_1 4396.167 4398.316 <o,f4,male> la factorisation est difficile.
20131025 1 20131025_Locuteur_1 4398.316 4405.158 <o,f4,male> et il y a plein de gens qui essayent de casser rsa en prouvant qu'on peut factoriser des très grands nombres premiers, mais ils y arrivent pas encore ;
20131025 1 20131025_Locuteur_1 4405.158 4411.136 <o,f4,male> mais il y a des compétitions.
20131025 1 20131025_Locuteur_1 4411.136 4415.040 <o,f4,male> voilà, par exemple
20131025 1 20131025_Locuteur_1 4415.040 4416.396 <o,f4,male> si n
20131025 1 20131025_Locuteur_1 4416.396 4421.635 <o,f4,male> si [pi] pardon si p et q sont des nombres très grands de type deux à la puissance cent vingt-huit
20131025 1 20131025_Locuteur_1 4421.635 4427.470 <o,f4,male> alors il faudra à peu près dix puissance vingt-trois siècles pour factoriser n ; c'est matériellement impossible de le faire
20131025 1 20131025_Locuteur_1 4427.470 4430.649 <o,f4,male> même en mettant beaucoup de machines.
20131025 1 20131025_Locuteur_1 4430.649 4432.533 <o,f4,male> il y a des compétitions
20131025 1 20131025_Locuteur_1 4432.533 4434.928 <o,f4,male> euh [pi]
20131025 1 20131025_Locuteur_1 4434.928 4440.081 <o,f4,male> il y a des compétitions de factorisation mais
20131025 1 20131025_Locuteur_1 4440.081 4442.151 <o,f4,male> [pi] pardon
20131025 1 20131025_Locuteur_1 4442.151 4447.844 <o,f4,male> si vous voulez gagner de l'argent, vous pouvez vous lancer dans ces compétitions hein.
20131025 1 20131025_Locuteur_1 4447.844 4449.260 <o,f4,male> alors voilà
20131025 1 20131025_Locuteur_1 4449.260 4451.572 <o,f4,male> il y a des nombres à factoriser
20131025 1 20131025_Locuteur_1 4451.572 4456.260 <o,f4,male> ça s'appelle des compétitions et puis vous vous pouvez gagner de l'argent si vous réussissez à les factoriser.
20131025 1 20131025_Locuteur_1 4456.260 4465.528 <o,f4,male> il y a beaucoup d'argent à gagner, mais croyez-moi c'est pas facile.
20131025 1 20131025_Locuteur_1 4465.528 4469.233 <o,f4,male> bon
20131025 1 20131025_Locuteur_1 4469.233 4470.220 <o,f4,male> le dernier
20131025 1 20131025_Locuteur_1 4470.220 4472.910 <o,f4,male> un des derniers travaux qu'on a envie de faire, en général
20131025 1 20131025_Locuteur_1 4472.910 4476.134 <o,f4,male> en cryptographie, c'est de signer ses documents
20131025 1 20131025_Locuteur_1 4476.134 4481.470 <o,f4,male> quand vous aurez à faire une déclaration d'impôts, vous verrez que vous pouvez signer de manière électronique.
20131025 1 20131025_Locuteur_1 4481.470 4484.557 <o,f4,male> donc le [pi] le cahier des charges
20131025 1 20131025_Locuteur_1 4484.557 4488.572 <o,f4,male> d'une signature numérique, c'est qu'elle soit calculable par le signataire
20131025 1 20131025_Locuteur_1 4488.572 4491.338 <o,f4,male> quel que soit le message.
20131025 1 inter_segment_gap 4491.338 4493.345 <o,f4,>
20131025 1 20131025_Locuteur_1 4493.345 4495.200 <o,f4,male> donc la signature
20131025 1 20131025_Locuteur_1 4495.200 4498.250 <o,f4,male> doit dépendre du signataire
20131025 1 20131025_Locuteur_1 4498.250 4506.721 <o,f4,male> quand on signe un document, on signe un o() on on atteste que on signe le bon document, donc la la signature c'est pas dire : je m'appelle jérémy bourdon.
20131025 1 20131025_Locuteur_1 4506.721 4512.034 <o,f4,male> c'est dire : je m'appelle jérémy bourdon et je signe tout le document que je viens d'écrire.
20131025 1 20131025_Locuteur_1 4512.034 4517.270 <o,f4,male> la signature est associée à la fois à une personne et à un document.
20131025 1 20131025_Locuteur_1 4517.270 4523.026 <o,f4,male> le principe d'une signature, c'est qu'elle doit être vérifiable par tout individu.
20131025 1 20131025_Locuteur_1 4523.026 4525.629 <o,f4,male> elle doit pas être falsifiable
20131025 1 20131025_Locuteur_1 4525.629 4528.700 <o,f4,male> falsifiable dans le sens où une signature papier, c'est falsifiable.
20131025 1 20131025_Locuteur_1 4528.700 4532.390 <o,f4,male> on peut imiter la signature de ses parents pour signer un bulletin de de notes.
20131025 1 20131025_Locuteur_1 4532.390 4534.498 <o,f4,male> ça doit pas être le cas dans le cadre d'une signature électronique.
20131025 1 20131025_Locuteur_1 4534.498 4535.809 <o,f4,male> c'est pas terminé !
20131025 1 20131025_Locuteur_1 4535.809 4536.834 <o,f4,male> il reste encore
20131025 1 20131025_Locuteur_1 4536.834 4540.020 <o,f4,male> au moins deux minutes.
20131025 1 20131025_Locuteur_1 4540.020 4546.810 <o,f4,male> et dans deux minutes dans deux min() le prochain transparent c'est le transparent de conclusion, donc laissez-moi finir.
20131025 1 20131025_Locuteur_1 4546.810 4548.849 <o,f4,male> donc un exemple de mise en oeuvre
20131025 1 20131025_Locuteur_1 4548.849 4553.231 <o,f4,male> d'une signature électronique, c'est en signant avec a() avec rsa.
20131025 1 20131025_Locuteur_1 4553.231 4555.607 <o,f4,male> alice veut signer un message
20131025 1 20131025_Locuteur_1 4555.607 4557.326 <o,f4,male> avec cette clé-là
20131025 1 20131025_Locuteur_1 4557.326 4560.137 <o,f4,male> elle calcule cette signature
20131025 1 20131025_Locuteur_1 4560.137 4564.010 <o,f4,male> par euh ce petit calcul-là, elle prend le message
20131025 1 20131025_Locuteur_1 4564.010 4566.030 <o,f4,male> elle le met à la puissance d
20131025 1 20131025_Locuteur_1 4566.030 4569.388 <o,f4,male> le d, c'est son nombre euh privé
20131025 1 20131025_Locuteur_1 4569.388 4571.660 <o,f4,male> module n
20131025 1 20131025_Locuteur_1 4571.660 4574.342 <o,f4,male> et sa signature
20131025 1 20131025_Locuteur_1 4574.342 4576.908 <o,f4,male> sa signature, c'est ce nombre, là.
20131025 1 20131025_Locuteur_1 4576.908 4578.383 <o,f4,male> donc elle dépend bien
20131025 1 20131025_Locuteur_1 4578.383 4584.486 <o,f4,male> d'alice, puisque le d dépend d'alice ; elle dépend bien du message, puisque c'est n à la puissance d.
20131025 1 20131025_Locuteur_1 4584.486 4586.740 <o,f4,male> pour vérifier la signature
20131025 1 20131025_Locuteur_1 4586.740 4589.421 <o,f4,male> sur un message
20131025 1 20131025_Locuteur_1 4589.421 4592.250 <o,f4,male> il suffit de calculer
20131025 1 20131025_Locuteur_1 4592.250 4597.910 <o,f4,male> euh le la signature à la puissance e modulo n.
20131025 1 20131025_Locuteur_1 4597.910 4600.230 <o,f4,male> c'est quasiment un chiffrement / déchiffrement
20131025 1 20131025_Locuteur_1 4600.230 4604.310 <o,f4,male> de rsa, sauf que c'est fait à l'envers en utilisant [pi] clés différentes.
20131025 1 20131025_Locuteur_1 4604.310 4607.980 <o,f4,male> [pi] en en inversant les clés.
20131025 1 20131025_Locuteur_1 4607.980 4612.939 <o,f4,male> et ça, c'est un protocole de signature qui est classique.
20131025 1 20131025_Locuteur_1 4612.939 4616.934 <o,f4,male> pour terminer
20131025 1 20131025_Locuteur_1 4616.934 4618.660 <o,f4,male> alors tout [pi]
20131025 1 20131025_Locuteur_1 4618.660 4621.648 <o,f4,male> va reposer sur une suite de protocoles.
20131025 1 20131025_Locuteur_1 4621.648 4623.055 <o,f4,male> un protocole
20131025 1 20131025_Locuteur_1 4623.055 4626.553 <o,f4,male> qui va consister à comment on fait pour envoyer un message très long.
20131025 1 20131025_Locuteur_1 4626.553 4628.071 <o,f4,male> un message très long
20131025 1 20131025_Locuteur_1 4628.071 4631.530 <o,f4,male> comme on a () on on va devoir le découper en petits bouts
20131025 1 20131025_Locuteur_1 4631.530 4633.976 <o,f4,male> si on veut le coder.
20131025 1 20131025_Locuteur_1 4633.976 4641.027 <o,f4,male> donc là, le le découpage [pi] dans des mots comme ça, ça va reposer sur un certain nombre de protocoles : comment on fait pour enchaîner les les messages [pi]
20131025 1 20131025_Locuteur_1 4641.027 4644.058 <o,f4,male> est-ce qu'on tient compte du message d'avant ou pas ?
20131025 1 20131025_Locuteur_1 4644.058 4645.739 <o,f4,male> donc il y a des protocoles pour ça
20131025 1 20131025_Locuteur_1 4645.739 4648.076 <o,f4,male> on va avoir des protocoles sur euh comment
20131025 1 20131025_Locuteur_1 4648.076 4651.294 <o,f4,male> on fait pour bien partager un secret entre plusieurs personnes.
20131025 1 20131025_Locuteur_1 4651.294 4654.508 <o,f4,male> partager un secret, ça veut dire que on a un secret global
20131025 1 20131025_Locuteur_1 4654.508 4656.453 <o,f4,male> et on veut que chaque personne
20131025 1 20131025_Locuteur_1 4656.453 4659.136 <o,f4,male> possède une petite partie du secret ;
20131025 1 20131025_Locuteur_1 4659.136 4664.903 <o,f4,male> le secret ne devant être dévoilé que si la totalité des personnes se mettent à discuter les unes avec les autres.
20131025 1 20131025_Locuteur_1 4664.903 4668.384 <o,f4,male> il y a des protocoles d'échange de s() de partage de secret comme ça.
20131025 1 20131025_Locuteur_1 4668.384 4670.966 <o,f4,male> il y a des protocoles pour euh
20131025 1 20131025_Locuteur_1 4670.966 4675.414 <o,f4,male> générer des nombres aléatoires ; ça, c'est () vous avez vu, on génère plein de nombres aléatoires
20131025 1 20131025_Locuteur_1 4675.414 4677.984 <o,f4,male> et il faut qu'ils soient bien générés.
20131025 1 20131025_Locuteur_1 4677.984 4681.670 <o,f4,male> [pi] protocole de signature
20131025 1 20131025_Locuteur_1 4681.670 4688.239 <o,f4,male> et puis il y a tout un tas de problèmes algorithmiques à résoudre sur comment on fait pour générer des très grands nombres premiers, comment on fait pour calculer des
20131025 1 20131025_Locuteur_1 4688.239 4691.473 <o,f4,male> des nombres à des très grandes puissances,
20131025 1 20131025_Locuteur_1 4691.473 4698.335 <o,f4,male> comment on fait pour calculer efficacement des inverses de nombres, et cetera, et cetera
20131025 1 20131025_Locuteur_1 4698.335 4702.682 <o,f4,male> donc il y a pas mal d'a() d'algorithmique derrière
20131025 1 20131025_Locuteur_1 4702.682 4703.804 <o,f4,male> et puis
20131025 1 20131025_Locuteur_1 4703.804 4705.892 <o,f4,male> pour conclure,
20131025 1 20131025_Locuteur_1 4705.892 4712.825 <o,f4,male> il y a un certain nombre de craintes autour de la cryptographie, et il faudrait démystifier un certain nombre de choses
20131025 1 20131025_Locuteur_1 4712.825 4713.686 <o,f4,male> donc
20131025 1 20131025_Locuteur_1 4713.686 4717.260 <o,f4,male> ce qu'on a vu aujourd'hui, c'était des pri() des primitives de cryptographie
20131025 1 20131025_Locuteur_1 4717.260 4720.314 <o,f4,male> des primitives de cryptographie moderne fiables
20131025 1 20131025_Locuteur_1 4720.314 4724.134 <o,f4,male> fiables, puisqu'elles sont vérifiées par des experts.
20131025 1 20131025_Locuteur_1 4724.134 4729.729 <o,f4,male> ensuite, il y a des protocoles qui génèrent () qui gèrent des services, par exemple des protocoles de vote électronique
20131025 1 20131025_Locuteur_1 4729.729 4732.187 <o,f4,male> et en général, il y a des preuves de
20131025 1 20131025_Locuteur_1 4732.187 4737.787 <o,f4,male> des preuves de type mathématique ou de type () pour moi, c'est matériellement impossible de
20131025 1 20131025_Locuteur_1 4737.787 4740.174 <o,f4,male> de falsifier les choses
20131025 1 20131025_Locuteur_1 4740.174 4742.135 <o,f4,male> quand ces protocoles
20131025 1 20131025_Locuteur_1 4742.135 4747.160 <o,f4,male> ont été définis. et ça, c'est fiable puisque c'est vérifié par des experts.
20131025 1 20131025_Locuteur_1 4747.160 4748.982 <o,f4,male> ce qui n'est pas fiable,
20131025 1 20131025_Locuteur_1 4748.982 4753.043 <o,f4,male> c'est que ces protocoles sont en général repris par des entreprises
20131025 1 20131025_Locuteur_1 4753.043 4756.054 <o,f4,male> à but lucratif
20131025 1 20131025_Locuteur_1 4756.054 4761.447 <o,f4,male> et que tout ce qui est écrit dans ces implémentations de protocoles sont difficiles à vérifier.
20131025 1 20131025_Locuteur_1 4761.447 4766.176 <o,f4,male> donc là, le manque de fiabilité et le manque de de confiance peut
20131025 1 20131025_Locuteur_1 4766.176 4768.734 <o,f4,male> peut reposer là-dedans.
20131025 1 20131025_Locuteur_1 4768.734 4770.064 <o,f4,male> voilà
20131025 1 20131025_Locuteur_1 4770.064 4773.112 <o,f4,male> ça termine le cours d'aujourd'hui ;
20131025 1 20131025_Locuteur_1 4773.112 4779.435 <o,fx,male> je vous remercie de votre attention.
