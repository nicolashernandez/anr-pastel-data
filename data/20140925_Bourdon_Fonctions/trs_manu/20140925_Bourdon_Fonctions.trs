<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE Trans SYSTEM "trans-14.dtd">
<Trans audio_filename="20140925" version="5" version_date="170614">
<Speakers>
<Speaker id="spk21" name="Locuteur 1" check="no" type="male" dialect="native" accent="" scope="local"/>
</Speakers>
<Episode>
<Section type="report" startTime="0" endTime="4468.541">
<Turn startTime="0" endTime="0.300">
<Sync time="0"/>

</Turn>
<Turn startTime="0.300" speaker="spk21" endTime="4468.541" mode="planned" fidelity="high" channel="studio">
<Sync time="0.300"/>
<Background time="0.3" type="speech" level="high"/>
donc la dernière fois on avait juste euh
<Sync time="2.720"/>
introduit la la quatrième partie du cours sur les fonctions.
<Sync time="7.520"/>
je vais r() recommencer cette introduction parce que tout simplement il y a eu un problème technique la semaine dernière, et euh la vidéo a été perdue.
<Sync time="15.827"/>
donc je vais r() juste 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 réenregistrer cette introduction, ça m'évitera de de l'avoi() d'avoir à le refaire ;
<Sync time="20.963"/>
ça vous permettra de l'avoir en vidéo.
<Sync time="23.912"/>
donc très rapidement, j'avais présenté les motivations : pourquoi on introduit des fonctions en () dans un langage informatique,
<Sync time="30.929"/>
et pourquoi c'est utile ?
<Sync time="32.929"/>
ben je vous avais montré
<Sync time="35.836"/>
ce petit programme
<Sync time="39.645"/>
qui fait un () qui qui effectue un calcul
<Sync time="42.714"/>
un calcul qui est finalement pas si compliqué que ça quand on sait ce que ça fait.
<Sync time="47.636"/>
je vous avais montré le même algorithme, mais écrit avec une fonction
<Sync time="53.042"/>
et ce qu'on avait remarqué, c'est que d'une part les deux algorithmes
<Sync time="56.379"/>
font la même chose
<Sync time="59.032"/>
mais que évidemment
<Sync time="60.882"/>
le la deuxième écriture de l'algorithme est à la fois plus compacte
<Sync time="65.529"/>
et plus explicite parce qu'on a donné un nom explicite à une partie du calcul.
<Sync time="71.733"/>
voilà. donc on va parler de ça aujourd'hui, on va parler des fonctions
<Sync time="77.287"/>
donc s() ce dont on va parler, c'est euh ces valeurs qui peuvent être modifiées à l'intérieur d'une fonction, qu'on appellera des paramètres.
<Sync time="85.917"/>
donc ces paramètres
<Sync time="88.393"/>
qui seront désignés par une variable
<Sync time="90.525"/>
à l'intérieur de la fonction
<Sync time="92.154"/>
x
<Sync time="93.767"/>
et qui prendront une valeur à l'extérieur de la fonction, cinq par exemple
<Sync time="99.347"/>
au moment de l'appel.
<Sync time="101.573"/>
je vous avais dit aussi que dans un projet raisonnable, ça ne se faisait pas tout seul
<Sync time="105.447"/>
et là v() des projets raisonnables vous allez en avoir
<Sync time="108.178"/>
quand vous allez faire votre projet en binôme ou en trinôme,
<Sync time="111.2"/>
ce sera quelque chose d'assez conséquent et vous vous partagerez le travail.
<Sync time="116.202"/>
et il y aura une personne
<Sync time="119.048"/>
qui demandera de faire le travail à l'autre personne
<Sync time="121.445"/>
par exemple, calculer
<Sync time="123.352"/>
racine de trois plus racine de cinq plus racine de sept
<Sync time="128.631"/>
sachant que chaque personne a ses compétences
<Sync time="133.025"/>
ses compétences propres en () dans le langage informatique, donc s() celle-là elle est capable d'écrire
<Sync time="138.008"/>
cette ligne de code-là, mais elle est pas capable de d'écrire la fonction qui calcule la racine carrée
<Sync time="143.687"/>
et elle le demande
<Sync time="145.224"/>
elle demande ce s() ce travail à quelqu'un d'autre.
<Sync time="149.630"/>
voilà, donc ça c'est ce qui se passe dans un projet raisonnable.
<Sync time="152.290"/>
on avait vu que un mot-clé important, c'était ce qui s'appelait la spécification.
<Sync time="157.250"/>
et la spécification,
<Sync time="159.098"/>
c'est uniquement une description
<Sync time="161.778"/>
d'une manière un petit peu codifiée de s()
<Sync time="164.604"/>
de du nom de la fonction, de ce qu'elle prend en paramètres et de ce qu'elle renvoie.
<Sync time="169.241"/>
donc euh je veux une fonction qui, étant donné un réel x, calcule un nombre réel égal à racine de x
<Sync time="174.96"/>
ça, c'est une spécification en français ; la spécification dont on va vouloir parler, c'est une spécification
<Sync time="181.271"/>
dans un langage algorithmique.
<Sync time="183.280"/>
fonction racine qui prend en paramètre un réel x qui renvoie à un réel
<Sync time="187.043"/>
et dont le but est de calculer la racine carrée ;
<Sync time="190.255"/>
ça s'écrira comme ça.
<Sync time="193.432"/>
voilà, donc on avait vu que
<Sync time="195.871"/>
on avait déjà plus ou moins introduit ce que donnait le langage algorithmique pour une fonction, mais on reviendra là-dessus.
<Sync time="203.128"/>
et on s'était dit que
<Sync time="204.729"/>
vu qu'on travaillait à deux, on n'était pas tous obligés de comprendre exactement tout ce qu'il y avait dans le programme
<Sync time="210.904"/>
donc le travail est partagé réellement et les compétences sont partagées.
<Sync time="215.445"/>
voilà
<Sync time="216.275"/>
et puis on a on va parler aussi de fonctions qui sont prédéfinies, puisque la racine carrée
<Sync time="220.248"/>
c'est une fonction
<Sync time="221.901"/>
qu'on utilise euh dans la vie de tous les jours, donc euh les les gens qui f() écrivent les langages informatiques souvent
<Sync time="227.746"/>
prévoient une fonction racine carrée dans le langage.
<Sync time="230.879"/>

<Event desc="pi" type="pronounce" extent="instantaneous"/>
 on va parler de tout ça.
<Sync time="233.853"/>
donc pour () la suite aux aux motivations, c'est qu'on se dit : c'est c'est pratique d'avoir des fonctions prédéfinies qui calculent les valeurs absolues
<Sync time="240.160"/>
on a déjà v() en td vous avez déjà utilisé la valeur absolue, vous la réutiliserez plein de fois.
<Sync time="245.585"/>
c'est pratique d'avoir une fonction qui calcule la racine carrée, c'est pratique d'avoir une fonction qui calcule
<Sync time="250.258"/>
une puissance d'un nombre
<Sync time="252.362"/>
et c'est pratique d'avoir des fonctions efficaces qui font ces calculs.
<Sync time="257.341"/>
on n'a pas tous les compétences pour écrire des fonctions efficaces, donc il faut euh
<Sync time="262.209"/>
se poser la question de quelle est la meilleure méthode pour l'écrire, et demander à la personne
<Sync time="266.163"/>
de le faire.
<Sync time="268.467"/>
voilà, donc on peut pas avoir des fonctions prédéfinies pour tout, et évidemment dans ce cours on présentera comment écrire de nouvelles fonctions.
<Sync time="277.280"/>
donc
<Sync time="278.202"/>
brièvement, pourquoi on écrit des fonctions ?
<Sync time="280.630"/>
ben pour ne pas répéter de calculs laborieux,
<Sync time="287.433"/>
pour ne pas faire de calculs laborieux, donc pour ne pas avoir à écrire des algorithmes qui font des calculs laborieux,
<Sync time="294.793"/>
et puis
<Sync time="296.002"/>
le dernier point, il est important
<Sync time="298.637"/>
c'est que les
<Sync time="299.978"/>
si on on ajoute des fonctions dans son programme, c'est aussi pour le rendre un peu plus lisible.
<Sync time="304.525"/>
et ça, vous en aviez un exemple flagrant
<Sync time="306.830"/>
en tout début de cours.
<Sync time="310.045"/>
voilà, donc ça ça clôt les la partie des motivations.
<Sync time="313.258"/>
j'espère que vous êtes convaincus que c'est important de savoir écrire une fonction
<Sync time="317.835"/>
et de savoir ce que c'est qu'une fonction. donc on va maintenant les définir : qu'est-ce que c'est qu'une fonction ?
<Sync time="326.440"/>

<Event desc="pi" type="pronounce" extent="instantaneous"/>

<Sync time="327.088"/>
tout bêtement
<Sync time="328.558"/>
on a une fonction
<Sync time="331.650"/>
dès qu'on attribue un nom à une partie du programme,
<Sync time="336.050"/>
une partie du calcul,
<Sync time="340.690"/>
ce calcul on va euh () ça va être un calcul numérique ou un calcul sur des chaînes de caractères, en tout cas il y aura un type du résultat donc la fonction sera aussi définie par un type, donc un nom un type
<Sync time="353.420"/>
des arguments
<Sync time="354.629"/>
avec leurs types
<Sync time="355.982"/>
donc là c'était x qui était un réel 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 la racine carrée
<Sync time="358.954"/>
mais on peut avoir plein d'arguments différents, de types différents ; il faut les définir.
<Sync time="364.450"/>
et puis un effet
<Sync time="366.570"/>
un effet qui est un calcul, finalement.
<Sync time="368.820"/>
partant des arguments,
<Sync time="370.540"/>
on effectue un calcul pour obtenir un résultat qu'on va rendre à l'utilisateur
<Sync time="374.420"/>
ou au programme appelant, en l'occurrence.
<Sync time="378.128"/>
alors il y a des analogies en maths, hein
<Sync time="379.914"/>
euh logarithme népérien, c'est une fonction
<Sync time="384.300"/>
et c'est une vraie analogie
<Sync time="386.489"/>
par rapport à ce qu'on va voir en en informatique hein
<Sync time="389.252"/>
on a le nom : logarithme népérien
<Sync time="392.899"/>
on a les arguments
<Sync time="395.400"/>
on a au moins le type des arguments dans cette notation, c'est réel
<Sync time="399.466"/>
on a le type renvoyé par la fonction, c'est réel.
<Sync time="402.988"/>
logarithme va de r() d'un réel
<Sync time="405.448"/>
dans les réels
<Sync time="407.824"/>
on a le la description de l'effet :
<Sync time="411.000"/>
calcule la valeur du logarithme népérien de x, et puis on () le x, en fait, c'est le le
<Sync time="417.009"/>
la petite lettre qu'on avait vue, c'est le paramètre.
<Sync time="420.379"/>
donc s() ce qu'on () ce dont on va parler en informatique, c'est une vraie analogie avec les fonctions mathématiques.
<Sync time="429.115"/>
pour revenir un petit peu sur le vocabulaire,
<Sync time="432.200"/>
abs, c'est le nom de la fonction
<Sync time="435.363"/>
r, c'est le type de l'argument
<Sync time="438.491"/>
l'autre r, c'est le type du résultat
<Sync time="441.641"/>
le x, c'est l'argument qu'on appellera argument formel
<Sync time="445.248"/>
formel, parce qu'on donne sa forme, on donne son nom
<Sync time="449.305"/>
et euh
<Sync time="450.33"/>
après, on a la description du calcul.
<Sync time="452.683"/>
si on sait faire ça
<Sync time="454.465"/>
en maths,
<Sync time="455.628"/>
on sait calculer la fonction,
<Sync time="458.051"/>
si on sait faire ça en informatique, on saura de la même manière calculer la fonction ; il y a une vraie analogie.
<Sync time="467.070"/>
alors vous savez très bien qu'en maths,
<Sync time="469.571"/>
il y a des fonctions qui prennent deux paramètres
<Sync time="472.17"/>
par exemple, la distance ; calcul de la distance entre deux points
<Sync time="477.021"/>
eh ben c'est pareil, en fait
<Sync time="478.131"/>
ça change rien : en informatique, on aura des fonctions qui prennent plusieurs paramètres.
<Sync time="483.910"/>
et même
<Sync time="486.310"/>
quand vous saurez très bien programmer,
<Sync time="489.75"/>
vous verrez que
<Sync time="491.989"/>
ce qu'on a de plus en informatique, c'est que les fonctions
<Sync time="496.020"/>
on a une manière de les définir pour qu'elles prennent un nombre quelconque de paramètres ;
<Sync time="499.790"/>
et selon le nombre de paramètres qu'elle prend, elle peut faire des choses différentes.
<Sync time="504.630"/>
on appellera ça le polymorphisme dans les () dans beaucoup de langages.
<Sync time="509.910"/>
voilà
<Sync time="511.242"/>
une fonction, ça peut prendre un ou plusieurs arguments
<Sync time="514.230"/>
mais par contre
<Sync time="515.501"/>
j'attire votre attention sur le fait que il y a qu'un résultat.
<Sync time="520.430"/>
voilà
<Sync time="522.030"/>
donc en informatique, on peut avoir plusieurs arguments, on ne peut avoir qu'un seul résultat pour une fonction.
<Sync time="527.720"/>
c'est technique, hein, c'est purement technique. en informatique, on est limité là-dessus.
<Sync time="532.257"/>
donc on peut vraiment avoir plusieurs arguments, mais on ne peut avoir qu'un seul résultat.
<Sync time="535.553"/>
c'est pas tout à fait la même chose en maths, mais c'est pas très très grave
<Sync time="539.385"/>
on s'en sort très bien.
<Sync time="543.921"/>
un petit peu de suite sur le vocabulaire
<Sync time="547.690"/>
quand on va chercher à associer une valeur au paramètre formel,
<Sync time="552.320"/>
alors la valeur s'appellera l'argument d'appel
<Sync time="555.331"/>
ou le paramètre d'appel.
<Sync time="557.850"/>
par exemple, quand on cherchera à calculer la valeur absolue de quinze
<Sync time="563.560"/>
où valeur absolue, c'est une fonction
<Sync time="566.830"/>
qui prend en paramètre formel x et qui k() fait un calcul en fonction de x ben euh quand on appelle
<Sync time="572.506"/>
valeur absolue de quinze,
<Sync time="574.78"/>
c'est comme si on avait une instruction qui disait : x reçoit la valeur quinze.
<Sync time="579.899"/>
faut pas chercher à faire plus compliqué que ça
<Sync time="582.192"/>
donc il y a un lien
<Sync time="583.487"/>
naturel
<Sync time="584.698"/>
implicite entre les paramètres d'appel,
<Sync time="587.410"/>
qui sont des valeurs,
<Sync time="589.644"/>
et les paramètres formels, qui sont des variables internes à la fonction.
<Sync time="594.380"/>
donc euh il y a un () voilà
<Sync time="596.203"/>
notez bien le lien entre paramètres d'appel, qui sont des valeurs,
<Sync time="600.112"/>
paramètres formels, qui sont des variables.
<Sync time="605.940"/>
alors
<Sync time="607.229"/>
on va prendre un premier un premier petit exemple
<Sync time="610.389"/>
qui est une conversion de degrés celsius en fahrenheit ou fahrenheit en celsius
<Sync time="615.53"/>

<Event desc="pi" type="pronounce" extent="instantaneous"/>
 deux degrés fahrenheit en degrés celsius
<Sync time="619.150"/>
on a un algorithme qui décrit le calcul en français
<Sync time="622.773"/>
tout ça, ça se traduit évidemment dans un langage
<Sync time="626.785"/>
mathématique
<Sync time="630.496"/>
et puis euh
<Sync time="633.957"/>
et puis on est capable d'écrire en mathématiques la fonction comme ça.
<Sync time="638.017"/>
voilà donc
<Sync time="638.876"/>
c to
<Event desc="en" type="language" extent="previous"/>
 f, ça va être le nom, c to
<Event desc="en" type="language" extent="previous"/>
 f de x
<Sync time="642.934"/>
est égal à
<Sync time="645.260"/>
neuf cinquième de x plus trente-deux.
<Sync time="648.701"/>
donc notez en passant que c'est un algorithme qu'on n() qu'on définit pour euh convertir hein, c'est () la description d'un calcul, c'est un algorithme
<Sync time="656.642"/>
voilà donc
<Sync time="659.760"/>
pour insister sur le vocabulaire,
<Sync time="662.587"/>
je vous mets ce transparent-là que vous pouvez noter
<Sync time="665.720"/>
donc une fonction a un nom, un type pour le résultat et des types pour les arguments
<Sync time="670.680"/>
les arguments lors de la déclaration de la fonction sont appelés des a() arguments formels
<Sync time="675.537"/>
les arguments lors de l'utilisation de la fonction sont appelés arguments d'appel.
<Sync time="689.220"/>
donc vous allez voir, on va parler beaucoup de vocabulaire
<Sync time="692.478"/>
dans la première partie
<Sync time="696.918"/>
parce que
<Sync time="698.006"/>
finalement
<Sync time="700.710"/>
une fonction, c'est ni plus ni moins qu'un
<Sync time="703.744"/>
qu'un al() qu'un bout d'algorithme, voire même un un algorithme
<Sync time="707.427"/>
souvent on n'appelle pas ça une fonction, on peut appeler ça aussi un sous-algorithme
<Sync time="711.760"/>
pou() pour vraiment vous dire que il y a pas de
<Sync time="713.522"/>
il y a pas vraiment beaucoup de mots-clés différents, pas beaucoup de mots-clés nouveaux.
<Sync time="718.260"/>
mais ça permettra de faire beaucoup de choses quand même, malgré tout
<Sync time="721.415"/>
donc c'est important de garder cette euh ce vocabulaire en tête.
<Sync time="727.032"/>
je passe ?
<Sync time="729.924"/>
non ?
<Sync time="746.363"/>
c'est bon ?
<Sync time="748.449"/>
alors
<Sync time="752.338"/>
bon, celui-là je le passe,
<Sync time="753.838"/>
il sert à rien.
<Sync time="757.127"/>
il y a tout un tas de fonctions prédéfinies
<Sync time="759.740"/>
pour faire des calculs mathématiques,
<Sync time="762.260"/>
mais pas que pour faire des calculs mathématiques.
<Sync time="767.259"/>
donc il y a un terme, la fonction prédéfinie,
<Sync time="770.373"/>
pour calculer le sinus, le cosinus, la *valeur absolue, la racine carrée, les é() l'exponentiel
<Sync time="775.735"/>
et plein d'autres calculs que vous pouvez imaginer.
<Sync time="779.114"/>
la saisie, c'est une fonction prédéfinie aussi, donc il y a pas que des fonctions qui font des calculs, il y a des fonctions qui demandent des choses à l'utilisateur
<Sync time="786.426"/>
saisie, c'est une fonction.
<Sync time="789.800"/>
écrire, c'est une fonction ; donc il y a des fonctions de restitution de de choses.
<Sync time="796.949"/>
en gros
<Sync time="797.997"/>
tout ce que vous manipulerez
<Sync time="800.190"/>
en informatique qui sera composé d'un nom avec u() suivi d'une parenthèse, ce sera une fonction.
<Sync time="809.291"/>
donc plein de fonctions prédéfinies
<Sync time="811.237"/>
pour faire des calculs
<Sync time="812.626"/>
plein de fonctions prédéfinies
<Sync time="815.353"/>
pour euh
<Sync time="817.020"/>
travailler sur autre chose que des réels, calculer la longueur d'une chaîne
<Sync time="822.552"/>
donc ça, c'est une fonction qui va des chaînes de caractères dans les entiers
<Sync time="826.330"/>
euh
<Sync time="828.369"/>
on peut penser à d'autres fonctions : une fon() la fonction typeof
<Sync time="832.157"/>
qui prend n'importe quoi
<Sync time="833.680"/>
de n'importe quel type
<Sync time="835.197"/>
et qui renvoie son type
<Sync time="837.553"/>
donc ça, c'est un exemple de fonction qui va s'adapter
<Sync time="840.064"/>
aux types des paramètres, quand même.
<Sync time="842.069"/>
il y a plusieurs formes possibles selon les types des paramètres
<Sync time="845.867"/>
j'en passe et des meilleurs
<Sync time="847.516"/>
donc des fonctions, on reviendra dessus, vous en a() vous en verrez plein en tp notamment
<Sync time="852.108"/>
euh il y en a des tonnes.
<Sync time="857.087"/>
donc
<Sync time="859.940"/>
on va reparler un tout petit peu des paramètres, parce que c'est important de faire attention
<Sync time="863.560"/>
à ce que les types des paramètres correspondent vraiment au type de la spécification.
<Sync time="869.170"/>
donc quand on écrit log de trois,
<Sync time="871.118"/>
je vous rappelle : trois, c'est le paramètre d'appel
<Sync time="874.829"/>
qui sont des valeurs
<Sync time="876.555"/>
ou qui peuvent être des expressions qui renvoient à une valeur.
<Sync time="881.810"/>
la seule chose à laquelle il faut faire a() attention,
<Sync time="884.709"/>
c'est que quand on déclare une fonction qui prend en paramètre un certain type,
<Sync time="889.700"/>
bah il faut il faut l'appeler avec une expression
<Sync time="892.749"/>
qui renvoie le bon type,
<Sync time="894.760"/>
notamment des expressions de type logarithme de une chaîne de caractères
<Sync time="900.526"/>
vous vous doutez bien que ça pose des problèmes.
<Sync time="904.952"/>
des problèmes qui sont levés
<Sync time="907.983"/>
par le le le langage de programmation
<Sync time="910.700"/>
si on écrit une chaîne de caractères qui se convertit
<Sync time="913.724"/>
on a un entier
<Sync time="915.139"/>
ou un () on a un réel
<Sync time="917.990"/>
mais en l'occurrence ici, ça posera un vrai problème parce qu'on n'est pas capable de convertir
<Sync time="921.942"/>
ceci est un beau jour
<Sync time="924.267"/>
en un nombre.
<Sync time="925.980"/>
il y a pas de de méthode de conversion.
<Sync time="929.989"/>
donc ça posera () ça ça peut produire un bug qui se répercute
<Sync time="934.005"/>
dans tout votre programme.
<Sync time="938.690"/>
alors où est-ce qu'on les utilise ?
<Sync time="940.636"/>
donc ça c'est la deuxième partie de l'utilisation. ben
<Sync time="943.754"/>
comme une fonction renvoie une valeur,
<Sync time="946.110"/>
cette valeur peut être utilisée dans n'importe quelle expression
<Sync time="949.830"/>
a l'intérieur d'un calcul, évidemment. donc un plus logarithme de trois, on utilise le résultat de logarithme de trois
<Sync time="955.300"/>
dans l'expression un plus quelque chose.
<Sync time="960.314"/>
et évidemment, il faut que le type renvoyé par la fonction corresponde au type attendu par l'opérateur.
<Sync time="966.542"/>
et faudra toujours faire attention à ça.
<Sync time="968.684"/>
donc ça peut apparaître évidemment dans une affectation, dans un affichage,
<Sync time="972.775"/>
dans une conditionnelle, j'en passe et des meilleurs
<Sync time="975.238"/>
partout où on peut avoir une expression.
<Sync time="982.560"/>
encore un tout petit peu de vocabulaire
<Sync time="986.637"/>
parce que ces expressions on va leur donner un nom
<Sync time="991.330"/>
finalement, il y a deux expressions :
<Sync time="993.370"/>
il y a l'expression
<Sync time="994.872"/>
qui va d() donner la valeur
<Sync time="997.154"/>
des arguments
<Sync time="999.182"/>
et puis il y a l'expression dans laquelle est utilisée la fonction, dans laquelle est utilisé le résultat
<Sync time="1003.603"/>
de la fonction.
<Sync time="1006.089"/>
ben elle porte deux noms différents : il y a euh il y a l'expression du paramètre d'appel
<Sync time="1009.96"/>
et il y a l'expression appelante.
<Sync time="1011.640"/>
et elles ont deux noms différents
<Sync time="1016.284"/>
et on les distinguera
<Sync time="1017.965"/>
on fera vraiment attention à les distinguer.
<Sync time="1021.342"/>
euh cette euh ce qui est en dessous, ce
<Sync time="1025.277"/>
ce sera encore sur le prochain transparent
<Sync time="1029.880"/>
ça va un peu vite, je sais, mais vous retrouvez l'expression en haut là
<Sync time="1033.452"/>
donc expression
<Sync time="1035.697"/>
bon, notez le vocabulaire, je vous laisse un peu de temps.
<Sync time="1051.830"/>
bah finalement le vocabulaire, c'est plutôt pour les questions de cours
<Sync time="1055.168"/>
que vous aurez à l'examen, hein
<Sync time="1059.810"/>
ce qui compte, c'est que vous compreniez bien à quel moment il faut écrire une fonction et comment on l'écrit.
<Sync time="1075.869"/>
c'est bon ?
<Sync time="1079.970"/>
alors là, c'est un transparent qui est assez important
<Sync time="1083.630"/>
puisqu'on va voir comment on fait pour évaluer une fonction, dans quel ordre sont () dans quel ordre on évalue
<Sync time="1088.665"/>
une expression qui contient une fonction ?
<Sync time="1092.850"/>
alors partant dans () de l'historique d'exécution
<Sync time="1096.980"/>
d'une mémoire remplie avec la valeur cinq pour hypoténuse
<Sync time="1100.581"/>
et la valeur quarante-cinq pour angle, on cherche à évaluer l'expression
<Sync time="1104.900"/>
où l'instruction opposée reçoit
<Sync time="1107.54"/>
hypoténuse fois sinus entre parenthèses angle fois deux.
<Sync time="1111.966"/>
comment ça se passe ?
<Sync time="1113.840"/>
bah là il y a plein d'étapes finalement, et plein de vérifications
<Sync time="1116.624"/>
de type
<Sync time="1119.567"/>
pour éviter de
<Sync time="1121.41"/>
d'aller dans le mur, de d'avoir un bug. donc il y a vraiment
<Sync time="1124.218"/>
tout un tas d'étapes de vérification qu'on va qu'on va lister là maintenant.
<Sync time="1129.819"/>
donc pour évaluer l'expression,
<Sync time="1131.830"/>
on doit d'abord évaluer hypoténuse
<Sync time="1134.060"/>
et on doit d'abord évaluer sinus de angle fois deux.
<Sync time="1137.510"/>
on a une expression avec euh c'est quoi ? c'est un un multiplier entre deux choses
<Sync time="1143.740"/>
avant d'évaluer le mu() le résultat de la multiplication, il v() faut évaluer les deux
<Sync time="1149.230"/>
les deux bouts de l'expression.
<Sync time="1151.680"/>
donc hypoténuse, c'est facile : ça vaut cinq.
<Sync time="1154.486"/>
on va voir en mémoire, ça vaut cinq
<Sync time="1156.967"/>
par contre
<Sync time="1158.248"/>
sinus de angle fois deux,
<Sync time="1160.381"/>
on sait pas l'évaluer d'un coup.
<Sync time="1163.574"/>
pour l'évaluer,
<Sync time="1166.220"/>
ben la la première chose à faire, c'est d'évaluer
<Sync time="1169.220"/>
l'expression du du paramètre d'appel,
<Sync time="1173.358"/>
angle fois deux.
<Sync time="1175.128"/>
et si on va voir en mémoire, angle ça vaut quarante-cinq
<Sync time="1178.811"/>
on retrouve la valeur quarante-cinq, fois deux ça fait quatre-vingt-dix :
<Sync time="1182.048"/>
l'expression appelante est évaluée à quatre-vingt-dix.
<Sync time="1185.592"/>
donc reste à évaluer sinus de quatre-vingt-dix
<Sync time="1190.960"/>
on continue ? si
<Sync time="1192.830"/>
on a une fonction
<Sync time="1195.910"/>
et là, il y a une étape de vérification.
<Sync time="1199.760"/>
la vérification, c'est
<Sync time="1201.650"/>
premièrement, est-ce que sinus c'est une fonction qui existe dans ma bibliothèque de fonctions que j'ai déjà
<Sync time="1206.562"/>
qui sont prédéfinies ou que j'ai définies ?
<Sync time="1209.664"/>
la réponse va être oui dans ce cas-là.
<Sync time="1212.7"/>
mais si on avait écrit sinus s i n u s, c'était moins clair.
<Sync time="1217.353"/>
donc il y a une vérification du nom.
<Sync time="1220.804"/>
une fois qu'on a vérifié que ça existe
<Sync time="1224.650"/>
donc euh pardon s() si si ça n'existe pas, ça s'arrête s() il y a une erreur.
<Sync time="1229.487"/>
ça vous met : il y a une erreur de syntaxe, je ne connais pas sinus.
<Sync time="1233.380"/>
si oui, et c'est le cas,
<Sync time="1235.091"/>
la deuxième question qu'on se pose, c'est est-ce que sinus
<Sync time="1238.565"/>
appliqué à un entier,
<Sync time="1240.793"/>
c'est une fonction qui existe ?
<Sync time="1242.953"/>
donc il y a une vérification du type par la suite
<Sync time="1248.403"/>
donc
<Sync time="1249.530"/>
si oui, on continue
<Sync time="1251.674"/>
si non
<Sync time="1254.260"/>
on produit pas systématiquement une erreur
<Sync time="1257.34"/>
on essaye quand même d'évaluer l'expression. c'est ce qu'on a fait dans l'e()
<Sync time="1260.972"/>
dans l'exercice deux : on a essayé de corriger les expressions. ben dans certains cas c'est possible, dans d'autres ça l'est pas.
<Sync time="1267.173"/>
donc on essaye de transtyper ; si on peut *transtyper,
<Sync time="1271.183"/>
on fait le calcul.
<Sync time="1272.739"/>
voilà, donc on s'est () on est arrivé à une étape, nous, où le calcul était bon. on sait que sinus quatre-vingt-dix, ça vaut un
<Sync time="1278.042"/>
et on continue.
<Sync time="1279.576"/>
donc à la fin, on est arrivé à évaluer cinq fois un qui vaut cinq,
<Sync time="1283.123"/>
on exécute l'instruction opposé reçoit cinq.
<Sync time="1287.540"/>
donc vous voyez, c'est pas si simple que ça d'évaluer une expression qui contient une fonction. il y a tout un tas d'étapes de vérification qui sont faites
<Sync time="1294.639"/>
par l'interpréteur de commandes.
<Sync time="1298.890"/>
il faut les garder en tête, ces ces choses-là.
<Sync time="1303.522"/>
c'est bon ?
<Sync time="1305.770"/>
il y a beaucoup de bruit là-haut, hein.
<Sync time="1311.093"/>
notamment il faut faire très attention au type
<Sync time="1318.960"/>
euh no() t() par exemple, si on a quelque chose comme ça
<Sync time="1324.643"/>
trois virgule cinq inférieur à b, ben on attend un nombre
<Sync time="1329.21"/>
donc b peut être n'importe quoi qui renvoie à un nombre.
<Sync time="1333.786"/>
c
<Sync time="1335.400"/>
le résultat est forcément un booléen, donc on attend n'importe quoi, n'importe quelle fonction qui renvoie à un booléen.
<Sync time="1341.981"/>
ok ?
<Sync time="1344.080"/>
donc à chaque fois, il faudra faire attention au type
<Sync time="1346.600"/>
du résultat. donc a()
<Sync time="1348.604"/>
attention au type des paramètres de la fonction, attention au type des résultats.
<Sync time="1355.827"/>
on va maintenant parler des fonctions prédéfinies
<Sync time="1362.996"/>
je vais m'arrêter là, hein.
<Sync time="1367.018"/>
on va maintenant parler des fonctions prédéfinies
<Sync time="1369.415"/>
puisque dans tous les langages de programmation, il y en a plus ou moins des fonctions prédéfinies, mais il y en a
<Sync time="1374.946"/>
donc je vous ai dit : il y a racine carrée, il y a de grandes chances qu'elle soit prédéfinie dans le langage
<Sync time="1379.280"/>
que vous allez manipuler ; javascript, elle est prédéfinie.
<Sync time="1384.433"/>
valeur absolue, elle est prédéfinie donc il y en a il y en a tout un tas.
<Sync time="1389.219"/>
dans chacun de ces de ces prédéfinitions,
<Sync time="1393.570"/>
la fonction est prévue pour fonctionner avec des types particuliers qu'il faudra connaître.
<Sync time="1397.723"/>
et ça, c'est donné dans la documentation
<Sync time="1400.691"/>
du javascript.
<Sync time="1402.474"/>
ça se trouve sur internet, sur plein de sites qui vous sont indiqués.
<Sync time="1408.412"/>
voilà
<Sync time="1409.325"/>
la plupart du temps, ces fonctions
<Sync time="1412.371"/>
elles sont groupées
<Sync time="1413.849"/>
les fonctions qui font des calculs mathématiques sont regroupées dans une bibliothèque qui s'appelle maths
<Sync time="1418.006"/>
maths point quelque chose donc
<Sync time="1419.558"/>
racine carrée, elle s'appelle pas racine carrée, elle s'*appelle m() maths point sqrt
<Sync time="1424.293"/>
en javascript.
<Sync time="1425.544"/>
valeur absolue s'appelle maths point abs.
<Sync time="1428.430"/>
et il y a un certain nombre de bibliothèques comme ça, qui permettent de manipuler des fonctions
<Sync time="1432.752"/>
qui ne sont pas uniquement numériques.
<Sync time="1435.511"/>
voilà
<Sync time="1437.771"/>
ça termine s() la petite introduction sur ce que c'est qu'une fonction
<Sync time="1443.240"/>
mais ce qui va vous intéresser maintenant, ce qui va nous intéresser surtout, c'est comment on fait pour en écrire des nouvelles : puisqu'on peut pas en avoir
<Sync time="1449.302"/>
de prédéfinies pour tout,
<Sync time="1451.888"/>
on a intérêt à savoir en écrire des nouvelles.
<Sync time="1454.23"/>
et c'est une des forces du langage
<Sync time="1456.830"/>
d'un langage de programmation.
<Sync time="1458.820"/>
c'est de définir d() ces nouvelles briques
<Sync time="1461.529"/>
qui permettent de construire des choses plus compliquées.
<Sync time="1466.050"/>
qu'est-ce que ça veut dire que déclarer une fonction ?
<Sync time="1471.281"/>
comme pour les algorithmes, déclarer une fonction c'est en donner l'en-tête,
<Sync time="1475.790"/>
mais un en-tête un petit peu plus compliqué, un petit peu plus complet que pour un algorithme puisqu'on doit préciser dans l'en-tête
<Sync time="1482.087"/>
le nom, les
<Sync time="1483.644"/>
le nom des arguments formels, leur type, le type renvoyé par la fonction. et ça, ça s'appelle la spécifier.
<Sync time="1490.011"/>
donner les spécifications, c'est donner
<Sync time="1493.290"/>
l'en-tête de la fonction.
<Sync time="1497.970"/>
déclarer la fonction, c'est aussi
<Sync time="1500.57"/>
expliciter le calcul qui permet de passer
<Sync time="1504.065"/>
des valeurs
<Sync time="1506.800"/>
de paramètres envoyés à la fonction à un résultat
<Sync time="1510.578"/>
d'un calcul qui sera renvoyé par la fonction.
<Sync time="1514.482"/>
donc expliciter le lien entre
<Sync time="1516.51"/>
les paramètres de la fonction
<Sync time="1518.260"/>
et le résultat du calcul.
<Sync time="1520.945"/>
et si on fait ces deux choses-là, ben on a s() on a déclaré la fonction.
<Sync time="1528.849"/>
donc voilà un exemple
<Sync time="1530.082"/>
de fonction
<Sync time="1531.314"/>
qu'on a déclarée
<Sync time="1532.629"/>
et ça, c'est une euh une écriture dans le langage
<Sync time="1536.067"/>
algorithmique.
<Sync time="1538.710"/>
donc la fonction 
<Event desc="en" type="language" extent="begin"/>
celsius to fahrenheit
<Event desc="en" type="language" extent="end"/>
, elle prend en paramètre une température en celsius qui est un réel,
<Sync time="1544.667"/>
elle renvoie à un réel
<Sync time="1546.612"/>
ça, c'est la spécification ; cette ligne-là, c'est la spécification.
<Sync time="1550.128"/>
vous pouvez tout à fait l'associer à la ligne algorithme
<Sync time="1553.052"/>
temp en degrés celsius,
<Sync time="1555.518"/>
donc c'est l'en-tête.
<Sync time="1557.890"/>
on déclare les variables
<Sync time="1560.700"/>
et on donne le corps de la fonction.
<Sync time="1564.970"/>
donc ce qu'on retrouve, c'est le nom
<Sync time="1566.898"/>
ici
<Sync time="1569.070"/>
ce qu'on retrouve, c'est le
<Sync time="1571.972"/>
les paramètres,
<Sync time="1573.160"/>
les noms des paramètres
<Sync time="1574.985"/>
d'une part, donc il y en a un ici mais peut y en avoir plusieurs
<Sync time="1578.1"/>
séparés par des virgules
<Sync time="1580.960"/>
on retrouve le type
<Sync time="1583.063"/>
du ou des paramètres
<Sync time="1586.000"/>
qui peuvent être différents pour chacun des paramètres
<Sync time="1589.810"/>
on retrouve ici le type de la fonction, le type du résultat renvoyé par la fonction.
<Sync time="1596.540"/>
ici, on retrouve une description du calcul
<Sync time="1600.086"/>
quand on écrivait un algorithme, c'est exactement l'étape deux de la construction de l'algorithme ; on va revenir là-dessus.
<Sync time="1609.178"/>
la grosse nouveauté,
<Sync time="1611.560"/>
c'est le "retourner" là,
<Sync time="1613.824"/>
c'est un mot-clé important
<Sync time="1617.370"/>
qui va caractériser les fonctions informatiques
<Sync time="1621.030"/>
puisque ce mot-clé-là,
<Sync time="1624.767"/>
c'est euh ce qui va dire qu'est-ce qu'on va renvoyer ; qu'est-ce que la fonction va renvoyer ? elle va renvoyer res.
<Sync time="1632.329"/>
ok ?
<Sync time="1639.310"/>
donc euh de manière un petit peu moins euh sur un exemple,
<Sync time="1645.590"/>
voilà ce que fait la fonct() voilà comment on définit une fonction :
<Sync time="1649.083"/>
donc nom f
<Sync time="1650.830"/>
nom f c'est un identifiant comme les comme les variables, finalement ; on n'a pas le droit à n'importe quoi
<Sync time="1655.665"/>
des paramètres formels, des types,
<Sync time="1657.589"/>
un type de la fonction, on peut déclarer des variables utilisées à l'intérieur de la fonction ; on reviendra dessus parce que c'est important s()
<Sync time="1664.198"/>
il y a une notion d'in()
<Sync time="1665.380"/>
de variables à l'intérieur de la fonction qui est importante.
<Sync time="1669.660"/>
des instructions et le mot-clé retourner.
<Sync time="1676.531"/>
alors évidemment la fon()
<Sync time="1677.927"/>
on peut ne pas avoir besoin de variables supplémentaires pour décrire le calcul, ce sera souvent le cas
<Sync time="1682.947"/>
dans ce cas-là, la partie variable on la met pas.
<Sync time="1689.140"/>
des paramètres formels
<Sync time="1691.900"/>
il existe des fonctions qui n'ont pas de paramètres formels,
<Sync time="1696.310"/>
on a le droit de ne pas mettre de paramètres formels. dans ce cas-là, on a une parenthèse ouvrante une parenthèse fermante
<Sync time="1701.480"/>
il est faux mais euh il y a pas besoin de choses à l'intérieur.
<Sync time="1706.925"/>
on en met autant qu'on veut
<Sync time="1710.750"/>
le type de l'expression
<Sync time="1713.720"/>
c'est forcément celui qui est () comme c'est l'expression qui est renvoyée par la fonction, le type
<Sync time="1718.440"/>
de l'expression doit correspondre
<Sync time="1721.317"/>
au type de la fonction.
<Sync time="1727.750"/>
aujourd'hui, il y a beaucoup de bruit hein
<Sync time="1729.370"/>
c'est pas c'est pas facile.
<Sync time="1737.714"/>
alors
<Sync time="1740.948"/>
dans la deuxième partie du cours, on avait fait un exercice
<Sync time="1743.619"/>
typique de () pour écrire un algorithme
<Sync time="1746.467"/>
on va faire la même chose
<Sync time="1748.440"/>
pour voir comment on fait pour euh pour écrire une fonction.
<Sync time="1751.910"/>
donc l'exercice, c'est euh
<Sync time="1754.213"/>
l() le suivant :
<Sync time="1755.584"/>
écrire une fonction qui, étant donnée une année de naissance, calcule l'âge qu'aura la personne au trente et un décembre deux mille vingt à minuit.
<Sync time="1766.033"/>
souvenez-vous
<Sync time="1767.164"/>
l'exercice qu'on avait fait
<Sync time="1770.484"/>
dans le deuxième cours, c'était ça l'énon() euh avait s() avait k() ça pour énoncé :
<Sync time="1775.66"/>
écrire un algorithme
<Sync time="1777.235"/>
qui
<Sync time="1778.382"/>
demande à l'utilisateur de saisir une année de naissance et calcule l'âge qu'aura la personne au trente et un décembre deux mille vingt puis l'affiche
<Sync time="1787.970"/>
donc finalement, dans les énoncés c'est assez proche.
<Sync time="1793.210"/>
ça on peut cons() l() le premier énoncé, on va considérer que vous savez répondre à la question
<Sync time="1798.368"/>
vous avez éventuellement fait l'exercice cinq en td, si vous avez déjà eu le td
<Sync time="1803.571"/>
on vous av() on avait donné le la manière d'écrire l'algorithme pas à pas, donc je considère que vous savez écrire ça.
<Sync time="1811.353"/>
algorithme
<Sync time="1812.746"/>
calcul âge, variable, début, fin
<Sync time="1816.166"/>
et le lien entre la les saisies et les affichages.
<Sync time="1821.629"/>
bon ben 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 si vous savez écrire l'algorithme,
<Sync time="1825.375"/>
au niveau de la syntaxe vous saurez écrire la fonction
<Sync time="1829.058"/>
tout simplement parce que il y a beaucoup de liens entre les énoncés.
<Sync time="1832.15"/>
dans un cas on dit euh écrire un algorithme, dans l'*autre cas on dit écrire une fonction.
<Sync time="1836.371"/>
ben qu'est-ce que ça change ?
<Sync time="1837.760"/>
pas grand-chose finalement
<Sync time="1840.170"/>
il suffit de transformer algorithme en fonction
<Sync time="1843.137"/>
et puis euh
<Sync time="1844.575"/>
le nom qu'on avait donné à l'algorithme, ben on est un peu plus figé, quoi. *enfin c'est
<Sync time="1849.871"/>
on n'a on n'a pas le droit à n'importe quel nom, notamment on n'a pas le droit aux espaces
<Sync time="1853.718"/>
donc faut faire un peu plus attention.
<Sync time="1855.876"/>
ce qu'on voit apparaître dans la spécification aussi, c'est euh
<Sync time="1859.445"/>
des paramètres
<Sync time="1861.930"/>
d'appel et un type. donc euh pour le moment, j'ai laissé les les parenthèses vides, mais il y aura des choses à l'intérieur
<Sync time="1869.550"/>
première transformation pour passer d'un d'un algorithme en une fonction, c'est transformer le mot-clé algorithme en le mot-clé fonction.
<Sync time="1878.580"/>
ensuite, on avait vu qu'il y avait des variables
<Sync time="1881.080"/>
année de naissance et âge
<Sync time="1883.500"/>
ben les variables, il y a pas de raison qu'on n'en ait pas besoin dans la fonction.
<Sync time="1889.720"/>
la seule différence
<Sync time="1891.438"/>
c'est qu'elles ont pas tout à fait le même statut
<Sync time="1894.500"/>
entre l'algorithme est la fonction,
<Sync time="1896.580"/>
notamment euh l'année de naissance n'a pas le même statut
<Sync time="1901.940"/>
dans le premier cas, c'est une valeur qu'on demande à l'utilisateur
<Sync time="1906.450"/>

<Event desc="pi" type="pronounce" extent="instantaneous"/>
 on demande de saisir la valeur
<Sync time="1908.806"/>
et c'est pour ça qu'on a une instruction année reçoit saisie ;
<Sync time="1912.277"/>
et dans l'autre cas, elle est donnée en paramètre de la fonction.
<Sync time="1917.398"/>
donc retenez bien
<Sync time="1919.011"/>
que ce qu'on va faire là
<Sync time="1922.360"/>
pour transformer l'algorithme en une fonction,
<Sync time="1925.090"/>
on va repérer
<Sync time="1926.973"/>
toutes les variables qui sont saisies,
<Sync time="1930.600"/>
toute la partie un de la déclaration de l'algorithme,
<Sync time="1933.689"/>
ça va donner les paramètres d() formels.
<Sync time="1937.640"/>
donc la variable année euh de type entier, elle est plus définie dans les variables internes à la fonction, elle est définie qu'une seule fois en tant que paramètre
<Sync time="1944.650"/>
mais elle sera passée en paramètre
<Sync time="1947.171"/>
de la fonction
<Sync time="1949.870"/>
donc il y a plus de raison de la saisir.
<Sync time="1953.450"/>
quand on sera à l'étape du calcul, année aura une valeur qui sera envoyée
<Sync time="1958.484"/>
en paramètre d'appel de la fonction.
<Sync time="1963.685"/>
ben on finit ?
<Sync time="1966.751"/>
le travail à faire par l'algorithme est le même que celui qui est à faire par la fonction : calculer l'âge qu'aura la personne au trente et un décembre deux mille vingt.
<Sync time="1974.306"/>
donc le calcul
<Sync time="1975.658"/>
ne change pas :
<Sync time="1977.450"/>
âge reçoit deux mille vingt moins année.
<Sync time="1980.335"/>
la seule différence, c'est dans la restitution du résultat :
<Sync time="1983.354"/>
dans un cas on va restit()
<Sync time="1985.053"/>
on va restituer le résultat à l'utilisateur directement par un affichage,
<Sync time="1990.198"/>
dans l'autre cas
<Sync time="1992.150"/>
c'est pas un affichage, mais c'est une valeur restituée par la fonction. donc le mot-clé, il est là et il remplace un "écrire".
<Sync time="1999.010"/>
je vais vous dire où je voulais en venir : je vous montre comment ça se traduit en javascript
<Sync time="2003.554"/>
c'est très compact, hein
<Sync time="2005.070"/>
donc le mot-clé fonction devient le mot-clé function
<Event desc="en" type="language" extent="previous"/>

<Sync time="2009.750"/>
on retrouve le nom
<Sync time="2011.868"/>
là encore, faut faire attention : on n'a pas le droit d'écrire n'importe quel nom, mais vous aurez l'habitude d'écrire des noms convenables assez vite
<Sync time="2018.768"/>
entre parenthèses, les paramètres qu'on passe, sans les types parce qu'en javascript on les précise pas.
<Sync time="2024.200"/>
on précise pas les types renvoyés par la fonction,
<Sync time="2027.140"/>
ils sont implicites
<Sync time="2030.400"/>
déclaration des variables, calcul et le mot-clé retourner se traduit par le mot-clé return
<Event desc="en" type="language" extent="previous"/>
.
<Sync time="2036.886"/>
donc la traduction est est presque syntaxique hein, entre le langage algorithmique et le langage javascript.
<Sync time="2044.533"/>
voilà
<Sync time="2045.583"/>
et puis souvent
<Sync time="2046.940"/>
pour préciser la spécification, on ajoute une ligne de commentaire
<Sync time="2051.581"/>
qui décrit le calcul en français.
<Sync time="2053.630"/>
ça c'est une habit() c'est une bonne habitude à prendre.
<Sync time="2057.680"/>
et vous serez notés là-dessus, évidemment, puisqu'on vous () on est là pour vous faire prendre de bonnes habitudes.
<Sync time="2062.94"/>
voilà, donc moralité
<Sync time="2065.467"/>
là où je veux en venir, c'est que si vous savez écrire un algorithme
<Sync time="2069.213"/>
et j'imagine que ça, vous saurez très vite le faire,
<Sync time="2073.570"/>
alors a priori vous avez toutes les clés en main pour écrire les fonctions.
<Sync time="2077.440"/>
écrire une fonction,
<Sync time="2080.360"/>
il y a rien de plus compliqué.
<Sync time="2083.370"/>
moralité euh suite, c'est que les paramètres de la fonction
<Sync time="2088.110"/>
ça *généralise les saisies
<Sync time="2094.160"/>
donc les paramètres de la fonction généralisent les saisies
<Sync time="2097.028"/>
les affich() les valeurs retournées par la fonction généralisent les affichages.
<Sync time="2102.290"/>
autrement dit, retenez bien ça :
<Sync time="2104.780"/>
un algorithme où on a saisi calcul affichage,
<Sync time="2108.033"/>
une fonction où on a
<Sync time="2109.490"/>
paramètres, calcul, restitution de la valeur
<Sync time="2113.390"/>
ou retour du résultat, pour être 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 encore plus proche du langage.
<Sync time="2118.323"/>
et ça, c'est à retenir
<Sync time="2119.760"/>
si vous retenez bien ces règles-là, vous saurez passer assez facilement d'un algorithme en une fonction.
<Sync time="2125.420"/>
et si vous savez passer d'un algorithme en une fonction, très très rapidement vous saurez écrire des fonctions directement.
<Sync time="2147.217"/>
hein ?
<Sync time="2150.081"/>
j'ai j'ai complété un tout petit peu euh j'ai rajouté deux lignes ce matin
<Sync time="2160.684"/>
on passe ?
<Sync time="2162.217"/>
nan ?
<Sync time="2176.27"/>
c'est bon ?
<Sync time="2177.908"/>
bon
<Sync time="2179.940"/>
alors il y a des bonnes pratiques
<Sync time="2181.822"/>
quand on écrit des fonctions :
<Sync time="2186.440"/>
première bonne pratique, c'est que on a tout fait pour enlever les saisies et l'a() et les affichages
<Sync time="2192.481"/>
des fonctions. donc sauf cas très particulier,
<Sync time="2195.970"/>
on mettra jamais de saisie et de calcul dans une fonction, et en général, et ça c'est une règle euh assez stricte, on ne mélangera jamais calcul et affichage à l'intérieur d'une fonction.
<Sync time="2205.550"/>
une fonction elle fait soit un calcul
<Sync time="2208.166"/>
soit un affichage compliqué : afficher un tableau compliqué, ça peut être intéressant d'avoir une fonction.
<Sync time="2212.958"/>
mais on mélangera pas calcul et affichage
<Sync time="2215.043"/>
c'est pas bien de de faire comme ça
<Sync time="2216.868"/>
c'est c'est pas une bonne pratique.
<Sync time="2219.119"/>
la deuxième bonne pratique, c'est que
<Sync time="2221.740"/>
les fonctions sont des choses qui sont là pour être partagées
<Sync time="2226.880"/>
partagées entre plusieurs parties du programme, entre un m() un programme que vous allez faire aujourd'hui et un programme que vous allez faire dans six mois
<Sync time="2234.494"/>
donc elles ont un but
<Sync time="2235.72"/>
elles ont comme but d'être euh partagées
<Sync time="2238.569"/>
et euh partagées à long terme.
<Sync time="2240.698"/>
donc il faut bien les commenter pour bien les comprendre euh
<Sync time="2243.440"/>
euh plus tard.
<Sync time="2245.445"/>
c'est une bonne pratique
<Sync time="2248.891"/>
alors ça c'est même pas une bonne pratique, c'est que c'est
<Sync time="2252.220"/>
c'est une source de bugs
<Sync time="2253.673"/>
que vous trouverez en tp, c'est que toutes les variables qui sont utilisées à l'intérieur de la fonction
<Sync time="2258.113"/>
doivent être déclarées.
<Sync time="2260.550"/>
gardez en tête que si vous les déclarez pas, ça marche pas.
<Sync time="2265.076"/>
en vrai, ça va marcher mais ça va mal marcher, et vous aurez des bugs de temps en temps.
<Sync time="2270.642"/>
donc la bonne pratique, c'est de toujours les déclarer,
<Sync time="2273.896"/>
surtout en tp.
<Sync time="2275.330"/>
vous allez voir pourquoi ça marche pas quand on parlera de la portée des variables.
<Sync time="2281.009"/>
quatrième bonne pratique, c'est que quand on déclare une fonction
<Sync time="2288.532"/>
il est bien de donner
<Sync time="2290.885"/>
une manière de la tester
<Sync time="2293.465"/>
de tester son bon fonctionnement.
<Sync time="2296.616"/>
ça peut être tout bêtement
<Sync time="2298.562"/>
l'inclure dans un algorithme
<Sync time="2300.485"/>
qui permet de la tester
<Sync time="2302.864"/>
ou de manière un petit peu plus euh
<Sync time="2305.430"/>
évoluée,
<Sync time="2306.821"/>
décrire ce qu'on appelle les tests unitaires
<Sync time="2309.705"/>
qui permettent de tester une fonction dans la plupart de ces cas classiques d'utilisation.
<Sync time="2317.030"/>
on reviendra sur cette notion de tests
<Sync time="2319.345"/>
dans dans deux cours.
<Sync time="2322.470"/>
mais 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 la bonne pratique,
<Sync time="2324.313"/>
c'est que dès qu'on a une fonction, il faut qu'elle soit utilisée
<Sync time="2326.623"/>
et il faut qu'elle soit testée.
<Sync time="2332.850"/>
et les bonnes pratiques de programmation telles qu'elles sont décrites dans les livres
<Sync time="2338.734"/>
pour euh les programmeurs de haut niveau,
<Sync time="2341.087"/>
c'est même de définir les tests
<Sync time="2343.780"/>
avant même d'avoir écrit la fonction.
<Sync time="2346.090"/>
donc de pas faire l'in() de pas écrire la fonction et de de réfléchir aux tests, mais de réfléchir aux tests
<Sync time="2350.755"/>
et de les définir avant même de d'écrire la fonction.
<Sync time="2354.490"/>
on fera jamais ça, on n'est on on n'est pas là pour euh
<Sync time="2359.268"/>
devenir au bout de six mois d'excellents programmeurs d'entreprise, 
<Sync time="2363.199"/>
mais c'est une pratique classique.
<Sync time="2368.520"/>
la deuxième question qu'on va se poser, c'est : quand est-ce qu'on doit écrire une fonction ?
<Sync time="2372.931"/>
*alors m()
<Sync time="2373.780"/>
moi j'ai tendance à vous dire : dès que possible
<Sync time="2377.088"/>
plus il y a de fonctions, mieux c'est.
<Sync time="2380.692"/>
mais la bonne pratique,
<Sync time="2383.500"/>
c'est de se dire que
<Sync time="2388.730"/>
dès qu'on a deux boucles imbriquées l'une dans l'autre,
<Sync time="2391.718"/>
c'est qu'il y en a une de trop
<Sync time="2393.196"/>
c'est qu'à un moment, il faut écrire une fonction.
<Sync time="2397.120"/>

<Event desc="pi" type="pronounce" extent="instantaneous"/>
 la bonne pratique de programmation,
<Sync time="2400.133"/>
c'est de
<Sync time="2403.100"/>
d'écrire le problème à résoudre
<Sync time="2405.782"/>
en break de ré() en briques de résolution qui paraissent élémentaires.
<Sync time="2411.440"/>
voilà, donc on écrit le problème
<Sync time="2415.950"/>
de manière à ce que ce ce soit un assemblage de briques élémentaires, et les briques élémentaires c'est des fonctions.
<Sync time="2423.880"/>
donc
<Sync time="2424.765"/>
pour vous donner un exemple
<Sync time="2430.250"/>
ça c'est
<Sync time="2432.400"/>
un algorithme
<Sync time="2434.849"/>
qui dessine un triangle
<Sync time="2437.670"/>
le triangle, il est composé de deux briques imbri() de de deux for imbriqués l'un dans l'autre.
<Sync time="2444.096"/>
ben clairement
<Sync time="2447.000"/>
la deuxième boucle imbriquée, elle est de trop ; il faut écrire une fonction.
<Sync time="2451.268"/>
et ce serait 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 ce serait bien d'avoir une fonction qui fait le travail de la deuxième du deuxième bloc.
<Sync time="2456.972"/>
on reviendra dessus puisqu'on la on la définira un peu plus tard, cette fonction.
<Sync time="2462.280"/>
mais dès que vous avez ça, ben c'est que il y a une bou()
<Sync time="2464.901"/>
c'est qu'à un moment il manque une fonction.
<Sync time="2472.504"/>
quand on écr() euh il y a une question euh classique qui revient, c'est : où est-ce qu'on écrit la fonction, où est-ce qu'on écrit l'algorithme ? puisque il y a il y aura les deux qui se
<Sync time="2487.633"/>
on aura à écrire les deux
<Sync time="2489.890"/>
dans le même euh sur la même feuille pour résoudre un problème, il faudra écrire une ou plusieurs fonctions, écrire un algorithme qui euh utilise les fonctions
<Sync time="2496.945"/>
donc l'u() il y a pas d'usage là-dessus, dans le langage il y a pas de règle :
<Sync time="2500.178"/>
on peut mélanger des lignes d'algorithme et des fonctions dans le langage,
<Sync time="2504.967"/>
l'usage fait que c'est pas
<Sync time="2507.291"/>
ça () c'est pas lisible
<Sync time="2509.190"/>
donc ce que je vous demanderai
<Sync time="2511.680"/>
c'est d'écrire
<Sync time="2513.900"/>
les déclarations des fonctions
<Sync time="2516.650"/>
puis de les utiliser. donc la bonne habitude, c'est de faire ça :
<Sync time="2524.014"/>
on écrit une fonction,
<Sync time="2526.473"/>
donc la fonction qui s'appelle euh truc
<Sync time="2532.220"/>
et puis ensuite on utilise truc
<Sync time="2537.205"/>
d'accord ?
<Sync time="2541.916"/>
dans le langage,
<Sync time="2544.070"/>
c'est bien d'écrire ça comme ça.
<Sync time="2545.958"/>
on déclare les fonctions
<Sync time="2547.637"/>
on les déclare toutes à la suite, et puis à la fin on écrit un algorithme qui les utilise.
<Sync time="2552.395"/>
la bonne pratique, c'est de pas mélanger les choses,
<Sync time="2555.556"/>
voilà.
<Sync time="2556.473"/>
alors qu'évidemment, vous avez le droit de le faire ; il y a pas de règle qui l'interdit dans le langage.
<Sync time="2563.834"/>
on fera attention à ça.
<Sync time="2568.704"/>
ça, je passe.
<Sync time="2573.010"/>
bon, maintenant qu'on sait déclarer les fonctions
<Sync time="2576.160"/>
on va construire un historique d'exécution comme on l'a fait pour les boucles.
<Sync time="2579.474"/>
comment ça se passe pour un historique d'exécution quand quand il y a une fonction ?
<Sync time="2589.419"/>
ben si on regarde bien
<Sync time="2593.020"/>
les historique d'exécution, ils vont se mélanger.
<Sync time="2598.700"/>
donc on va exécuter les instructions les unes après les autres
<Sync time="2602.090"/>
et puis des fois j'é() j'exécuterai une instruction du premier euh
<Sync time="2606.269"/>
de l'algorithme, des fois j'exécuterai une instruction de la fonction.
<Sync time="2609.750"/>

<Sync time="2610.910"/>
et ce qui est important, c'est de repérer l'ordre. donc on va construire un historique d'exécution pour les variables
<Sync time="2617.627"/>
de l'algorithme et pour les variables de la fonction
<Sync time="2621.215"/>
donc v et i
<Sync time="2625.750"/>
la première instruction qu'on va exécuter, c'est toujours l'instruction de l'algorithme
<Sync time="2630.290"/>
donc on commence par là
<Sync time="2632.380"/>
et on va chercher à exécuter l'instruction un
<Sync time="2634.850"/>
donc on se place avant un. et avant un
<Sync time="2637.850"/>
ce qu'on se rend compte, c'est que v
<Sync time="2639.571"/>
n'a pas de valeur
<Sync time="2643.050"/>
mais que i, c'est pire que ça. c'est pire que euh () c'est pire qu'elle a pas de valeur, c'est qu'elle est inconnue
<Sync time="2649.080"/>
donc on notera inconnue.
<Sync time="2653.277"/>
la variable i n'est connue qu'à l'intérieur de la fonction double
<Sync time="2656.887"/>
donc comme on n'a pas commencé à évaluer
<Sync time="2659.119"/>
double,
<Sync time="2659.972"/>
la variable est inconnue.
<Sync time="2663.240"/>
ensuite, on va *chercher à évaluer l'instruction un
<Sync time="2666.522"/>
de l'algorithme.
<Sync time="2669.830"/>
pour évaluer l'instruction un de l'algorithme, il faut d'abord
<Sync time="2673.502"/>
vérifier si double existe, c'est le cas ; vérifier si elle s'applique à des
<Sync time="2677.770"/>
à des entiers, c'est le cas ;
<Sync time="2680.567"/>
et donc commencer
<Sync time="2683.970"/>
à exécuter l'instruction un.
<Sync time="2686.612"/>
donc qu'est-ce qui se passe ?
<Sync time="2691.150"/>
dans la fonction, i est connue
<Sync time="2694.360"/>
et non seulement elle est connue, mais
<Sync time="2696.285"/>
i a la valeur trois, puisque il y a une instruction implicite qui est : i reçoit trois.
<Sync time="2701.783"/>
i c'est la le paramètre formel, ça reçoit la valeur d'appel.
<Sync time="2706.688"/>
donc i vaut trois, puisque
<Sync time="2708.614"/>
il y a un passage de la valeur trois à i.
<Sync time="2712.170"/>
selon les langages que vous allez utiliser,
<Sync time="2714.670"/>
dans la fonction v 
<Event desc="tx" type="noise" extent="instantaneous"/>
 pardon v est connue ou v n'est pas connue
<Sync time="2719.170"/>
en javascript v sera connue
<Sync time="2723.221"/>
mais il est d'usage de ne pas trop f() utiliser des variables
<Sync time="2727.297"/>
de l'algorithme à l'intérieur de la fonction.
<Sync time="2729.550"/>
donc nous on considérera qu'elle n'est pas connue
<Sync time="2734.086"/>
ben la suite, c'est on fait le calcul :
<Sync time="2736.340"/>
après a, i vaut six
<Sync time="2739.451"/>
v est toujours connue ou inconnue
<Sync time="2745.198"/>
et ensuite on exécute l'instruction b qui va consister à renvoyer la valeur
<Sync time="2750.480"/>
six à la variable v. donc il y a un passage de retour
<Sync time="2755.520"/>
de six à l'expression appelante.
<Sync time="2758.330"/>
donc l'expression appelante, c'est v reçoit double euh
<Sync time="2761.72"/>
de trois.
<Sync time="2763.430"/>
donc après cette instruction
<Sync time="2766.600"/>
b
<Sync time="2768.014"/>
on est a() en mesure de terminer l'instruction un de l'algorithme
<Sync time="2773.744"/>
et de passer la valeur six à la variable v.
<Sync time="2777.900"/>
après cette étape,
<Sync time="2781.050"/>
on n'est plus dans la fonction, donc i est oubliée.
<Sync time="2785.410"/>
elle redevient inconnue,
<Sync time="2791.643"/>
voilà.
<Sync time="2794.359"/>
donc pourquoi on a 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 écrit des fon() pourquoi on a écrit des fonctions ?
<Sync time="2799.670"/>
pour avoir un problème qui se décompose en tout petits modules élémentaires
<Sync time="2803.800"/>
et pour rendre lisible
<Sync time="2806.450"/>
le programme.
<Sync time="2807.670"/>
donc notez juste modularité
<Sync time="2810.420"/>
il y a quatre ou cinq transparents comme ça, donc mo() no() notez juste modularité.
<Sync time="2817.030"/>
notez juste maintenabilité ;
<Sync time="2820.916"/>
qu'est-ce que ça veut dire ?
<Sync time="2822.749"/>
ça veut dire que si j'ai le même code
<Sync time="2825.444"/>
répété plusieurs fois dans l'algorithme, et que je n'ai pas () que j'ai décidé que ça valait pas la peine de d'en faire une fonction,
<Sync time="2833.030"/>
alors si je me rends compte six mois plus tard que j'avais un bug
<Sync time="2836.100"/>
dans cette partie du code,
<Sync time="2838.594"/>
je dois modifier le bug à tous les endroits où je l'ai écrit.
<Sync time="2842.688"/>
si
<Sync time="2843.799"/>
j'avais décidé d'écrire une fonction,
<Sync time="2846.196"/>
je me rends compte qu'il y a un bug dans la fonction, j'ai qu'un seul endroit à à corriger.
<Sync time="2850.290"/>
donc
<Sync time="2851.120"/>
s()
<Sync time="2852.021"/>
avoir euh un maximum de fonctions, ça rend les codes
<Sync time="2855.320"/>
plus facile à maintenir
<Sync time="2857.040"/>
en cas de de bug.
<Sync time="2865.560"/>
si on écrit des fonctions aussi, c'est pour euh pouvoir réutiliser
<Sync time="2869.509"/>
six mois plus tard l()
<Sync time="2871.205"/>
le résultat d'un calcul.
<Sync time="2873.973"/>
donc ça permet () on () notamment on sera en () a() en mesure de construire des bibliothèques de fonctions.
<Sync time="2879.300"/>
c'est pas ce qu'on va apprendre ce semestre, mais euh c'est très facile à faire.
<Sync time="2883.871"/>
donc partager une portion de programme avec d'autres algorithmes ou avec d'autres camarades
<Sync time="2888.920"/>

<Event desc="pi" type="pronounce" extent="instantaneous"/>

<Sync time="2891.534"/>
donc euh
<Sync time="2893.457"/>
prenons un exemple
<Sync time="2896.480"/>
tout à l'heure, je vous ai dit que dès qu'on avait deux boucles imbriquées, ça valait la peine de faire une fonction. bah là on est
<Sync time="2901.782"/>
la fonction qu'on va devoir écrire, c'est celle-là :
<Sync time="2905.690"/>
alors on va la retrouver ici.
<Sync time="2907.308"/>
le but ça va être de tracer
<Sync time="2909.559"/>
cette flèche avec des caractères.
<Sync time="2912.950"/>
et si on regarde ce que c'est que cette flèche,
<Sync time="2916.870"/>
elle est composée de cinq espaces une étoile, puis de quatre espaces trois étoiles, et cetera et cetera
<Sync time="2923.081"/>
ça c'est le haut de la flèche, et puis pour le bas de la flèche
<Sync time="2925.923"/>
il y a une répétition de
<Sync time="2927.929"/>
quatre espaces et trois étoiles.
<Sync time="2933.810"/>
donc ce qui serait vraiment bien, c'est d'avoir une fonction qui répète
<Sync time="2938.867"/>
un certain nombre de caractères ;
<Sync time="2941.380"/>
qui accumule
<Sync time="2943.099"/>
n fois le même caractère.
<Sync time="2947.050"/>
cette fonction-là, on va l'écrire
<Sync time="2949.379"/>
et on va l'appeler répéter.
<Sync time="2951.695"/>
donc typiquement, c'est cette fonction-là
<Sync time="2954.199"/>
qu'on aurait aimé écrire tout à l'heure,
<Sync time="2956.854"/>
qui prend deux paramètres :
<Sync time="2958.510"/>
un nombre de répétitions et un caractère
<Sync time="2961.477"/>
et qui va () finalement si vous regardez bien, c'est un accumulateur qu'on a programmé là,
<Sync time="2966.310"/>
un accumulateur de chaînes de caractères.
<Sync time="2971.222"/>

<Event desc="pi" type="pronounce" extent="instantaneous"/>

<Sync time="2972.369"/>
pourquoi c'est bien de s'être fatigué 
<Event desc="tx" type="noise" extent="instantaneous"/>
 à définir cette fonction une fois pour toutes ?
<Sync time="2978.497"/>
ben tout simplement parce que quand on va vouloir écrire la flèche,
<Sync time="2983.880"/>
on va l'utiliser pas mal, cette fonction répéter,
<Sync time="2987.350"/>
puisqu'on a des répétitions de d'espaces
<Sync time="2990.650"/>
et d'étoiles pour le haut, et on a des répétitions d'espaces et d'étoiles pour le bas
<Sync time="2995.186"/>
donc ce programme-là permet de dessiner la flèche.
<Sync time="3006.618"/>
vous l'aurez en exemple euh à tester
<Sync time="3010.690"/>
voilà, donc qu'est-ce qu'on voit ? on voit qu'on a défini répéter une seule fois
<Sync time="3015.950"/>
si on *veut *lui si on veut lui f() donner des fonctionnalités supplémentaires,
<Sync time="3020.543"/>
c'est pas compliqué : il suffira de les ajouter.
<Sync time="3023.768"/>
par contre, on l'a utilisé quatre fois
<Sync time="3026.834"/>
quatre fois pour dessiner la flèche, et si on avait voulu faire le triangle,
<Sync time="3031.481"/>
de l'exemple précédent, on l'aurait utilisé une fois de plus.
<Sync time="3035.760"/>
donc c'est important de bien penser que des fonctions, on peut les réutiliser.
<Sync time="3041.120"/>
voilà, et puis on on é() on doit écrire des fonctions parce que c'est plus facile de se partager des portions de de code
<Sync time="3051.100"/>
voilà, se partager le travail.
<Sync time="3052.977"/>
bilan
<Sync time="3054.110"/>
pour les fonctions : les avantages, c'est un avantage de réutilisabilité,
<Sync time="3058.597"/>
de généricité,
<Sync time="3060.422"/>
de lisibilité,
<Sync time="3062.382"/>
de partage
<Sync time="3063.962"/>
et de modularité.
<Sync time="3066.143"/>
*donc petits modules pour rendre le
<Sync time="3068.989"/>
la le travail plus facile à écrire
<Sync time="3105.282"/>
c'est bon ?
<Sync time="3107.874"/>
bon
<Sync time="3110.590"/>
il nous reste deux grosses par()
<Sync time="3112.440"/>
deux grosses parties dans ce dans ce cours euh
<Sync time="3116.552"/>
dans cette quatrième partie du cours.
<Sync time="3120.810"/>
la première chose donc on va parler, c'est la portée des variables
<Sync time="3125.880"/>
donc je vous ai d() je vous ai dit : il faut déclarer toutes les variables qui sont utilisées à l'intérieur de la fonction.
<Sync time="3132.580"/>
et on a vu que ces variables, elles n'étaient connues qu'à l'intérieur de la fonction.
<Sync time="3137.893"/>
par contre, il y avait un petit () une petite interrogation sur les variables de l'algorithme d'appel
<Sync time="3144.753"/>
donc là on va parler
<Sync time="3146.730"/>
de ce qu'on appelle euh la portée des variables.
<Sync time="3152.571"/>
donc ce qu'on a vu, c'est que les variables définies à l'intérieur de la fonction sont pas accessibles de l'extérieur
<Sync time="3158.030"/>
on parle de variables locales,
<Sync time="3160.253"/>
locales à la fonction.
<Sync time="3163.290"/>
par contre selon les langages, les variables de l'algorithme peuvent être accessibles à l'intérieur de la fonction
<Sync time="3170.416"/>
je dirais même : tous les langages
<Sync time="3173.347"/>
définissent un processus plus ou moins simple
<Sync time="3176.190"/>
pour accéder aux variables globales.
<Sync time="3178.927"/>
en javascript, c'est simple : il y a rien à faire.
<Sync time="3182.171"/>
dans d'autres langages, il faut déclarer quelles sont les variables auxquelles on veut accéder,
<Sync time="3185.829"/>
voilà. donc ces variables l() les variables du programme ou de l'algorithme sont dites globales.
<Sync time="3192.583"/>
c'est important ça, parce que comme
<Sync time="3195.280"/>
les progra() comme les les bouts de code, les bouts d'al() d'algorithme peuvent être écrits par des personnes différentes
<Sync time="3202.16"/>
qui utilisent donc des variables
<Sync time="3204.805"/>
qui peuvent avoir le même nom
<Sync time="3206.940"/>
là, i pour un indice de boucle, c'est classique ;
<Sync time="3212.550"/>
donc si on met une boucle
<Sync time="3214.550"/>
indicée par i
<Sync time="3217.700"/>
à l'intérieur d'une boucle indicée par i, vous sa() v() vous savez bien que ça pose problème ;
<Sync time="3222.360"/>
il faudrait deux noms différents.
<Sync time="3225.060"/>
qu'est-ce qui se passe quand la
<Sync time="3227.231"/>
les deux i sont dans une euh vari() dans une euh fonction ?
<Sync time="3230.2"/>
ben là, ça pose moins de problèmes
<Sync time="3232.526"/>
et on va prendre un exemple :
<Sync time="3236.270"/>
l'exemple, c'est l'exemple de la flèche
<Sync time="3240.110"/>
donc j'ai la fonction répéter
<Sync time="3243.970"/>
qui fait () qui utilise la variable i
<Sync time="3247.080"/>
de type entier à l'intérieur, donc elle est déclarée à l'intérieur de la fonction
<Sync time="3251.240"/>
et elle est connue à l'intérieur de la fonction.
<Sync time="3255.100"/>
manque de chance :
<Sync time="3256.517"/>
c'est quelqu'un d'autre qu'a écrit
<Sync time="3258.731"/>
l'algorithme
<Sync time="3260.063"/>
et lui aussi utilise la variable i
<Sync time="3262.151"/>
nommée i ;
<Sync time="3264.369"/>
il y a un conflit, là.
<Sync time="3266.770"/>
comme on fait pour résoudre le conflit ?
<Sync time="3272.070"/>
ben ça se passe comme ça dans l'historique d'exécution :
<Sync time="3276.303"/>
il y a deux cases mémoire associées à i finalement
<Sync time="3281.029"/>
et dans un cas, l'association entre le i
<Sync time="3284.162"/>
et la case mémoire sera une association avec la case mémoire globale, et dans l'autre cas ce sera une association avec la case mémoire locale.
<Sync time="3292.281"/>
bah si on regarde bien ce qui se passe : avant d'exécuter l'instruction
<Sync time="3296.406"/>
a,
<Sync time="3298.550"/>
i a pour valeur
<Sync time="3301.140"/>
i, c'est la variable globale
<Sync time="3303.331"/>
donc i a pour valeur un.
<Sync time="3307.050"/>
*donc chaîne un et chaîne deux sont pas encore évaluées
<Sync time="3309.873"/>
résultat n'est pas connu
<Sync time="3313.870"/>
résultat ne commence à être connu que quand on rentre dans la fonction,
<Sync time="3318.880"/>
donc après l'instruction un de la fonction
<Sync time="3321.540"/>
res vaut chaîne de caractères vide, après l'instruction deux on a répété un espace
<Sync time="3326.661"/>
un certain nombre de fois
<Sync time="3328.870"/>
mais si vous regardez bien le i
<Sync time="3332.256"/>
qui a été déclaré,
<Sync time="3334.019"/>
il a changé.
<Sync time="3336.761"/>
il a changé parce que s() ça fait plus référence au i global, mais ça fait référence au i de la fonction.
<Sync time="3349.640"/>
si vous ne faites pas attention
<Sync time="3352.060"/>
en javascript 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 si vous ne déclarez pas le i comme une variable à l'intérieur de la fonction, il prendra la variable globale.
<Sync time="3358.716"/>
la seule différence que vous allez avoir,
<Sync time="3361.066"/>
c'est qu'à la sortie
<Sync time="3364.094"/>
vous aurez perdu
<Sync time="3367.367"/>
la valeur de i.
<Sync time="3369.020"/>
au lieu d'avoir un à la dernière ligne comme valeur de i, vous auriez vous aurez zéro
<Sync time="3373.616"/>
puisque là il y a plus de variable, il prend s() il prend la variable globale
<Sync time="3376.875"/>
et il utilise la variable globale.
<Sync time="3378.514"/>
donc ça c'est une grosse source de bugs, et de bugs en ce sens euh qu'on fait des boucles infinies quand on fait ça.
<Sync time="3383.265"/>
*enfin bref
<Sync time="3384.577"/>
retenez bien ça
<Sync time="3386.790"/>
la portée des variables peut être soit locale, soit globale
<Sync time="3393.800"/>
un, deux, trois
<Sync time="3395.092"/>
le sixième rang
<Sync time="3401.028"/>
voilà
<Sync time="3402.564"/>
ça, c'était le premier gros point : faire attention à la portée des variables.
<Sync time="3406.404"/>
le deuxième gros point,
<Sync time="3409.640"/>
c'est ce qui va s'appeler la récursivité.
<Sync time="3413.540"/>
alors c'est très proche de ce que vous allez appeler euh
<Sync time="3416.946"/>
suite définie par récurrence en maths.
<Sync time="3423.954"/>
on va définir ça
<Sync time="3428.740"/>
comme ça
<Sync time="3431.172"/>
quand on écr()
<Sync time="3432.337"/>
quand on écrit le corps de la fonction,
<Sync time="3435.300"/>
il y a plein de règles d'écriture
<Sync time="3438.930"/>
mais à aucun moment j'ai interdit
<Sync time="3441.163"/>
d'utiliser la fonction
<Sync time="3443.264"/>
à l'intérieur
<Sync time="3445.100"/>
des instructions qui sont () qui définissent le corps de la fonction.
<Sync time="3448.240"/>
donc on a le droit *de faire ap() un appel à la fonction
<Sync time="3450.960"/>
au moment où on décrit le corps de la fonction.
<Sync time="3454.540"/>
cet appel, ça s'appelle un un appel récursif.
<Sync time="3458.480"/>
donc l'analogie en maths, c'est les suites qu'on définit par récurrence
<Sync time="3462.230"/>
où dans la définition de u n,
<Sync time="3465.040"/>
on voit apparaître
<Sync time="3467.780"/>
u n moins un, donc en gros la fonction u de n, on l'applique
<Sync time="3472.570"/>
auss() dans la définition du calcul
<Sync time="3475.340"/>
on fait un appel à u de ()
<Sync time="3477.273"/>
du paramètre n moins un.
<Sync time="3479.787"/>
et ça, vous vous en sortez très bien en maths
<Sync time="3481.834"/>
à partir du moment où vous avez le cas de base.
<Sync time="3485.418"/>
mais en informatique
<Sync time="3486.873"/>
ça marche aussi, ça.
<Sync time="3488.740"/>
on peut faire ce genre de déclarations où on fait des appels à la fonction
<Sync time="3492.832"/>
a l'intérieur de
<Sync time="3495.456"/>
du corps de la fonction.
<Sync time="3505.950"/>
c'est un autre moyen de faire des boucles.
<Sync time="3510.598"/>
il y a certains langages informatiques qui n'ont pas de boucles
<Sync time="3517.570"/>
et qui sont aussi puissants que les langages informatiques qui ont des boucles.
<Sync time="3521.691"/>
ce que je veux dire maintenant, c'est qu'il y a une équivalence d'expressivité totale
<Sync time="3525.870"/>
entre euh un langage qui a une conditionnelle et les fonctions récursives
<Sync time="3530.608"/>
et un langage qui a les conditionnelles et
<Sync time="3532.82"/>
un type de boucle.
<Sync time="3534.325"/>
on peut faire exactement la même chose
<Sync time="3537.073"/>
à partir du moment où on a
<Sync time="3539.610"/>
la conditionnelle et soit une () les fonctions, soit une boucle.
<Sync time="3544.314"/>
quand on a le le tout, c'est encore mieux évidemment
<Sync time="3546.746"/>
et on a le tout dans beaucoup de langages.
<Sync time="3551.061"/>
bon
<Sync time="3553.258"/>
en informatique, la fonction factorielle elle s'écrira comme ça :
<Sync time="3556.878"/>
donc fonction factorielle
<Sync time="3558.494"/>
elle prend en paramètre un entier qu'on va appeler n,
<Sync time="3561.342"/>
elle renverra un entier
<Sync time="3567.834"/>
donc elle renverra un entier
<Sync time="3569.972"/>
et il y aura deux cas :
<Sync time="3572.860"/>
s() la caractéristique des fonctions récursives, c'est qu'elles commenceront souvent par un si
<Sync time="3577.094"/>
pour tester le cas de base.
<Sync time="3579.040"/>
donc si n est égal à zéro, alors re() résultat ça vaut un, donc u de zéro ça vaut un
<Sync time="3584.682"/>
sinon, u de n ça vaut n fois factorielle n moins un.
<Sync time="3588.824"/>
et ces
<Sync time="3590.057"/>
ces écritures récursives sont en général
<Sync time="3592.190"/>
très intuitives
<Sync time="3593.800"/>
et calquées sur le calcul mathématique récursif.
<Sync time="3596.869"/>
donc euh en général, on on aime bien les écrire
<Sync time="3599.431"/>
parce qu'elles sont faciles à écrire.
<Sync time="3601.213"/>
donc qu'est-ce qu'on retrouve, et quel est le vocabulaire qu'on retrouve ? c'est la condition d'arrêt
<Sync time="3605.298"/>
on s'arrête quand n est égal à zéro.
<Sync time="3607.042"/>
et ça, elle est importante : c'est important qu'on arrive à la condition d'arrêt
<Sync time="3610.730"/>
parce que si on n'y arrive pas, ça fait une boucle infinie ;
<Sync time="3613.443"/>
c'est le même problème que les tant que.
<Sync time="3618.517"/>
qu'est-ce qu'on retrouve ?
<Sync time="3619.820"/>
c'est la valeur d'arrêt.
<Sync time="3621.910"/>
u de zéro est égal à un,
<Sync time="3623.970"/>
et il faut le préciser.
<Sync time="3626.009"/>
vous savez très bien que quand vous définissez une suite par récurrence, si vous avez pas la valeur initiale, votre suite par récurrence elle tombe à l'eau.
<Sync time="3632.948"/>
ben là c'est pareil : si vous n'avez pas cette valeur,
<Sync time="3635.509"/>
ça tombe à l'eau.
<Sync time="3639.350"/>
et puis on retrouve les appels récursifs, donc qu'est-ce que c'est qu'un appel récursif ? c'est : on appelle la fonction avec un autre paramètre.
<Sync time="3646.889"/>
si on fait pas attention, on se met à faire des boucles infinies.
<Sync time="3650.750"/>
donc il faut vraiment faire attention à ce que ici, le paramètre
<Sync time="3653.737"/>
décroisse, donc ten() arrive un jour à n est égal à zéro.
<Sync time="3661.240"/>
donc ça c'est vraiment le schéma des appels récursifs classiques.
<Sync time="3666.050"/>
donc les dangers, c'est ce que je viens de vous dire,
<Sync time="3668.643"/>
c'est d'avoir une condition d'arrêt qui ne soit jamais satisfaite.
<Sync time="3674.660"/>
pour euh être sûr de ça, il faut au minimum que le ()
<Sync time="3678.540"/>
dans l'appel récursif on modifie le paramètre d'appel
<Sync time="3681.646"/>
on appelle la récurrence en n moins un,
<Sync time="3683.808"/>
et pas en n.
<Sync time="3688.370"/>
et puis il y a () là, c'est un autre problème qui est plus un problème informatique, c'est que les appels récursifs
<Sync time="3695.060"/>
suspendent l'exécution d'une é() d'une instruction
<Sync time="3698.700"/>
donc 
<Event desc="pi" type="pronounce" extent="instantaneous"/>

<Sync time="3699.89"/>
autrement dit, quand je fais euh
<Sync time="3701.400"/>
résultat reçoit n fois factorielle n moins un, je suis obligé d'attendre le rés() le calcul de factorielle n moins un
<Sync time="3708.744"/>
pour terminer l'exécution de l'instruction.
<Sync time="3712.490"/>
donc euh
<Sync time="3713.440"/>
le fait d'attendre le résultat, ça ça se met en tas sur la mémoire s()
<Sync time="3718.281"/>
donc la mémoire se met à se remplir
<Sync time="3720.189"/>
par ces instructions non exécutées
<Sync time="3722.750"/>
et ça peut saturer, la mémoire.
<Sync time="3724.899"/>
*alors on va voir on va voir pourquoi
<Sync time="3732.707"/>
on va voir pourquoi sur cet exemple :
<Sync time="3735.890"/>
je cherche à calculer factorielle de cinq
<Sync time="3739.760"/>
donc ce que je dois faire comme calcul, c'est renvoyer cinq fois
<Sync time="3743.59"/>
factorielle de quatre ;
<Sync time="3745.860"/>
factorielle de quatre que je ne connais pas
<Sync time="3748.590"/>
donc avant de pouvoir faire ce calcul,
<Sync time="3751.640"/>
je l'entasse en mémoire
<Sync time="3753.569"/>
et j'essaye de calculer factorielle de quatre. factorielle de quatre, c'est trois f() c'est quatre fois factorielle de trois
<Sync time="3759.153"/>
factorielle de trois que je ne connais pas
<Sync time="3761.377"/>
donc pour pouvoir renvoyer ce résultat-là, je le mets en tas.
<Sync time="3765.392"/>
il y a trop de bruit, là !
<Sync time="3770.95"/>
quelle heure il est ?
<Sync time="3776.266"/>
on fait pas de bruit quinze minutes avant la fin du cours, hein.
<Sync time="3779.440"/>
on range pas quinze minutes avant la fin
<Sync time="3782.510"/>
c'est c'est vraiment pas poli, c'est vraiment pas poli pour vos camarades.
<Sync time="3789.623"/>
donc on cherche à entasser factorielle de trois
<Sync time="3792.690"/>
euh on entasse factorielle de () le calcul de factorielle de trois, pardon
<Sync time="3796.922"/>
on cherche à calculer factorielle de deux, et puis vous connaissez la suite :
<Sync time="3799.935"/>
on entasse, on entasse, on entasse
<Sync time="3802.201"/>
jusqu'à arriver au calcul de factorielle zéro. et factorielle zéro, c'est le cas de base donc ça on connaît la valeur de factorielle zéro
<Sync time="3808.713"/>
on est capable de renvoyer l() un comme résultat.
<Sync time="3812.680"/>
et c'est à ce moment-là
<Sync time="3814.935"/>
qu'on dépile
<Sync time="3819.280"/>
donc on dépile factorielle de un, puis factorielle de deux puis factorielle de trois puis factorielle de quatre puis factorielle de cinq
<Sync time="3825.108"/>
et enfin on
<Sync time="3826.045"/>
on arrive au calcul.
<Sync time="3827.181"/>
a() on arrive au résultat du calcul.
<Sync time="3832.223"/>
autrement dit,
<Sync time="3836.146"/>
on peut se mettre à à saturer assez vite la mémoire dès qu'on cherche à calculer des factorielles de cent, voire des factorielles un peu plus compliquées que des factorielles de cent ;
<Sync time="3844.444"/>
on verra comment on fait
<Sync time="3846.11"/>
un peu plus tard pour éviter ces cas-là.
<Sync time="3850.158"/>
euh zut !
<Sync time="3853.62"/>
voilà
<Sync time="3854.576"/>
pourquoi je vous parle de ça ?
<Sync time="3857.974"/>
ben tout simplement parce que
<Sync time="3860.200"/>
il y a certains certaines résolutions de problèmes
<Sync time="3864.440"/>
qu'on sait plus facilement écrire sous forme récursive.
<Sync time="3868.913"/>
en voilà un exemple :
<Sync time="3874.770"/>
alors l'exemple, c'est s() c'est sur le jeu des tours de hanoï
<Sync time="3879.260"/>
qui connaît
<Sync time="3880.495"/>
l() le jeu des tours de hanoï ? beaucoup ? ouais
<Sync time="3884.550"/>
le but de ce jeu, c'est que vous avez un tas
<Sync time="3887.402"/>
de disques
<Sync time="3889.370"/>
qu'il faut réussir à déplacer disque par disque d'une () de la première tige à la troisième tige, en utilisant une tige au milieu de tampon.
<Sync time="3898.850"/>
avec comme règle que on n'a pas le droit de superposer un disque plus grand s()
<Sync time="3903.050"/>
on n'a pas le droit de mettre un disque euh plus grand qu'un () au-dessus d'un disque petit.
<Sync time="3906.730"/>
voilà
<Sync time="3909.530"/>
résoudre le problème, c'est donner la suite de mouvements qui permettent de déplacer l'ensemble des
<Sync time="3915.189"/>
l'ensemble des disques.
<Sync time="3918.140"/>
voilà, donc ça c'est la règle
<Sync time="3919.883"/>
et on déplace un disque à la fois.
<Sync time="3925.590"/>
eh ben je je dois vous montrer ça
<Sync time="3950.880"/>
voilà, si on a cinq tiges
<Sync time="3952.990"/>
la suite de mouvements à faire, c'est ça :
<Sync time="3957.052"/>

<Event desc="rire en fond" type="noise" extent="begin"/>
vous avez vu ?
<Event desc="rire en fond" type="noise" extent="end"/>

<Sync time="3958.195"/>

<Event desc="rire en fond" type="noise" extent="instantaneous"/>

<Sync time="3962.553"/>
allez, si on en met s()
<Sync time="3964.570"/>
si on en met six,
<Sync time="3966.82"/>
c'est ça
<Sync time="3967.590"/>
et vous regardez bien, il y a qu'un disque qui est bougé à chaque fois.
<Sync time="3970.137"/>
mais six mou() *enfin six disques, ça commence à faire beaucoup de mouvements.
<Sync time="3976.431"/>
donc
<Sync time="3977.394"/>
ce qui prouve que on est capable de le programmer ;
<Sync time="3983.084"/>
on est capable de
<Sync time="3984.665"/>
d'écrire un problème qui résout ce
<Sync time="3987.353"/>
qui () d'écrire un algorithme qui résout ce problème
<Sync time="3989.746"/>
de déplacer les les disques.
<Sync time="3996.116"/>
comment on fait ?
<Sync time="4000.010"/>
comment vous feriez
<Sync time="4001.094"/>
sans la récursivité ?
<Sync time="4002.878"/>
ben vous réfléchiriez à comment vous faites pour euh déplacer le premier disque
<Sync time="4007.512"/>
bon la bonne idée, c'est le mettre au milieu.
<Sync time="4011.179"/>
ensuite, vous *prenez vous prenez le deuxième disque, vous le mettez à la fin
<Sync time="4015.337"/>
et puis euh le premier du milieu, vous le mettez à la fin
<Sync time="4019.335"/>
et puis et puis et puis
<Sync time="4021.524"/>
là on est coincé parce que il y a plein de cas particuliers
<Sync time="4024.741"/>
à gérer.
<Sync time="4026.685"/>
donc c'est très difficile d'imaginer en séquentiel
<Sync time="4030.526"/>
la manière de résoudre le problème.
<Sync time="4033.600"/>
par contre en récursif,
<Sync time="4035.900"/>
c'est facile.
<Sync time="4038.065"/>
pour déplacer trois disques,
<Sync time="4040.180"/>
vous allez imp() vous allez avoir l'impression que je triche,
<Sync time="4043.120"/>
mais pour déplacer trois disques
<Sync time="4045.067"/>
il suffit de prendre les deux premiers,
<Sync time="4046.848"/>
de les mettre au milieu ;
<Sync time="4048.480"/>
le troisième disque est libre, je le mets à la fin
<Sync time="4050.939"/>
et je prends les deux disques du milieu et je les mets
<Sync time="4053.070"/>
sur le sur la fin.
<Sync time="4055.623"/>
autrement dit
<Sync time="4064.980"/>
autrement dit, on va voir le problème comme ça :
<Sync time="4067.699"/>
imaginons que j'ai huit cylindres,
<Sync time="4070.160"/>
huit disques, comment je fais pour les déplacer ?
<Sync time="4075.090"/>
ben je prends les sept du dessus, je les mets au milieu
<Sync time="4077.830"/>
je déplace celui qui en bas, je le mets à la fin et je reprends les sept du milieu et je les mets au bout.
<Sync time="4084.453"/>
pardon ?
<Sync time="4087.040"/>
bonne remarque : on peut faire qu'un disque à la fois.
<Sync time="4090.100"/>
mais là je vous ai décrit comment je fais pour en déplacer huit.
<Sync time="4094.115"/>
je sais en déplacer huit
<Sync time="4096.375"/>
si je sais en déplacer sept.
<Sync time="4099.450"/>
si je suis capable de déplacer sept euh cylindres d'une tige à l'autre
<Sync time="4104.421"/>
je sais en déplacer huit.
<Sync time="4106.750"/>
bon, ben pour en déplacer sept
<Sync time="4108.348"/>
j'en prends six
<Sync time="4109.535"/>
je les mets au milieu
<Sync time="4110.847"/>
je prends celui qui est libre, je le mets à la fin, et je prends les sept du milieu, je les mets
<Sync time="4115.183"/>
à la fin.
<Sync time="4117.480"/>

<Event desc="pi" type="pronounce" extent="instantaneous"/>
 je sais en déplacer sept si je sais en déplacer six.
<Sync time="4121.101"/>
donc vous vous doutez bien que si je sais en déplacer cinq, je vais savoir en déplacer six ;
<Sync time="4124.913"/>
si je sais en déplacer quatre,
<Sync time="4126.541"/>
je saurai en déplacer cinq, et cetera et cetera
<Sync time="4129.101"/>
la seule question que qui va se poser, c'est : est-ce que je suis capable d'en déplacer
<Sync time="4132.845"/>
un ?
<Sync time="4134.610"/>
et pour en déplacer un, c'est facile : je le prends, je le mets à la fin, et ça c'est un mouvement autorisé.
<Sync time="4141.096"/>
donc mine de rien, je vous ai donné une manière d'écrire
<Sync time="4144.937"/>
de manière récursive le processus de résolution.
<Sync time="4152.660"/>
alors ça, c'est une description
<Sync time="4155.021"/>
de ce que j'ai fait :
<Sync time="4156.188"/>
je prends le grand bloc, je le mets au milieu
<Sync time="4158.730"/>
le cylindre du du début, je le mets à la fin et le grand bloc du milieu, je le remets à la fin.
<Sync time="4166.200"/>
donc ce qui va compter, ça va être de numéroter les
<Sync time="4169.293"/>
les tiges début, milieu, fin
<Sync time="4172.075"/>
et l'algorithme de résolution,
<Sync time="4174.925"/>
il va s'écrit comme ça
<Sync time="4177.510"/>
*alors en fait je vous ai dit : si je sais en déplacer un,
<Sync time="4181.270"/>
ça marche
<Sync time="4182.479"/>
mais ça marche même si je sais pas en déplacer
<Sync time="4185.680"/>
le cas de base en fait, c'est pas n égale un mais c'est n égal à zéro.
<Sync time="4189.814"/>
si j() pour déplacer zéro cylindre, je fais rien
<Sync time="4194.600"/>
donc
<Sync time="4195.441"/>
l'algorithme s'écrit comme ça. pour déplacer n cylindre
<Sync time="4200.594"/>
j'en déplace n moins un
<Sync time="4202.960"/>
du début, je les amène au milieu en utilisant la tige de fin comme tampon.
<Sync time="4208.350"/>
ensuite, je fais un vrai déplacement autorisé que j'affiche
<Sync time="4212.970"/>
du cylindre numéro n de début à fin
<Sync time="4217.780"/>
et je fais un autre appel récursif
<Sync time="4220.220"/>
pour redéplacer les n moins un cylindre que j'avais mis au milieu
<Sync time="4224.156"/>
pour les mettre à la fin.
<Sync time="4225.179"/>
donc 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 je les envoie du milieu à la fin en utilisant début comme tige tampon
<Sync time="4230.810"/>
et c'est cet algorithme-là que j'ai utilisé pour résoudre le problème.
<Sync time="4237.250"/>
donc je vous ai dit : un des problèmes
<Sync time="4239.110"/>
majeur de la récursivité, c'est le () un problème de saturation de la mémoire.
<Sync time="4244.279"/>
et il existe des techniques
<Sync time="4247.217"/>
qui permettent de n() de moins saturer la mémoire, voire de ne pas la saturer. on appelle ça
<Sync time="4251.336"/>
écrire les fonctions
<Sync time="4252.820"/>
sous la forme d'une récursion terminale.
<Sync time="4255.914"/>
ce qui sature la mémoire, c'est qu'il y a une é() une instruction qui est en cours d'exécution, qui n'a pas terminé son exécution.
<Sync time="4262.420"/>
écrire sous forme de récursion terminale, c'est éviter qu'il y ait des instructions qui ne soient pas terminées
<Sync time="4267.411"/>
au moment de l'appel récursif.
<Sync time="4272.406"/>
théorème
<Sync time="4273.810"/>
m() mathématique :
<Sync time="4277.132"/>
on peut toujours passer d'une fonction qui est définie
<Sync time="4280.970"/>
avec des appels récursifs qui s'entassent, donc qu'on appellera non terminale
<Sync time="4285.630"/>
en une fonction qui est définie sans récursivit() sans appels récursifs qui s'entassent ; on parlera de récursion terminale.
<Sync time="4294.730"/>
deuxième théorème mathématique, ça j'en ai pas parlé :
<Sync time="4299.498"/>
c'est qu'on peut prouver aussi que les z()
<Sync time="4302.040"/>
vu qu'on peut se passer des fonctions et qu'on a la même expressivité,
<Sync time="4307.318"/>
bah en fait la récursivité n'est pas indispensable en informatique.
<Sync time="4311.425"/>
on peut toujours
<Sync time="4312.326"/>
passer d'une fonction définie récursivement à une fonction qui n'est pas définie récursivement.
<Sync time="4316.843"/>
c'est un théorème mathématique, c'est une règle absolue.
<Sync time="4321.050"/>
des fois c'est pas facile : pour les tours de hanoï, c'est vraiment pas facile.
<Sync time="4326.074"/>
bon
<Sync time="4329.620"/>
qu'est-ce que ça donne,
<Sync time="4331.013"/>
une fonction écrite sous forme récursive terminale ?
<Sync time="4335.930"/>
bah là vous avez sous les yeux
<Sync time="4338.940"/>
la fonction factorielle
<Sync time="4340.637"/>
écrite
<Sync time="4343.160"/>
sous forme non récursive,
<Sync time="4347.140"/>
une fonction factorielle qu'on a déjà vue ; finalement c'est un accumulateur de produits.
<Sync time="4353.800"/>
la même fonction telle que je vous l'ai donnée tout à l'heure, avec l'appel récursif
<Sync time="4358.966"/>
et le cas de base, alors c'est () elle est écrite un tout petit peu différemment
<Sync time="4362.490"/>
au niveau de l'appel récursif, mais c'est pareil.
<Sync time="4366.330"/>
et là il y a un n()
<Sync time="4367.930"/>
un entassement de l'instruction res() res reçoit factorielle récursif de n moins un fois n.
<Sync time="4378.799"/>
dans la forme récursive
<Sync time="4380.621"/>
non terminale
<Sync time="4382.590"/>
si vous voyez () si vous regardez bien,
<Sync time="4384.640"/>
l'instruction qui est exécutée, c'est l'appel récursif. il y a pas () c'est pas stocké euh c'est () l'appel récursif n'est pas à l'intérieur d'une expression
<Sync time="4392.847"/>
il y a trop de bruit, là !
<Sync time="4402.650"/>
donc ce qu'on () la règle générale, c'est que pour euh passer du récursif
<Sync time="4407.750"/>
non terminal à un récursif terminal, on va ajouter un paramètre à la fonction qui va permettre de stocker le résultat,
<Sync time="4413.853"/>
et c'est la règle absolue.
<Sync time="4415.434"/>
donc bilan
<Sync time="4417.03"/>
on termine là-dessus :
<Sync time="4418.290"/>
une fonction est définie par un nom,
<Sync time="4420.553"/>
des paramètres formels, une valeur de retour.
<Sync time="4423.350"/>
il y a plein de fonctions prédéfinies ;
<Sync time="4426.860"/>
défin() déclarer une fonction,
<Sync time="4429.730"/>
ce () ça se fait dans une syntaxe qui est proche que la déclaration d'un algorithme, donc il y a rien de gross() nouveau.
<Sync time="4435.750"/>
on a parlé de portée des variables, qui peut être soit locale à la fonction, soit globale
<Sync time="4441.394"/>
et on a vu que la récursivité était particulièrement adaptée
<Sync time="4445.440"/>
pour résoudre des problèmes qui se décrivent naturellement de manière récursive.
<Sync time="4450.380"/>
donc on a vu ça aujourd'hui.
<Sync time="4452.672"/>
c'était un cours un peu lourd ;
<Sync time="4456.710"/>
je mettrai pas mal de démonstrations en ligne, donc n'hésitez pas à aller les voir
<Sync time="4465.863"/>
et on termine là-dessus.
<Background time="4468.182" type="other" level="off"/>

</Turn>
</Section>
</Episode>
</Trans>
