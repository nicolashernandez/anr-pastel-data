https://groupefmr.hypotheses.org/4097








		    src: url("https://f-origin.hypotheses.org/wp-content/cleo-commons/fonts/social-font/socicon.eot?#iefix") format("embedded-opentype"),
			 url("https://f-origin.hypotheses.org/wp-content/cleo-commons/fonts/social-font/socicon.woff") format("woff"),
			 url("https://f-origin.hypotheses.org/wp-content/cleo-commons/fonts/social-font/socicon.ttf") format("truetype"),
			 url("https://f-origin.hypotheses.org/wp-content/cleo-commons/fonts/social-font/socicon.svg#icomoonregular") format("svg");
		    font-weight: normal;
		    font-style: normal;
		}
		@media screen and (-webkit-min-device-pixel-ratio:0) {
		    @font-face {
			font-family:si;
			src: url(https://f-origin.hypotheses.org/wp-content/cleo-commons/fonts/social-font/socicon.svg) format(svg);
		    }
		}
		.entry ul.soc { overflow:hidden; margin:0; padding:0; list-style:none;}
		.soc li { display:inline-block; *display:inline; zoom:1;}
		.soc li a { font-family:si!important; font-style:normal; font-weight:400; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; -webkit-box-sizing:border-box; -moz-box-sizing:border-box; -ms-box-sizing:border-box; -o-box-sizing:border-box; box-sizing:border-box;
		    -o-transition:.1s; -ms-transition:.1s; -moz-transition:.1s; -webkit-transition:.1s; transition:.1s; -webkit-transition-property: transform;transition-property: transform; -webkit-transform: translateZ(0); transform: translateZ(0);
		    overflow:hidden; text-decoration:none; text-align:center; display:block; position: relative; z-index: 1; width: 38px;  height: 38px; line-height: 38px; font-size: 20px; -webkit-border-radius: 0px; -moz-border-radius: 0px; border-radius: 0px; margin-right: 13px; color: #ffffff; background-color: none;}
		.soc a:hover { z-index: 2; -webkit-transform: scale(1.1); transform: scale(1.1);}
		.soc-icon-last{ margin:0 !important;}
		.soc-twitter { background-color: #4da7de;}
		.soc-twitter:before { content:"\e040";}
		.soc-facebook { background-color: #3e5b98;}
		.soc-facebook:before { content:"\e041";}
		.soc-googleplus { background-color: #dd4b39;}
		.soc-googleplus:before { content:"\e042";}
		.soc-linkedin { background-color: #3371b7;}
		.soc-linkedin:before { content:"\e049";}
		

		// Share buttons
				return false;
			});
		});
		





 
    span.icon-hypotheses {
      background:url(https://f-origin.hypotheses.org/wp-content/cleo-commons/images/favicon_18x20.png);width:18px;height:20px;display:inline-block;margin-right:5px;
    }
  

				.site-header {

			/*
			 * No shorthand so the Customizer can override individual properties.
			 * @see https://core.trac.wordpress.org/ticket/31460
			 */
			background-image: url(https://groupefmr.hypotheses.org/files/2012/12/cropped-Shipping_routes.png);
			background-repeat: no-repeat;
			background-position: 50% 50%;
			-webkit-background-size: cover;
			-moz-background-size:    cover;
			-o-background-size:      cover;
			background-size:         cover;
		}

		@media screen and (min-width: 59.6875em) {
			body:before {

				/*
				 * No shorthand so the Customizer can override individual properties.
				 * @see https://core.trac.wordpress.org/ticket/31460
				 */
				background-image: url(https://groupefmr.hypotheses.org/files/2012/12/cropped-Shipping_routes.png);
				background-repeat: no-repeat;
				background-position: 100% 50%;
				-webkit-background-size: cover;
				-moz-background-size:    cover;
				-o-background-size:      cover;
				background-size:         cover;
				border-right: 0;
			}

			.site-header {
				background: transparent;
			}
		}
		









 body, html.js body {margin-top:40px;}



Aller au contenu



groupe fmr
(flux, matrices, réseaux)
Menu et widgets






Rechercher :



Catégories 
Acteurs et actrices (2)

Brèves et actualités (84)

Glossaire (49)

Lectures (16)

Lieux (8)

Mesures (10)

Outils (56)

Projets (15)


  Billets récents 

Réunion fmr sur la simulation de croissance des réseaux


Atelier d’Analyse de réseaux avec R : Exploration de réseaux dynamiques


Network Analysis 2.1 et QGIS 3.0


Le 28 mars: retour des ateliers d’analyse de réseaux avec R


Réunions fmr : Cycle sur la détection de communautés


Mots-clef
ArcgIs10
cartographie
complex networks
Convertisseur de matrices
Cours
Cytoscape
ego-network
flux
France
Gephi
graphe biparti
graphe planaire
igraph
intergraph
Mesures
mobilité
méthode de Louvain
NetworkX
Network_Analysis
open source
Pajek
partitionnement
physique
Pigale
Python
périurbain
QGIS
questionnaire fmr
R
réseau ferroviaire
réseaux complexes
réseaux sociaux
réseaux spatiaux
SENSEable City Lab
SIG
SNCF
SocioPatterns
statnet
TGV
tutoriel
Visone
visualisation
VOS clustering
VOSviewer
web


 GDR Analyse de réseaux en SHSInternational and cross-time comparisons of personal networks (Toulouse, 15-16 mai 2018) 06/04/2018École thématique Analyse de réseaux et complexité, Cargèse (Corse),  24-28 septembre 2018 04/04/2018Financements pour la SunBelt 2018 16/01/2018Appel à propositions 2018 : journées d’études pluri-disciplinaires en analyse de réseaux 16/01/2018Trajectoires et dynamiques des réseaux : approches quantitatives 28/11/2017 RES-HISTThe Connected Past à Oxford, décembre 2018Communiquer au colloque annuel HNR – analyse de réseaux en histoireUne revue centrée sur l’analyse de réseaux en histoireInitiation à l’analyse de réseaux, Nice, 3 au 8 juillet 2017 QUANTI / sciences socialesTutoriel pour de l’analyse textuelle de réseau avec linkage.fr (3/3) 03/04/2018L’analyse textuelle avec linkage, éléments de théorie (2/3) 03/04/2018Les courants de la sociologie de l’éducation? Exemple d’analyse textuelle (1/3) 03/04/2018Journée d’études « Travail, immigration, santé : perspectives quantitatives », le vendredi 4 mai 2018 à l’ENS de Lyon 26/03/2018Liens

Aviz
Collection fmr
Complex Networks
facebook – groupe fmr
GDR AR-SHS
INSNA
REDES
Réseaux sociaux










Combinaisons de graphes avec igraph 

Ayant eu récemment à me pencher sur la question délicate des jointures entre réseaux ayant des liens en communs, j’en profite pour faire un point rapide sur les fonctions du package igraph permettant ces combinaisons. Si vous ne connaissez pas ce package, voyez les billets taggés R sur ce blog. Le script utilisé est téléchargeable sur github ici-même. et, pour les personnes qui n’ont pas envie et/ou besoin de s’inscrire sur ce git, il est reproduit à la fin de ce billet.
Soit les deux graphes suivants :

g1 et g2 sont deux graphes non orientés et ont trois sommets (ACD) et deux liens en commun (pléonasme…). Toutes les fonctions commentées ici prennent des graphes de même type en entrée (orientés ou non), certaines autorisent les combinaisons de graphes différents (un orienté et un non orienté).
La première étape du script consiste à créer des attributs pour g1 et g2 : attributs du réseau, des sommets et des liens. L’objectif est de contrôler la perte éventuelle d’attributs lors des opérations effectuées. Pour mémoire, pour un graphe nommé g, la syntaxe de igraph est la suivante :
g$densite <- graph.density(g) #attribut du graphe
V(g)$degre <- degree(g) #attribut des sommets (V comme vertex)
E(g)$betw <- edge.betweenness(g) #attributs des liens (E comme edges)
La fonction graph.complementer prend un graphe en attribut et crée son complémentaire : les liens absents dans le graphe de départ sont créés, les liens présents dans le graphe de départ sont supprimés. Un paramètre booléen loops permet de décider si on souhaite ou non générer des boucles (par défaut, loops = FALSE). Les attributs du réseau et des sommets sont conservés, les attributs des liens sont perdus (ce qui semble cohérent, ces liens étant supprimés).
La fonction graph.difference prend deux graphes en entrée : seuls les liens présents dans le premier réseau et non dans le deuxième sont conservés, tous les attributs du premier réseau sont gardés. On peut également utiliser l’opérateur %m% (comme minus) : écrire graph.difference(g1,g2) ou g1%m%g2 est donc équivalent. La figure ci-dessous permet de comparer les résultats obtenus : le lien AD présent dans g1 et g2 donc les opérations g1-g2 et g2-g1 entraînent sa disparition.

La fonction (non utilisée dans le script) graph.disjoint.union permet de joindre deux graphes dont les sommets sont distincts.
La fonction graph.intersection (ou %s%) prend deux graphes en entrée et un paramètre keep.all.vertices (TRUE par défaut) permet de choisir entre garder l’ensemble des sommets et les seuls sommets connectés dans le graphe produit. Les attributs sont tous conservés. Enfin, la fonction graph.union prend deux graphes en entrée : tout lien présent dans un moins un graphe
sera dans le graphe produit – sans création de liens multiples – et tous les attributs seront conservés.
Script complet
library(igraph)
#création des deux graphes
d1 <- rbind(c(« A », »B »),c(« A », »C »), c(« B », »C »), c(« A », »D »), c(« D », »E »))
d2 <- rbind(c(« A », »F »), c(« A », »D »), c(« A », »C »), c(« C », »I »))
g1 <- graph.data.frame(d1, directed = FALSE)
g2 <- graph.data.frame(d2, directed = FALSE)
#visualisation
par(mfrow = c(1,2))
plot(g1, main = « g1 »)
plot(g2, main = « g2 »)
dev.off()
#3 points communs (ACD) et deux liens communs (AD et AC)
#ajout d’attributs : degré des sommets
V(g1)$degree <-  degree(g1)
V(g2)$degree <- degree(g2)
#ajout d’attributs aux liens (intermédiarité)
E(g1)$between <- edge.betweenness(g1)
E(g2)$between <- edge.betweenness(g2)
#ajout d’attributs au réseau : densité
g1$densite <- graph.density(g1)
g2$densite <- graph.density(g2)
#fonction graph.complementer
#crée un graphe avec les liens absents du graphe de départ
#les liens présents au départ sont eux supprimés
compg1 <- graph.complementer(g1, loops = FALSE)
plot(compg1)
#les attributs des sommets et du graphe sont conservés
#attributs des liens sont perdus
V(compg1)$degree
compg1
#fonction graph.difference premier réseau – deuxième réseau (opérateur %m%)
#seuls les liens présents dans le premier réseau et non dans le deuxième sont conservés
#tous les attributs du premier réseau sont gardés
diffg1 <- graph.difference(g1, g2)
diffg1
diffg2 <- graph.difference(g2, g1)
#coordonnées (quasi) identiques pour faciliter la comparaison
lay <- layout.fruchterman.reingold(g1)
#lien A-D présent dans g1 et g2 donc g1-g2 et g2-g1 entrainent sa disparition
par(mfrow = c(2,2))
plot(g1, main = « g1 », layout = lay, vertex.color = « red », vertex.size = 20, vertex.label.dist =3)
plot(g2, main = « g2 », layout = lay, vertex.color = « red », vertex.size = 20, vertex.label.dist =3)
plot(diffg1, main = « graph.difference(g1, g2) », layout = lay, vertex.color = « red », vertex.size = 20, vertex.label.dist =3)
plot(diffg2, main = « graph.difference(g2, g1) », layout = lay, vertex.color = « red », vertex.size = 20, vertex.label.dist =3)
dev.off()
#calculer degré actualisé
V(diffg1)$degree2 <- degree(diffg1)
V(diffg1)$degree
V(diffg1)$degree2
#graph.disjoint.union pour joindre des graphes dont les sommets différents (opérateur %du%)
#liens communs à deux graphes : conserve les attributs
#tous les sommets sont conservés (opérateur %s%)
interg1 <- graph.intersection(g1,g2, keep.all.vertices = TRUE)
#seuls sommets adjacents aux liens communs sont gardés (ici ACD)
interg2 <- graph.intersection(g1,g2, keep.all.vertices = FALSE)
par(mfrow = c(1,2))
plot(interg1, sub = « graph.intersection(g1,g2,\nkeep.all.vertices = TRUE) »)
plot(interg2, sub = « graph.intersection(g1,g2,\nkeep.all.vertices = FALSE) »)
dev.off()
#union de graphes : tout lien présent dans un moins un graphe
#est dans le graphe produit – tous les attributs sont conservés
#ne crée pas de liens multiples
uniong <- graph.union(g1,g2) #opérateur %u%








Laurent BeauguitteMore Posts Follow Me: 

Publié le 18/07/2015Auteur Laurent BeauguitteCatégories OutilsMots-clés igraph, R 



Laisser un commentaire Annuler la réponse 
Votre adresse de messagerie ne sera pas publiée. Les champs obligatoires sont indiqués avec *Commentaire Nom * 
Adresse de messagerie * 
Site web 
Enregistrer mon nom, mon e-mail et mon site web dans le navigateur pour mon prochain commentaire.
 

 

Ce site utilise Akismet pour réduire les indésirables. En savoir plus sur comment les données de vos commentaires sont utilisées.


Navigation de l’article
Précédent Article précédent : Analyse (et visualisation) de réseaux avec NetworkX – 1Suivant Article suivant : Sélection de flux avec R : le package flows






Un carnet de recherche proposé par  Hypothèses - Ce carnet dans le catalogue d'OpenEdition - Politique de confidentialitéFlux de syndication - Crédits 
				Fièrement propulsé par WordPress			





    // tracker methods like "setCustomDimension" should be called before "trackPageView"
      var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
      g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'pk.js'; s.parentNode.insertBefore(g,s);
    })();
  



