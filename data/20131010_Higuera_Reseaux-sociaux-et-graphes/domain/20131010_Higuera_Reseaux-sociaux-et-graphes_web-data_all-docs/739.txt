http://theses.insa-lyon.fr/publication/2008ISAL0028/these.pdf

NO D’ORDRE 2008-ISAL-0028

ANNÉE 2008

THÈSE

STRUCTURATION RELATIONNELLE DES
POLITIQUES DE CONTRÔLE D’ACCÈS
REPRÉSENTATION, RAISONNEMENT ET
VÉRIFICATION LOGIQUES

Présentée devant :
L’Institut National des Sciences Appliquées de Lyon
Pour obtenir :
Le grade de docteur
Spécialité :
Informatique
Formation doctorale :
Informatique
École doctorale :
Informatique et Information pour la Société
Par :
Romuald THION

SOUTENUE PUBLIQUEMENT DEVANT LE JURY COMPOSÉ DE :

Stéphane COULONDRE, Maître de Conférences, INSA de Lyon . . . . . . . . . . . . . . . . . . . . Co-directeur de thèse
André FLORY, Professeur des Universités, INSA de Lyon . . . . . . . . . . . . . . . . . . . . . . . . . . Co-directeur de thèse
Georges GARDARIN, Professeur des Universités, Université de Versailles . . . . . . . . . . . . . . . . . . . Examinateur
Philippe PUCHERAL, Professeur des Universités, Université de Versailles . . . . . . . . . . . . . . . . . . . . . Rapporteur
Florence SÈDES, Professeur des Universités, Université Paul Sabatier Toulouse . . . . . . . . . . . . . . Rapporteur

LABORATOIRE D’INFORMATIQUE EN IMAGE ET SYSTÈMES D’INFORMATION

À qui de droit

Avant-propos

Remerciements

Étape difﬁcile de la rédaction de thèse s’il en est, mais au combien appréciée : les
remerciements. Qui remercier ? Dans quel ordre ? Pourquoi ? Tant de questions qui res-
teront certainement sans réponse aucune. Alors, évitons prudemment tout écueil en
optant pour tout ce qu’il y a de plus classique : une grande liste sans ordre particulier.
Je tiens en premier lieu à remercier Stéphane Coulondre, qui est en grande partie le
responsable de mon engagement dans la recherche et l’enseignement. C’est avec plaisir
que je t’ai connu et que j’ai travaillé avec toi depuis bientôt 5 ans (mais ça ne rajeunit
pas du tout . . . ). Je remercie également André Flory qui m’a livré quelques ﬁcelles du
métier et qui a su me conseiller avisément. Je remercie bien sûr les membres du jury,
Georges Gardarin, Florence Sèdes et Philippe Pucheral, d’avoir accepté leurs charges
respectives. J’adresse une dédicace particulière aux rapporteurs : un grand merci pour
vos critiques. J’espère que vous ne m’en avez pas trop voulu en voyant le nombre de
pages de la thèse.

Je remercie bien sûr l’ensemble des doctorants et autres chercheurs avec qui j’ai
échangé et partagé (voire plus si afﬁnités) pendant ces dernières années et qui se sont
également lancé dans l’aventure d’une thèse. En premier lieu, ceux qui ont le plus souf-
fert en étant mes co-bureaux : Jube, Sandro, Yann, Ny-Hango, les voisins d’en face ou
d’à côté : Marian, Jean-Marc (x2) Ieva, Jeremy, Céline, sans oublier les collègues du CITI
(bouh, un autre labo !) : Danto, Yvan, Nico. Je pourrai certainement encore étendre cette
liste je pense.

Enﬁn, je remercie ma famille ainsi que tous les proches qui m’ont soutenu et avec
qui j’ai passé tant de temps ces dernières années. Chers amis de lycée (Maillet, An-
gus, Couscous, Jaymz, Loutre, Bozot, Toto et d’autres vieux raisins), de l’INSA et toute
la bande d’IF (Gus, Lorentz, Pastis, Seb, Damien et vos compagnes respectives bien
sûr !) ou d’ailleurs (attention, certains cumulent des mandats de catégories, n’est ce pas
Jube ?), je vous remercie tous. Et une dernière bise pour Virginie, pour la route.

ii

Résumé

LES enjeux de la sécurité des systèmes d’information, avec l’omniprésence de l’infor-

matique, la mise en ligne des systèmes et l’augmentation du nombre d’utilisateurs,
sont devenus considérables : sécurité nationale, image de marque, aspects légaux ou
encore pertes ﬁnancières directes et indirectes colossales.

Le contrôle d’accès, ou autorisation – c’est-à-dire le mécanisme qui déﬁnit et impose ce
qu’il est permis et interdit de faire – est un outil technique et organisationnel incontour-
nable lorsqu’on envisage de garantir la sécurité d’un système. Initié par la défense amé-
ricaine dans les années 70, ce domaine de recherche traite de multiples problématiques
relatives à la notion de droit dans un système : structuration, formalisation, sémantique,
stockage, représentation ou encore vériﬁcation et raisonnement.

Face à la diversité et à la taille croissante des systèmes d’information, les modèles
historiques de contrôle d’accès ont trouvé leurs limites : trop rigides, insufﬁsamment
sûrs ou difﬁciles d’administration. Ces limites ont conduit à la proposition du contrôle
d’accès à rôles (Role Based Access Control – RBAC) dont le principe est d’introduire un
niveau d’indirection entre utilisateurs et permisions [Ferraiolo03b]. Depuis – initiées
par les modèles RBAC – de nombreuses propositions sur le contrôle d’accès ont été
faites, dont on peut identiﬁer deux grandes tendances :

– d’une part, une modélisation de plus en plus riche et complexe des organisations,
permettant de mieux gérer les droits d’accès en les calquant sur la réalité pour
faciliter le travail des administrateurs : multiples niveaux d’indirection et d’abs-
traction ou introduction d’aspects temporels par exemple. Ces propositions, gui-
dées par les besoins, tendent à manquer de cadres formels et d’outils cohérents,
rendant difﬁcile leur intégration homogène dans les systèmes.

– d’une autre part, des propositions fondées sur des aspects théoriques, qui tâchent
à partir d’un cadre logique déterminé de proposer des langages et des outils per-
mettant de modéliser et de raisonner sur les droits d’accès : utilisation de la né-
gation pour exprimer des politiques hybrides d’autorisation et d’interdiction ou
raisonnements temporels par exemple. Ces propositions, basées sur des cadres
logiques novateurs, peuvent être en revanche assez éloignées des préoccupations
et des besoins des administrateurs.

La ligne directrice de ce travail se fonde sur la fertilisation croisée entre ces deux ap-
proches : plutôt que de créer un cadre théorique sur mesure dans lequel exprimer une
modélisation complexe, mais difﬁcile d’utilisation, où à l’inverse, de proposer des solu-
tions ad hoc pour des problèmes d’administration qui peuvent être généralisés, la thèse
propose d’utiliser un cadre bien fondé, permettant d’exprimer et de résoudre de grandes
classes de problèmes d’administration des droits d’accès, avec un souci d’homogénéité et
d’utilisabilité de la proposition. Nous développerons d’une part un cadre logique pour
le contrôle d’accès mais aussi un ensemble d’outils formels pour la conception et l’ad-
ministration du contrôle d’accès.

iii

La thèse montre que les modèles de contrôle d’accès, qui permettent d’organiser
les droits dans un système, partagent des concepts communs. Après avoir identiﬁé ces
éléments structurants et les relations qui les unissent, nous montrons que ces modèles
peuvent être formalisés à l’aide du modèle relationnel, et que les propriétés dont ils
jouissent peuvent être modélisées à l’aide de dépendances de données : des classes de
formes syntaxiques restreintes de la logique du premier ordre permettant de garantir
l’intégrité de données relationnelles [Abiteboul95, Beeri84].

Les classes de dépendances sont organisées en ensembles de formules de plus en
plus expressives, ce qui permet, selon les classes, d’exprimer des propriétés des modèles
de contrôle d’accès de plus en riches : de la matrice de contrôle d’accès la plus simple
– formalisée par une relation unique ([Lampson74]) – aux modèles les plus récents de
la littérature, qui intègrent hiérarchies et contraintes – exprimés à l’aide des classes de
dépendances les plus générales [Maher96]. L’approche permet de mettre à proﬁt des
résultats qui dépassent le cadre strict du modèle relationnel et résolvent des problèmes
actuels d’expression, de vériﬁcation et de raisonnement sur les politiques de contrôle
d’accès, tout en assurant une intégration homogène dans les systèmes d’information.

Un des problèmes majeurs du contrôle d’accès que nous traitons est de s’assurer
qu’une politique est intègre, c’est-à-dire qu’elle satisfait bien aux propriétés qu’elle doit
respecter. En effet, une grande partie des failles des systèmes sont dues à des erreurs ou
des oublis d’administration : proposer des outils de vériﬁcation automatique permet
d’éviter et de corriger ces erreurs, améliorant ainsi la sécurité des systèmes.

Par exemple, dans les politiques RBAC, on peut déﬁnir des rôles qui sont mutuelle-
ment exclusifs – aucun utilisateur ne doit pouvoir les endosser simultanément. Ce type
de contrainte permet d’interdire qu’un utilisateur ne dispose pas de trop de droits :
on ne souhaite pas qu’une personne puisse à la fois faire une demande d’achat et la
valider. Les dépendances permettent de formaliser les propriétés algébriques que les
contraintes respectent, de vériﬁer qu’elles sont cohérentes et qu’elles sont effectivement
satisfaites par les politiques. L’expressivité des classes de dépendances les plus géné-
rales nous permet de traduire et de vériﬁer des contraintes complexes qui n’ont pas été,
jusque-là, abordées dans la littérature.

iv

Ce travail propose également de déﬁnir des outils et des méthodes pour prendre
en compte le cycle de vie et l’évolution des modèles de contrôle d’accès. Supposons un
cas de réorganisation d’une entreprise où le système d’information est restructuré. Les
responsables de la sécurité choisissent d’introduire un nouveau concept pour faciliter
la gestion des droits. Les outils proposés dans la thèse permettent d’exprimer cette re-
structuration et de vériﬁer que les droits exprimés dans le nouveau modèle sont bien
équivalents à ceux dont les utilisateurs disposaient avant.

Dans le cadre de cette restructuration, les contraintes que les administrateurs
avaient déﬁnies indépendamment les uns des autres se retrouvent désormais regrou-
pées dans une seule et même politique. La thèse propose d’exploiter les algorithmes
de preuve qui ont été développés pour les dépendances, pour éliminer les contraintes
redondantes et ainsi réduire leur nombre, avec toujours l’objectif de faciliter l’adminis-
tration. Notons que ces procédures de preuve ne passent pas par des réécritures ou des
transformations qui compliquent le travail d’analyse des administrateurs.

Le travail proposé met à proﬁt des ponts existants entre les dépendances et des
domaines de recherche connexes. Nous proposons une représentation permettant d’ex-
primer graphiquement les règles et propriétés qui déﬁnissent les modèles de contrôle
d’accès et de suivre les étapes des raisonnements sur les politiques à l’aide des graphes
conceptuels [Salvat96].

Nous proposons également une méthode pour assister la réorganisation des droits
nécessaire lors de la restructuration des politiques de contrôle d’accès à l’aide de l’ana-
lyse de concepts formels [Arévalo07]. Par exemple, quand une organisation décide d’in-
troduire la notion de rôle dans ses politiques, alors qu’elle ne disposait jusque-là que
des droits exprimés sous forme de listes d’autorisations, l’outil proposé assiste l’identi-
ﬁcation des hiérarchies rôles implicitement présents dans les listes.

Enﬁn, notre approche propose plusieurs perspectives d’utilisation de travaux issus
des bases de données pour les problématiques du contrôle d’accès. L’étude des dépen-
dances et de leurs applications est un domaine de recherche actif, abordant des thèmes
variés : la réparation automatisée de base de données [Chomicki05], les requêtes consis-
tantes [Bertossi06], le maintien des dépendances lors des mises à jour [Christiansen06]
ou encore la correspondance de schémas [Fagin06].

Ces recherches devraient permettre d’apporter des éléments de réponse aux pro-
blématiques les plus actuelles sur le contrôle d’accès : réparation automatique de poli-
tiques, mode dégradé, interrogation de politiques distribuées, modélisation des droits
des administrateurs ou encore coopération de politiques organisées selon des modèles
différents.

Notes

v

Table des matières

Avant-propos
Résumé .
. . .
Table des matières .

. . .

. . .
. . .

. .
. .

. . .
. . .

. . .
. . .

. . .
. . .

. .
. .

. . .
. . .

. . .
. . .

. . .
. . .

. . .
. . .

. .
. .

. . .
. . .

i
ii
vii

1
3
3
5
6
7

11
13
16
24
34
38
48
54

65
67
69
71
79
96

.
.

.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.

. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .

. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .

Structuration du contrôle d’accès
4.1
. . .
4.2 Concepts et relations des modèles de contrôle d’accès . .

Structuration générale du contrôle d’accès . . .

. . .

. . .
. . .

. .
. .

. . .
. . .

99
. 101
. 104

Introduction
1.1
1.2 Besoins du contrôle d’accès . . .
. . .
. . .
1.3 Motivations
. . .
. . .
1.4 Contributions . . .
. . .
1.5 Organisation du manuscrit .
. . .

Sécurité des systèmes d’information .
. . .
. . .
. . .
. . .

. .
. .

.

. .
. .
. .
. .
. .

. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .

. . .

. . .

Contrôle d’accès au système d’information
. . .
2.1 Place du contrôle d’accès dans la sécurité . . .
. . .
. . .
2.2 Modèles historiques . .
. . .
. . .
. . .
2.3
Structuration du contrôle d’accès . . .
2.4 Administration des modèles structurés
. . .
. . .
2.5 Enrichissements et extensions des modèles structurés . .
. . .
2.6 Cadres logiques pour le contrôle d’accès .
2.7 Discussion et synthèse . . .
. .
. . .

. . .
. . .
. . .
. . .

. . .
. . .

. . .
. . .

. .
. .
.

. . .

. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .

Choix d’un cadre logique
3.1 Critères pour un cadre logique .
Structuration des modèles .
3.2
. . .
3.3 Modélisation des principes
. . .
3.4
3.5 Discussion et synthèse . . .

. .
. .
. .
Intégrité des politiques de contrôle d’accès
. .

. . .
. . .
. . .

. . .

. . .

. . .
. . .
. . .
. .
. . .

. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .

1

2

3

4

viii

TABLE DES MATIÈRES

. . .
4.3 Principes des modèles de contrôle d’accès . . .
. . .
4.4 Catégorisation des aspects des modèles .
. . .
4.5 Contraintes dans les modèles de contrôle d’accès . .
. . .
4.6 Modélisation du contexte .
4.7 Discussion et synthèse . . .
. . .

. . .
. . .

. . .
. . .

. . .
. . .

. .
. .

. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .

5 Mise en œuvre de la structuration

. .
5.1
Structuration en couches . .
. . .
. .
5.2 Conception de modèles . . .
. . .
5.3 Administration des politiques . .
. .
5.4 Représentation graphique de modèles . .
5.5
. .
. .
5.6 Discussion et synthèse . . .

Ingénierie de rôles hiérarchisés .
. . .

. . .
. . .
. . .

. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .

6 Aspects techniques et réalisations

. . .
6.1 Architecture du contrôle d’accès
. . .
. . .
6.2 Bibliothèque pour les dépendances . .
6.3 Cas d’étude .
. . .
. . .
6.4 Réalisation de l’identiﬁcation de concepts . . .
. . .
6.5

Synthèse . . .

. .
. .
. .

. . .

. . .

. . .

. .

. . .

. .

. . .

. . .

. .

. . .

7

. . .
. . .

. . .
. . .

Synthèse générale .

Conclusion et perspectives
. . .
. . .
7.1
. .
. . .
7.2 Discussion générale . .
. . .
. . .
7.3 Aspects logiques du contrôle d’accès .
7.4 Extension du périmètre du contrôle d’accès . .
. . .
7.5 Administration du contrôle d’accès . .
7.6
Industrialisation de la proposition . .
. . .
. . .
. . .
7.7 Contrôle d’accès aux réseaux . .

. .
. .
. .

. .
. .
. .

. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .

. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .

. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .

A Préliminaires au cadre logique
A.1 Logique du premier ordre .
A.2 Modèle relationnel
. . .
A.3 Base de données et logique .

. .

. . .
. . .
. . .

. . .
. . .
. . .

. .
. .
. .

. . .
. . .
. . .

. . .
. . .
. . .

. . .
. . .
. . .

. . .
. . .
. . .

. .
. .
. .

. . .
. . .
. . .

B

Théories logiques
B.1 Symboles utilisés .
. . .
B.2 Modèles de contrôle d’accès . . .

. . .

. .

. . .
. . .

. .
. .

. . .
. . .

. . .
. . .

. . .
. . .

. . .
. . .

. .
. .

. . .
. . .

C Traces d’inférence

. 108
. 112
. 115
. 120
. 122

125
. 128
. 129
. 137
. 143
. 152
. 167

171
. 173
. 180
. 184
. 189
. 194

195
. 197
. 199
. 201
. 204
. 205
. 210
. 213

217
. 219
. 228
. 229

233
. 235
. 238

243

TABLE DES MATIÈRES

C.1 Inclusion des triplets d’autorisation .
. . .
C.2 Simpliﬁcation des propriétés de l’exclusion mutuelle . .

. . .

. .

. . .

Bibliographie

ix

. . .
. . .

. .
. .

. . .
. . .

. 245
. 247

266

Table des ﬁgures

2.1 Mécanisme de moniteur mis en œuvre pour réaliser le contrôle d’accès .
. . .
. . .
.
2.2 Représentation du modèle RBAC1 (UML)
. . .
.
. . .
. .
2.3 Famille x-BAC (UML) .
. . .
. . .
. . .
2.4 Exemples de hiérarchies (UML) .
. .
.
.
2.5 Représentation du modèle ORBAC (UML) . . .
. . .
.
2.6 Modèle d’administration de RBAC : ARBAC (UML) .
.
.
2.7 Modélisation et formalisation du contrôle d’accès
2.8 Combinaison des deux tableaux de synthèse .
. . .
.

. . .
. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .

. .
. .
. .
. .
. .
. .
. .

. . .
. . .

. . .

3.1 Modèle Entité-Relation de RBAC0 . . .
. . .
3.2 Procédure de preuve pour les dépendances . .

. .

. . .
. . .

. . .
. . .

. . .
. . .

. .
. .

. . .
. . .

.
.

15
25
26
28
31
36
47
58

69
89

4.1 Catégorisation des composants de la structuration relationnelle .

. . .

. 114

. .

. . .

. . .

. . .

. . .

5.1 Étapes de la conception d’un modèle .
. . .
5.2 Etapes de la conception d’une politique de contrôle d’accès . .
. . .
5.3 Représentation de faits avec les graphes conceptuels . . .
. . .
. . .
5.4 Hiérarchisation de rôles avec les graphes
5.5 Core-rule des modèles RBAC . . .
. .
. . .
. . .
5.6 Procédure de preuve en marche arrière sur les graphes (1/2) .
5.7 Procédure de preuve en marche arrière sur les graphes (2/2) .
. . .
. . .
5.8 Approches d’ingénierie des rôles [Epstein02]
.
. . .
5.9 Hiérarchies issues du contexte du tableau 5.5 .
. . .
5.10 Élagage de la SHG à partir d’une liste ordonnée . . .
. . .
5.11 Évolution des modèles et des politiques de contrôle d’accès . .

. . .
. . .
. . .

. . .
. . .

. . .
. . .

6.1 Modèle de contrôle d’accès du GMSIH (UML) [GMSIH03] . . .
. . .
6.2 Exemple de hiérarchie en arbre (UML) . .
. . .
6.3 Résultats expérimentaux, moyenne sur dix exécutions . .
. . .

. . .

. . .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .

. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .

. 131
. 137
. 146
. 147
. 148
. 150
. 151
. 154
. 164
. 165
. 170

. 185
. 187
. 192

Liste des tableaux

Spécialisations des politiques de sécurité

. . .
2.1
. . .
2.2 Exemple jouet de matrice de contrôle d’accès .
. . .
2.3 Exemple de classiﬁcation de conﬁdentialité [Journal Ofﬁciel98]
. . .
2.4 Principes du modèle de Bell et LaPadula [Bell75] . .
. . .
. . .
2.5 Concepts et relations du noyau RBAC [Ferraiolo03b] . . .
. . .
2.6 Cadres pour la spéciﬁcation et la vériﬁcation graphique .
. . .
. . .
2.7 Essai de synthèse des modèles de contrôle d’accès .
2.8 Essai de synthèse des cadres logiques
. . .
. . .
. . .

. . .
. . .

. . .
. . .

. . .

. .

. .
. .
.
. .
. .
. .
. .
. .

. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .

. .

. . .

. . .

. . .

Instance du schéma relationnel de RBAC0

Instance de la relation en intention Statique . .

3.1
. . .
3.2 Déﬁnitions logiques des triplets d’autorisations du modèle RBAC0 . . .
3.3
. . .
. .
. . .
3.4 Formalisation logique de l’héritage entre rôles du modèle RBAC1
. . .
. . .
. .
3.5 Exemple de dépendances fonctionnelle et d’inclusion . .
.
3.6 Formes syntaxiques des principales classes de dépendances
. .
. . .
.
. . .
. .
3.7 Axiomes d’Armstrong pour les dépendances fonctionnelles
. . .
. .
. . .
3.8 Exemples de dépendances totales . . .
. . .
. . .
. .
3.9 Formalisation logique des propriétés du modèle RBAC0 .
. . .
3.10 Formalisation logique des propriétés de l’exclusion mutuelle .
. .
. . .

. . .

. . .

. . .

. . .

. . .

. .

. .

. . .
4.1 Application de représentation Ψ . . .
. . .
. . .
4.2 Catégorisation des aspects des politiques de contrôle d’accès .
. . .
4.3
Instance de la relation Habilite et contraintes contextuelles . .
4.4 Restrictions de permissions hors-contexte . . .
. . .
. . .
4.5 Correspondance entre contrôle d’accès et structuration relationnelle . .

. .
. .
. .
. .

. . .

. . .

. . .

. . .

. . .

. .

. .
. .
5.1 Abstraction en couches pour le contrôle d’accès
. .
5.2 Classiﬁcation de la théorie du premier ordre .
. . .
. .
5.3 Corrections possibles d’une politique non intègre .
5.4 Applications de correspondance Φ et Φ−1 . . .
. .
. . .
. .
. . .
5.5 Contexte formel jouet .
. . .
5.6
. .
Identiﬁcation des termes de FCA et de RBAC .
. . .
5.7 Affectations de rôles aux utilisateurs et de permissions aux rôles .
5.8 Critères principaux proposés pour le classement des concepts . .

. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .

. . .

. . .

. . .

. .

. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.

14
17
21
22
27
54
61
63

70
76
78
79
80
82
86
90
93
95

. 106
. 113
. 121
. 122
. 124

. 129
. 132
. 141
. 145
. 157
. 158
. 160
. 163

xiv

LISTE DES TABLEAUX

5.9 Outillage pour le contrôle d’accès . . .

. .

. . .

. . .

. . .

. . .

. .

. . .

. 168

6.1 Expression relationnelle de la hiérarchie de la ﬁgure 6.2 .
. . .
6.2 Paramètres utilisés pour les expérimentations .

. . .

. . .
. . .

B.1 Symboles ensemblistes du contrôle d’accès . .
. . .
B.2 Structuration relationnelle .
. . .
B.3 Symboles de prédicats . . .
B.4 Théorie logique des modèles MAC en treillis
.
B.5 Théorie logique des modèles RBAC1 et RBAC2 .
B.6 Théorie logique des modèles RBAC2 et RBAC3 .

. . .
. . .

. . .
. . .

. .
. .

. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .

. .
. .

. .
. .
. .
. .
. .
. .

. . .
. . .

. 188
. 191

. . .
. . .
. . .
. . .
. . .
. . .

. 235
. 236
. 237
. 238
. 240
. 241

Liste des déﬁnitions

. . .

. . .
. . .
Session dans les modèles RBAC [Ferraiolo03b]
. .
. . .
. . .
. . .
. .

. . .
2.1 Contrôle d’accès [Lampson74] . .
. .
. . .
. . .
2.2 Contrôle d’accès mandataire [Sandhu93] .
. . .
. . .
2.3
. . .
. . .
2.4 Hiérarchie générale de rôles [Ferraiolo03b]
. . .
. . .
2.5 Hiérarchie limitée de rôles [Ferraiolo03b]
. . .
. . .
. .
2.6 Utilisateurs affectés et autorisés .
. . .
. . .
. . .
2.7 Permissions affectées et autorisées . .
. .
. . .
. . .
2.8 Principe de séparation des tâches [Nash90]
. . .
2.9 Exclusion mutuelle statique entre rôles [Ferraiolo03b] . .
. . .
2.10 Exclusion mutuelle dynamique entre rôles [Ferraiolo03b] . . .
2.11 Principe du moindre privilège [Nash90] .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .

. . .

. . .

. . .

3.1 Règle de déduction DATALOG [Abiteboul95]
3.2 Règle de déduction DATALOGC [Li03b] . .
3.3
. .
3.4

Satisfaction de dépendances . . .
Independence of Negative Constraints [Lassez89]

.
. . .
. . .

. . .
. . .
. . .
.

. . .

. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .

. . .

. . .

. . .
. . .

. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .

. . .
4.1 Modèle de contrôle d’accès
. .
. . .
4.2 Triplet fondamental du contrôle d’accès .
. . .
. .
4.3 Moniteur de contrôle d’accès
. .
4.4 Politique de contrôle d’accès . . .
. . .
. .
4.5 Représentation des concepts et des relations d’un modèle . . .
. . .
. . .
4.6 Concepts et relations étendus d’un modèle . . .
. . .
4.7 Dépendances structurelles des modèles .
. . .
. . .
4.8 Dérivation du triplet fondamental d’autorisation . .
. . .
4.9 Dérivation des triplets d’autorisation orientés utilisateurs . . .
. . .
4.10 Inclusion des autorisations orientées utilisateurs . .
. . .
. . .
4.11 Principe fondamental des modèles structurés .
. . .
. . .
. . .
4.12 Concept hiérarchisé . .
. . .
4.13 Hiérarchie limitée .
. .
. . .
. . .
. . .
. . .
. . .
4.14 Aspects statiques et dynamiques . . .
. . .
. . .
. . .
4.15 Contrainte dans un modèle de contrôle d’accès . . .
4.16 Exclusion mutuelle entre concepts . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .

. . .
. . .

. .

. . .

. . .
. . .

. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.

15
20
25
28
28
29
29
32
39
39
45

72
74
84
90

. 101
. 101
. 102
. 104
. 105
. 106
. 106
. 108
. 109
. 109
. 110
. 110
. 111
. 113
. 115
. 116

xvi

LISTE DES DÉFINITIONS

4.17 Sémantique de l’exclusion mutuelle .
. . .
4.18 Transmission de l’exclusion par hiérarchie . . .
. . .
4.19 Relation de prérequis .
. . .
. . .
4.20 Relation de prérequis intra-relation . .
. . .
4.21 Relation d’héritage spécialisée . .
. . .
4.22 Contraintes d’accès contextuelles . . .
. . .

. .
. .
. .
. .

. . .

. . .

. .

. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .

. . .

. .
.

. .
. .

. . .
5.1 Conception de modèle de contrôle d’accès . . .
. . .
. . .
. . .
5.2 Primitives de conception . .
. . .
. . .
. . .
5.3 Modèle non intègre de contrôle d’accès
. . .
. . .
. . .
5.4 Redondance dans un modèle de contrôle d’accès . .
. . .
. . .
5.5 Primitive d’administration .
. . .
5.6 Primitive de manipulation .
. . .
5.7 Principe d’administration des modèles structurés
. . .
.
5.8 Revue d’une relation de politique de contrôle d’accès . .
. . .
5.9 Politique intègre de contrôle d’accès .
5.10 Comparaison statique de politiques
.
. . .
. . .
5.11 Ingénierie des rôles hiérarchisés .
. . .
. . .
5.12 Ingénierie de concepts hiérarchisés . .
7.1 Modèle d’administration . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .

. .
. .
. .
. .
. .

. . .
. . .

. . .
. . .

. . .
. . .

. . .

. .
. .
. .
. .
. .
. .

. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
A.1 Langage . . .
. . .
. . .
. . .
A.2 Terme . .
. . .
. . .
. . .
. . .
A.3 Formule . . .
. . .
. . .
A.4 Clause .
. . .
. . .
. . .
. . .
A.5 Interprétation . . .
. . .
A.6 Valuation . . .
. . .
. . .
. . .
A.7 Satisfaction de formule . . .
A.8 Univers de Herbrand .
. . .
. . .
A.9 Base et interprétation de Herbrand . .
. .
. . .
A.10 Déduction . .
. . .
. .
. . .
. . .
A.11 Substitution .
. .
. . .
A.12 Attribut .
. . .
. . .
. .
. . .
A.13 Produit cartésien .
. .
A.14 Relation .
. . .
. . .
. . .
A.15 Base de donnée . .
. .
A.16 Requête conjonctive . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .

. . .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .

. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .

. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .
. . .

. 116
. 117
. 117
. 118
. 118
. 120

. 129
. 131
. 133
. 135
. 138
. 138
. 138
. 139
. 139
. 142
. 159
. 166
. 206

. 219
. 219
. 219
. 220
. 221
. 222
. 223
. 224
. 224
. 226
. 227
. 228
. 228
. 228
. 228
. 230

Don’t rely on network safeguards and ﬁrewalls to protect your information.
Looktoyourmostvulnerablespot.You’llusuallyﬁndthatvulnerabilityliesin
yourpeople.

Kevin D. Mitnick – “The Art of Deception”, p.79

1

Introduction

⊲ En début de chaque chapitre nous proposons un résumé des principales contributions présentées.

Sur la page suivant chaque résumé, une table des matières du chapitre est proposée.

Le présent chapitre est l’introduction de la thèse. Nous découvrons les problématiques de la sécurité
et du contrôle d’accès dans les systèmes d’information. Nous présentons également les objectifs, nos
motivations, nos principales contributions, le périmètre scientiﬁque ainsi que la structure du manuscrit.
⊳

2

Chapitre 1. Introduction

Plan du chapitre

1.1
1.2
. .
1.3 Motivations .
. .
1.4 Contributions . .
. .
1.5 Organisation du manuscrit

. .
. .

. .
. .

Sécurité des systèmes d’information . .
. .
Besoins du contrôle d’accès . .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
Principe de Quintilien . .
. .
Périmètre de l’étude .
Plan de la thèse . .
. .
. .

1.5.1
1.5.2
1.5.3

.
.
.
.
.
.
.

. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .

.
.
.
.
.
.
.
.

. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .

.
.
.
.
.
.
.
.

3
3
5
6
7
7
8
8

Section 1.1. Sécurité des systèmes d’information

3

LE XXe siècle fut marqué par la révolution des technologies de l’information et des

communications. L’informatique est passée, en l’espace de quelques décennies, du
statut de curiosité scientiﬁque et de prototype militaire à celui d’outil incontournable
et massivement répandu : désormais, toutes les organisations – de l’ordinateur do-
mestique aux systèmes d’information des multinationales – stockent, traitent et trans-
mettent des quantités massives d’information.

1.1 Sécurité des systèmes d’information

Avec l’ère du numérique, toute une variété de nouveaux déﬁs techniques, scienti-
ﬁques et sociaux est apparue. L’un d’entre eux est la sécurité des systèmes d’information.
Il éveille utilisateurs, industriels et scientiﬁques. Alors que nous incluons tous dans les
problèmes de sécurité, les logiciels malveillants ou le courrier indésirable qui polluent
nos environnements de travail, les grandes entreprises redoutent la mise hors d’usage
de leurs systèmes de production et la fuite d’informations conﬁdentielles. Les enjeux
de la sécurité sont devenus tels – image de marque, pertes ﬁnancières directes ou indi-
rectes massives – que des moyens considérables sont investis pour garantir la sécurité.
Les principes d’authentiﬁcation et d’autorisation sont incontournables lorsqu’on envi-
sage de garantir la sécurité d’un système. L’authentiﬁcation concerne la preuve de l’iden-
tité, l’autorisation – synonyme de contrôle d’accès – déﬁnit et impose ce qu’il est permis
et interdit de faire. La notion de contrôle d’accès est bien antérieure à l’informatique :
de tout temps des gardes, des chaînes et des herses ont été dressés pour protéger des
accès illégitimes.

Les recherches dans le domaine du contrôle d’accès furent initiées par le Departe-
ment of Defense américain (DOD) dans les années 70 [Lampson74]. Des modèles théo-
riques furent élaborés et très largement implantés, pour faire face aux besoins de sécu-
rité, militaires à l’époque. Avec la démocratisation de l’informatique et son usage in-
contournable dans presque toutes les organisations, tous les acteurs de l’informatique
prêtent désormais attention à la sécurité de leurs systèmes d’information.

1.2 Besoins du contrôle d’accès

Les recherches sur le contrôle d’accès s’attachent à de multiples problèmes relatifs à
la notion de droit dans un système : organisation, formalisation, sémantique, architec-
ture. . . Une des rencontres majeures sur le sujet est l’ACM Symposium on Access Control
Models And Technologies1. Le regain d’intérêt sur le contrôle d’accès – motivé par les en-
jeux et besoins de sécurité – date des années 1990, période où la famille des modèles de

1SACMAT, dont l’adresse du site internet est http://www.sacmat.org

4

Chapitre 1. Introduction

contrôle d’accès basés sur les rôles, appelés généralement contrôle d’accès à rôles pour Role
Based Access Control (RBAC), ont été proposés pour la première fois.

La famille des modèles RBAC présente une nouvelle organisation des droits centrée
sur le concept de rôle. Cette notion a été étudiée dans de nombreux domaines (modèles
objets, philosophie, gestion des connaissances, modèles agents. . . ) et introduite dans le
contrôle d’accès pour simpliﬁer l’administration des droits des grands systèmes. De-
puis, les principes fondateurs des modèles RBAC ont largement été répandus et adap-
tés pour aboutir à la déﬁnition de nouveaux modèles rafﬁnés, intégrants des notions
de plus en plus complexes. De nombreuses propositions ont été faites, que d’aucuns
appelleraient les modèles x-Based Access Control, comme les notions de treillis (Lattice-
BAC), de temps (Temporal-RBAC, Generalized-Temporal-RBAC), d’équipes (Team-BAC), de
tâches (Task-BAC), d’organisations (Organization-BAC) ou encore de contextes (Context-
BAC) ont été proposées pour structurer les droits.

La volonté sous-jacente à cette profusion de modèles de contrôle d’accès est de pro-
poser une organisation des droits qui permette de traduire au mieux les « politiques de
sécurité », c’est-à-dire l’ensemble des règlements qui régissent la façon dont sont pro-
tégées les ressources d’un système. Ces politiques sont exprimées en langue naturelle
au début du cycle de développement du contrôle d’accès. Il faut ensuite traduire ces
règlements dans les systèmes grâce à des modèles de contrôle d’accès qui soient :

– sufﬁsamment expressifs, pour permettre l’expression de règlements complexes et

représenter ﬁdèlement la structure et le fonctionnement des organisations,

– décidables, pour évaluer les autorisations à partir des règlements,
– faciles d’administration, les modèles doivent fournir un ensemble de primitives

et de fonctionnalités simpliﬁant les activités des administrateurs.

La mise en place d’une politique de contrôle d’accès dans un système est un chan-
tier important pour une organisation, à la croisée de l’informatique, de la gestion des
ressources humaines et de la qualité. Dans cette activité interviennent de multiples pro-
blématiques relatives à la notion de droit dans un système, dont nous identiﬁons six
axes de recherche majeurs.

La conception de nouveaux modèles de contrôle d’accès. La famille RBAC a ouvert
un grand nombre de perspectives d’application et a contribué à fonder une nou-
velle structuration du contrôle d’accès, où des concepts et relations intermédiaires
entre utilisateurs et permissions sont introduits pour organiser les droits d’accès
de façon souple et efﬁcace.

La formalisation des modèles de contrôle d’accès. Un cadre logique dans lequel spé-
ciﬁer formellement les modèles de contrôle d’accès permet une meilleure caracté-
risation des propriétés qu’ils doivent satisfaire et donne un langage d’expression
commun sans ambiguïtés. La formalisation permet également d’utiliser des outils
mathématiques pour raisonner sur les modèles.

Section 1.3. Motivations

5

L’enrichissement des modèles de contrôle d’accès. Les notions de contraintes et de
propriétés de sécurité ont été étudiées pour ajouter du sens aux politiques de
contrôle d’accès. Le but de ces travaux est de permettre aux organisations d’expri-
mer les spéciﬁcités de leurs métiers par l’intermédiaire de règles et de restrictions
que les politiques de contrôle d’accès doivent satisfaire.

La vériﬁcation des politiques de contrôle d’accès. S’assurer qu’une politique est sûre,
équivalente à une autre, qu’elle instancie bien un modèle ou qu’elle satisfait à des
propriétés de sécurité sont des besoins actuels des administrateurs. Avec la taille
des politiques, les capacités humaines sont mises en défaut : des outils permettant
d’automatiser l’analyse et la vériﬁcation des politiques deviennent nécessaires.

La mise en œuvre du contrôle d’accès. Que ce soit dans les systèmes d’exploitation ou
les systèmes de gestion de bases de données, il faut déﬁnir comment, à partir des
modélisations conceptuelles puis des formalisations, mettre en œuvre le contrôle
d’accès effectif dans les systèmes.

Les méthodologies de mise en œuvre du contrôle d’accès. Il faut proposer des outils
et des méthodes pour que les organisations puissent mettre en place un contrôle
d’accès structuré. Cette activité côtoie celles du génie logiciel, de la modélisation
conceptuelle et de la représentation de connaissances.

1.3 Motivations

La thèse propose des outils et des méthodes répondant aux différents besoins qui
surviennent au long du cycle de vie du contrôle d’accès : de la conception du modèle
à l’administration et l’évolution des politiques. Nous voulons apporter une réponse
cohérente aux problèmes de formalisation, d’expression, de vériﬁcation, de conception
et de représentation posés par le contrôle d’accès.

Pour cela nous proposons un socle commun bâti sur la caractérisation logique des
modèles de contrôle d’accès qui permette la conception de modèles adaptés aux besoins
des acteurs de la sécurité. De plus, la thèse munit le cadre proposé d’outils pour la réa-
lisation des activités d’administration, de conception et de vériﬁcation des politiques.
Les critères qui guident la réalisation de ces objectifs sont :

l’expressivité : nous souhaitons un cadre qui permette de concevoir des modèles de
contrôle d’accès élaborés et d’exprimer des contraintes complexes sur ces mo-
dèles. L’expressivité de la proposition permettra par exemple de développer de
nouvelles classes de contraintes et de propriétés de sécurité,

l’homogénéité : nous souhaitons une approche qui permet de répondre aux probléma-
tiques qui surviennent tout au long du cycle de vie du contrôle d’accès dans un
cadre formel sous-jacent homogène. Le choix d’un paradigme logique sur lequel
nous pouvons raisonner directement sans passer par des transformations et des
réductions est guidé par ce critère,

6

Chapitre 1. Introduction

le bon fondement : nous désirons que la proposition se base sur un cadre logique bien
fondé et établi, sur lequel de nombreux résultats et applications ont été proposés.
Nous ne voulons pas composer un paradigme ad hoc, mais mettre à proﬁt des
résultats existants et reconnus comme sûrs, et nous en servir pour répondre et
anticiper les problématiques du contrôle d’accès,

l’utilisabilité : nous désirons que notre proposition soit utilisable par les responsables
de la sécurité des systèmes d’information et qu’elle réponde à leurs attentes en
étant proche des systèmes existants, sans proposer de surcouche mais plutôt en in-
tégrant les notions de contrôle d’accès au cœur des systèmes d’information. Cette
motivation nous conduit à éviter les mécanismes boîtes noires, à se rapprocher
des bases de données.

Nous proposons d’utiliser le cadre des dépendances de données pour caractériser et
répondre aux classes de problèmes que nous avons présentées. La notion d’intégrité
des modèles et des politiques en particulier est au centre de notre approche. Notre
proposition innove en intégrant des aspects transversaux du contrôle d’accès qui ont
jusqu’ici été traités de façon indépendante, et se démarque en proposant une approche
cohérente qui répond aux différents problèmes qui surviennent lors de l’élaboration
des politiques de contrôle d’accès.

1.4 Contributions

Nous proposons une structuration relationnelle du contrôle d’accès, basée sur l’identi-
ﬁcation des concepts communs aux différentes propositions de ce domaine. Nous déﬁ-
nissons un modèle de contrôle d’accès comme une organisation structurée de données,
utilisée pour prendre une décision d’accès, c’est-à-dire accorder ou refuser à un sujet
d’effectuer une action sur un objet [Thion07a]. La structuration relationnelle proposée
notée AC = (sch, P, Σ) est composée :

– d’un schéma relationnel sch qui permet d’organiser les politiques,
– d’un ensemble de principes P qui permettent de dériver de nouvelles informa-

tions à partir de celles connues, en vue de prendre les décisions d’accès,

– d’un ensemble de propriétés Σ que les politiques doivent respecter.
Il s’agit d’une structuration fondée sur les fondements logiques des bases de don-
nées relationnelles. Les principes P et les propriétés Σ sont des ensembles de formules
logiques closes. Les dépendances de données sont des fragments de la logique du pre-
mier ordre. Elles permettent l’expression de principes et de propriétés complexes. Dif-
férentes restrictions sont imposées aux composants de la structure. On impose notam-
ment qu’il existe une seule et unique plus petite interprétation de P. Les différentes
classes de dépendances à l’expressivité et à la décidabilité contrôlées nous permettent
de déﬁnir et de faire varier ces restrictions.

Section 1.5. Organisation du manuscrit

7

La généricité de la structure relationnelle permet de concevoir différents modèles
de contrôle d’accès. Nous illustrons notre approche avec la famille des modèles à rôles
dont nous prenons en compte de nombreuses extensions qui ne font pas partie du
standard RBAC : hiérarchies multiples, différentes sémantiques de l’exclusion, aspects
contextuels, contraintes de prérequis et surtout contraintes d’intégrité.

À partir de la structuration relationnelle, nous déﬁnissons ce qu’est une politique
de contrôle d’accès : une instance en extension du schéma. Pour faciliter l’adminis-
tration, les propriétés déﬁnissent comment déduire une politique en intention sur la-
quelle sont basées les décisions d’accès. Les propriétés Σ permettent de garantir l’in-
tégrité des politiques. S’assurer de la cohérence des droits est pour nous un objecttif
central [Thion06c, Thion06a].

À partir de la structuration relationnelle nous déﬁnissons les différentes activités
qui interviennent sur le contrôle d’accès : la conception de modèle, de politique et l’ad-
ministration des politiques. Les outils algorithmiques existants pour les dépendances
sont utilisés pour répondre aux problèmes de raisonnement et vériﬁcation du contrôle
d’accès. Ils permettent d’automatiser certaines tâches et de s’assurer de l’intégrité des
politiques. Nous exploitons également des connexions entre les dépendances et les
graphes conceptuels ou l’analyse de concept formel pour enrichir la palette d’outils
proposés [Thion06b, Thion07b].

1.5 Organisation du manuscrit

1.5.1 Principe de Quintilien

Quintilien est un rhéteur latin du Ier siècle après J.-C. auquel on doit un principe2
– Quis, Quid, Ubi, Quibus Auxiliis, Cur, Quomodo, Quando (qui, quoi, où, avec quels
moyens, pourquoi, comment, quand) – qui résume la démarche des instructions judi-
ciaire. Nous proposons d’appliquer cette démarche aﬁn identiﬁer les aspects essentiels
des problèmes auxquels nous nous intéressons dans la thèse :

quis – qui : les responsables de la sécurité, les concepteurs de modèles de contrôle d’ac-

cès et les administrateurs de politiques,

quid – quoi : les problèmes qui surviennent au long du cycle de vie d’une politique
de contrôle d’accès, de la conception à l’évolution, en essayant de généraliser les
approches proposées dans la littérature sur le contrôle d’accès,

ubi – où : dans les systèmes d’information, en particulier avec les bases de données re-
lationnelles qui en sont une des pierres angulaires, et qui disposent de nombreux
mécanismes techniques robustes,

2Ce principe se rapproche d’un des sept outils de la qualité : le Qui, Quoi, Où, Quand, Comment,

Pourquoi (QQOQCP) qui sert à identiﬁer un problème à partir de six questions fondamentales.

8

Chapitre 1. Introduction

quibus auxiliis – avec quels moyens : en proposant une structuration relationnelle,
bien fondée et expressive, qui permet d’aborder les modèles de contrôle d’accès
d’un point de vue générique,

cur – pourquoi : car la prise en compte du contrôle d’accès fait partie intégrante du
système d’information et de la mise en place d’une politique de sécurité, et que
cette prise en compte doit se faire de façon homogène et cohérente,

quomodo – comment : en étant le plus homogène possible et en s’intégrant au mieux
dans les paradigmes existants, sans ajouter de mécanismes ad hoc, et en construi-
sant des outils sur la structuration relationnelle,

quando – quand : au plus tôt du cycle de conception des systèmes, pour que la sécurité
de l’information soit prise en compte dans le cycle de vie du système d’informa-
tion.

1.5.2 Périmètre de l’étude

Nous avons identiﬁé six axes de recherche majeurs qui vont guider notre propo-
sition. D’autres directions sont envisageables et d’autres perspectives pourraient être
prises en compte. La notion de délégation par exemple, qui est couramment utilisée
dans les organisations, ou encore les principes de conﬁance, de partage et de collabo-
ration sécurisés sont d’autres domaines de recherches actifs. Nous évoquerons certains
de ces travaux, mais embrasser l’ensemble de ce champs d’étude dépasserait le cadre
que nous nous ﬁxons.

Devant l’étendue des directions prises par la recherche en sécurité et le dynamisme
du domaine, nous avons effectué des choix pour déﬁnir les limites de notre travail. La
portée de la thèse couvre la majorité des aspects introduits dans les modèles de contrôle
d’accès. Or ces derniers sont inscrits dans le cadre plus large des architectures de sécu-
rité. Le contrôle d’accès, qui est un objet d’étude à part entière, reste un moyen mis en
œuvre pour garantir la sécurité des systèmes, mais seul il est inutile. La métaphore de
la portée blindée aux multiples points sécurisant l’accès à une maison dont les fenêtres
sont grandes ouvertes représente assez ﬁdèlement cette situation.

Deux domaines en particulier sont étroitement liés au contrôle d’accès : d’une part
la cryptographie, et d’autre part les mécanismes d’authentiﬁcation qui se basent sur
des primitives cryptographiques, comme les architectures de clefs publiques. Si nous
évoquons ces aspects dans la thèse, ils ne sont pas l’objet principal de notre étude.

1.5.3 Plan de la thèse

Après cette introduction générale de la thèse, le chapitre 2 présente l’état de l’art
relatif à nos travaux : après avoir précisé la place du contrôle d’accès au sein de la
problématique générale de la sécurité des systèmes d’information, nous critiquons les

Section 1.5. Organisation du manuscrit

9

différentes modélisations du contrôle d’accès. Cette étude est conduite sur les aspects
pratiques, mais aussi théoriques. Comme nous avons souhaité couvrir un champ relati-
vement large des recherches sur le contrôle d’accès, deux essais de tableaux de synthèse
concluent cette étude.

Ensuite, le chapitre 3 propose le cadre logique dans lequel nous formalisons le
contrôle d’accès. Nous justiﬁons le choix des dépendances de données pour réaliser
nos objectifs avec les critères ﬁxés. La description de ce cadre est illustrée par son ap-
plication aux modèles à rôles.

Une fois le cadre logique déterminé, nous déﬁnissons dans le chapitre 4 une modé-
lisation générique des autorisations dans les systèmes en nous appuyant sur les traits
communs que partagent les modèles de contrôle d’accès. Nous portons une attention
particulière à intégrer les différentes critiques qui leur sont adressées. Nous catégori-
serons également les différents aspects intervenants lors de la réalisation effective du
contrôle d’accès.

Dans le chapitre 5 nous développons l’utilisation de la modélisation générique pro-
posée. Après avoir déﬁni les principales activités relatives à l’organisation des droits
dans les systèmes, nous proposons un ensemble d’outils pour la conception de modèles
puis pour l’administration des politiques de contrôle d’accès.

Le chapitre 6 donne les clefs techniques de l’implantation de notre approche et
propose des exemples d’applications. Ce chapitre décrit une architecture logicielle du
contrôle d’accès reponsant sur les systèmes de gestion de bases de données pour le sto-
ckage des politiques. Nous présentons également une bibliothèque pour la manipula-
tion de dépendances que nous avons développée pour le raisonnement et la vériﬁcation
du contrôle d’accès.

Enﬁn, le dernier chapitre conclut la thèse en synthétisant et discutant notre ap-
proche et les principaux choix que nous avons faits. Le chapitre propose des perspe-
tives de recherche organisées selon cinq axes : la mise en œuvre d’une architecture de
contrôle d’accès, l’utilisation d’autres fragments de logique, l’extension du périmètre
du contrôle d’accès, l’étude des modèles d’administration et enﬁn la réutilisation de
nos travaux pour le domaine du contrôle d’accès aux réseaux.

Nous proposons de plus trois annexes. La première expose les notions de logique
du premier ordre auxquelles nous faisons référence. Cette première annexe décrit éga-
lement les liens qui unissent la logique aux fondements des bases de données relation-
nelles. La seconde annexe est technique. Elle propose des listes des principaux sym-
boles utilisés dans la thèse ainsi que des exemples de modèles de contrôle d’accès. La
troisième propose des traces de preuves obtenues avec notre prototype.

10

Chapitre 1. Introduction

Exemple 1.1 Un exemple hospitalier ﬁlé

La thèse est illustrée par des exemples d’applications. Aﬁn qu’ils soient homogènes
et qu’ils représentent des situations de la vie réelle, ils portent souvent sur un éta-
blissement hospitalier, voire plusieurs. Pour s’éviter de pesantes tournures comme
« supposons l’existence d’une structure hospitalière », nous proposons de prendre la
même. Ces exemples sont « ﬂottants », comme les ﬁgures ou les tableaux, et peuvent
être lus relativement indépendamment du texte qui les encadre.
L’établissement partiellement ﬁctif utilisé dans les exemples est désigné par l’acro-
nyme CHM : le Centre Hospitalier de Marlitémon. Ainsi, quand nous traitons de rôles,
nous évoquons des fonctions ou des professions de la santé, lorsqu’il s’agit de don-
nées, des dossiers patients sont pris comme exemples.
Le CHM est certes de taille modeste, environ 500 postes et 1.582 utilisateurs, mais
les applications se multiplient : déjà plus de 12 reparties sur six serveurs, eux-mêmes
sous des systèmes d’exploitation différents. Il va sans dire que ces applications sont
variées, allant d’antiques terminaux du bureau de gestion des entrées, au tout nouvel
intranet communautaire web 2.0 réparti sur les cinq sites du CHM.
Les membres de l’équipe informatique sont constamment occupés à résoudre des
problèmes de droits, que ce soit pour accéder à une imprimante, accéder à un dossier
administratif ou encore émettre un bon de commande. Il devient difﬁcile de s’assurer
qu’une modiﬁcation des droits ne va pas à l’encontre de ce que l’on prévoit. Face
à l’évolution des techniques et des besoins, les membres de l’équipe se retrouvent
encombrés de soucis qu’ils souhaiteraient bien éviter.

(6)Itiseasiertomoveaproblemaround(forexample,bymovingtheproblem
toadifferentpartoftheoverallnetworkarchitecture)thanitistosolveit.
(6a)(corollary).Itisalwayspossibletoaddanotherlevelofindirection.

Ross Callon – RFC1925, “The Twelve Networking Truths”

2

Contrôle d’accès au système d’information

⊲ Ce chapitre commence par déﬁnir les notions de sécurité des systèmes d’information auxquelles
s’intéresse la thèse, et notamment la place du contrôle d’accès dans le cadre général de la sécurité. Ensuite,
nous étudierons les modèles de contrôle d’accès selon :

les principes d’organisation des droits : de nombreux modèles de contrôle d’accès ont été proposés,
chacun introduisant de nouveaux principes et concepts pour faciliter la modélisation et l’admi-
nistration des droits. Nous mettrons en évidence que ces modèles partagent des principes et des
concepts communs,

les enrichissements : les principes fondateurs des modèles RBAC ayant largement été répandus, adap-
tés et repris dans des propositions de modèles contrôle d’accès, la littérature couvre désormais un
très large spectre d’extensions des modèles de base dont nous décrivons les principaux enrichisse-
ments,

les formalismes et modèles logiques proposés : plusieurs cadres logiques ont été proposés pour
formaliser les structures, les principes et les propriétés des modèles de contrôle d’accès. Nous
comparerons les cadres existants selon leur expressivité et les applications aux problématiques
du contrôle d’accès proposées.

Le choix d’un modèle logique est guidé d’une part, par le besoin d’expressivité nécessaire pour cap-
turer la richesse des modèles de contrôle d’accès et d’autre part par le besoin de décidabilité des structures
théoriques. Ce chapitre se termine par une synthèse présentée à l’aide de deux tableaux croisés, évaluant
d’une part les modèles de contrôle d’accès, et d’autre part les cadres logiques proposés pour leur étude.

L’annexe B synthétise les symboles utilisés pour les déﬁnitions de ce chapitre. ⊳

12

Chapitre 2. Contrôle d’accès au système d’information

Plan du chapitre

2.1

2.3

2.5

.

.
.
.

. .
. .
. .

. .
. .
. .

. .
. .
. .

. .
.
. .

. .
. .
. .

. .
. .
. .

. .

. .

. .
. .
. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .

. .
. .
. .
. .

2.2 Modèles historiques . .

2.4 Administration des modèles structurés . .
. .
. .

Synthèse de la structuration des droits d’accès .
. .
. .
. .

Primitives d’administration . .
. .

. .
. .
. .

. .
. .
. .

. .
. .
. .

.

. .
. .
. .
. .
. .
. .

Place du contrôle d’accès dans la sécurité .
2.1.1
2.1.2
2.1.3

. .
Synthèse des modèles historiques
. .

. .
. .
. .
. .
Concept de rôle pour structurer les droits . .
. .

. .
Introduction à la sécurité des systèmes d’information . .
.
Politique de sécurité .
. .
. .
Politique de contrôle d’accès
.
. .
2.2.1 Matrice de contrôle d’accès et modèles discrétionnaires .
. .
2.2.2 Modèles à niveaux et mandataires . .
. .
. .
. .
. .
2.2.3 Modèles basés sur les vues
. .
. .
. .
2.2.4
. .
Structuration du contrôle d’accès
. .
. .
. .
. .
2.3.1
. .
2.3.2 Hiérarchisation des rôles .
. .
. .
2.3.3 Autres concepts pour la structuration des droits . .
2.3.4
. .
. .
. .
. .
. .
. .
. .
. .
.
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

.
.
.
.
.
.
.
.
.
.
.
Représentation graphique de modèles et de politiques
Synthèse de l’administration des modèles structurés .
.
.
Séparation des tâches et exclusion mutuelle .
.
. .
Intégration du contexte . .
. .
Interdictions et politiques hybrides . .
.
. .
Vers le contrôle d’accès basé sur des cadres logiques .
.
.
.
.
.
.
.
.
.
.

2.4.1
2.4.2 Modèle d’administration .
2.4.3
2.4.4
Enrichissements et extensions des modèles structurés . .
. .
2.5.1
. .
2.5.2
2.5.3
. .
2.5.4

. .
. .
. .
Cadres pour la gestion de la conﬁance . .
. .
Cadres pour le contrôle d’accès . .
. .
Cadre basés sur la représentation graphique . .
. .
. .
. .
. .
. .
. .

. .
. .
Structuration des droits
.
2.7.1
Intégrité des politiques . .
2.7.2
. .
2.7.3
Cadres logiques . .
. .
2.7.4 Notre approche . .
2.7.5
. .

. .
. .
Tableaux de synthèse .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .

2.6 Cadres logiques pour le contrôle d’accès .

2.7 Discussion et synthèse .

. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .

2.6.1
2.6.2
2.6.3

. .
. .
. .
. .

.

.

.
.
.
.
.
.

. .

. .

. .
. .
. .

.

. .

. .

. .
. .

. .

. .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

13
13
14
15
16
17
20
22
24
24
25
27
29
33
34
34
35
37
37
38
38
41
45
47
48
49
51
53
54
54
55
56
56
58

Section 2.1. Place du contrôle d’accès dans la sécurité

13

2.1 Place du contrôle d’accès dans la sécurité

LA notion de système d’information couvre l’ensemble des éléments qui participe à

la collecte, au stockage, à la gestion, au traitement et à la diffusion de l’information
au sein des organisations. Cette déﬁnition recouvre à la fois des processus manuels et
automatisés. Dans la thèse, nous nous intéressons principalement aux systèmes d’infor-
mation informatisés, c’est-à-dire aux ressources matérielles et logicielles des systèmes.

2.1.1 Introduction à la sécurité des systèmes d’information

Les principes de la qualité incitent les concepteurs, développeurs et autres acteurs
à prendre en compte les propriétés non fonctionnelles dans le développement des sys-
tèmes d’information [ISO91]. Une de ces propriétés est la sécurité : la propriété qui per-
met aux utilisateurs d’avoir une conﬁance justiﬁée dans le système et dans les services
qu’il délivre. Cette notion dépasse largement le cadre des systèmes d’information in-
formatisés, et couvre des domaines allant de la sécurité physique à la sécurité logique.
La propriété de sécurité peut être analysée selon plusieurs sous-propriétés :

– la conﬁdentialité, l’information ne doit être accessible qu’aux ayants droits,
– l’intégrité, l’information doit être cohérente et valide,
– la disponibilité, le système doit être accessible et prêt à l’emploi,
– la ﬁabilité, la continuité des services rendus doit être assurée,
– la maintenabilité, le système doit être corrigible et capable d’évoluer,
– la sûreté de fonctionnement1, le système ne doit pas provoquer de dégâts.
Lorsqu’on traite de sécurité l’information, on s’attache plus précisément à considé-
rer la sécurité comme la combinaison des trois propriétés de conﬁdentialité, d’intégrité
et de disponibilité [Rihaczek91]. D’autres facettes peuvent être intégrées à cette notion,
en particulier pour les domaines d’application où la sécurité revêt un aspect impor-
tant. C’est le cas du secteur de la santé et des affaires sociales [Abou El Kalam03]. On
peut alors introduire des propriétés additionnelles comme l’auditabilité (les accès et les
opérations doivent être enregistrés), l’authenticité (la propriété d’être vrai) ou la non-
répudiation (l’impossibilité de nier être l’auteur d’un accès ou d’une opération).

De nombreuses pratiques et dispositifs participent à garantir les propriétés de sécu-
rité dans les systèmes d’informations : la protection des réseaux (par exemple : pare-feux,
détection d’intrusions), le cryptage de l’information, la sauvegarde des données, la re-
dondance matérielle et logicielle ou encore les architectures d’authentiﬁcation. Parmi les
moyens mis en œvre pour renforcer la sécurité, nous allons nous intéresser aux poli-
tiques de sécurité.

1Il est notable que cette déﬁnition de la « sûreté de fonctionnement » est celle entendue par « safety »
en anglais, c’est-à-dire la propriété de limiter les dégâts que le système puisse occasionner, ou de rendre
cette occurrence la moins probable possible [Deswarte03].

14

Chapitre 2. Contrôle d’accès au système d’information

Type

Description

Physique

restrictions d’accès

physiques aux ressources

Administrative

règlements et procédures
pour renforcer la sécurité

Logique

restrictions d’accès

logiques aux ressources
informatisées, mises en
œuvre par des logiciels et

matériels

Exemples
barrières
coffres
passesetclefs
enquêtes,audits
reponsabilisation
bonnespratiques
authentiﬁcation
identiﬁcation
cryptage
cloisonnement
organisationdesdroits

TAB. 2.1 – Spécialisations des politiques de sécurité

2.1.2 Politique de sécurité

Une politique de sécurité est [Rihaczek91] :

. . . the set of laws, rules and practices that regulate how sensitive information and
other resources are managed, protected and distributed within a speciﬁc system. It
shall identify the security objectives of the system and the threats to the system.

La mise en place d’une politique de sécurité est un dispositif organisationnel fonda-
mental pour garantir la sécurité de l’information d’un système. Cette politique peut être
spécialisée selon les propriétés auxquelles elle s’attache plus spéciﬁquement. On peut
distinguer parmi ces spécialisations [Solomon05] (tableau 2.1) :

– les politiques de sécurité physique qui déﬁnissent des procédures et des moyens
pour protéger les ressources des risques (électriques, incendies. . . ) et des accès
physiques aux matériels (postes de contrôle, barrières, blindages. . . ),

– les politiques de sécurité administrative qui régissent la sécurité organisationnelle

et les procédures en vigueur dans l’établissement,

– les politiques de sécurité logique qui font référence aux aspects informatiques et
techniques des systèmes et déﬁnissent les actions légitimes qu’un utilisateur peut
effectuer. La sécurité logique concerne deux aspects principaux :
– l’identiﬁcation et l’authentiﬁcation : donner et prouver son identité,
– l’autorisation, ou contrôle d’accès : la vériﬁcation de la légitimité des opérations

demandées, selon une politique de contrôle d’accès, ou politique d’autorisation

Nos travaux s’intéressent en particulier aux politiques de sécurité logique et plus
précisément à l’organisation des droits et au contrôle des accès aux systèmes. Nous
allons donc déﬁnir ces aspects.

Section 2.1. Place du contrôle d’accès dans la sécurité

15

2.1.3 Politique de contrôle d’accès

Contrôler les accès, c’est déterminer si un sujet peut effectuer une action demandée
sur un objet. Une permission est un droit d’action sur un objet, un privilège est l’affectation
d’une permission à un sujet. Les principaux ensembles impliqués sont représentés par :
– l’ensemble U des utilisateurs connus du système. Les utilisateurs utilisent le sys-

tème par l’intermédiaire d’un sujet,

– l’ensemble S des sujets connus du système. Les sujets peuvent être des processus,
des machines : toute entité informatique qui représente l’utilisateur au sein du
système et se comporte selon sa volonté,

– l’ensemble O des objets connus du système. Un objet est une entité du système
comme un tuple, une table (cas des systèmes de gestion de bases de données), un
objet ou un ﬁchier (cas des systèmes de ﬁchier),

– l’ensemble A des actions connues du système que l’on peut effectuer sur les ob-
jets. Les actions comprennent par exemple les opérations de sélection, suppres-
sion, modiﬁcation et création de tuples dans un système de gestion de bases de
données,

Déﬁnition (Contrôle d’accès [Lampson74]). Le contrôle d’accès est un mécanisme grâce
auquel un système autorise ou interdit les actions demandées par des sujets (entités actives)
sur des objets (entités passives).

FIG. 2.1 – Mécanisme de moniteur mis en œuvre pour réaliser le contrôle d’accès

16

Chapitre 2. Contrôle d’accès au système d’information

Le contrôle d’accès renforce particulièrement la conﬁdentialité et l’intégrité de l’infor-
mation, a fortiori sa disponibilité. Le contrôle d’accès est généralement mis en œuvre par
un moniteur, intermédiaire entre les utilisateurs et les ressources auxquelles ces derniers
essaient d’accéder.

La déﬁnition d’un tel moniteur est délicate, car ce dernier doit être incontournable,
inviolable et vériﬁé. Lorsqu’un utilisateur demande un accès, le moniteur va décider si
cet accès est autorisé ou non d’après la politique de contrôle d’accès : une instance spécia-
lisée de la politique de sécurité logique, qui s’attache à déﬁnir les droits des utilisateurs
des systèmes. Le principe de fonctionnement d’un moniteur est décomposable en six2
étapes, comme l’illustre la ﬁgure 2.1 :

1. envoi de la requête de l’utilisateur au moniteur,
2. interrogation de la politique de contrôle d’accès,
3. réponse de la politique,
4. le moteur accède à la ressource si l’accès est autorisé pour exécuter la requête,
5. retour de l’exécution de la requête,
6. retour de la requête ou exception en cas d’accès non autorisé.

La thèse s’intéresse aux politiques de contrôle d’accès logique, c’est-à-dire à la
déﬁnition des droits des utilisateurs des systèmes. Nos travaux concernent à la fois
l’expression des droits et leur gestion par les administrateurs de la sécurité. Les poli-
tiques de contrôle d’accès logique sont parmi les principaux dispositifs permettant de
garantir la sécurité des systèmes d’information. Structurer les droits, c’est-à-dire expri-
mer pourquoi et comment un utilisateur acquiert les privilèges, est l’objet des modèles
de contrôle d’accès, qui sont au centre de notre étude.

2.2 Modèles historiques de contrôle d’accès

Cette section présente les premières approches proposées sur le contrôle d’accès. Si
elles sont conceptuellement simples, elles ont néanmoins bénéﬁcié d’études approfon-
dies et de nombreuses applications. Cette étude est importante, car :

– les approches historiques sont à la racine des propositions ultérieures,
– ces recherches ont abouti à des résultats majeurs,
– elles permettent d’introduire les principales notions du contrôle d’accès,
– les modèles historiques ont largement été implémentés.

2En cas d’accès non autorisé, les étapes 4 et 5 n’ont pas lieu.

Section 2.2. Modèles historiques

17

2.2.1 Matrice de contrôle d’accès et modèles discrétionnaires

Les premières formalisations du contrôle d’accès sont dues à Lampson, qui parmi
les premiers a déﬁni les concepts de sujet, d’objet et d’actions [Lampson74]. Ces termes
sont traditionnellement3 repris dans la littérature sur le contrôle d’accès [Landwehr81].
Nous les utiliserons également tout au long de la thèse.

1
r
e
i
h
c
i
F

rw
r
r

2
r
e
i
h
c
i
F

r
rw
r

3
r
e
i
h
c
i
F

r
r
rw
r

4
r
e
i
h
c
i
F

rwx
rwx

r

Alice
Bob
Charly
Denise

TAB. 2.2 – Exemple jouet de matrice de contrôle d’accès

2.2.1.1 Principe

Le modèle de Lampson introduit dans ces premières études est la matrice de contrôle
d’accès qui permet de représenter le triplet d’autorisation ACCE SS entre sujets, actions
et objets ACCE SS ⊆ S × A × O. Cette représentation est à la base de nombreux déve-
loppements. Le tableau 2.2 est un exemple jouet de matrice de contrôle d’accès4, impli-
quant quatre sujets (en lignes), quatre objets (en colonnes) et trois actions (r pour read,
w pour write et x pour execute).

Le principal modèle de contrôle d’accès qui peut être exprimé grâce à cette matrice
est le contrôle d’accès discrétionnaire (Discretionnary Access Control – DAC). Ce modèle
est mis en œuvre dans de très nombreuses applications, comme les systèmes d’exploi-
tation de type Unix/Linux. Un modèle discrétionnaire est déﬁni comme [TCS85] :

. . . a means of restricting access to objects based on the identity of subjects and/or
groups to which they belong. The controls are discretionary in the sense that a sub-
ject with a certain access permission is capable of passing that permission (perhaps
indirectly) on to any other subject (unless restrained by mandatory access control).

Il existe une ambiguïté sur l’adjectif discrétionnaire, qui peut être entendu :
– soit comme le fait que les droits sont organisés selon une matrice de contrôle d’ac-
cès, où l’on peut lire les permissions des utilisateurs en lignes, ou en colonnes,

3Quelquefois sujet et utilisateur sont confondus, comme ressource et objet ou opération et action.
4Cette matrice servira d’exemple tout au long de la thèse.

18

Chapitre 2. Contrôle d’accès au système d’information

mais sans préciser si c’est une autorité qui déﬁnit les droits, où si ce sont les uti-
lisateurs qui peuvent le faire. Pour cette interprétation, certains auteurs préfèrent
traiter de contrôle d’accès basé sur l’identité (Identity-BAC) [Deswarte04],

– soit comme le fait que les utilisateurs peuvent eux-mêmes déﬁnir les droits d’accès
sur les ressources dont ils sont propriétaires. Pour cette interprétation, les sujets
sont eux-mêmes des objets et il existe une action supplémentaire owner dans la
matrice de contrôle d’accès. Cette action permet au sujet qui en dispose de déﬁnir
les opérations autorisées sur toute la colonne correspondante. C’est cette déﬁni-
tion de discrétionnaire que nous utiliserons dans la suite.

2.2.1.2 Administration des droits

De nombreux systèmes (par exemple, des systèmes d’exploitation ou de gestion de
bases de données) ont mis en œuvre le contrôle d’accès basé sur des matrices. Ces sys-
tèmes sont partitionables en deux grandes catégories, selon la méthode qu’ils proposent
pour administrer les matrices de contrôle d’accès :

– manipuler les permissions par lignes : Capabilities List (CL),
– manipuler les permissions par colonnes : Access Control List (ACL).

Exemple 2.1 Gestion des matrices de contrôle d’accès par listes

Au CHM, un service d’annuaire Lightweight Access Directory Protocol (LDAP) a été
mis en place par un valeureux stagiaire. Dans ce type d’annuaire, on peut déﬁnir
quels sont les droits des utilisateurs sur des nœuds et des feuilles d’un arbre, que
nous représentons par des ﬁchiers d’un système de ﬁchiers.
En se basant sur la matrice d’exemple du tableau 2.2, voici deux exemples de listes
qui permettent de représenter les droits des usagers sur les ﬁchiers 1,2 et 3 pour Alice
et Bob. La syntaxe proposée est un pseudolangage simpliﬁé, inspiré de ceux utilisés
dans les annuaires :

Type Access Control List

Type Capabilities List

GRANT r

SUBJECT Alice

ON : Fichier1, Fichier2,

Fichier3

TO : Alice, Bob

GRANT w

ON : Fichier1
TO : Alice
ON : Fichier2
TO : Bob.

IS GRANTED r
ON : Fichier1, Fichier2, Fichier3
IS GRANTED w
ON : Fichier1.

SUBJECT Bob

IS GRANTED r
ON : Fichier1, Fichier2, Fichier3
IS GRANTED w
ON : Fichier2.

La gestion des listes s’avère fastidieuse et sujette à erreurs en présence d’un grand
nombre d’utilisateurs et de permissions : les listes peuvent se chevaucher et il n’existe
pas de représentation unique d’une politique de contrôle d’accès.

Section 2.2. Modèles historiques

19

Les travaux de Lampson ont été repris par Harrisson, Ruzzo et Ullman pour étudier
l’administration des droits [Harrison76]. Les opérations administratives (par exemple,
ajouter des sujets, des ressources, déﬁnir les actions autorisées) qui permettent de ma-
nipuler les matrices de contrôle d’accès sont étudiées et le safety problem est caractérisé.
Ce problème est le suivant : à partir d’une politique de contrôle d’accès reconnue
comme sûre, est-il possible d’atteindre une politique non sûre, c’est-à-dire où les droits
disposent d’une propriété interdite. Les travaux ont prouvé que ce problème est in-
décidable dans le cas général, en réduisant ce problème à celui du problème de l’arrêt
d’une machine de Turing. Ce résultat limite fortement les ambitions de vériﬁcation des
politiques de contrôle d’accès.

Dans la démonstration du résultat, chaque politique est représentée par une matrice
de contrôle d’accès et des opérations administratives permettant de passer d’une poli-
tique à une autre sont déﬁnies à partir de six opérations primitives (ajouter et supprimer
des colonnes, ajouter et supprimer des lignes, ajouter et supprimer des actions dans une
cellule de la matrice). Par exemple : l’opération administrative GrantREAD(S1, S2, O) ac-
corde au sujet S2 le droit de lecture sur l’objet O si S1 est propriétaire de O.

Les auteurs ont cependant montré que le safety problem est décidable si des restric-
tions fortes (par exemple, si l’on ne peut ajouter ni d’objets ni de sujets à la matrice)
sont imposées sur le modèle de contrôle d’accès.

Théorème (Indécidabilité du safety problem [Harrison76]). It is undecidable whether a
given conﬁguration of a given protection system is safe for a given generic right.

2.2.1.3 Problèmes soulevés

Les modèles discrétionnaires ont une faiblesse importante : on ne peut plus contrô-
ler ce qui est fait de l’information une fois que celle-ci a été accédée par un utilisateur
légitime. Le problème majeur de la transitivité de la lecture qui en découle peut être
une source de diffusion de chevaux de Troie.

Outre le problème de la transitivité du droit de lecture et de l’indécidabilité dans
le cas général du safety problem pour les modèles DAC, une des critiques adressées aux
modèles basés sur les matrices est qu’ils sont difﬁciles à administrer dans de grandes
structures. Quand les organisations comportent de nombreux sujets et objets et lorsque
des changements fréquents ont lieu dans les droits, il devient impossible de dégager
une vision globale de l’organisation des droits et de garantir la sécurité du système.
C’est pour répondre à ces problèmes que les modèles à niveaux sont apparus.

20

Chapitre 2. Contrôle d’accès au système d’information

Exemple 2.2 Transitivité de la lecture des systèmes DAC

Au CHM, les mécanismes de partage de données des systèmes d’exploitation sont
utilisés par toute l’administration. Il arrive des fois qu’un document conﬁdentiel se re-
trouve mis en partage. Si ce dernier est lu par un utilisateur, alors il est difﬁcile de
contrôler l’usage qu’il en sera fait. Supposons l’état (sûr) suivant :
– La directrice des affaires ﬁnancières, Mme. F., est propriétaire d’un rapport sur le

budget prévisionnel de la cantine,

– Mme. F. donne le droit de lecture sur le rapport à M. S., pour qu’il le relise,
– Mme. F. ne donne le droit de lecture sur ce rapport à aucun autre sujet,
Ensuite, déﬁnissons un état comme non sûr si un autre sujet que M. S ou Mme. F.
peut connaitre le contenu du rapport, en particulier le responsable de la restauration.
Supposons la succession d’états suivant :
– M. S. fait une copie du rapport en l’enregistrant par mégarde dans le mauvais dos-

sier partagé,

– par défaut, son éditeur de texte donne le droit de lecture à tout le monde.
On a atteind un état non sûr dans lequel le redouté responsable de la restauration
peut prendre connaissance du contenu du rapport.

2.2.2 Modèles à niveaux et mandataires

2.2.2.1 Principe

Dans les modèles mandataires (Mandatory Access Control – MAC) les usagers ne
peuvent pas déﬁnir les droits d’accès, car ils ne sont pas propriétaires des données :
toutes les ressources informatiques sont la propriété exclusive de l’organisation.

Ces modèles sont basés sur la notion de niveau de sécurité : les objets et les sujets sont
classés par conﬁdentialité et un niveau leur est attribué. C’est à partir des niveaux de
sécurité attribués au requérant et à la ressource démandée que sont dérivées les actions
autorisées. Le tableau 2.3 présente les niveaux Conﬁdentiel-Défense, Secret-Défense, Très
Secret-Défense utilisés par le gouvernement français.

Déﬁnition (Contrôle d’accès mandataire [Sandhu93]). Le contrôle d’accès mandataire est
exprimé en termes de niveaux de sécurité associés aux sujets et aux objets et à partir desquels
sont dérivés les actions autorisées.

2.2.2.2 Flux de l’information dans les systèmes mandataires

À partir des niveaux, on déﬁnit des principes régissant la manière dont l’informa-
tion est transmise dans le système, ce qui va imposer les droits de lecture et d’écriture
des sujets. L’application de ces principes est en vigueur dans des systèmes militaires,
où plus généralement dans tout système où les sujets ne peuvent (ou ne doivent) pas

Section 2.2. Modèles historiques

21

Classiﬁcation
Très Secret-Défense

Secret-Défense

Conﬁdentiel-Défense

Description
Le niveau Très Secret-Défense est réservé aux infor-
mations ou supports protégés dont la divulgation
est de nature à nuire très gravement à la défense na-
tionale et qui concernent les priorités gouvernemen-
tales en matière de défense.
Le niveau Secret-Défense est réservé aux informa-
tions ou supports protégés dont la divulgation est
de nature à nuire gravement à la défense nationale.
Le niveau Conﬁdentiel-Défense est réservé aux infor-
mations ou supports protégés dont la divulgation
est de nature à nuire à la défense nationale ou pour-
rait conduire à la découverte d’un secret de la dé-
fense nationale classiﬁé au niveau Très Secret-Défense
ou Secret-Défense.

TAB. 2.3 – Exemple de classiﬁcation de conﬁdentialité [Journal Ofﬁciel98]

se faire conﬁance. Les principes de contrôle du ﬂux de l’information imposent qu’un
sujet doive recevoir des informations provenant de sujets de plus faible accréditation, et
transmettre des informations à des sujets de plus haute accréditation.

2.2.2.3 Administration

L’administration des modèles mandataires est uniquement basée sur l’attribution
des niveaux de sécurité et sur les principes de transmission de l’information : c’est le
système qui, à partir de deux règles de contrôle du ﬂux de l’information, détermine les
opérations autorisées en fonction de l’accréditation du requérant et de la classiﬁcation
de l’objet. Les règles présentées dans le tableau 2.4 sont celles du modèle de Bell et
LaPadula [Bell75], orienté conﬁdentialité. Le modèle de Biba et Denning [Denning76]
est quant à lui orienté intégrité des données et propose deux règles duales de celles de
Bell et LaPadula où écriture et lecture sont inversées.

2.2.2.4 Problèmes soulevés

Les premiers modèles DAC ont proposé d’organiser les niveaux selon un ordre
strict [Bell75, Denning76]. Cette contrainte a été relaxée par les modèles où les niveaux
sont organisés selon des treillis [Sandhu93]. Cette hiérarchisation des niveaux accorde
une plus grande liberté de modélisation aux administrateurs du contrôle d’accès.

22

Chapitre 2. Contrôle d’accès au système d’information

Propriété
Simple security rule No read up

Nom commun Description

Un sujet accrédité d’un niveau donné ne
peut pas accéder en lecture à des objets d’un
niveau plus élevé

⋆-property

No write down Un sujet accrédité d’un niveau donné ne
peut pas accéder en écriture à des objets
d’un niveau moins élevé

TAB. 2.4 – Principes du modèle de Bell et LaPadula [Bell75]

Les modèles DAC sont bien adaptés aux systèmes à haute conﬁdentialité et forte-
ment structurés – les systèmes militaires par exemple – ou plus généralement pour
tout environnement clos et contrôlé – comme les systèmes bancaires. Cependant, pour de
grandes organisations ils s’avèrent trop rigides, car il est difﬁcile de classer objets et
sujets dans un nombre prédéﬁni de niveaux de sécurité.

Les systèmes de gestion de base de données ayant utilisé les modèles mandataires
n’ont eu que peu de succès commercial, vraisemblablement à cause de leur rigidité et
de la hiérarchisation stricte qu’ils imposent aux utilisateurs et aux objets. Une formali-
sation logique à l’aide de règles DATALOG des principes des modèles DAC appliqués
aux bases de données a été proposée [Cuppens99, Cuppens00].

2.2.3 Modèles basés sur les vues

2.2.3.1 Principes

Dans les systèmes de gestion de bases de données relationnelles, le niveau le plus
proche de l’utilisateur est composé de vues : des représentations construites sur le mo-
dèle logique de données sous-jacent. Une vue dans une base de données est assimilable
à une requête conjonctive sur la base à laquelle on a donné un nom : elle peut être soit
virtuelle – elle est calculée sous forme de réécriture de requêtes – soit matérialisée – elle
est stockée puis mise à jour. Le concept de vue est utilisé entre autres pour exprimer les
politiques d’autorisation dans les systèmes de gestion de base de données en limitant
l’accès au modèle logique. Une vue sur une base de données R s’exprime en logique
par une formule close de la forme [Abiteboul95] :

ans(e1, . . . , em) ← R1(u1) ∧ . . . ∧ Rn(un) ∧ φ(u)

Dans cette expression, les Ri sont des noms de relations de R, ans est un nom de
relation ne faisant pas partie de R, les ui sont des tuples (utilisant soit des variables
soit des constantes) et φ(u) est une conjonction de contraintes arithmétiques (prédicats
built-in) sur les termes ui. La relation ans est donc une relation déﬁnie en intention.

Section 2.2. Modèles historiques

23

Lorsqu’elles sont utilisées à des ﬁns de contrôle d’accès, les vues permettent de

masquer certaines données à l’utilisateur soit :

– en interdisant l’accès à des attributs d’une relation, pour que les utilisateurs
n’aient pas connaissance de tout une colonne d’une table, en utilisant la projection
par exemple,

– en interdisant l’accès à des tuples d’une relation, pour que les utilisateurs n’aient
pas connaissance de certaines lignes d’une table, en utilisant par exemple la sé-
lection.

2.2.3.2 Administration

Les vues sont, du point de vue du contrôle d’accès, des objets abstraits qui masquent
les objets concrets sous-jacents. L’administration des vues se base sur les primitives
déﬁnies dans le système de gestion de base de données. Les droits sur les vues sont ainsi
manipulés comme des droits sur des relations classiques. La grammaire du langage
d’administration du standard Structured Query Language (SQL) est [ISO99] :

GRANT <action> ON <objet>
TO <sujet>
[WITH GRANT OPTION]

<action> ::= ALL |

SELECT | DELETE |

INSERT [<attribut>]| UPDATE [<attribut>]|
REFERENCE [<attribut>]

<objet> ::= TABLE <relation> * | VIEW <vue> *
<sujet> ::= PUBLIC| <sujet> *

2.2.3.3 Problèmes soulevés

Comme l’illustre l’exemple « utilisation du concept de vue pour contrôler les ac-

cès », les modèles basés sur les vues posent les problèmes de :

– la cohérence des droits. En reprenant l’exemple du personnel externe, supposons
qu’un administrateur autorise l’accès en lecture à la table Personnel directement
à tout utilisateur. Le règlement stipulant que l’adresse des employés ne doit pas
être accessible est contourné,

– la maintenance des multiples contrôles d’accès implémentés par l’intermédiaire
des vues. Dans l’exemple proposé, pour chaque service de l’organisation il de-
vient nécessaire de déﬁnir une nouvelle vue, avec le risque d’explosion combina-
toire du nombre de vues et de droits accordés sur ces vues.

24

Chapitre 2. Contrôle d’accès au système d’information

Exemple 2.3 Utilisation du concept de vue pour contrôler les accès

Au CHM, une application de gestion du personnel est utilisée. Cette application est
principalement une interface graphique pour accéder à des données gérées avec un
système de gestion de bases de données. Le schéma de base de données manipulé
par cette application est composé de trois relations :
– Personnel(ID, Nom, Prenom, Adresse), les employés,
– Service(ID, Description, Lieu), les services médicaux,
– A f f ectation(IDPersonne, IDService), les affectations des personnes.
La vue PersonnelExterne(Nom, Prenom, Lieu) permet de restreindre les accès au
seuls champs nom et prénom des personnes du bureau externe, sans avoir accès
à leurs adresses personnelles, elle est exprimable en logique par :

Personnel(IDP, N, P, A) ∧ Service(IDS, D, L)∧
A f f ectation(IDP, IDS) ∧ D = bureauExterne
→ PersonnelExterne(N, P, L)

2.2.4 Synthèse des modèles historiques

Les organisations des droits historiques présentées dans cette section ont introduit
les principes génériques du contrôle d’accès. Le souci d’imposer des règles strictes à
conduit à introduire la notion de niveaux d’accès : des intermédiaires organisés entre
sujets et permissions qui n’existent pas dans les approches matricielles. Nous verrons
que ce principe générique de structuration des droits a donné naissance à de grandes
familles de modèles.

2.3 Structuration du contrôle d’accès

Après l’organisation hiérarchique stricte des modèles à niveaux, de nouvelles or-
ganisations des droits ont été proposées à partir des années 90 : les modèles à rôles
(Role-Based Access Control – RBAC). Le principe général de ces modèles est d’introduire
un niveau d’indirection entre utilisateurs et permissions, en faisant en sorte que cette
nouvelle abstraction permette [Ferraiolo03b] :

– d’organiser les droits de la façon la plus proche possible de la structure des or-
ganisations, aﬁn de permettre aux administrateurs de manipuler les droits d’une
façon plus intuitive,

– de limiter le nombre d’affectations des permissions, pour éviter les erreurs en

réduisant la taille des politiques,

– d’exprimer de nouvelles règles et contraintes, qui permettront de traduire facile-

ment les politiques exprimées en langue naturelle.

Section 2.3. Structuration du contrôle d’accès

25

FIG. 2.2 – Représentation du modèle RBAC1 (UML)

2.3.1 Concept de rôle pour structurer les droits

2.3.1.1 Noyau du modèle

Le concept central de rôle dans les modèles RBAC est déﬁni comme [Sandhu96] :


auth_users(r) = {u ∈ U | r′ (cid:23) r ∧ (u, r′) ∈ U RA}

∀r ∈ R assigned_users(r) ⊆ auth_users(r)

Déﬁnition (Permissions affectées et autorisées). L’application assigned_perms : R →
2P, fait correspondre à un rôle l’ensemble des permissions qui lui sont explicitement affectées.
L’application auth_perms : R → 2P fait correspondre à un rôle l’ensemble des permissions
autorisées :

assigned_perms(r) = {p ∈ P | (r, p) ∈ PRA}

auth_perms(r) = {p ∈ P | r′ (cid:22) r ∧ (r′, p) ∈ PRA}

∀r ∈ R assigned_perms(r) ⊆ auth_perms(r)

Après l’introduction de la hiérarchie dans les modèles RBAC, plusieurs propositions
ont repris cette notion dans de nouveaux modèles de contrôle d’accès. Par exemple,
pour hiérarchiser les objets [Barker03], les contextes [Covington01], les zones géogra-
phiques [Damiani07] ou les différents concepts du modèle ORBAC [Miège05]. La sec-
tion suivante va présenter d’autres concepts intermédiaires que les rôles pour structurer
les droits d’accès.

2.3.3 Autres concepts pour la structuration des droits

Dans certaines applications, la seule notion de rôle ne permet pas de reﬂéter ﬁdè-
lement les structures des organisations. Des auteurs ont alors proposé d’intégrer dans
les modèles de contrôle d’accès d’autres concepts, soit en ajoutant des concepts supplé-
mentaires à ceux des modèles RBAC, soit en les remplaçant. Cette section va présenter
les principaux concepts intermédiaires introduits entre utilisateurs et permissions.

30

Chapitre 2. Contrôle d’accès au système d’information

2.3.3.1 Concept d’organisation

Le modèle Organization-Based Access Control (ORBAC) est construit autour de la
notion centrale d’organisation [Abou El Kalam03, Cuppens04a, Cuppens04b, Miège05].
ORBAC rassemble plusieurs concepts introduits dans différents modèles (rôle, vue,
équipe, . . . ) et les relie par l’intermédiaire de la notion d’organisation. Les principes
de hiérarchies [Cuppens04a], de contraintes [Cuppens03, Miège05] et de modèle d’ad-
ministration [Cuppens04b] ont également été repris dans ORBAC.

La ﬁgure 2.5, simpliﬁée de [Abou El Kalam03], illustre la structuration proposée du

modèle ORBAC. Cette illustration est divisée en trois parties :

– la partie supérieure de ce schéma est la politique abstraite, composée des concepts
de rôle, de vue, d’activité et de contexte, communs à l’ensemble des organisations.
La relation entre ces concepts génériques permet de déﬁnir des permissions abs-
traites,

– la partie inférieure est la politique concrète, composée des concepts de sujet, action
et objet propres à chaque organisation et desquels sont dérivées les permissions
concrètes.

– la partie intermédiaire joue le rôle de médiateur entre les parties supérieures et
inférieures, elle va instancier la politique abstraite en une politique concrète, en
faisant correspondre aux rôles, vues et activités abstraits des utilisateurs, objets et
actions concrets du système.

Le concept d’organisation est ainsi un élément pivot entre les politiques abstraites
– consensuelles entre les organisations – et les concrètes – spéciﬁques à chaque or-
ganisation. En effet, le modèle ORBAC est structuré grâce à trois relations ternaires :
Habilitation, Consid ´eration, Utilisation, toutes liées au concept d’organisation. Cette
particularité permet d’exprimer le fait qu’une personne puisse disposer de rôles dif-
férents dans des organisations différentes, propriété qui n’est pas exprimable dans
d’autres modèles. Par exemple, le modèle RBAC est uniquement composé de relations
binaires entre les concepts du modèle.

2.3.3.2 Concept d’équipe

La notion d’équipe a été proposée dans le modèle TMAC (TeaM-based Access Control),
où les permissions sont associées aux rôles ainsi qu’aux équipes. Les privilèges dont
disposent les utilisateurs sont l’union des permissions accordées aux rôles qu’endossent
les utilisateurs et des permissions accordées aux équipes dont les utilisateurs font par-
tie [Thomas97a].

La notion d’équipe a été introduite pour représenter des aspects transversaux des
rôles qui ne sont pas directement exprimables dans les modèles RBAC. Le principe de
TMAC est d’accorder à chaque utilisateur membre d’une équipe l’union des permis-
sions accordées aux autres membres de l’équipe actuellement actifs, en plus des permis-

Section 2.3. Structuration du contrôle d’accès

31

FIG. 2.5 – Représentation du modèle ORBAC (UML)

sions accordées par les rôles qu’il endosse. Les relations de ce modèle sont dynamiques,
car les permissions sont accordées par l’intermédiaire des sessions actives des membres
d’une équipe. Il s’agit d’un modèle par essence dynamique, dans lequel les droits effec-
tifs sont évaluables seulement lors des requêtes d’accès en non une fois pour toutes.

2.3.3.3 Concept de tâche

Les modèles à niveaux sont dits « orientés ﬂux » : l’attribution des droits est basée
sur l’autorité des acteurs et les règles régissant la transmission de l’information à des
acteurs de niveaux différents. Plusieurs approches ont pris en compte la notion de ﬂux
de l’information pour organiser les droits.

La famille des modèles TBAC (Task-Based Access Control) [Thomas97b] est organisée
en quatre modèles, comme la famille RBAC (ﬁgure 2.3). La famille des modèles TBAC
propose de structurer les droits selon les tâches que les acteurs du système d’informa-
tion doivent effectuer, mais sans concept de rôle. Les autorisations sont ainsi vériﬁées
au ﬁl de l’exécution des activités qui sont décomposées en tâches.

La famille des modèles WRBAC (Workﬂow Role-Based Access Control) [Wainer03,
Wainer07] se base quant à elle sur la notion de rôle, mais rafﬁne le modèle RBAC en
y introduisant les concepts :

32

Chapitre 2. Contrôle d’accès au système d’information

Exemple 2.4 L’équipe comme aspect transversal des rôles

Le CHM se retrouve établissement témoin pour mettre en œuvre un nouvel équipe-
ment mobile. Certains utilisateurs se retrouvent équipés d’assistants personnels. Le
dispositif est censé permettre un meilleur suivi du patient. Le logiciel déployé utilise le
modèle RBAC, et trois rôles ont été déﬁnis :
– le rôle Infirmier,
– le rôle M´edecin,
– le rôle Secr´etaire.
Chaque rôle dispose d’un ensemble de permissions permettant de réaliser les tâches
dont il a la charge. Le CHM est structuré en équipes de soins, chacune étant composée
d’un ou plusieurs inﬁrmiers, médecins et secrétaires. L’une d’entre elles est l’équipe
pilote qui évalue la mise en œuvre de TMAC.
Le modèle RBAC ne permet pas à un secrétaire ou un inﬁrmier de saisir des diag-
nostics. Cependant, dans certaines situations (urgence par exemple), en présence du
médecin responsable de son équipe, un inﬁrmier devrait pouvoir saisir des diagnos-
tics. Le modèle TMAC permet d’exprimer cette attribution dynamique de permission.

– d’une unité organisationnelle (organizational unit), c’est un groupe d’utilisateurs

dont un est désigné comme étant le responsable de l’unité.

– de cas d’utilisation (case), c’est une relation entre privilèges et utilisateurs qui per-

met de modéliser les activités métiers. Elle représente les ﬂux dans le système.

Ces familles de modèles ont été proposées pour contrôler l’exécution des activités
dans les processus métiers, ces derniers étant découpés en tâches élémentaires qui sont
composées pour former des activités complexes. Ainsi, le cas d’utilisation de « la réser-
vation d’un voyage » va être composé de l’achat d’un billet d’aller, la réservation d’un
hôtel, la location d’un véhicule sur place, l’achat de billets de spectacle, etc.

Les auteurs de [Bertino99] ont organisé leur proposition de contrôle d’accès autour
de la notion de processus métier. Leur motivation est de combler une lacune des mo-
dèles RBAC : il est difﬁcile avec des rôles de spéciﬁer que des tâches doivent être effec-
tuées par des utilisateurs différents. Les modèles orientés ﬂux visent principalement à
renforcer le principe séparation des tâches (Separation of Duties – SOD). Ce principe a été
introduit dans [Clark87], approfondi dans [Nash90] puis repris dans différents modèles
de contrôle d’accès [Sandhu96, Bertino99, Thomas97b, Abou El Kalam03].

Déﬁnition (Principe de séparation des tâches [Nash90]). La séparation des tâches est
un principe de sécurité qui impose que les acteurs qui interviennent dans la réalisation d’une
tâche soient différents.

Dans le cas général, la séparation des tâches s’exprime par une règle de la forme
« il faut qu’au moins n utilisateurs différents interviennent dans ce processus métier »,
comme à chaque étape du processus métier correspondent des tâches qui nécessitent
des permissions, on peut exprimer la séparation des tâches comme une contrainte de la

Section 2.3. Structuration du contrôle d’accès

33

forme « il ne peut pas y avoir (n − 1) utilisateurs qui disposent à eux seuls de l’ensemble
des permissions pour effectuer l’ensemble du processus » [Nash90].

Le besoin d’exprimer la séparation des tâches a été pris en compte dans les mo-
dèles contrôle d’accès. Il a reçu une attention particulière dans les modèles RBAC. Les
notions de contraintes introduites dans le modèle RBAC2, et plus précisément la notion
d’exclusion mutuelle, ont été développées à cet effet. Ces contraintes permettent de limi-
ter les privilèges des utilisateurs et augmentent le pouvoir d’expression des modèles
RBAC.

Exemple 2.5 Exemple de séparation des tâches

Au CHM, les commandes de produits pharmaceutiques sont quotidiennes. Une ap-
plication permet heureusement de traiter ces commandes, en les groupant automa-
tiquement par fournisseurs, dates, etc. Les étapes identiﬁées pour exercer l’activité
sont :

1. passer une commande de produits et enregistrer le bon de commande,
2. réceptionner la facture et vériﬁer qu’elle correspond à la commande,
3. réceptionner les produits et vériﬁer qu’ils correspondent à la facture,
4. autoriser le paiement sur facture.

La politique de sécurité pourraita imposer qu’aucun utilisateur ne puisse commander
et autoriser le paiement de sa propre commande aﬁn d’éviter des abus de pouvoir, des
détournement d’argent ou encore des contrats de complaisance. Il s’agit d’un exemple
de contrainte de séparation des tâches.

aUNE POLITIQUE SÉVÈRE DEVRAIT MÊME IMPOSER QUE CE SOIT LE CAS.

2.3.4 Synthèse de la structuration des droits d’accès

De nombreux concepts ont été introduits pour structurer les droits d’accès selon
l’activité et le métier des utilisateurs du système. Ces notions sont toutes des intermé-
diaires entre les utilisateurs et les permissions du système. Ainsi, selon les spécialités
des organisations, il peut être intéressant d’introduire la notion de ﬂux, d’équipe ou de
rôle pour représenter le plus ﬁdèlement possible les interactions et les responsabilités
des acteurs. Selon les activités, l’utilisation de hiérarchies multiples peut être un choix
de modélisation pertinent.

Il est donc difﬁcile de considérer qu’un modèle de contrôle d’accès est meilleur
qu’un autre : cela dépend essentiellement du domaine d’application et du type de l’or-
ganisation qui le met en œuvre. Par exemple, les modèles à niveaux sont bien adaptés
aux structures très organisées, où la conﬁdentialité est une priorité. C’est pourquoi les
organisations militaires et banquaires les utilisent encore.

34

Chapitre 2. Contrôle d’accès au système d’information

D’un autre côté, certaines structures ont des organisations beaucoup plus souples
et complexes. Elles souhaitent alors déﬁnir leurs propres modèles de contrôle d’accès
adaptés à leur besoins. Pour les établissements de santé par exemple, le Groupement
pour la Modernisation du Système d’Information Hospitalier (GMSIH) a proposé un
modèle de contrôle d’accès sur mesure, adapté aux métiers de la santé. Ce modèle
réutilise les concepts présentés dans cette section (rôle, organisation, hiérarchies) et en
introduit de nouveaux [GMSIH03].

Les propositions basées sur les rôles forment la plus grande famille des modèles de
contrôle d’accès et sont les plus étudiées du domaine. Un standard des modèles RBAC
a été déﬁni [Ferraiolo01, Ferraiolo03b]. Il formalise les principes des modèles RBAC
et spéciﬁe les primitives nécessaires à leur implantation. Or d’une part, ce standard
souffre encore de lacunes [Li07], et d’autre part la mise en œuvre de RBAC dans les
systèmes ne respecte pas toujours les standards. Des extensions, des adaptations ou
même des modiﬁcations structurelles étant introduites (en particulier dans les grands
systèmes comme Solaris ou Oracle).

2.4 Administration des modèles structurés

Dans les modèles structurés, les concepts intermédiaires entre utilisateurs et per-

missions ont une place centrale dans l’administration des droits :

– ils représentent les responsabilités ou les activités des utilisateurs,
– leurs hiérarchisations permettent de représenter la structure de l’organisation,
– ils sont obligatoires : il n’y a pas d’affectation directe de permissions aux utilisa-

teurs, les privilèges sont toujours acquis par l’intermédiaire des concepts.

Cette section sur l’administration des politiques de contrôle d’accès structurées s’in-
téresse aux mécanismes et principes mis en œuvre pour manipuler les concepts et rela-
tions ainsi que pour organiser les droits des administrateurs sur les politiques.

2.4.1 Primitives d’administration

Une fois qu’une organisation a décidé de mettre en place un modèle de contrôle
d’accès, il faut développer des outils pour permettre aux administrateurs de déﬁnir et
faire évoluer les droits du système. Pour les modèles RBAC, un ensemble d’opérations
nécessaires est proposé dans le standard qui se compose de deux parties [Ferraiolo01,
Ferraiolo03b] :

– d’une part, la spéciﬁcation ensembliste des modèles de la famille RBAC (RBAC0,
RBAC1, RBAC2 et RBAC3) et la formalisation partielle en logique du premier ordre
des propriétés qu’une politique doit respecter pour être intègre. Cette formalisa-
tion a été reprise et étendue par les autres modèles intégrant également la no-
tion de rôle [Thomas97b, Damiani07, Barker03, Covington01]. Dans l’état de l’art,

Section 2.4. Administration des modèles structurés

35

nous avons repris la formalisation proposée des modèles RBAC, en prenant en
compte les critiques qui lui ont été adressées [Li07]. Cette première partie du stan-
dard donne la structure de la politique de contrôle d’accès à rôles,

– d’autre part, la spéciﬁcation des fonctionnalités attendues d’une implantation des

modèles RBAC, que nous désignons par primitives d’administration :
– les opérations de revue, c’est-à-dire les primitives permettant l’interrogation
d’une politique. En termes d’opérations dans une base de données, il s’agit du
langage de requêtes de la politique,

– les opérations de manipulation, c’est-à-dire les primitives permettant l’ajout, la
suppression et la modiﬁcation de données dans une politique. En termes d’opé-
rations dans une base de données, il s’agit du langage de manipulation,

Les spéciﬁcations du standard RBAC déﬁnissent la sémantique des opérations sur
la politique ainsi que les préconditions et postconditions devant êtres vériﬁées pour
que ces opérations ne rendent pas la politique incohérente [Ferraiolo03b, Gavrila98].
Les spéciﬁcations des primitives d’administration sont utilisées dans la déﬁnition des
modèles d’administration [Sandhu99].

Cette partie du standard n’a pas été aussi bien développée dans les modèles de
contrôle d’accès autres que RBAC. Comme les opérations administratives et de revue
sont des droits sur les politiques, les auteurs ont proposé de les organiser selon des
modèles d’administration. Il s’agit donc de « métapolitiques » de contrôle d’accès : des
organisations des permissions des administrateurs.

2.4.2 Modèle d’administration

Avec l’informatique contemporaine, il peut être difﬁcile d’envisager une adminis-
tration monolithique centralisée d’une politique de contrôle d’accès de taille considé-
rable. Généralement, plusieurs administrateurs interviennent sur une même politique,
avec ou sans partage des responsabilités strictement déﬁni. Dans le cas de grandes or-
ganisations, le nombre d’administrateurs peut devenir assez grand pour qu’une struc-
turation de leurs privilèges soit nécessaire.

Une fois un modèle structuré reconnu et accepté, un modèle d’administration du mo-
dèle de base peut être proposé. Le principe de cette approche, qui a été repris dans
plusieurs propositions, est d’ajouter des concepts et relations administratifs au modèle
de base. Le modèle d’administration organise les privilèges des administrateurs.

Dans plusieurs propositions [Sandhu99, Cuppens04b], le modèle d’administration
est un modèle « miroir » du modèle de base qui s’organise selon les mêmes principes :
les concepts et relations introduits dans le modèle de base sont utilisés pour structurer
les droits des utilisateurs ﬁnaux ainsi que ceux de leurs administrateurs. L’objectif de
ces modèles est d’avoir une structuration homogène de l’ensemble des droits. Parmi les
propositions qui ont suivi cette démarche, on retrouve les modèles d’administration :

36

Chapitre 2. Contrôle d’accès au système d’information

FIG. 2.6 – Modèle d’administration de RBAC : ARBAC (UML)

– Administrative-RBAC (ARBAC) pour les modèles RBAC [Sandhu99, Sandhu98],
– Scoped-Administrative-RBAC (SARBAC) qui reprend ARBAC en utilisant la notion
de portée administrative sur la hiérarchie de rôles [Crampton03b, Crampton05],

– Administrative-ORBAC (ADDORBAC) pour ORBAC [Cuppens04b],
– X-GTRBAC-Admin, pour le modèle GTRBAC [Bhatti05].
La ﬁgure 2.6 est une représentation UML de ARBAC (Administrative Role-Based Access
Control) le modèle d’administration de RBAC. Dans ARBAC, les concepts de rôles admi-
nistratifs et de permissions administratives sont introduits. Les permissions administra-
tives sont les opérations qui permettent d’ajouter, modiﬁer ou supprimer des concepts
et relations « classiques » dans les politiques RBAC. Des exemples sont l’affectation et
la révocation de rôles aux utilisateurs, l’affectation et la révocation de permissions aux
rôles ou encore l’affectation et la révocation de relations d’héritage entre rôles.

La hiérarchisation des concepts dans les modèles de contrôle d’accès revêt une place
stratégique dans l’administration des politiques structurées : la hiérarchie est l’élément
pivot sur lequel vont être opérées la majeure partie des opérations d’administration.
Ainsi, disposer d’une bonne hiérarchie est indispensable pour tirer parti des modèles
structurés [Coyne96].

Pour les modèles à rôles, il est reconnu comme bénéﬁque d’organiser les droits des
administrateurs à partir de la hiérarchie des rôles [Crampton05]. Or d’une part, l’iden-
tiﬁcation des rôles est délicate, mais d’autre part, la réorganisation en hiérarchie de
rôles déﬁnis précédemment sans ordre est une tâche difﬁcile. Si mal entreprise, la hié-
rarchisation peut être un remède pire que le mal. Il est ainsi important d’assister les
administrateurs lors de l’identiﬁcation et de la hiérarchisation des rôles.

Section 2.4. Administration des modèles structurés

37

Exemple 2.6 Un méta de trop

Le CHM est très impliqué dans une collaboration régionale de lutte contre le cancer.
De nombreux administrateurs collaborent sur ce réseau de soin. Chacun d’entre eux
est responsable d’une partie d’un établissement de santé : il faut pouvoir organiser
leurs droits, car on projette à terme d’étendre le réseau.

Le modèle d’administration peut être différent du ou des modèles de contrôle d’accès.
On peut par exemple organiser les droits des administrateurs d’une politique ORBAC
avec un modèle mandataire : chaque administrateur aurait un niveau d’accréditation
lui permettant d’accéder à tout ou partie des primitives d’administration.

Dans une perspective visonnaire, les reponsables informatiques du réseau de soin on
choisi de mettre en œuvre un modèle RBAC. Les droits d’utilisation des primitives d’ad-
ministration peuvent alors être régis par le modèle ARBAC qui les structure grâce au
concept de rôle administratif. Quid des administrateurs qui manipulent les rôles admi-
nistratifs ? S’agit-il d’une instance encore plus haute que les administrateurs à l’échelle
régionale ? On pourrait imaginer un « modèle d’administration du modèle d’adminis-
tration ». L’expérience montre qu’un seul nouveau niveau d’indirection sufﬁt dans la
pratique.

2.4.3 Représentation graphique de modèles et de politiques

Une grande partie des failles dans les mécanismes de contrôle d’accès sont dues
à des erreurs humaines d’administration : avec un nombre croissant d’utilisateurs, les
politiques deviennent plus grandes, les cas particuliers plus nombreux et la gestion des
droits plus complexe. Ceci est d’autant plus vrai lorsque des enrichissements ou des
extensions de modèles sont intégrés dans les modèles de contrôle d’accès.

Il est admis que les outils d’aide à l’administration doivent être munis d’interfaces
graphiques appropriées, permettant à l’utilisateur de suivre les étapes des processus
automatisés qu’ils intègrent [Koch03, Tidswell01, Sandhu04]. Plusieurs formalismes
graphiques pour la gestion des politiques de contrôle d’accès ont été proposés : cer-
tains spéciﬁques à RBAC [Ferraiolo03a], d’autres plus génériques [Tidswell01, Koch03].
Ces propositions visent à faire correspondre des symboles et des actions graphiques
à des primitives d’administration. Comme à chaque représentation est généralement
associé un cadre logique sous-jacent donné (théorie des graphes, graphes conceptuels,
UML), nous détaillons les propositions de ce domaine en section 2.6.3.

2.4.4 Synthèse de l’administration des modèles structurés

Le terme d’administration recouvre un large spectre des activités de gestion effec-
tuées par les administrateurs : des opérations de création de la politique à la mainte-
nance quotidienne en passant par l’évolution du contenu. Cette section a survolé les
notions principales relatives à ce champ d’activité :

38

Chapitre 2. Contrôle d’accès au système d’information

– les primitives administratives : des ensembles d’opérations permettant d’interro-

ger et de manipuler des politiques,

– les modèles d’administration : des modèles de contrôle d’accès aux primitives ad-

ministratives,

– la représentation des modèles et des politiques : des formalismes graphiques en

correspondance avec les primitives,

Nous reprendrons ces notions dans la suite de la thèse, plus précisément dans le
chapitre 5, où nous proposons une généralisation des notions de primitives et des outils
de conception de modèle.

Les propositions de modèles d’administration permettent généralement l’expres-
sion de contraintes dans les politiques. La section suivante présente cette notion ainsi
que les principaux enrichissements et extensions introduits dans le contrôle d’accès.

2.5 Enrichissements et extensions des modèles structurés

Plusieurs modèles de contrôle d’accès organisent les droits des utilisateurs selon
les processus métiers dans lesquels ils interviennent. Répartir les tâches d’un même
processus entre plusieurs acteurs permet de garantir le principe de séparation des
tâches [Nash90]. Ce principe est généralement introduit dans les modèles structurés par
l’intermédiaire de la notion de contrainte qui permet de limiter les permissions accor-
dées aux utilisateurs. La littérature distingue deux grandes catégories de contraintes :
– les contraintes dynamiques, qui doivent être évaluées lors des demandes d’accès,

c’est-à-dire lors de l’exécution du moniteur et de l’ouverture de sessions,

– les contraintes statiques, qui sont évaluables une fois pour toutes et qui ne dé-

pendent pas de l’exécution du moniteur.

Une contrainte peut généralement être déclinée dans l’une ou l’autre des catégories :
en dynamique, si la contrainte porte sur les sujets qui représentent l’activité des utilisa-
teurs du système, ou en statique, si la contrainte porte sur les utilisateurs eux-mêmes,
qui sont des entités passives du point de vue du contrôle d’accès. La section suivante
s’intéresse aux contraintes les plus utilisées dans les modèles de contrôle d’accès : les
contraintes d’exclusion mutuelle.

2.5.1 Séparation des tâches et exclusion mutuelle

Le moyen proposé pour garantir le principe de séparation des tâches est la notion de
contrainte, et en particulier les relations d’exclusion mutuelle entre concepts d’un modèle
de contrôle d’accès (par exemple, entre tâche et utilisateur ou entre rôle et session). La
distinction entre objectif et moyen est attribuable aux auteurs de [Li04a] qui ont précisé
ces deux notions, parfois confondues :

Section 2.5. Enrichissements et extensions des modèles structurés

39

– la séparation des tâches : un principe de sécurité qui vise à garantir la sécurité d’un
processus, en imposant que des acteurs différents interviennent dans sa réalisa-
tion, c’est un objectif à garantir [Clark87, Nash90, Simon97],

– l’exclusion mutuelle entre concepts : une contrainte déﬁnie entre les concepts d’un
système qui interdit qu’ils aient des utilisateurs en commun, c’est un moyen utilisé
pour exprimer et garantir la séparation des tâches [Kuhn97].

2.5.1.1 Exclusion mutuelle dans les modèles à rôles

En sus des notions de rôle et de hiérarchie associées, les modèles RBAC ont introduit
les contraintes d’exclusion mutuelle avec le modèle RBAC2. Les contraintes permettent
d’imposer de restrictions devant être garanties dans les politiques. Les contraintes
sont un aspect important du modèle RBAC, voire même une des principales motiva-
tions [Ahn00]. Les contraintes d’exclusion mutuelle (statiques et dynamiques) entre
rôles sont d’ailleurs les seules proposées dans le standard [Ferraiolo03b].

Déﬁnition (Exclusion mutuelle statique entre rôles [Ferraiolo03b]). L’exclusion mu-
tuelle statique entre deux rôles r1 et r2, impose qu’aucun utilisateur ne dispose à la fois du
rôle r1 et de r2. Soit ME R ⊆ R × R la relation d’exclusion mutuelle statique :

∀r1, r2 (r1, r2) ∈ ME R ⇒ assigned_users(r1) ∩ assigned_users(r2) = ∅

Déﬁnition (Exclusion mutuelle dynamique entre rôles [Ferraiolo03b]). L’exclusion mu-
tuelle dynamique entre deux rôles r1 et r2, impose qu’aucun utilisateur ne dispose d’une ses-
sion dans laquelle il endosse simultanément les rôles r1 et r2.

La possibilité pour un utilisateur de disposer de plusieurs sessions est un problème
pour l’application des contraintes dynamiques6. En effet, si deux rôles r1 et r2 sont en
exclusion dynamique, cela n’interdit pas à un utilisateur de disposer de deux sessions
s1 et s2 où il endosse séparément r1 et r2 : la séparation des tâches n’est pas garantie.
C’est un des arguments justiﬁant l’intérêt particulier porté à l’exclusion mutuelle sta-
tique [Li04a].

L’exclusion mutuelle est donc une relation binaire interne entre rôles. Comme la
relation d’héritage, l’exclusion mutuelle doit vériﬁer des propriétés algébriques, iden-
tiﬁées par les auteurs de [Benantar06, Ferraiolo03b, Gavrila98] :

– elle est symétrique, si r1 est en exclusion avec r2, alors r2 est en exclusion avec r1 :

∀r1, r2 (r1, r2) ∈ ME R ⇒ (r2, r1) ∈ ME R.

– elle est irréﬂexive, un rôle r ne peut pas être en exclusion mutuelle avec lui même :

∀r (r, r) 6∈ ME R

6Nous ne proposons pas de formalisation l’exclusion mutuelle dynamique car elle nécessiterait l’intro-

duction de nouvelles déﬁnitions techniques.

40

Chapitre 2. Contrôle d’accès au système d’information

L’exclusion mutuelle présentée a été étendue aux utilisateurs, aux objets et aux per-

missions, sous les dénominations de [Crampton03a, Gligor98]7 :

– User-based separation of duty, aucun rôle ne doit avoir d’utilisateurs en commun,
– Permission-based separation of duty, aucun rôle (ou aucun utilisateur) ne doit avoir

de permissions en commun,

– Object-based separation of duty, aucun rôle (ou aucun utilisateur) ne doit avoir d’ac-

cès communs sur des objets.

2.5.1.2

Interaction entre exclusion et hiérarchie

Certains modèles, comme RBAC3, autorisent l’expression de contraintes sur des
concepts hiérarchisés. Or, les interactions entre les relations d’exclusion mutuelle et les
relations d’héritage induisent de nouvelles propriétés que les politiques de contrôle
d’accès doivent respecter.

Pour le modèle RBAC3, on doit redéﬁnir la relation d’exclusion d’exclusion mu-
tuelle de RBAC2 pour qu’elle ne porte non pas sur les utilisateurs affectés explicitement
(application assigned_users) aux rôles, mais à tous ceux qui l’endossent implicitement (ap-
plication auth_users), c’est-à-dire à tous les utilisateurs qui sont affectés à des rôles qui
spécialisent des rôles en exclusion :

∀r1, r2 (r1, r2) ∈ ME R ⇒ auth_users(r1) ∩ auth_users(r2) = ∅

De plus, la relation d’exclusion et la relation d’héritage portant toutes deux sur les
rôles, la déﬁnition de contraintes d’exclusion peut conduire à des politiques inconsis-
tantes. Les propositions des auteurs de [Kuhn97, Gavrila98, Benantar06, Ferraiolo03b]
ont évalué ce problème avec des formalisations légèrement différentes : la relation d’hé-
ritage entre rôles ne dispose pas des mêmes propriétés dans les différentes approches.
Nonobstant cette différence, les principales propriétés algébriques qui doivent être vé-
riﬁées par la relation d’exclusion ont été identiﬁées :

– deux rôles en exclusion mutuelle ne peuvent pas hériter l’un de l’autre :

∀r1, r2 (r1, r2) ∈ ME R ⇒ ¬(r1 (cid:23) r2)

– il ne doit pas y avoir de rôle qui hérite de deux rôles en exclusion mutuelle :

∀r1, r2, r r (cid:23) r1 ∧ r (cid:23) r2 ⇒ (r1, r2) 6∈ ME R,

– l’exclusion mutuelle est propagée par la relation d’héritage :

∀r1, r2, r (r1, r2) ∈ ME R ∧ r (cid:23) r1 ⇒ (r, r2) ∈ ME R

Ces propriétés n’ont pas été généralisées aux différentes variétés de l’exclusion mu-
tuelle proposées dans [Crampton03a, Gligor98]. Nous pensons que ces propriétés sont
applicables à ces formes d’exclusion particulières, mais aussi à d’autres, plus générales
encore.

7La remarque sur l’ambiguité entre séparation des tâches et exclusion se ressent ici, pour la dénomina-

tion que nous avons adopté, il s’agit de contraintes d’exclusion mutuelle et non de séparation.

Section 2.5. Enrichissements et extensions des modèles structurés

41

Exemple 2.7 Interaction entre exclusion et hiérarchie

Au CHM trois rôles sont déﬁnis dans les structures de soin :
– le rôle d’inﬁrmier, qui peut lire des prescriptions,
– le rôle de médecin, qui peut lire et écrire des prescriptions,
– le rôle de responsable des soins, qui hérite à la fois du rôle d’inﬁrmier (pour disposer
des mêmes droits que ses subordonnés) et de celui de médecin (en imaginant
qu’on impose qu’un responsable des soins soit toujours un médecin).

Aﬁn d’éviter qu’un inﬁrmier puisse un jour modiﬁer des prescriptions, les responsables
de la sécurité croient bon de déﬁnir comme exclusivement mutuels les rôles d’inﬁrmier
et de médecin. Un utilisateur qui endosse le rôle de responsable des soins endosse
implicitement les rôles d’inﬁrmier et de médecin et viole alors la contrainte d’exclusion.
Une telle politique n’est pas intègre.
On pourrait pour ce cas privilégier l’affectation multiple de rôles à l’héritage multiple.
Alors, il faudrait affecter à chaque responsable des soins le rôle d’inﬁrmier et celui
de médecins. Ceci conduit à multiplier les affectations, augmentant ainsi la taille et la
complexité de la politique.

2.5.2 Intégration du contexte

Avec l’évolution des systèmes prenant en compte des caractéristiques par essence
dynamiques, comme la position géographique d’un utilisateur, l’état des équipements
ou l’horaire d’utilisation, il est devenu nécessaire d’intégrer les aspects contextuels dans
les modèles de contrôle d’accès.

Les principes des modèles RBAC ont été repris dans plusieurs propositions d’exten-
sions permettant une déﬁnition plus expressive des principes des modèles de contrôle
d’accès. La prise en compte la notion de contexte dans les politiques à rôles est un do-
maine d’investigation actif. Cependant, la déﬁnition du contexte en informatique est
délicate, une déﬁnition générale est celle proposée par Dey [Dey01] :

Context is any information that can be used to characterise the situation of an en-
tity. An entity is a person, place, or object that is considered relevant to the in-
teraction between a user and an application, including the user and applications
themselves.

Les quatre principales directions des enrichissements contextuels présentées dans

cette section concernent :

– la prise en compte du temps, pour limiter les actions possibles sur des plages ho-

raires ou pour exprimer l’activation périodique de rôles,

– la prise en compte de l’espace, pour exprimer des restrictions géographiques sur

les rôles endossables ou les actions possibles par exemple,

– la prise en compte du contexte des utilisateurs et des objets,
– les choix de modélisation et de formalisation des aspects contextuels.

42

Chapitre 2. Contrôle d’accès au système d’information

2.5.2.1 Difﬁcultés de modélisation du contexte

À la différence des données « traditionnelles » des politiques de contrôle d’accès,
les données contextuelles sont souvent numériques. L’évaluation du contexte se base es-
sentiellement sur des comparaisons de valeurs ou des opérations d’analyse numérique.
Une particularité commune des données numériques de contexte est qu’elles prennent
généralement leurs valeurs sur des domaines continus. On peut cependant éviter aux
administrateurs de manipuler de tels domaines continus :

– en discrétisant les domaines au prix d’approximations. On peut par exemple dis-
crétiser le temps avec une granularité en seconde, ou paver régulièrement le plan
avec un motif géométrique,

– en ne s’intéressant non pas aux valeurs elles-mêmes mais aux relations qualitatives

entre les données.

Plutôt que de manipuler des horaires, on peut par exemple utiliser l’algèbre des
intervalles d’Allen [Allen83] (chevauche, ﬁnit avec, commence avec, . . . ). Dans le cas de
contexte spatial, on utilisera des relations topologiques [Egenhofer91] (dans, touche,
croise, . . . ). Ces relations qualitatives spatiales sont très intéressantes pour la modéli-
sation des contextes géographiques, car elles sont invariantes par changement de pro-
jection ou d’échelle, contrairement aux distances et aux angles.

Le temps ou l’espace sont souvent donnés en exemples comme les principaux
représentants du contexte. Mais selon les applications et les domaines d’activités,
d’autres valeurs numériques que les coordonnées où les dates peuvent être utilisées.
Par exemple, dans les applications orientées réseau, on s’intéresse au temps de latence
et au débit des liaisons, dans les applications de surveillance physique, on collectera
des valeurs de pression ou de température. Ainsi la notion de contexte est délicate à au
moins deux égards :

– c’est une notion qui peut être entendue différemment selon les domaines d’ap-
plication et les organisations. Pour le géographe, la notion d’espace fait partie du
métier, pour l’historien, la notion de chronologie également. La notion de contexte
est ainsi relative : alors que pour une organisation donnée, la prise en compte du
temps dans le contrôle d’accès est incontournable et fait partie des éléments struc-
turants fondamentaux du modèle, pour une autre ce sera la notion d’espace ou
de bande passante,

– la notion de contexte introduit une nouvelle complexité dans l’organisation des
droits. La prise en compte du contexte nécessite la déﬁnition de nouvelles rela-
tions, qui à leurs tours induisent de nouvelles propriétés que les politiques de
contrôle d’accès doivent respecter. De plus, certains aspects des contextes sont
difﬁciles à formaliser dans le cas général.

La prise en compte du contexte dans le contrôle d’accès, ou plus généralement dans
les systèmes d’information context-aware, nécessite la mise en œuvre de mécanismes
dédiés à l’acquisition des informations contextuelles. Que ce soit avec un système GPS

Section 2.5. Enrichissements et extensions des modèles structurés

43

pour les coordonnées spatiales, une horloge globale pour les contextes temporels, ou
d’autres architectures de type context-broker pour collecter de multiples informations
de contexte. Dans tous ces cas, nous supposons, comme pour le moniteur de référence,
que les mécanismes mis en œuvre sont incontournables, inviolables et vériﬁés.

2.5.2.2 Contexte temporel

Pour combler le déﬁcit d’expression d’aspects contextuels des modèles RBAC, les
auteurs de [Mossakowski03] proposent d’introduire le temps dans le contrôle d’accès
et d’utiliser la logique temporelle du premier ordre (temporal ﬁrst-order logic) comme
cadre formel. Les procédures de preuves sur la logique temporelle permettent d’inférer
sur des règles du type « un utilisateur peut passer une commande, mais un autre doit
ensuite la valider » aﬁn de vériﬁer qu’il n’existera pas d’état inconsistant de la politique.
Avec le modèle nommé Extended-RBAC (ERBAC), les auteurs de [Mossakowski03]
proposent de manipuler des règles de contrôle d’accès basées sur l’ordre temporel
d’exécution des tâches dans les processus métier. Le modèle Authorization Model for Tem-
poral and derived Data (AMTD) [Atluri02] poursuit des buts similaires avec le cadre des
bases de données temporelles. Ce modèle n’est cependant pas structuré avec le concept
de rôle. Enﬁn, les auteurs de [Joshi05] proposent un modèle nommé Generalized-
Temporal-RBAC (GTRBAC), qui étend le modèle Temporal-RBAC (TRBAC) [Bertino01]
en autorisant de nouvelles formes de contraintes temporelles.

Tous ces modèles intégrant le contexte temporel dans la modélisation des droits sont
basés sur l’existence d’une horloge globale ﬁable, grâce à laquelle sont développées des
contraintes d’accès basées sur l’horaire où les sujets agissent dans le système :

– l’activation et la désactivation périodique de rôle,
– les affectations de rôles aux utilisateurs et de permissions aux rôles,
– la durée pendant laquelle on peut endosser un rôle.
Comme pour les relations d’exclusion mutuelle qui interagissent avec les hiérar-
chies, l’introduction du contexte temporel a conduit à proposer des relations d’héritage
rafﬁnées en présence de contexte [Joshi02] :

– Inheritance-only hierarchy : la hiérarchie classique RBAC,
– Activation-only hierarchy : la hiérarchie basée sur le temps,
– General inheritance hierarchy : la combinaison des deux précédentes.
Comparées au modèle AMTD [Atluri02], qui est bâti sur un ensemble de règles sans
concepts intermédiaires, les propositions basées sur les rôles [Mossakowski03, Atluri02,
Joshi05] sont plus fortement structurées et permettent de développer des modèles d’ad-
ministration [Bhatti05], qui ne sont pas réalisables avec le modèle AMTD.

44

Chapitre 2. Contrôle d’accès au système d’information

2.5.2.3 Contexte géographique

Les spéciﬁcités des applications mobiles ou basées sur la localisation ont été prises
en compte par les auteurs de [Damiani07]. Leur proposition, la famille des modèles
Geographical-RBAC (GEORBAC), étend les modèles RBAC en déﬁnissant de nouveaux
concepts spatiaux pour représenter la position des sujets et celles des objets. Ces nou-
veaux concepts sont utilisés pour limiter géographiquement l’utilisation des rôles. L’in-
téraction entre aspects géographiques, contraintes et hiérarchie a conduit les auteurs
de [Damiani07] à structurer leur famille de modèles comme celle de RBAC (ﬁgure 2.3).
Le principe proposé dans GEORBAC est de comparer une position physique, suppo-
sée obtenue de façon ﬁable (par exemple la localisation GPS), à des positions logiques
(exemples : route, ville, région) auxquelles sont associés des rôles géographiques. Ce
principe a été appliqué à d’autres modèles de contrôle d’accès que RBAC. Les modèles
TMAC [Thomas97a, Georgiadis01] et ORBAC [Cuppens03] reprennent le principe de
comparaison entre positions physiques et logiques.

2.5.2.4 Contexte d’utilisateur et d’objet

Certaines approches ont choisi d’intégrer la notion de contexte dans le contrôle
d’accès en la liant étroitement aux utilisateurs et aux objets, sans introduire de nou-
veaux concepts spéciﬁques. Les modèles Context-Sensitive-RBAC (CSRBAC) et Environ-
ment-RBAC (ENVRBAC) regroupent les paramètres dépendants des utilisateurs et des
objets dans des contextes de sujets et des contextes d’objets [Kumar02, Covington01]. Les
contextes peuvent comprendre la position géographique ou l’heure de la demande
d’accès. Dans CSRBAC et ENVRBAC, un accès est autorisé si et seulement si les contextes
de sujets sont inclus dans les contextes d’objets.

2.5.2.5 Formalisation des contextes

Une des difﬁcultés de la prise en compte du contexte dans le contrôle d’accès n’est
non pas sa formalisation dans un cadre théorique, mais plutôt les choix de modélisation
et leur intégration dans les politiques. La fonction du moniteur de référence est modiﬁée :
ce dernier doit désormais assurer des fonctions de context-broker. Le moniteur doit col-
lecter les informations contextuelles relatives aux sujets requérants, à l’objet cible et
même éventuellement à l’action demandée.

Plusieurs propositions ont modélisé le contexte dans les modèles de contrôle d’ac-
cès, nous avons présenté les plus remarquables extensions de RBAC. La formalisation
logique des contextes est catégorisable en deux approches : les contextes peuvent être
représentés soit par des contraintes dans les principes des modèles, soit par des condi-
tions portant sur les faits des politiques.

Section 2.5. Enrichissements et extensions des modèles structurés

45

Contraintes dans les principes des modèles

Aﬁn de pouvoir prendre en compte l’expression de relations arithmétiques dans la
formalisation logique du contexte dans les modèles de contrôle d’accès, le cadre théo-
rique utilisé est une extension de DATALOG, généralement DATALOGC qui permet l’ex-
pression de contraintes arithmétiques dans les formules logiques [Barker03, Joshi05,
Atluri02, Bertino01, Miège05, Damiani07].

Dans le modèle ORBAC (ﬁgure 2.5), le contexte est représenté par un concept spé-
ciﬁque contexte, relié à tous les concepts concrets (sujet, action et objet) et au concept
d’organisation par une relation spéciﬁque. Cette relation exprime qu’un contexte est
valide dans une organisation donnée pour un triplet sujet, action et objet donné. Le
concept de contexte est utilisé dans la déﬁnition des permissions abstraites.

Conditions sur les faits

Dans les modèles RBAC introduisant le temps (TRBAC, GTRBAC, ENVRBAC), les ho-
raires sont introduits dans toutes les relations des modèles, aﬁn de permettre une ﬂexi-
bilité maximum pour l’expression de politiques de contrôle d’accès prenant en compte
les horaires.

Avec ce type de modélisation du contexte temporel, pour conditionner les affecta-
tions de rôles aux utilisateurs entre les dates constantes h1 et h2 on utilisera la formule
f1. Pour limiter les affectations de permissions aux rôles on utilisera f2.

f1 : Heure(H), h1 ≥ H ≥ h2 → Habilite(user, role)
f2 : Heure(H), h1 ≥ H ≥ h2 → A f f ecte(role, action, object)

Une contrainte d’utilisation engendrée par cette modélisation est qu’elle rend tous
les concepts et relations du modèle de contrôle d’accès dynamiques en les conditionnant
par l’heure. De plus, tout devient des règles : la séparation entre contenus factuel et
déduit dans les politiques disparait.

2.5.3 Interdictions et politiques hybrides

Les politiques de contrôle d’accès peuvent être catégorisées en deux grands types
généraux, en fonction du principe qui guide la gestion des droits des utilisateurs dans
le système :

– les politiques ouvertes : tout ce qui n’est pas explicitement interdit est permis,
– les politiques fermées : tout ce qui n’est pas explicitement permis est interdit.

Déﬁnition (Principe du moindre privilège [Nash90]). Le moindre privilège est un prin-
cipe de sécurité qui impose que les acteurs du systèmes ne disposent que du minimum de privi-
lèges (permissions) nécessaire à la réalisation des tâches qui leurs sont attribuées.

46

Chapitre 2. Contrôle d’accès au système d’information

La modélisation logique d’une politique ouverte ou fermée est identique, seul dif-
fère la mise en œuvre du moniteur. Pour respecter le principe du moindre privilège, les
politiques ouvertes sont mieux adaptées. Néanmoins, pour répondre au besoin d’ex-
pressivité et de ﬂexibilité de certaines organisations, il est apparu comme intéressant
de proposer des politiques hybrides, permettant la déﬁnition à la fois d’interdictions et
d’autorisations [Halpern03, Bertino03, Jajodia01, Abadi07, DeTreville02]

L’introduction de la négation dans la déﬁnition des droits d’accès pose plusieurs

problèmes d’ordres pratiques, mais aussi théoriques :

– elle conduit à des conﬂits et demande la déﬁnition de règles permettant de les
résoudre. Les mécanismes de résolution proposés peuvent être soit des règles
de haut niveau, exprimées en logique du second ordre par exemple [Li00b,
Al-Kahtani04], soit des règles portant sur des symboles de relations intermé-
diaires auxquels les administrateurs n’ont pas accès. Ces relations sont introduites
uniquement pour leur intérêt technique [Miège05],

– elle rend plus coûteux les algorithmes qui déterminent si un accès est auto-
risé. En effet, la sémantique des formules exprimées dans des cadres théoriques
supportant la négation est plus complexe que celle de ceux qui ne l’autorisent
pas [Abiteboul95].

– elle est difﬁcile à représenter graphiquement. Son support n’est pas directement
pris en compte ni dans les propositions d’interfaces d’administration des mo-
dèles à rôles, ni dans les paradigmes de représentation graphique des modèles de
contrôle d’accès [Tidswell01, Koch03, Ferraiolo03a, Sandhu04].

Exemple 2.8 Difﬁcultés engendrées par les politiques hybrides

Supposons que le CHM, qui utilisait une politique fermée basée sur les rôles, réforme
sa gestion des droits d’accès avec un modèle hybride. Les administrateurs utilisaient
une application graphique, dans laquelle pour associer une permission à un rôle il
fallait tracer un lien entre le rôle et l’objet de la permission.
– Pour représenter les interdictions les administrateurs vont devoir manipuler de nou-
veaux symboles, qui peuvent être multipliés si l’on souhaite proposer des options
comme « ajouter toutes ces permissions sauf . . . ».

– Que faire si un administrateur interdit une permission à un rôle alors qu’elle était

autorisée par un rôle parent ?

– Quelle résolution des conﬂits choisir lorsqu’un utilisateur dispose de plusieurs rôles,

dont un qui interdit un accès et l’autre qui l’autorise ?

Les difﬁcultés engendrées par les politiques hybrides ont été rencontrées dans un
autre mécanisme de sécurité : les pare-feux. Alors que le contrôle d’accès logique auto-
rise ou interdit des actions demandées par les utilisateurs, les pare-feux autorisent ou in-
terdisent des paquets à transiter sur les réseaux. Dans les politiques des pare-feux, il a été
fait le choix historique d’organiser le ﬁltrage des paquets avec des politiques hybrides.
Ce choix a causé et cause encore de nombreux problèmes d’expression [Gouda04], de

Section 2.5. Enrichissements et extensions des modèles structurés

47

stockage [Liu04], de vériﬁcation des règles [Al-Shaer04, Mayer06] et est une source d’er-
reur de conﬁguration considérable [Wool04].

Cependant, dans les modèles structurés qui permettent l’expression de contraintes,
comme l’exclusion mutuelle, il est possible de limiter les permissions des utilisateurs,
sans utiliser explicitement d’interdiction. De plus, en pratique, on peut limiter l’impact
de l’absence d’interdictions en proposant des fonctionnalités adéquates dans les inter-
faces graphiques d’administration qui limitent le nombre d’opérations élémentaires à
effectuer pour exprimer l’équivalent d’une interdiction.

2.5.4 Vers le contrôle d’accès basé sur des cadres logiques

Les principaux modèles de contrôle d’accès que nous avons présentés sont basés sur
des structurations fortes des autorisations. Un nombre limité de concepts et de relations
forme le noyau du modèle, à partir duquel sont dérivées les autorisations effectives.
Les principes et algorithmes qui régissent ces dérivations sont également en nombres
limités. Le but est de proposer des modèles de contrôle d’accès qui répondent au mieux
aux besoins de modélisation des droits des organisations. C’est avant tout la nature
opérationnelle du contrôle d’accès qui prime sur sa formalisation logique.

FIG. 2.7 – Modélisation et formalisation du contrôle d’accès

Depuis 2003 environ, nous assistons à la tendance inverse, en rupture avec le déve-
loppement des modèles à rôles. Cette tendance est désignée sous le terme de « contrôle
d’accès basé sur les règles » (Rule-Based Access Control – Rule-BAC). Les deux démarches
sont illustrées par la ﬁgure 2.7.

Comme il est difﬁcile de rassembler en un unique modèle cohérent et homogène
les besoins variés de sécurité des organisations, les auteurs proposent désormais des
cadres logiques dans lesquels formaliser et développer des modèles de contrôle d’accès.
Cette approche formelle est bien moins pragmatique que celle motivée en premier lieu
par l’usage et l’administration du contrôle d’accès. De multiples cadres logiques avec
lesquels modéliser le contrôle d’accès ont été proposés [Halpern03, Bertino03, Jajodia01,
Abadi07, DeTreville02, Al-Kahtani04]. Leur étude est l’objet de la section suivante.

48

Chapitre 2. Contrôle d’accès au système d’information

2.6 Cadres logiques pour le contrôle d’accès

Nous avons présenté un ensemble de modèles de contrôle d’accès structurés et de
principes qu’ils mettent en œuvre, depuis les modèles historiques les plus simples, jus-
qu’à des modèles riches, comportant de nombreux concepts permettant de structurer
les droits.

Cependant, dans un but d’uniﬁcation, d’autres approches de modélisation du
contrôle d’accès ont été proposées. Elles consistent à identiﬁer des cadres logiques sur
lesquels bâtir des politiques de contrôle d’accès. Ces approches s’attachent rarement à
un modèle particulier : elles visent moins à structurer les droits qu’à les formaliser pour
pouvoir utiliser des outils formels. Disposer de cadres logiques dans lesquels exprimer
les règles régissant les droits dans les systèmes est une étape qui facilite :
– la déﬁnition de langages sans ambiguïtés (fragments de la logique),
– l’évaluation théorique du coût des algorithmes qui seront exécutés (complexité),
– la déﬁnition de procédures d’inférence sur les politiques (décidabilité).
Les approches que nous présentons dans cette section sont basées sur des cadres de
logique du premier ordre8, dans lesquels des constructeurs spéciﬁques sont dévelop-
pés pour exprimer des règlements de sécurité. La plupart de ces cadres sont basés sur
DATALOG et ses dérivés.

Un programme DATALOG est un ensemble de règles, sous forme de clauses de
Horn, satisfaisant à certaines restrictions syntaxiques, selon la variante de DATALOG
utilisée. Les extensions de DATALOG comprennent principalement le support de la né-
gation (DATALOG¬) ou des contraintes arithmétiques (DATALOGC). DATALOG constitue
un fragment de la logique du premier ordre qui n’autorise pas les fonctions et qui est
particulièrement adapté à la modélisation logique des bases de données relationnelles :
c’est le paradigme des bases de données déductives9.

Contrairement aux programmes logiques PROLOG (PROgrammation LOGique), en
DATALOG les faits (le contenu de la base de données relationnelle) et règles qui les gou-
vernent sont clairement séparés. Dans les programmes PROLOG, les faits font partie in-
tégrante du programme [Abiteboul95]. Cette séparation permet par exemple d’optimi-
ser l’accès aux données. De plus, les études théoriques des modèles DATALOG portent
généralement sur des structures ﬁnies, comme l’ensemble des faits contenus dans une
base de données.

De façon informelle, nous pourrions dire que les programmes DATALOG sont des
programmes logiques avec peu de règles et beaucoup de données, alors que les pro-
grammes PROLOG sont composés de peu de données et de beaucoup de règles.

8Il a été proposé d’utiliser des logiques d’ordres supérieurs dans [Appel99] par exemple.
9Nous décrivons les liens entre logique des prédicats et base de données dans l’annexe A.

Section 2.6. Cadres logiques pour le contrôle d’accès

49

2.6.1 Cadres pour la gestion de la conﬁance

Dans la thèse, nous avons fait le choix de ne pas traiter d’authentiﬁcation, nous sup-
posons ces mécanismes sous-jacents existants. Cependant, les études sur l’authentiﬁca-
tion et l’autorisation ont apportés des réponses à certains problèmes de formalisation
logique. En effet, plusieurs cadres logiques pour l’étude des règlements de sécurité ont
été proposés dans le domaine du Trust Management, que nous traduirons par « infra-
structure de gestion de la conﬁance ».

Certaines propositions de cadres logiques pour le Trust Management s’orientent plus
sur les infrastructures de gestions de clefs et les échanges sécurisés [Clarke01], d’autres
s’intéressent à la gestion des droits et en particulier les langages pour exprimer les mo-
dèles et les politiques de contrôle d’accès. Nous portons notre attention sur ces der-
nières propositions principalement.

2.6.1.1 Logique de délégation et gestion de la conﬁance

L’approche nommée Delegation Logic (DL ou D1LP), vise la déﬁnition des autorisa-
tions dans les systèmes distribués [Li03a, Li00a, Li00b]. Le cadre propose des construc-
teurs spéciﬁques pour formaliser les règles à partir desquelles sont dérivées les autori-
sations. L’expression Bob says remove(file1) indique que le sujet Bob souhaite suppri-
mer le ﬁchier file1. Cette expression utilise le constructeur d’assertion says.

Le cadre DL propose deux constructeurs pour modéliser la délégation (construc-
teurs delagates et represents) et un autre pour l’expression de contraintes de séparation
des tâches (constructeur threshold). Il n’a pas été proposé de mécanisme d’inférence
traitant directement les expressions écrites en DL. En revanche, il est possible de ré-
écrire les expressions de ce langage en DATALOG à l’aide de règles qui permettent de
traduire ces constructeurs en logique des prédicats du premier ordre.

La proposition de cadre logique RTC

1 [Li03b] pour Role-based Trust-management se
base sur Constraint-DATALOG (DATALOGC). DATALOGC est une extension de DATA-
LOG où des contraintes arithmétiques sont autorisées dans le corps des règles, c’est une
forme restreinte de la programmation logique par contraintes. Un exemple d’utilisa-
tion de RTC
1 est proposé, il s’agit d’analyser et de vériﬁer des expressions du langage
KeyNote, une infrastructure de gestion de la conﬁance [Blaze99].

2.6.1.2 D3LOG

Le langage Secure Dynamically Distributed Datalog (D3LOG), proposé par Jim Tre-
vor ajoute à DATALOG des constructeurs spéciﬁques reliés aux échanges cryptogra-
phiques [Jim01a]. L’objectif de D3LOG est d’exprimer des modèles de contrôle d’accès,
mais surtout les échanges sécurisés et les étapes de l’authentiﬁcation : cela forme le
cadre D3LOG proposé dans [Jim01b].

50

Chapitre 2. Contrôle d’accès au système d’information

En particulier, on peut exprimer en D3LOG qu’une entité est détentrice de clefs de
cryptographie. L’objectif est la formalisation logique de protocoles d’échange crypto-
graphique en vue de l’évaluation de l’authentiﬁcation des systèmes. Un exemple de
modélisation est proposé dans [Jim01a]. D3LOG est utilisé pour spéciﬁer le protocole
DNSSEC10. L’évaluation du langage est une réduction en DATALOG [Jim01b].

2.6.1.3 BINDER

BINDER est un langage d’expression de règlements de sécurité basé sur la logique
du premier ordre, déﬁni par son auteur comme « un DATALOG pour les autorisa-
tions » [DeTreville02]. Des constructeurs spéciﬁques sont introduits pour modéliser les
chiffrements utilisés dans les échanges. On peut exprimer qu’un message est crypté
avec RSA (Rivest Shamir Adleman, un algorithme de cryptographie à clefs publiques très
répandu) en spéciﬁant la clef publique utilisée par exemple. Le langage introduit égale-
ment le constructeur says, similaire à celui proposé dans DL. Le mécanisme utilisé pour
l’évaluation de BINDER est une réduction en DATALOG.

Enﬁn, Martín Abadi a proposé d’utiliser le Dependency Core Calculus (DCC), une
extension du λ-calcul pour formaliser et inférer sur les modèles de contrôle d’ac-
cès [Abadi07]. L’approche permet de raisonner sur des formules du type de BIN-
DER. Cette proposition montre que le DCC est adéquat pour représenter des règles de
contrôle d’accès aux systèmes distribués. Cependant, aucune application sur un modèle
de contrôle d’accès existant n’est proposée, seule une structuration ad hoc est utilisée.

2.6.1.4 Synthèse sur les cadres pour la conﬁance

Les propositions présentées s’intéressent à un spectre très large de la sécurité, celui
de la gestion de la conﬁance qui comprend identiﬁcation, authentiﬁcation et contrôle
d’accès. Comme l’authentiﬁcation se base sur des primitives cryptographiques, plu-
sieurs de ces propositions les modélisent, ce qui les rapproche des travaux sur la vé-
riﬁcation de protocoles d’échange sécurisés (exemple avec DNSSEC pour D3LOG). Un
autre trait de ces propositions est qu’elles s’intéressent particulièrement aux systèmes
hautement distribués, pour lesquels il est difﬁcile de disposer d’une autorité centrale
connaissant tous les droits dans le système.

Ces approches proposent des résultats théoriques très généraux, dont la portée dé-
passe le cadre strict de la gestion de la conﬁance [Jim01b]. Le revers de la médaille est
que ces résultats sont quelquefois difﬁciles à mettre en œuvre. De plus, pour ce qui est
de l’expression des modèles de contrôle d’accès et de leurs principes :

10DNSSEC est un service de résolution de noms sécurisé qui étend Domain Name Service [Arends05]

Section 2.6. Cadres logiques pour le contrôle d’accès

51

– d’une part, ces approches ne basent pas la structuration des droits sur des mo-
dèles établis : elles laissent libres de modéliser sous forme de règles les principes
et les propriétés de sécurité que les politiques de contrôle d’accès doivent vériﬁer,
– d’autre part, ces propositions ne traitent ni de la mise en œuvre du principe de

séparation des tâches ni des contraintes d’exclusion mutuelle,

– enﬁn, nonobstant l’héritage afﬁrmé de DATALOG, peu d’éléments sont donnés

quant au stockage des politiques et à leur administration.

2.6.2 Cadres pour le contrôle d’accès

Les propositions précédentes de cadre logiques s’intéressent aux architectures de
gestion de la conﬁance. Celles que nous présentons maintenant ne s’intéressent plus à
l’authentiﬁcation, mais seulement au contrôle d’accès. Les aspects étudiés sont princi-
palement l’expressivité des modèles ainsi que l’interrogation et la vériﬁcation de poli-
tiques aﬁn de prouver qu’elles satisfont bien à des propriétés de sécurité.

2.6.2.1 Spécialisation de programmes logiques

Une première approche est celle Steve Barker [Barker03], qui propose de spécia-
liser des programmes logiques avec contraintes pour la modélisation des règlements
de contrôle d’accès. La programmation logique par contraintes (Constraint Logic Pro-
gramming – CLP) est une extension de PROLOG autorisant la présence de contraintes
arithmétiques dans les formules [Jaffar94].

Steve Barker étudie en particulier RBAC3 et propose des extensions de ce modèle
de contrôle d’accès pour exprimer des politiques hybrides. Il est aussi proposé de
prendre en compte le temps dans les autorisations pour se rapprocher du modèle TR-
BAC [Barker03]. L’approche proposée est principalement orientée sur la performance et
compare l’efﬁcacité des programmes logiques spécialisés face à un solver de contraintes
classique. Cependant, la proposition ne prend en compte ni l’intégrité des politiques,
ni l’interaction entre hiérarchies et contraintes. De plus, certaines propriétés de RBAC3
ne sont pas prises en compte [Ferraiolo03b].

L’approche de Halpern et Weissman se base aussi sur l’étude d’un fragment de lo-
gique, LITHIUM, construit autour de la notion de bipolarité [Halpern03]. La bipolarité
est une restriction syntaxique qui permet de garantir la décidabilité de l’implication en
présence de négation, cette notion est proche de la stratiﬁcation en DATALOG¬. La pro-
position de Halpern et Weissman vise la déﬁnition de politiques hybrides, prenant en
compte des autorisations temporelles simples. Le modèle de contrôle d’accès proposé
est une variante hybride du modèle RBAC1. Malheureusement, la formalisation propo-
sée de RBAC n’est pas celle du standard. La formalisation de l’affectation de rôles aux
utilisateurs interdit la quantiﬁcation des rôles (∃ r ∈ R . . . , ∀r ∈ R . . .) ce qui limite
fortement l’expression des propriétés de sécurité à vériﬁer.

52

Chapitre 2. Contrôle d’accès au système d’information

2.6.2.2 C-Datalog

Les auteurs de [Bertino03] ont proposé d’utiliser le paradigme Complex-DATALOG
(C-DATALOG), une extension orientée objet de DATALOG [Greco92] qui permet d’ex-
primer de façon naturelle des hiérarchies entre les concepts des modèles de contrôle
d’accès. Cette proposition est utilisée pour représenter les modèles Identity-BAC, MAC
et RBAC hybrides. L’approche permet également l’expression de contraintes sur les po-
litiques sous forme de règles, mais sans structuration. La méthode proposée pour l’im-
plantation est une traduction en DATALOG des modèles exprimés en C-DATALOG.

2.6.2.3 Authorization Speciﬁcation Language

Le langage Authorization Speciﬁcation Language (ASL), est proposé dans [Jajodia01]
comme cadre logique pour exprimer des politiques de contrôle d’accès hybrides. Ce fra-
mework se base sur la notion de stratiﬁcation pour permettre l’expression de négation.
Les strates sont des restrictions syntaxiques sur les expressions autorisées du langage.
Le cadre est illustré par un modèle de contrôle d’accès ad hoc qui intègre des notions
de rôles et de hiérarchies, mais sans se baser strictement sur le cadre de RBAC (comme
le font [Barker03, Bertino03]). L’article s’intéresse particulièrement aux problèmes de
gestion des conﬂits qui surviennent dans les politiques hybrides, mais ne traite pas des
contraintes entre concepts.

2.6.2.4 Logiques modales

Les logiques modales étendent la logique des prédicats du premier ordre en ajou-
tant, en plus des connecteurs booléens, des modiﬁcateurs qui peuvent s’interpréter in-
formellement comme des adverbes sur les prédicats. Les modalités permettent d’expri-
mer la possibilité, la permission, l’obligation, la connaissance, etc. La sémantique des
mondes possibles (ou sémantique de Kripke) permet d’évaluer la vérité des proposi-
tions de logique modale. Selon les modes autorisés dans la construction des formules,
différentes logiques modales existent :

– la logique modale classique, exprime la nécessité et la possibilité (et leur négation),
– la logique déontique, exprime l’obligation, l’interdiction et la permission, elle per-

met d’exprimer des règlements moraux,

– les logiques temporelles, introduisent des modes temporels sur un temps discret,

comme toujours, un jour, jusqu’à ce que, . . . .

La logique déontique [Jones93] a été proposée pour évaluer les règlements de sé-
curité [Abou El Kalam03, Cholvy97], en particulier pour résoudre les conﬂits dans les
politiques hybrides. Certaines simpliﬁcations ont été apportées, notamment la suppres-
sion de la modalité de recommandation. Le cadre de la logique déontique a été utilisé

Section 2.6. Cadres logiques pour le contrôle d’accès

53

pour exprimer formellement le modèle ORBAC, mais pour l’évaluation des formules,
l’approche se base sur une transformation en logique du premier ordre non modale.

La logique temporelle linéaire (Linear Temporal Logic – LTL) a été proposée pour véri-
ﬁer qu’une politique satisfait bien à des propriétés attendues. L’approche de [Hansen05]
est celle du Model-Checking de politiques RBAC. Le modèle de contrôle d’accès et la poli-
tique sont exprimés dans un langage (PROMELA), les propriétés attendues – c’est-à-dire
les contraintes sur les modèles, comme l’exclusion mutuelle – sont exprimées en LTL.
Le vériﬁcateur SPIN [Holzmann97] vériﬁe que les propriétés sont satisfaites en explo-
rant tous les états possibles du système RBAC. Les auteurs de [Mossakowski03] ont
également proposé d’utiliser une logique temporelle pour représenter formellement les
propriétés des modèles de contrôle d’accès Extended-RBAC qui permet l’expression de
contraintes temporelles.

2.6.3 Cadre basés sur la représentation graphique

Les auteurs de [Koch03] notent que pour éviter les erreurs dans les politiques de
contrôle d’accès, il est utile de disposer d’une modélisation graphique qui permette de
représenter les règles de contrôle d’accès et rendre ainsi plus facile les tâches d’admi-
nistration. [Koch03] fait un tour d’horizon des paradigmes graphiques proposés pour
la spéciﬁcation et la vériﬁcation graphique de politiques de contrôle d’accès. Le type
de vériﬁcations étudié est la « résolution des conﬂits », c’est-à-dire la détection de
contraintes inconsistantes. Trois approches sont évaluées dans [Koch03], nous adjoi-
gnons à cette comparaison une quatrième (la dernière) :

– ALLOY est un langage graphique basé sur la logique du premier ordre muni
d’un model checker qui permet l’expression de comportement et contraintes com-
plexes [Jackson00]. La méthode proposée de vériﬁcation pour les politiques RBAC
est un parcours exhaustif de toutes les sessions possibles. Cette approche ne per-
met pas d’inférer sans déﬁnir de politique ni d’exprimer des contraintes.

– Graph Transformation (GT) est un modèle de graphe où des règles de transforma-
tion sont utilisées pour déduire des connaissances [Rozenberg97]. Ce modèle ne
permet pas de représenter toutes les propriétés que les modèles de contrôle d’ac-
cès respectent. Il ne permet pas non plus l’expression des politiques.

– UML (Uniﬁed Modelling Language) muni d’OCL (Object Constraint Language) pour
ajouter une sémantique logique aux schémas UML [Richters01]. Cette modélisa-
tion reste cependant semi-formelle car basée sur UML. De plus, la méthode pro-
posée pour la vériﬁcation des propriétés est une transformation en GT.

– la représentation graphique du modèle Dynamically Types Access Control (DTAC),
basée sur les graphes. Cette approche permet de représenter graphiquement les
noyaux des modèles de contrôle d’accès, ainsi que les principes qui les gou-
vernent [Tidswell01]. Comme GT, ce modèle ne permet pas de représenter les
politiques, seulement les modèles.

54

Chapitre 2. Contrôle d’accès au système d’information

Représentation

UML Concepts, principes
ALLOY Concepts
GT
DTAC Concepts, principes, contraintes Résolution de conﬂits

Vériﬁcation
Transformation en GT
Parcours exhaustif

Concepts, principes, contraintes Parcours exhaustif, résolution de conﬂits

TAB. 2.6 – Cadres pour la spéciﬁcation et la vériﬁcation graphique

Seul le modèle DTAC est appliqué à d’autres modèles que RBAC. Le tableau 2.6,
en partie extrait de [Koch03], synthétise les apports de ces propositions. La première
colonne indique les aspects des modèles de contrôle d’accès que les propositions sont
capables de représenter. La seconde colonne indique quelles sont les possibilités de
vériﬁcations proposées par les approches.

2.7 Discussion et synthèse

Cette section résume et critique l’état de l’art que nous avons proposé, en croisant
les aspects fonctionnels des modèles de contrôle d’accès : structuration, hiérarchisation
des concepts, enrichissements et outils d’administration, avec les aspects théoriques des
cadres proposés pour leur étude. Nous terminons ce chapitre par une représentation
synthétique, sous forme de tableaux croisés (tableaux 2.7 et 2.8).

2.7.1 Structuration des droits

Depuis les modèles historiques, nous avons suivi l’évolution du contrôle d’accès
vers la structuration des droits, puis l’enrichissement progressif des modèles avec des
contraintes et la prise en compte de contextes et enﬁn les cadres logiques pour repré-
senter et raisonner sur le contrôle d’accès. Nous sommes en présence de propositions :
– de modèles de contrôle d’accès qui introduisent de multiples concepts pour struc-
turer les droits, du rôle à l’organisation en passant par les tâches et les hiérarchies,
– d’enrichissements des modèles, avec la notion de contraintes – en particulier l’ex-

clusion mutuelle et la séparation des tâches – ou l’intégration du contexte,

– composites, combinant des concepts introduits dans différents modèles, avec le but

d’offrir la palette la plus vaste possible d’expression pour structurer les droits,

– de cadres logiques qui permettent l’expression de multiples règles de déduction

des autorisations, mais qui n’imposent pas de structuration des droits,

– de prise en compte des besoins de l’administration et de la conception de modèles

et de politiques de contrôle d’accès.

Section 2.7. Discussion et synthèse

55

La famille des modèles RBAC et les modèles qui les ont étendus ont fait l’objet
d’études approfondies. Nous avons assisté à des rafﬁnements successifs du noyau fon-
dateur RBAC0, construit autour de la notion centrale de rôle. Ces enrichissements n’ont
pas toujours comblé les lacunes des modèles initiaux [Li07].

D’autres auteurs ont préféré remplacer la notion de rôle des modèles RBAC par une
ou plusieurs autres, comme les organisations dans ORBAC ou les tâches dans TBAC.
Une démarche de rafﬁnement à partir de ces nouveaux concepts est alors entreprise. Les
extensions s’orientent souvent vers la prise en compte du contexte et des contraintes.
Cependant ces approches n’intègrent pas certaines des propriétés identiﬁées dans les
modèles RBAC. Le problème majeur de l’intégrité des politiques, étudié dans le cadre
de RBAC, n’a pas toujours été repris.

Nous pensons qu’il est important d’identiﬁer des concepts centraux pour que les
administrateurs puissent structurer efﬁcacement les droits d’accès. Nous considérons
même que la structuration du contrôle d’accès est incontournable pour une gestion sûre
et efﬁcace des droits, et qu’en conséquence, les approches non structurées sont trop
délicates à utiliser, en particulier car elles manquent d’outils pratiques associés.

Nous pensons cependant qu’aucune structuration n’est meilleure qu’une autre dans
le cas général : concevoir un bon modèle de contrôle d’accès pour une organisation est
une tâche spéciﬁque propre à cette dernière. En effet, pour une petite structure, un
modèle contextuel simple est un choix satisfaisant : il est envisageable de gérer plu-
sieurs contextes associés aux utilisateurs si leur nombre est réduit. À l’inverse, pour
une multinationale, il sera certainement nécessaire d’avoir une notion de rôle générale
accompagnée de concepts et de relations spéciﬁques, capables de prendre en compte
de multiples facettes des métiers. Ceci explique en partie les spéciﬁcités des implémen-
tations du standard RBAC.

Le modèle de contrôle d’accès pour les métiers de la santé proposé par le GMSIH
est un bon exemple de modèle développé pour une catégorie d’organisations, par et
pour les acteurs des systèmes d’informations de santé [GMSIH03]. Nous pensons donc
qu’il faut permettre aux concepteurs de développer des modèles de contrôle d’accès
adéquats aux besoins de sécurité des organisations, en prenant en compte l’évolution
des modèles et les besoins de l’administration.

2.7.2 Intégrité des politiques

Dans tous les cas d’utilisation des modèles de contrôle d’accès : il est incontour-
nable de s’assurer de l’intégrité de la politique, c’est-à-dire s’assurer que la politique de
contrôle d’accès respecte bien le modèle dont elle est une instance. En particulier, des
propriétés devant être respectées sont déﬁnies dans les modèles, il faut s’assurer que
les politiques les satisfassent effectivement.

56

Chapitre 2. Contrôle d’accès au système d’information

Plusieurs propositions ont identiﬁé les propriétés que les modèles à rôles doivent
respecter. Des outils pour vériﬁer que les politiques respectent bien ces propriétés ont
été proposés en conséquence. Cependant, ces vériﬁcations n’ont pas toujours envisa-
gées pour les modèles autres que RBAC.

Cette constatation est particulièrement notable pour les approches qui permettent
de déﬁnir de nouveaux modèles ad hoc bâtis sur des cadres logiques, sans structuration
imposée. La déﬁnition de nouveaux concepts et relations dans un modèle implique la
déﬁnition de contraintes s’assurant que la politique est valide. Par exemple, l’interac-
tion entre la notion de hiérarchies et l’exclusion mutuelle induit des propriétés que les
politiques doivent respecter. Or plusieurs modèles proposent d’utiliser l’exclusion et
les hiérarchies, mais peu ont identiﬁé ces interactions.

2.7.3 Cadres logiques

Les cadres logiques que nous avons présentés sont majoritairement proposés
comme des extensions de DATALOG. Ces modèles permettent d’exprimer des règles de
déduction, mais certaines contraintes permettant de s’assurer que les politiques sont
valides ne sont pas envisagées. De plus, l’implantation des modèles est généralement
une réécriture de règles comportant des constructeurs ad hoc en DATALOG, ce qui ajoute
une étape de traduction des modèles.

Plusieurs modèles utilisent la notion de rôle, or dans [Ferraiolo03b] il est indiqué
que toute affectation de privilège doit se faire par l’intermédiaire d’un ou plusieurs rôles,
aucune affectation directe de permission à un utilisateur n’est autorisée. Cette propriété
permet de s’assurer qu’aucun administrateur n’a « court-circuité » la notion de rôle, et
évite de tomber dans l’écueil des modèles matriciels où la revue des permissions est
difﬁcile. À notre connaissance, ce principe élémentaire des modèles RBAC n’a pas été
prise en compte dans d’autres modèles structurés.

Enﬁn, les propositions de formalisation ne séparent pas toujours manifestement les
différents composants du contrôle d’accès, en particulier la distinction entre d’une part,
le modèle qui structure les droits, et la politique qui en est l’instance d’autre part. De
même, les activités de conception de modèle, de conception de politiques et d’admi-
nistration sont généralement mélées. Enﬁn, la séparation entre le contenu factuel de la
politique et ce qui peut en être déduit n’est pas toujours séparé non plus.

2.7.4 Notre approche

Notre approche est de structurer les politiques de contrôle d’accès du point de vue

des données. Nous allons catégoriser l’organisation des droits d’accès selon :

– les modèles de contrôle d’accès : l’ensemble de concepts et de relations qui per-

mettent de structurer les droits,

Section 2.7. Discussion et synthèse

57

– les politiques elles-mêmes : des instances des modèles de contrôle d’accès que les

administrateurs alimentent et sur lesquelles se basent les moniteurs,

– les principes des modèles : des ensembles de règles de déduction qui permettent

de dériver les autorisations effectives à partir des politiques,

– les contraintes d’intégrité des modèles : des ensembles de propriétés qui permettent

de s’assurer de la validité des politiques.

Le modèle DATALOG et ses dérivés ont été largement adoptés comme cadre
d’études des modèles de contrôle d’accès structurés. Ces modèles peuvent s’avérer
insufﬁsants pour exprimer certaines restrictions que les politiques doivent satisfaire,
en particulier celles qui expriment l’existence de fait inconnus à l’avance, mais dont
on souhaite imposer la présence. Grâce à l’utilisation des dépendances de données, notre
approche permet :

– d’exprimer et de concevoir des modèles de contrôle d’accès structurés,
– de prendre en compte des enrichissements apportés sur ces modèles,
– de déﬁnir formellement des propriétés que les modèles doivent respecter,
– de déﬁnir formellement l’intégrité et l’équivalence des politiques,
– d’utiliser des outils de preuve pour vériﬁer des propriétés :

– abstraites, relatives aux modèles eux-mêmes,
– concrètes, relatives aux politiques instances des modèles,

– de pouvoir contrôler la décidabilité des raisonnements,
– de proposer une représentation graphique des modèles,
– de proposer des outils pour assister la création des politiques.
Notons qu’il existe un débat sur l’intérêt de mettre en œuvre des classes de dépen-
dances de données de plus en plus générales, qui permettent d’exprimer des restric-
tions de plus en plus expressives sur les données. En effet, d’aucuns pensent que les
seules classes de dépendances utiles pour la modélisation du monde réel sont en fait
les plus connues, à savoir les dépendances fonctionnelles, les dépendances d’inclusion
et éventuellement, les dépendances multivaluées. D’autres pensent néanmoins que des
classes plus expressives sont d’intérêt [Fagin86].

La thèse va dans cette direction en présentant des applications aux besoins de mo-
délisation du contrôle d’accès qui font appel aux classes de dépendances les plus géné-
rales. Nous exploitons également l’expressivité dans l’autre direction pour proposer de
nouvelles propriétés d’intrégité des politiques.

58

Chapitre 2. Contrôle d’accès au système d’information

2.7.5 Tableaux de synthèse

Les tableaux 2.7 et 2.8 résument le chapitre d’état de l’art en croisant, d’une part
l’étude des modèles de contrôle d’accès (tableau 2.7) et d’autre part les cadres logiques
proposés pour leur étude (tableau 2.8). Il s’agit avant tout d’essais de synthèse, dans la
mesure où il est délicat de trouver des critères objectifs consensuels pour comparer les
propositions de modèles de contrôle d’accès et de cadres logiques, mais aussi d’afﬁrmer
qu’une proposition remplit ou non un des critères.

Un rond plein (•) dans une case indique un support explicite d’un critère, un rond
vide (◦) indique que le critère est peut-être applicable ou qu’il n’a pas été détaillé. Enﬁn
une case vide indique que le critère qu’aucun élément n’est donné et (N/A) qu’il n’est
pas applicable du tout.

Les deux tableaux pourraient être regroupés pour former une seule représentation
de synthèse qui aurait la forme de la lettre L. La partie grisée de la ﬁgure 2.8 est l’in-
tersection entre les deux tableaux de synthèse. Il s’agit du croisement entre les modèles
de contrôle d’accès d’une part, avec le tableau 2.7 qui forme la barre verticale du L, et
les cadres logiques utilisés pour les formaliser d’autre part, le tableau 2.8 qui forme la
barre horizontale du L.

Nous proposons comme dernière ligne de chaque tableau de synthèse la propo-
sition de la thèse. Nous n’avons pas fait ﬁguré dans les critères certains éléments de
comparaisons qui n’ont, à notre connaissance, pas été proposés, comme la conception
de modèle ou la catégorisation entre aspects statiques et dynamiques sur laquelle nous
déﬁnissons l’administration des politiques.

La page suivante est volontairement laissée blanche pour que les tableaux et leurs

descriptions respectives soient face-à-face.

Cadres logiques

Modèles de contrôle d’accès

FIG. 2.8 – Combinaison des deux tableaux de synthèse

Section 2.7. Discussion et synthèse

59

60

Chapitre 2. Contrôle d’accès au système d’information

2.7.5.1 Critères de synthèse des modèles de contrôle d’accès

Aﬁn de faciliter la lecture du tableau de synthèse 2.7, les modèles de contrôle d’accès

sont regroupés selon les grandes catégories de concepts présentés :

– les cinq premières colonnes regroupent les modèles historiques,
– les quatre suivantes concernent des modèles orientés tâches et ﬂux,
– la colonne suivante concerne le modèle ORBAC,
– les six colonnes suivantes regroupe les modèles organisés selon la notion de rôle,
– la dernière regroupe sous un terme générique les modèles basés sur les règles,

section 2.5.4.

Les critères (en lignes) proposés pour évaluer les différents modèles de contrôle

d’accès sont regroupés en quatre blocs :

1. la structuration des modèles :

– quels sont les concepts utilisés ou introduits pour structurer les droits,
– quels types de hiérarchies ont été proposés pour organiser les concepts,
– la possibilité de déﬁnir des interdictions dans le modèle,
– les aspects de la structure qui ont été formalisés,

2. les enrichissements proposés pour ces modèles :

– les catégories de contextes introduites dans l’expression des autorisations,
– les contraintes qui peuvent être déﬁnies dans les modèles,

3. les outils d’administration qui ont été développés :

– les modèles d’administration, qui organisent les droits des administrateurs,
– les primitives d’interrogation des politiques
– les outils de fouille pour assister la création de politiques,
– les outils permettant de vériﬁer l’intégrité des politiques
– les représentations graphiques des modèles et des politiques,

4. les cadres logiques proposés pour formaliser et vériﬁer les modèles de contrôle
d’accès. Ces cadres sont comparés dans le tableau 2.8. C’est l’intersection entre les
deux tableaux de synthèse représentée par la partie grisée de la ﬁgure 2.8.

é
t
i
t
n
e
d
Modèle I
Rôles
Données
Flux
Niveaux
Multiples

• •

Limitées
Générales
Multiples

•

• •

•

• •

• • •

◦ ◦

•

Principes
• • • • •
Structures ◦ ◦ • • ◦
Intégrité
• • • • •

Temps
Espace
Concept
Libre

Exclusions
Pré-requis
Libres

◦ ◦ ◦ ◦ ◦
◦ ◦ ◦ ◦ ◦

◦ ◦
• • • •

◦ ◦ •
◦ ◦ ◦ ◦ ◦
◦ ◦ ◦ ◦ ◦
◦ ◦ ◦
◦
◦
◦ ◦ ◦
◦ ◦ ◦ ◦
◦ ◦ ◦ ◦
◦ ◦ ◦ ◦

◦ ◦
◦ ◦
• ◦ • •
◦ ◦

◦
◦
◦
◦

◦ ◦ ◦
◦ ◦ ◦
◦ ◦ ◦
◦ ◦ ◦

Structuration

Concept

Hiérarchies

Interdictions

Formalisation

Contexte

Enrichissements

Contraintes

Modèle
Interrogation
Fouille
Intégrité
Graphique
C-DATALOG
DATALOG¬
RTC
1
DATALOGC
DL
D3LOG
BINDER

GT
ALLOY
DTAC
UML/OCL

Administration

Cadre

LITHIUM
CLP
LTL
L. déontique
L. de description

DCC
ASL

C
A
D

C
A
M

s
i
l
l
i
e
r
T

s
e
u
V

C
A
B
R
W

C
A
M
T

C
A
B
T

D
T
M
A

C
A
B
R
O

C
A
B
R
T

C
A
B
R

C
A
B
R
T
G

C
A
B
R
S
C

C
A
B
R
O
E
G

C
A
B
R
V
N
E

C
A
B

-
e
l
u
R

•

◦

•

•
•

•

•

•
•

• • •

• • •
◦
• • •

•

◦ ◦ ◦ ◦

◦ ◦ ◦ ◦
◦ ◦ ◦ ◦
◦ ◦ ◦ ◦

◦ ◦ ◦ ◦

•
•

•

•
◦

•

•
•
◦

◦
◦

•

•

•

•
◦

◦
◦

•

•

• • • • • •

◦ ◦ ◦

• • •
• • •
• •

• •
• •

•

◦

•
• •
◦

•

• •
• •
•

• • ◦

◦
◦ • ◦
•

•

• • • • • •
• ◦ ◦

•

•

•
•
•
•
•
•
◦
• • ◦ ◦ ◦
• • • • • ◦
◦
◦
◦

•
•
•
• ◦

◦ ◦ ◦
• • ◦
• •
◦
•

◦

◦
◦
◦
◦
•

◦
◦
•

•

•
•
•
•

•

•

◦

•

•
•
•
•
•

•
◦

•
•

•

◦ ◦ ◦ ◦

◦ ◦ ◦ ◦

◦ ◦ ◦ ◦

Notre proposition

• ◦ • • ◦

• • • ◦

•

• • ◦ ◦ ◦ ◦

TAB. 2.7 – Essai de synthèse des modèles de contrôle d’accès

62

Chapitre 2. Contrôle d’accès au système d’information

2.7.5.2 Critères de synthèse des cadres logiques

Plusieurs cadres ont été proposés pour formaliser et inférer sur les différents mo-
dèles de contrôle d’accès du tableau 2.7. Les tableaux 2.8 regroupent les cadres logiques
en quatre en grandes familles :

– les six premières lignes rassemblent les modèles basés sur DATALOG,
– les quatre suivantes sont des paradigmes graphiques,
– les deux lignes suivantes concernent deux cadres de programmation logique,
– les trois lignes suivantes sont des propositions de logiques modales,
– les deux dernières lignes traitent des cadres DCC [Abadi07] et ASL [Jajodia01].
Les critères (en colonnes) pris en compte pour l’évaluation des modèles logiques

proposés pour la formalisation du contrôle d’accès sont :

1. l’expressivité des langages, basée sur la comparaison des constructions de formules

logiques autorisées,

2. les outils développés pour ces modèles, en comparant si des algorithmes d’interro-
gation, d’inférence ou de satisfaction ont été proposés. Notons que les problèmes
de la satisfaction et de l’interrogation sont assez similaires : pour le premier on
s’intéresse à l’existence d’une valuation alors qu’on les cherche toutes pour le se-
cond,

3. les caractéristiques des propositions, selon trois sous-critères :

– que le cadre soit développé comme une réduction d’un autre modèle,
– que le cadre se base sur les axiomes et règles d’inférences de la logique du

premier ordre,

– que le cadre sépare le modèle de l’instance,

4. les applications à la conception et à l’administration du contrôle d’accès proposées.

F
o
n
c
t
i
o
n
s

C
o
n
t
r
a
i
n
t
e
s

t
ê
t
e

C
o
n
t
r
a
i
n
t
e
s

c
o
r
p
s

N
é
g
a
t
i
o
n

E
x
i
s
t
e
n
t
i
e
l

M
o
d
e
s

M
u
l
t
i
p
l
e
s

t
ê
t
e
s

C
o
n
s
t
r
u
c
t
e
u
r
s

I
n
t
e
r
r
o
g
a
t
i
o
n

S
a
t
i
s
f
a
c
t
i
o
n

I

m
p
l
i
c
a
t
i
o
n
l
o
g
i
q
u
e

R
é
é
c
r
i
t
u
r
e

R
è
g
l
e
s

i
n
f
é
r
e
n
c
e

S
é
p
a
r
a
t
i
o
n
m
o
d
è
l
e
/
i
n
s
t
a
n
c
e

R
e
p
r
é
s
e
n
t
a
t
i
o
n

I
n
t
é
g
r
i
t
é
d
e
s
p
o
l
i
t
i
q
u
e
s

È
v
o
l
u
t
i
o
n
d
e
m
o
d
è
l
e

C
o
n
c
e
p
t
i
o
n
d
e
m
o
d
è
l
e

I
d
e
n
t
i
ﬁ
c
a
t
i
o
n
a
u
t
o
m
a
t
i
s
é
e

Cadre

Ref.

Modèles cibles

Basés sur DATALOG

C-DATALOG
DATALOG¬
RTC
1
DATALOGC
DL
D3LOG
BINDER

GT
ALLOY
DTAC
UML/OCL

[Bertino03]
[Miège05]
[Li04b]
[Li03b]
[Li03a]
[Jim01a]
[DeTreville02]

Graphiques

[Koch03]
[Koch03]
[Tidswell01]
[Sohr05]

Programmation logique

Modèles multiples
ORBAC
Trust management
Trust management
Trust management
Trust management
Trust management

RBAC
RBAC
Modèles multiples
RBAC

•
•
•
•
•

•

N/A
N/A
N/A
N/A

LITHIUM
CLP

[Halpern03]
[Barker03]

Non-spéciﬁé
TRBAC

•
• •

•
•

Basés sur PROLOG

LTL
L. déontique
L. de description [Liu05]

[Hansen05]
[Abou El Kalam03]

RBAC
ORBAC
RBAC

• •

DCC
ASL

[Abadi07]
[Jajodia01]

Non-spéciﬁé
Modèles multiples

• • •

•

Notre proposition

Modèles multiples

• •

•

•

•

•

•
•
•

•
•
•

•

•
•
•
•
•
•
•

•
•

•
•
•

◦

•

•
•
•
◦
◦
◦
◦

•
•

•
•

•
◦

•

◦
◦
◦
◦

•
•
•
•

◦
◦

•
•
•

•
◦

•

•

•
•
•

•

• •
• •
•

•

•
•
•
•
•
•
•

•

•

•

◦
•
◦
◦
◦
◦
◦

•
•
•
•

◦
◦

◦

•

TAB. 2.8 – Essai de synthèse des cadres logiques

◦

◦
◦
◦
◦
◦

•

◦

◦

◦
◦

•

•
•
•
•

◦

• • •

Bewareofbugsintheabovecode;Ihaveonlyproveditcorrect,nottriedit.

Donald Knuth – “Notes on the van Emde Boas construction of priority

deques : An instructive use of recursion”

3

Choix d’un cadre logique

⊲ L’état de l’art a montré que de nombreux modèles ont été proposés pour organiser les droits des
utilisateurs selon les besoins des organisations. La thèse ne vise pas à déﬁnir un nouveau modèle de
contrôle d’accès mais à proposer une structuration logique qui permette de reprendre les éléments de
modélisation existants en les généralisant (chapitre 4). L’objectif est de pouvoir construire des outils
permettant la conception de nouveaux modèles et la vériﬁcation des politiques (chapitre 5).

La réalisation de ces objectifs nécessite de choisir un cadre logique approprié homogène qui permet
d’exprimer et d’inférer sur le plus grand nombre d’aspects présentés dans l’état de l’art. Le cadre que
nous proposons est issu du modèle relationnel : c’est celui des dépendances de données. Ce chapitre
présente le cadre et l’illustre avec son application aux modèles RBAC qui est la famille de modèle la plus
étudiée.

Les contributions présentées dans ce chapitre concernent :
– la classiﬁcation en composants (noyau, principes et propriétés) des notions introduites dans la

littérature sur les modèles de contrôle d’accès,

– la proposition d’un cadre logique pour l’étude des modèles et des politiques de contrôle d’accès,
– l’introduction de la notion d’intégrité des politiques de contrôle d’accès,
– l’analyse et la synthèse des développements successifs introduits dans les modèles RBAC,
– l’application du cadre logique pour la vériﬁcation des modèles RBAC.
La déﬁnition des dépendances dans ce chapitre se base sur [Abiteboul95]. Plus précisement les cha-
pitres huit (Functional and Join Dependencies) et dix (A larger Perspective). La notation utilisée et les
déﬁnitions se réfèrent à l’annexe A. La formalisation logique des modèles RBAC est donnée en annexe B.
Une trace de l’inférence de la section 3.4.5 est proposée en annexe C. ⊳

66

Chapitre 3. Choix d’un cadre logique

Plan du chapitre

3.1 Critères pour un cadre logique . .

.

. .

. .

. .

. .

. .

.
.
.
.

. .
. .

.
. .

. .
. .
. .
. .

Présentation . .
. .

3.1.1
3.1.2
. .
3.1.3 Application aux modèles à rôles
Structuration des modèles .
. .
. .
3.2.1 Noyau des modèles de contrôle d’accès .
3.2.2
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
Critères fonctionnels pour le cadre logique .
. .
Critères non fonctionnels pour le cadre logique .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. .
.
. .
Structuration du cadre logique . .
.
Vers une spéciﬁcation générique du contrôle d’accès .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .

. .
. .

. .
. .

. .
. .

.

. .

3.4

3.2

. .
. .

. .
. .
. .
. .

. .
. .
. .
. .

Revue de politiques . .
3.3 Modélisation des principes . .
. .
. .

. .
. .
. .
3.3.1
. .
3.3.2 Déﬁnitions .
3.3.3 Déduction dans les modèles à rôles . .
Intégrité des politiques de contrôle d’accès . .
3.4.1 Dépendances de données .
. .
3.4.2
. .
.
3.4.3
3.4.4
3.4.5 Utilisation des procédures .
3.4.6

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
Preuve de l’implication . .
. .
Propriétés des modèles de contrôle d’accès .
. .
Propriétés des modèles à rôles
. .
. .
. .
. .
. .
. .

. .
. .
Expression de l’exclusion mutuelle . .
. .
. .
. .

3.5 Discussion et synthèse .
3.5.1 De la négation .
3.5.2
3.5.3

. .
. .

. .
. .

. .
. .

. .
. .

.
.

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

67
67
67
68
69
69
70
71
71
72
76
79
79
85
92
92
93
95
96
96
97
98

Section 3.1. Critères pour un cadre logique

67

3.1 Critères pour un cadre logique

LE chapitre d’état de l’art a montré que plusieurs cadres issus de la logique ont été

proposés pour formaliser le contrôle d’accès. Chacun mettant à proﬁt l’expressivité
offerte pour développer et enrichir les modèles. Les directions prises par ces recherches
peuvent être organisées selon trois objectifs :

– répondre au besoin d’expressivité des modèles, qui conduit à des propositions

théoriques riches, étendant DATALOG notamment,

– répondre au besoin de vériﬁcation des modèles et des politiques, qui conduit à
l’utilisation d’outils de preuve à la décidabilité contrôlée permettant d’inférer sur
les droits d’accès,

– répondre au besoin de réalisation du contrôle d’accès, qui conduit à privilégier les

cadres disposant de mécanismes techniques nécessaires à une implémentation.

3.1.1 Critères fonctionnels pour le cadre logique

On retrouve ainsi une problématique de qualité, où une proposition de concep-
tion et d’administration des politiques doit satisfaire au mieux ces trois objectifs. Nous
avons dû identiﬁer un cadre théorique permettant de répondre au mieux aux objectifs
fonctionnels suivants :

– l’expression des entités et relations introduits dans les différents modèles de contrôle
d’accès par les administrateurs, pour répondre au mieux aux besoins des organi-
sations,

– l’expression des enrichissements des modèles en permettant la modélisation de

contraintes et d’aspects complexes,

– de formalisation des principes et propriétés que les modèles doivent respecter, dans

un langage d’expression commun et sans ambiguïté,

– la vériﬁcation des politiques, le cadre doit être doté d’algorithmes permettant de

vériﬁer efﬁcacement que la politique est correcte,

– l’implantation dans les systèmes d’information, en particulier la possibilité de sto-

cker et interroger efﬁcacement les politiques,

– la conception d’outils d’aide à l’administration des politiques, en particulier la

représentation graphique et l’aide à la conception.

3.1.2 Critères non fonctionnels pour le cadre logique

Le cadre que nous avons sélectionné répond à ces verrous scientiﬁques de modéli-
sation et de formalisation du contrôle d’accès logique. Dans le développement de notre
proposition, nous avons accordé une importance particulière à :

68

Chapitre 3. Choix d’un cadre logique

l’homogénéité : notre approche permet de répondre à de nombreuses problématiques
qui surviennent tout au long du cycle de vie du contrôle d’accès, dans un cadre
logique sous-jacent homogène,

le bon fondement : la proposition s’appuie sur les fondements logiques des bases de
données et utilise des outils qui ont été développés pour répondre à des besoins
de modélisation complexe,

l’utilisabilité : nous proposons des outils permettant d’automatiser une partie des
tâches d’administration, utilisables par les acteurs de la sécurité des systèmes
d’information.

Notre proposition est construite sur le modèle relationnel, et principalement avec
les dépendances de données qui permettent de s’assurer que les données en extension (la
politique elle-même) et en intention (les données déductibles à partir de la politique)
sont cohérentes avec les entités du monde réel qu’elles représentent. Notre architecture
logique est décomposable en trois niveaux :

– le modèle relationnel, sous-jacent aux dépendances et aux bases de données dé-

ductives, forme la couche la plus basse.

– le modèle DATALOG permet l’expression de règles de déduction de nouveaux

faits en intention à partir de faits connus en extension.

– les dépendances de données, qui permettent d’exprimer des contraintes sur les

données en intention ou en extension.

L’apport scientiﬁque de notre proposition se démarque de celles présentées dans
l’état de l’art par la prise en compte de l’intégrité des politiques. En effet, nous considé-
rons qu’il est d’une grande importance de s’assurer que les droits des utilisateurs sont
consistants et qu’aucune erreur n’est introduite dans les politiques. La notion d’inté-
grité est centrale dans la thèse.

3.1.3 Application aux modèles à rôles

Comme l’a montré l’état de l’art, Les modèles RBAC sont à la base de nombreux
développements et forment un socle commun des notions introduites dans le contrôle
d’accès. Ce chapitre présente les principes de notre proposition avec la structuration de
la famille RBAC avec le cadre relationnel.

Nous allons successivement enrichir la modélisation basée sur les rôles pour
prendre en compte les modèles étendant la famille de base et montrer quels sont
les apports des dépendances. Ensuite, nous généraliserons cette approche à d’autres
modèles de contrôle d’accès dans le chapitre 4.

Section 3.2. Structuration des modèles

69

FIG. 3.1 – Modèle Entité-Relation de RBAC0

3.2 Structuration des modèles

Notre proposition se base sur l’hypothèse qu’un modèle de contrôle d’accès est ex-
primable en terme de concepts et de relations entre ces concepts. Nous avons déjà in-
troduit les notions d’utilisateurs, de sujets, d’objets et d’actions. L’étude des modèles
de contrôle d’accès a montré que selon les modèles, plusieurs concepts intermédiaires
peuvent être introduits, et que des relations supplémentaires permettent d’exprimer les
hiérarchies et les contraintes de ces modèles.

3.2.1 Noyau des modèles de contrôle d’accès

Nous proposons d’utiliser le cadre des bases de données relationnelles, étendu par
des règles de déductions et des dépendances de données. L’objectif est de représenter,
d’intégrer et de vériﬁer les modèles et les politiques de contrôle d’accès. Le modèle
relationnel est un socle sur lequel s’appuient les autres couches de la proposition.

Illustrons l’application du cadre relationnel à la représentation du modèle RBAC0,
dont le tableau 2.5 présente la caractérisation ensembliste. Une représentation du
modèle RBAC0 en Entité-Relation est donnée en ﬁgure 3.1. Nous avons choisi de re-
présenter l’affectation de permissions aux rôles par une relation A f f ecte ternaire.
Dans le cadre relationnel nous notons RBAC0 la modélisation de RBAC0. La struc-
ture de RBAC0 est représentable par le schéma en extension de base de données
edb = {Habilite(U, R), A f f ecte(R, A, O), Repr ´esente(S, U), Endosse(S, R)}. Ce schéma
de base de données relationnelle exprime comment les droits dans le système sont
structurés et enregistrés.

Une politique de contrôle d’accès organisée selon le modèle RBAC0 est ainsi une
instance I du schéma edb de RBAC0. Le tableau 3.1 est un exemple de politique où
les droits statiques des utilisateurs correspondent à la matrice de contrôle d’accès du
tableau 2.2. On remarque qu’un utilisateur peut être affecté à plusieurs rôles et qu’il
peut endosser plusieurs sujets (sessions) [Sandhu96].

70

Chapitre 3. Choix d’un cadre logique

Relation Habilite

Utilisateur

Rôle

Alice
Alice
Bob
Bob
Charly
Charly
Denise

Sujet

S1
S1
S2
S3
S4
S5

Infirmier
M´edecin
Infirmier
Gastrologue
Infirmier
P´ediatre
Secr´etaire

Relation Endosse

Rôle

Infirmier
M´edecin
Infirmier
Gastrologue
P´ediatre
Secr´etaire

Relation A f f ecte

Rôle

Action

Objet

Infirmier
Infirmier
Infirmier
M´edecin
Gastrologue
Gastrologue
Gastrologue
Gastrologue
P´ediatre
P´ediatre
P´ediatre
P´ediatre
Secr´etaire
Secr´etaire

r
r
r
w
w
r
w
x
w
r
w
x
r
r

Fichier1
Fichier2
Fichier3
Fichier1
Fichier2
Fichier4
Fichier4
Fichier4
Fichier3
Fichier4
Fichier4
Fichier4
Fichier3
Fichier4

Relation Repr ´esente

Sujet

Utilisateur

S1
S2
S3
S4
S5

Alice
Bob
Bob
Charly
Denise

TAB. 3.1 – Instance du schéma relationnel de RBAC0

3.2.2 Revue de politiques

Le langage des requêtes conjonctives formé sur les relations du schéma de RBAC0
permet ce qui est nommé la revue des permissions (permissions review), c’est-à-dire la
possibilité d’interroger la politique de contrôle d’accès en vue de son administra-
tion [Ferraiolo03b]. Notons que pour l’instant, nous n’avons pas introduit la notion
de hiérarchie de rôles. Les requêtes suivantes sont des exemples de revues :

1. l’ensemble des permissions attribuées aux utilisateurs par l’intermédiaire des

rôles qui leurs sont attribués : {u, a, o | ∃r Habilite(u, r) ∧ A f f ecte(r, a, o)},

2. l’ensemble des utilisateurs qui disposent dans une session de la permission

d’écrire (r) : {u | ∃s, o, r Repr ´esente(s, r) ∧ Endosse(s, r) ∧ A f f ecte(r, r, o)},

3. l’ensemble des rôles qui disposent de permissions sur l’objet File4 et qui sont
actuellement endossés au cours de sessions : {r | ∃a, s A f f ecte(r, a, Fichier4) ∧
Endosse(s, r)},

4. l’ensemble des utilisateurs auxquels le rôle Infirmier est attribué, ou simplement

l’ensemble des inﬁrmiers du système : {u | Habilite(u, Infirmier)},

5. l’ensemble des permissions accordées au rôle Infirmier, ou simplement l’en-

semble des droits des inﬁrmiers du système : {a, o | A f f ecte(Infirmier, a, o)}.

Section 3.3. Modélisation des principes

71

Les requêtes 4 et 5 en particulier sont du plus grand intérêt : elles correspondent aux
applications assigned_users(Infirmier) et assigned_perms(Infirmier) déﬁnies en sec-
tion 2.3.2. Nous pouvons nommer ces requêtes pour construire des vues AssignedUsers
et AssignedPerms déﬁnies en intention. Le pouvoir d’expression des requêtes conjonc-
tives permet de réaliser les fonctionnalités simples, mais incontournables, qu’un sys-
tème de gestion de contrôle d’accès doit proposer.

Or, l’implantation des fonctionnalités de revue peut être délicate. Le standard RBAC
indique que parmi l’ensemble des spéciﬁcations fonctionnelles qu’une implantation de
RBAC doit comporter, seules les revues assigned_users et assigned_perms sont obliga-
toires [Ferraiolo03b]. Notre approche résout ce problème, non seulement pour les mo-
dèles RBAC, mais aussi pour tout modèle de contrôle d’accès dont la structure est ex-
primable dans le modèle relationnel. La citation suivante est extraite de [Ferraiolo03b] :

When URA and PRA relation instances have been created, it should be possible to
view the contents of those relations from both the user and role perspectives[. . . ]
Since not all RBAC implementations provide facilities for viewing role, user, and
soit I une instance symbolique vide de R
soit ν une valuation arbitraire des variables de φ
soit Γ l’ensemble de substitutions appliquées pour chaque dépendance
for atome Ri(c1, . . . , cn) de ν(φ) do

I ← I ∪ Ri(c1, . . . , cn)
{boucle principale}
while I′ 6= I do

I′ ← I
for α ∈ Σ, α de la forme a → b do

for valuation µ telle que µ(a) appartiennent à I do

if (α, µ) 6∈ Γ then

if α est une TGD then

for atome Ri(c1, . . . , cn) de µ(b) do

if Ri(c1, . . . , cn) 6∈ I then
I ← I ∪ Ri(c1, . . . , cn)

else

for égalité ci = cj de µ(b) do

remplacer les occurrences de ci dans I par cj

Γ ← Γ ∪ (α, µ)

{condition d’arrêt}
if σ est une TGD then

for atome Ri(c1, . . . , cn) de ν(ψ) do

if Ri(c1, . . . , cn) appartient à I then

retourner vrai et sortir

else

for égalité ci = cj de ν(ψ) do

if ci = cj ou si (ci ou cj) n’est pas présent dans I then

retourner vrai et sortir

end
retourner f aux et sortir (point ﬁxe)

FIG. 3.2 – Procédure de preuve pour les dépendances

90

Chapitre 3. Choix d’un cadre logique

σ1 MVD : R(A0, B0, C1, D0), R(A0, B1, C0, D1) → R(A0, B0, C0, D0)
σ2 FD
σ′ TTGD : R(A0, B0, C1, D1), R(A0, B1, C0, D2), R(A1, B0, C0, D0) → R(A0, B0, C0, D0)

: R(A0, B0, C0, D0), R(A1, B0, C0, D1) → A0 = A1

TAB. 3.8 – Exemples de dépendances totales

stratégie de recherche sélectionnée le résultat est le même, ce processus est dit « Church-
Rosser » [Abiteboul95].

3.4.2.4 Prise en compte de la quantiﬁcation existentielle

Pour l’extension du chase aux dépendances génératrices de tuples non totales, la
différence réside dans l’application d’une dépendance α qui comporte des variables
quantiﬁées existentiellement ˜Z. Dans ce cas, il faut étendre la valuation µ aux variables
˜Z en leur affectant des symboles de constantes arbitrairement choisis ne faisant pas
partie de I. Intuitivement, on imagine que ce peut être une source de bouclage.

Exemple 3.4 Semi-décidabilité du chase pour les dépendances non totales

Soit la dépendance σ, ∀A, B S(A, B) → ∃A′ S(B, A′), et demandons au chase de véri-
ﬁer si σ |= ∀A, B S(A, B) → R(A, B). Évidemment ce n’est pas le cas, mais regardons
le comportement de l’algorithme.

Au début, on suppose qu’il existe un tuple S(a0, b0). Par application de σ, avec µ0 =
{(A/a0), (B/b0)}, on peut déduire qu’il existe un autre tuple S(b0, a1) où a1 est un
nouveau symbole de constante : µ0 a été étendue à µ′
0 = {(A/a0), (B/b0), (A′/a1)}.
À l’étape suivante, on peut prendre µ1 = {(A/b0), (B/a1)} et déduire l’existence d’un
tuple S(a1, b1) et ainsi de suite.

Comme les dépendances génératrices de tuples contraintes sont parmi les plus gé-
nérales, nous allons présenter deux procédures de preuves qui leurs sont dédiées, déve-
loppées dans [Maher96]. C’est principalement une propriété du domaine de contraintes
utilisé, Independence of Negative Constraints, qui fait la différence entre ces deux procé-
dures.

Déﬁnition (Independence of Negative Constraints [Lassez89]). Pour un langage de
contraintes L est une interprétation D de ce langage, le couple (D, L) dispose de la propriété
Independence of Negative Constraints (INC) si, pour toutes contraintes c, c1, . . . , cn ∈ L :

D |= ˜∃ c ∧ ¬c1 ∧ . . . ∧ ¬cn

si et seulement si

D |= ˜∃c ∧ ¬ci pour i ∈ [1..n]

Section 3.4. Intégrité des politiques de contrôle d’accès

91

D’un point de vue général, les deux algorithmes dédiés aux dépendances généra-
trices de tuples contraintes reprennent le chase [Maher96]. Le principe est d’ajouter à un
magasin Env, les contraintes existantes entre les termes des tuples de I. Les contraintes
du magasin sont interprétées sur le domaine D. L’égalité en particulier est interprétée
dans ce domaine, et non traitée comme l’identiﬁcation de variables.

Quand (D, L) dispose de la propriété INC, la vériﬁcation de l’implication est sim-
pliﬁée, car il sufﬁt de considérer chaque « morceau » séparément, sans se soucier de
l’interaction des contraintes entre elles. Dans le cas où (D, L) ne dispose pas de la pro-
priété INC, la procédure est plus complexe car I et Env doivent garder en mémoire
quelles sont les contraintes supposées vraies utilisées pour produire des faits.

Quand on vériﬁe si Σ |= (φ, c → ψ, c′), où c et c′ sont des conjonctions de
contraintes, à chaque passe de la boucle principe du chase, la condition d’arrêt est tes-
tée. Un nouveau cas de terminaison doit être introduit, dans les cas où les contraintes
générées (c’est-à-dire produites par les conclusions des dépendances) se contredisent.
Trois cas de terminaison sont alors possibles :

1. si I contient une copie de ψ et que D |= Env → c′, alors Σ |= σ,
2. si le magasin est insatisfaisable , alors Σ (cid:15) σ par vacuité,
3. si I ne contient pas de copie de ψ et que l’on a atteint un point ﬁxe, alors Σ 6|= σ.

Exemple 3.5 Contraintes inconsistantes

1, R(A, B) → A < B et σ′

Soient les dépendances :
– σ1, R(A, B) → A ≤ B et σ2, R(A, B) → A ≥ B.
– σ′
2, R(A, B) → A > B.
– σ, R(A, B) → A = B.
On s’intéresse aux preuves de {σ1, σ2} |= σ et de {σ′
2} |= σ. Dans les deux cas,
les procédures de preuves commencent par supposer l’existence d’un tuple R(a, b)
qui satisfait l’hypothèse de σ. Pour la preuve de {σ1, σ2} |= σ :

1, σ′

1. par application de σ1 on ajoute (a ≤ b) à Env,
2. par application de σ2 on ajoute (a ≥ b) à Env,
3. D |= (a ≥ b) ∧ (a ≤ b) → (a = b).

La procédure termine par le cas de terminaison 1, on peut déduire que {σ1, σ2} |= σ.
Pour la preuve de {σ′

1, σ′

2} |= σ :

1. par application de σ′
2. par application de σ′
3. (a < b) ∧ (a > b) est insatisfaisable.

1 on ajoute (a < b) à Env,
2 on ajoute (a > b) à Env,

On peut déduire par vacuité que {σ′

1, σ′

2} |= σ, c’est le cas de terminaison 2.

92

Chapitre 3. Choix d’un cadre logique

3.4.2.5 Preuve de l’implication en marche arrière

Les procédures de preuves que nous avons présentées pour les dépendances géné-
ratrices de tuples [Beeri84] et leur extensions aux domaines de contraintes [Maher96,
Wang02] permettent d’inférer que Σ |= σ en marche avant. À partir de l’hypothèse de σ,
les procédures essaient de prouver sa conclusion.

Une procédure de preuve en marche arrière exploitant la notion de pièce à été mise
au point pour les dépendances génératrices des tuples [Coulondre03], il s’agit donc
d’une alternative au chase. La notion de pièce est issue du domaine des graphes concep-
tuels [Salvat96]. Informellement, nous dirons qu’une pièce est un ensemble d’atomes
d’une formule liés par la présence de variables quantiﬁées existentiellement.

De par leur nature, les procédures de preuve de l’implication en marche arrière
peuvent faciliter la compréhension et l’analyse des politiques de contrôle d’accès par
des administrateurs non spécialistes de la logique.

3.4.3 Propriétés des modèles de contrôle d’accès

Notre hypothèse de travail peut-être exprimée de façon informelle par « les autori-
sations d’un système sont des données structurées selon un modèle de contrôle d’ac-
cès : utilisons les dépendances de données pour s’assurer que les autorisations sont
valides ». Les dépendances permettent de modéliser des restrictions sur les instances
possibles d’un modèle de contrôle d’accès qui ne sont pas exprimables en DATALOG.

Les garanties de décidabilité du fragment considéré de DATALOG ou DATALOGC,
nous permettent de nous assurer qu’à partir de la politique I en extension, on peut
construire une politique I′ la plus petite possible comportant les relations en inten-
tion. Cette instance est avant tout conceptuelle, il n’est pas vraiment nécessaire de la
construire physiquement : I′ peut être considérée un ensemble de vues virtuelles déﬁ-
nies récursivement.

L’objectif est désormais de savoir si l’instance I′ respecte bien les restrictions que le
modèle de contrôle d’accès impose, représentées par un ensemble de dépendances Σ,
c’est-à-dire vériﬁer que I′ |= Σ. Grâce aux algorithmes qui permettent d’effectuer cette
vériﬁcation, nous résolvons une partie des problèmes de conception et de vériﬁcation
des modèles et des politiques de contrôle d’accès.

3.4.4 Propriétés des modèles à rôles

Comme il a été indiqué précédemment que, comme l’illustre la représentation UML
de la ﬁgure 2.2, pour garantir qu’une politique de contrôle d’accès RBAC0 soit correcte,
il faut ajouter l’expression des propriétés fondamentales des modèles RBAC à la struc-
turation relationnelle du contrôle d’accès :

Section 3.4. Intégrité des politiques de contrôle d’accès

93

Type
σ0 TGD
σ1
σ2 TTGD

Expression logique

Endosse(S, R) → ∃U Repr ´esente(S, U)

FD Repr ´esente(S, U1), Repr ´esente(S, U2) → U1 = U2

Repr ´esente(S, U), Endosse(S, R) → Habilite(U, R)

σ3 TGD
σ4 TGD
σ5 TGD

σ TGD
σ′ TTGD

Statique(U, A, O) → ∃R Habilite(U, R), A f f ecte(R, A, O)
Acc `es(S, A, O) → ∃R Endosse(S, R), A f f ecte(R, A, O)

Dynamique(U, A, O) → ∃S, R Endosse(S, R), Repr ´esente(S, U),

A f f ecte(R, A, O)

Repr ´esente(S, U), Acc `es(S, A, O) → ∃R A f f ecte(R, A, O), Habilite(U, R)

Dynamique(U, A, O) → Statique(U, A, O)

TAB. 3.9 – Formalisation logique des propriétés du modèle RBAC0

– l’existence et l’unicité de l’utilisateur associé à une session donnée (σ0, σ1),
– l’inclusion des rôles endossés dans une session dans ceux affectés à l’utilisateur

(σ2),

– l’absence d’affectation directe de permissions : le rôle doit être un intermédiaire

incontournable pour acquérir les privilèges (σ3, σ4, σ5).

Toute politique I, qui est une instance du modèle de contrôle d’accès RBAC0 doit
satisfaire les dépendances σ0, σ1 et σ2 du tableau 3.9, c’est-à-dire que ces propriétés
doivent être vériﬁées par toute politique. Les dépendances de ce tableau portent sur le
schéma edb de RBAC0. La politique jouet du tableau 3.1 satisfait σ0, σ1 et σ2.

De plus, si on ajoute à la base de données les règles de déductions des triplets d’au-
torisation du tableau 3.2, alors l’instance I′ doit également respecter σ3, σ4 et σ5 qui
expriment qu’on ne peut pas déﬁnir des triplets autorisations sans passer par des affec-
tations de rôles aux utilisateurs et de permissions aux rôles.

3.4.5 Utilisation des procédures

Quand on analyse les dépendances présentées par le tableau 3.9, on peut se deman-
der si d’autres propriétés sont satisfaites par les politiques RBAC0. Soit I′ une instance
qui satisfait les dépendances σ0 à σ5 du tableau 3.9. Alors I′ doit également vériﬁer les
propriétés suivantes qui sont logiquement impliquées par {σ0 . . . σ5} :

– si un utilisateur dispose d’une permission par l’intermédiaire d’une session, alors
l’utilisateur est affecté à au moins un rôle qu’il endosse dans la session en ques-
tion, et le rôle auquel il est affecté dispose de la permission. La dépendance σ du
tableau 3.9 formalise cette propriété exprimée en langue naturelle,

– les triplets d’autorisations dynamiques sont inclus dans les triplets d’autori-
sations statiques. Cette propriété est représentée par la dépendance σ′ du ta-
bleau 3.9.

94

Chapitre 3. Choix d’un cadre logique

Ce type d’inférence peut être réalisé à l’aide des procédures de preuve. Ces procé-
dures permettent de prouver l’implication logique d’une dépendance quelle que soit
l’instance considérée. Quand on modélise les modèles de contrôle d’accès avec les dé-
pendances, on peut donc raisonner sur les modèles quelle que soient les politiques
qui en seront instances. On peut ainsi identiﬁer des propriétés déduites des modèles
de contrôle d’accès pour la simpliﬁcation ou la vériﬁcation de modèles, sections 5.2.4
et 5.2.5.

Les procédure de preuves pour les dépendances sont particulièrement appréciables
pour ces applications, car quand on prouve que Σ |= φ → ψ on obtient une trace de
la forme φ, σ1 . . . σn, ψ ou chaque transition d’une formule à l’autre résulte de l’appli-
cation d’une et une seule dépendance de Σ. On dispose ainsi d’une trace de preuve
relativement lisible, qui peut être traduite en langue naturelle en « lisant » les applica-
tions succésives des dépendances. Ceci permet de faciliter d’analyse d’un preuve pas
un utilisateur non spécialiste de la logique.

Exemple 3.6 Inclusion des autorisations dynamiques

Considérons les dépendances des tableaux 3.2 (τi) et 3.9 (σi). Nous souhaitons vé-
riﬁer que dans toute politique RBAC0, Dynamique ⊆ Statique, c’est-à-dire la dépen-
dance σ′ du tableau 3.9. Une trace d’exécution du chase est la suivante :

1. supposons l’existence d’un tuple Dynamique(u0, a0, o0),
2. par application de σ5, il existe également un rôle r1 et une session s1 tels que

Endosse(s1, r1), Repr ´esente(s1, u0) et A f f ecte(r1, a0, o0),

3. comme il existe Endosse(s1, r1) et Repr ´esente(s1, u0), alors par application de

σ2 il existe Habilite(u0, r1),

4. comme il existe A f f ecte(r1, a0, o0) et Habilite(u0, r1), alors par application de

τ1, il existe Statique(u0, a0, o0),

5. donc si un tuple Dynamique(u0, a0, o0), quel qu’il soit, existe dans la politique
alors le tuple Statique(u0, a0, o0) existe aussi, on a prouvé que {σ5, σ2, τ1} |= σ.
Ainsi, toute politique RBAC0 qui respecte les dépendances des tableaux 3.2 et 3.9
respecte la propriété exprimée par la dépendance σ′ du tableau 3.9. Cet exemple de
preuve effectuée par le chase illustre une des applications que nous proposons dans
le chapitre 5 : la simpliﬁcation de modèle de contrôle d’accès. Une trace détaillée et
commentée de cette preuve est proposée en annexe C.

Section 3.4. Intégrité des politiques de contrôle d’accès

95

Type
TTGD
TTGD

NGD

γ0
γs

γr

γ1
γ2
γ3
γ4
γ5

Expression logique

S ´eparation(R1, R2) → Exclusion(R1, R2)
Exclusion(R1, R2) → Exclusion(R2, R1)
Exclusion(R, R) → ⊥
Exclusion(R1, R2), Habilite(U, R1), Habilite(U, R2) → ⊥
NGD
Exclusion(R1, R2), Endosse(S, R1), Endosse(S, R2) → ⊥
NGD
Exclusion(R1, R2), A f f ecte(R1, A, O), A f f ecte(R2, A, O) → ⊥
NGD
NGD Exclusion(R1, R2), A f f ecte(R1, A1, O), A f f ecte(R2, A2, O) → ⊥
NGD

Exclusion(R1, R2), Endosse(S, R1), Endosse(S, R2),

Repr ´esente(S, U), Repr ´esente(S, U) → ⊥

TAB. 3.10 – Formalisation logique des propriétés de l’exclusion mutuelle

3.4.6 Expression de l’exclusion mutuelle

En section 2.5.1, nous avons présenté une notion importante des modèles RBAC :
les relations d’exclusion mutuelle. Le travail de modélisation de la notion de contrainte
dans un modèle de contrôle d’accès nécessite l’analyse des propriétés algébriques que la
relation d’exclusion respecte et des restrictions qu’elle impose sur les politiques pour
qu’elles soient intègres.

Comme lors de l’ajout de la hiérarchie de rôles au modèle RBAC0, nous allons raf-
ﬁner le modèle RBAC0 pour prendre en compte l’exclusion mutuelle entre rôles. La
formalisation que nous proposons se base sur deux relations et sur les dépendances du
tableau 3.10 :

– S ´eparation ⊆ R × R, la relation d’exclusion en extension (γ0),
– Exclusion ⊆ R × R, la fermeture symétrique de S ´eparation (γs).
– l’irréﬂexivité de la relation Exclusion (γr).
Nous avons remarqué que les relations d’exclusion mutuelle ont été interprétées de
plusieurs façons dans les modèles RBAC [Gligor98, Crampton03a]. Les dépendances γ1,
γ2, γ3, γ4 et γ5 du tableau 3.10 formalisent les différentes signiﬁcations de l’exclusion
mutuelle entre rôles. On remarque que les expressions des dépendances γ1 à γ5 sont
très proches : pour chacune d’entre elles, une des relations du modèle RBAC est présente
deux fois dans l’hypothèse. Ainsi, on ajoutera l’une de ces cinq dépendances γ1 à γ5 à
l’ensemble Σ pour formaliser que la relation Exclusion(R1, R2) exprime l’impossibilité
d’avoir :

– un utilisateur commun à deux rôles : γ1,
– une session commune à deux rôles : γ2,
– une permission commune à deux rôles : γ3,
– un objet commun sur lequel deux rôles auraient droit d’action : γ4,
– un utilisateur commun à deux rôles par l’intermédiaire de sessions : γ5.

96

Chapitre 3. Choix d’un cadre logique

Les cinq signiﬁcations de l’exclusion mutuelle ne sont pas indépendantes. En effet,
interdire à deux rôles d’avoir un utilisateur en commun interdit également d’avoir une
session en commun, car chaque session ne correspond qu’à un et un seul utilisateur.
Les procédures de preuves permettent d’évaluer les interprétations de l’exclusion :

– {γ1, σ0, σ2} |= γ2,
– {γ4} |= γ3,
– {γ2} |= γ5,
– {γ5, σ0} |= γ2,
– si σ0 ∈ Σ, alors γ5 et γ2 sont équivalentes.
Grâce à l’identiﬁcation automatisée des relations entre les différentes signiﬁcations
de l’exclusion mutuelle, un concepteur peut décider de mettre en œuvre deux formes
d’exclusion mutuelle avec la garantie qu’elles sont indépendantes. On peut ainsi conce-
voir un modèle de contrôle d’accès qui comporte deux relations d’exclusion : une pre-
mière qui interdit d’avoir des utilisateurs communs à des rôles en exclusion (dépen-
dance γ3 du tableau 3.10), et une seconde qui interdit d’avoir des permissions com-
munes (dépendance γ1 du tableau 3.10).

Ces vériﬁcations de propriétés abstraites d’un modèle de contrôle d’accès n’ont, à
notre connaissance, pas été proposées. Elles sont cependant d’un grand intérêt pra-
tique lors de la conception d’un modèle de contrôle d’accès. De plus, grâce aux outils
de preuves dédiées aux dépendances de données que nous avons présentés, ces véri-
ﬁcations sont automatisées : nous montrerons que les outils de preuves permettent de
prouver des propriétés non triviales qui ont été démontrées manuellement.

3.5 Discussion et synthèse

3.5.1 De la négation

Les dépendances et le cadre DATALOG que nous avons présenté en section 3.3.3 ne
permettent pas l’expression de négation dans les formules. Des extensions de DATALOG
ont été proposées. DATALOG¬ étend les règles DATALOG en autorisant la présence de
littéraux négatifs dans le corps des règles. La sémantique des programmes DATALOG¬
est plus complexe que celle des programmes DATALOG [Abiteboul95] :

– un programme DATALOG¬ peut ne pas avoir de point ﬁxe du tout,
– plusieurs points ﬁxes minimaux peuvent exister,
– l’application de règles peut ne pas converger vers le point ﬁxe, même s’il existe,
– l’application de règles peut converger vers un point ﬁxe, mais ce dernier n’est pas

nécessairement minimal.

Plusieurs solutions ont été apportées à ce problème, en restreignant l’utilisation de
la négation avec la notion de strate, ou en dotant les programmes DATALOG¬ d’une

Section 3.5. Discussion et synthèse

97

sémantique plus complète. En revanche, il n’y a pas à notre de connaissance de classes
de dépendances autorisant l’expression de littéraux négatifs.

L’absence de négation n’est cependant pas un verrou au développement de mo-
dèles de contrôle d’accès. Les dépendances génératrices de nullité ou de contraintes
permettent de déﬁnir des conditions pour lesquelles une instance n’est pas valide, per-
mettant ainsi de modéliser des restrictions dans un modèle de contrôle d’accès sans
utiliser explicitement de négation, car φ → ⊥ équivaut à ¬(φ).

En sélectionnant le cadre des dépendances de données, nous avons fait le choix de
prendre en compte la possibilité d’exprimer des contraintes d’intégrité complexes fai-
sant intervenir des quantiﬁcateurs existentiels plutôt que d’utiliser la négation. Aucune
proposition de contrôle d’accès n’a encore pris ce parti.

3.5.2 Structuration du cadre logique

Depuis le modèle relationnel, nous avons successivement introduit le modèle DA-
TALOG puis les dépendances de données, pour aboutir à la déﬁnition d’un para-
digme de bases de données relationnelles étendues. Notre approche « orientée don-
nées » nous conduit à déﬁnir le contrôle d’accès comme une struture relationnelle
AC = (edb ∪ idb, P, Σ) composée :

– d’un ensemble de concepts et de relations en extension qui modélisent la structure

du contrôle d’accès : edb

– une politique en extension instance du modèle de contrôle d’accès : I,
– un ensemble de relations en intention et de règles de déduction qui modélise les
principes en vigueur dans le modèle de contrôle d’accès : idb et un ensemble de
règles P qui les déﬁnit,

– une politique en intention qui est déterminée à partir des règles de déduction :

une instance la plus petite possible I′ telle que I ⊆ I′ et I′ |= P,

– un ensemble de dépendances de données qui limitent les politiques possibles à

celles respectant les propriétés des modèles Σ, avec I′ |= Σ.

Le cadre proposé nous permet d’exprimer des propriétés complexes des modèles
de contrôle d’accès, manipulables directement sans réécriture par les algorithmes de
preuves. Cette possibilité n’est pas prise en compte dans les propositions étendant sur
DATALOG ou la programmation logique [Li03b, Barker03, Barker02]. Nous avons illus-
tré l’utilisation des dépendances aux modèles de contrôle d’accès RBAC en montrant
qu’elles :

– permettent la formalisation logique des propriétés des modèles RBAC,
– permettent de donner une sémantique logique à ces modèles,
– sont sufﬁsamment expressives pour modéliser des propriétés qui n’ont pas été

prises en compte dans les autres approches,

98

Chapitre 3. Choix d’un cadre logique

– permettent de développer la notion d’intégrité d’une politique de contrôle d’ac-

cès.

Nous pensons que l’intégrité des politiques revêt une place centrale dans la spéci-
ﬁcation des modèles de contrôle d’accès. En effet, comme la majeure partie des failles
sont dues à des erreurs ou à de mauvaises conﬁgurations, s’assurer de la correction des
politiques instances des modèles de contrôle d’accès est incontournable. Les procédures
de preuve, dont nous avons présenté le chase, permettent de raisonner sur les structu-
rations relationnelles du contrôle d’accès : elles permettent de vériﬁer les modèles et les
politiques.

3.5.3 Vers une spéciﬁcation générique du contrôle d’accès

Il n’est pas possible de limiter notre proposition à la seule famille des modèles à

rôles telle que déﬁnie dans le standard. En effet dans les systèmes d’information :

– d’une part il est rare qu’une implémentation des modèles RBAC respecte à la lettre
les spéciﬁcations du standard : modéliser ces implémentations nécessite un cadre
capable d’exprimer les nuances qui existent entre elles,

– d’autre part, la tendance actuelle est de développer des modèles de contrôle d’ac-
cès ad hoc qui permettent de répondre au mieux aux besoins de sécurité des orga-
nisations. De tels modèles sont souvent composites, intégrant des concepts et des
principes pris dans différents modèles de contrôle d’accès,

– enﬁn, il est courant d’avoir plusieurs modèles de contrôle d’accès cohabitants au
sein d’une même organisation. Le maintien des systèmes historiques (legacy sys-
tems) ainsi que la multiplication des applications conduisent généralement les ad-
ministrateurs à intervenir sur des politiques structurées selon des modèles diffé-
rents. Une formalisation homogène facilite l’uniﬁcation des mécanismes contrôle
d’accès à l’échelle globale du système d’information.

Les dépendances de données permettent d’établir les propriétés fondamentales
qu’un modèle de contrôle doit respecter et permettent de déﬁnir formellement la no-
tion d’intégrité des politiques dotée d’une sémantique logique. L’expressivité du cadre
retenu permet également l’expression de propriétés novatrices, qui n’ont pas été pro-
posées dans la littérature.

Le chapitre suivant généralise la formalisation des modèles à rôles de ce chapitre à
des familles plus générales de modèles de contrôle d’accès. Il présentera des déﬁnitions
génériques du contrôle d’accès permettant de concevoir et formaliser logiquement des
systèmes de gestion des autorisations complexes.

Whenindoubt,usebruteforce.

Butler Lampson, 1984 - “Hints for Computer System Design”

4

Structuration du contrôle d’accès

⊲ Le chapitre précédent a présenté le cadre des dépendances de données et l’a appliqué pour représen-
ter, raisonner et vériﬁer les modèles de contrôle d’accès à rôles. Ce chapitre reprend cette approche pour
des familles de modèles plus générales.

Nous présentons une modélisation générique des droits fondée sur les concepts communs aux diffé-
rents modèles de contrôle d’accès que nous avons identiﬁés. Cette modélisation générique s’appuie sur
le modèle relationnel. L’objectif est de représenter l’organisation des droits dans les systèmes à partir de
déﬁnitions réduites pour ensuite ajouter successivement des couches qui représentent les principes et les
propriétés de ces modèles.

C’est un pas vers une métamodélisation du contrôle d’accès dont les instances seraient des modèles
présentés dans l’état de l’art. Comme les dépendances de données n’autorisent pas certaines expressions
logiques, le modèle générique que nous proposons ne permet pas de prendre en compte certaines des
spéciﬁcités introduites dans la littérature. Nos principales contributions de ce chapitre concernent :

– les déﬁnitions génériques des composants présentés dans les modèles de contrôle d’accès,
– la classiﬁcation abstraite de ces composants, en particulier les catégorisations :

– en aspects factuels (effectivement stockés) et déduits,
– en aspects statiques (entièrement déterminés par les administrateurs) et dynamiques,

– la prise en compte des critiques formulées à l’encontre du standard RBAC,
– la généralisation du concept d’intégrité des politiques de contrôle d’accès.
L’ensemble des déﬁnitions que nous proposons dans ce chapitre forment le cœur de notre travail. À
partir de cette base de formalisation nous développons des outils pour la vériﬁcation des modèles et des
politiques de contrôle d’accès dans le chapitre 5. Ces outils utilisent les procédures de preuve pour les
dépendances dont la réalisation est décrite dans le chapitre 6.

L’annexe B synthétise la notation et les symboles de prédicats de ce chapitre. Une formalisation

générale des modèles RBAC organisée selon ce chapitre y est proposée. ⊳

100

Chapitre 4. Structuration du contrôle d’accès

Plan du chapitre

. .

. .

. .

4.1

4.3

. .
. .
. .

. .
. .
. .

. .
. .

. .
. .

. .
. .

. .
. .

. .
. .
. .
. .

. .
. .
. .
. .

Structuration générale du contrôle d’accès . .
. .
4.1.1 Modèle de contrôle d’accès
4.1.2 Moniteur . .
. .
. .
. .
4.1.3

. .
. .
. .
. .
4.2 Concepts et relations des modèles de contrôle d’accès . .

.
Structuration relationnelle .

. .
4.4 Catégorisation des aspects des modèles . .
4.4.1 Aspects statiques et dynamiques .
4.4.2 Aspects factuels et déduits .
. .

. .
. .
. .
. .
. .
Représentation des modèles de contrôle d’accès . .
4.2.1
Extension de la notion de concept et de relation . .
4.2.2
. .
4.2.3
Intégrité des schémas relationnels
Principes des modèles de contrôle d’accès
. .
4.3.1 Dérivation du triplet fondamental d’autorisation . .
. .
4.3.2 Dérivation des triplets orientés utilisateurs .
. .
4.3.3
4.3.4 Hiérarchisation des concepts
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
Principe fondamental des modèles structurés . .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
4.5 Contraintes dans les modèles de contrôle d’accès . .
. .
4.5.1 Modélisation avec les dépendances . .
. .
Contraintes d’exclusion mutuelle .
4.5.2
. .
. .
4.5.3
Exclusion en présence de hiérarchies .
Relation de prérequis .
4.5.4
. .
. .
Combinaison de prérequis et de hiérarchies .
4.5.5
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
Limitations de la notion de contrainte . .
. .
Synthèse . .

4.7 Discussion et synthèse .

4.6 Modélisation du contexte .

. .
4.6.1 Approche proposée . .
. .
4.6.2
. .

États de contexte .
. .

. .
. .
. .
. .

. .
. .
. .
. .

. .
. .
. .
. .

. .
. .
. .
. .

. .
. .
. .
. .

. .
. .
. .
. .

. .
. .
. .
. .

. .

. .

. .

. .

4.7.1
4.7.2

. .

. .

. .

. .

. .

. .

.

. .

.

.
.
.
.

.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. 101
. 101
. 102
. 103
. 104
. 104
. 105
. 106
. 108
. 108
. 109
. 110
. 110
. 112
. 112
. 114
. 115
. 115
. 116
. 117
. 117
. 118
. 120
. 120
. 121
. 122
. 122
. 123

Section 4.1. Structuration générale du contrôle d’accès

101

LE chapitre précédent a proposé un cadre logique fondé sur le modèle relationnel

pour représenter la structuration, les principes et les propriétés des modèles de
contrôle d’accès. Nous avons illustré l’application de ce cadre avec la famille des mo-
dèles RBAC. Désormais, nous entreprenons de généraliser la modélisation des droits.
Ce chapitre propose à notre initiative des déﬁnitions novatrices basées sur le modèle
relationnel. Elle reprennent et étendent celles présentées dans l’état de l’art.

4.1 Structuration générale du contrôle d’accès

Cette section propose des déﬁnitions génériques des ensembles et des relations
entre ces ensembles qui sont mis en œuvre dans les modèles de contrôle d’accès. Il
s’agit d’une première étape d’identiﬁcation et de formalisation des principales notions
communes aux modèles de contrôle d’accès. Dans les sections suivantes, nous réutili-
serons ces déﬁnitions pour les faire correspondre au modèle relationnel.

4.1.1 Modèle de contrôle d’accès

Déﬁnition (Modèle de contrôle d’accès). Un modèle de contrôle d’accès AC est exprimable
en terme de concepts, c’est-à-dire des entités déﬁnies et utilisées pour structurer les droits, et de
relations entre ces concepts, c’est-à-dire des associations n-aires entres les entités. Concepts et
relations sont recouvrés par le terme générique d’aspect. Les concepts de sujet (S), d’utilisateur
(U ), d’action (A) et d’objet (O) sont présents dans tout modèle de contrôle d’accès.

À chaque sujet donné n’est associé qu’un et un seul utilisateur : il existe une injection de S
dans U . À un modèle AC est associé un ensemble de principes qui régissent son fonctionnement
et de propriétés qui déﬁnissent son intégrité.

Cette déﬁnition généralise les principes des modèles structurés. Elle réduit à des
composants élémentaires l’organisation des droits. Le tableau 2.5 a présenté les en-
sembles et relations du modèle RBAC1. Par rapport à la déﬁnition minimaliste proposée
au dessus, le modèle RBAC1 introduit la notion de rôle. D’une même façon, la ﬁgure 2.5
a présenté les principaux concepts et relations du modèle ORBAC.

Sujets et utilisateurs peuvent être éventuellement confondus, comme dans les mo-
dèles basés sur l’identité. De plus, dans de nombreux modèles, on s’intéresse moins aux
ensembles A et O qu’aux permissions qui sont des paires d’actions sur des objets.

Déﬁnition (Triplet fondamental du contrôle d’accès). Tout modèle de contrôle d’accès doit
permettre de dériver le triplet fondamental d’autorisation, ACCE SS, qui représente l’en-
semble des actions autorisées aux sujets sur les objets du système :

ACCE SS ⊆ S × A × O

102

Chapitre 4. Structuration du contrôle d’accès

La dérivation de la relation ACCE SS à partir des concepts et des relations d’un modèle de

contrôle d’accès fait partie de ses principes.

Nous exprimons ainsi que l’objectif central des modèles de contrôle d’accès est de
permettre de dériver une relation ACCE SS représentable par une matrice de Lampson
comme celle du tableau 2.2. Un modèle de contrôle d’accès permet notamment de dé-
ﬁnir des intermédiaires entre sujets ou utilisateurs et permissions. Selon les domaines
d’application d’un modèle de contrôle d’accès, les permissions sont :

– des opérations SQL sur des tables : dans le contrôle d’accès aux systèmes de ges-
tion de bases de données, la politique va déﬁnir quelles opérations1 sont autori-
sées sur les tables,

– des primitives sur des ﬁchiers : dans les systèmes de gestion de ﬁchier, la politique
va déﬁnir les primitives autorisées2 sur les ﬁchiers. Notons que dans ce cas, les
objets sont généralement organisés sous forme d’arbres,

– des méthodes sur des services : dans les architectures de services web, la politique

va déﬁnir quelles méthodes sont autorisées d’invocation par les autres services.

4.1.2 Moniteur

À partir de la déﬁnition d’un modèle de contrôle d’accès, nous déﬁnissons le moni-
teur de référence. Son mécanisme consiste à évaluer une requête sur la relation ACCE SS.
Nous n’avons pas encore déﬁni comment dériver le triplet ACCE SS, en effet ceci est
dépendant du modèle considéré. Par exemple, dans les modèles MAC, les actions au-
torisées sont déduites des labels associés aux utilisateurs et aux objets, alors que dans
RBAC, les actions autorisées sont explicitement attribuées aux rôles.

Déﬁnition (Moniteur de contrôle d’accès). Un moniteur de contrôle d’accès est modé-
lisable par une fonction F qui à une action demandée par un sujet sur un objet – c’est-à-dire
une requête d’accès – fait correspondre une décision binaire d’autorisation indiquant si l’accès
demandé est autorisé ou non.

F : S × A × O → {vrai, f aux}

F (s, a, o) = (cid:26) vrai

si (s, a, o) ∈ ACCE SS
f aux si (s, a, o) 6∈ ACCE SS

Nous souhaitons la généralisation des différents principes introduits au ﬁl de l’évo-
lution de la structuration des droits. L’objectif de fournir un cadre dans lequel dévelop-
per de nouveaux modèles de contrôle d’accès adaptés aux besoins des organisations.
Nous réalisation cet objectif en réduisant les politiques de contrôle d’accès à une ex-
pression simple : la matrice introduite par les auteurs de [Lampson74].

1Par exemple, les opérations insert, delete, select et update.
2Par exemple, les droits read, write et execute.

Section 4.1. Structuration générale du contrôle d’accès

103

4.1.3 Structuration relationnelle

Nous avons choisi de construire la modélisation du contrôle d’accès sur le cadre re-
lationnel. Dans les sections suivantes de ce chapitre nous déﬁnirons successivement
des couches s’appuyant sur ce fondement en faisant correspondre aux composants
du contrôle d’accès des notions issues du modèle relationnel. Ces différentes notions
forment un paradgime assimilable aux bases de données déductives. Ainsi, un modèle
de contrôle d’accès est représenté par une structure relationnelle AC = (sch, P, Σ) avec :

– sch = edb ∪ idb : le schéma du modèle de contrôle d’accès,
– edb : le schéma en extension de AC, l’ensemble des relations en extension du
modèle. Pour notre application, cet ensemble représente le noyau du modèle de
contrôle d’accès : les concepts et relations introduits pour organiser les droits,

– idb : le schéma en intention de AC, l’ensemble de relations en intention du mo-
dèle. Il s’agit de concepts et de relations déductibles à partir de ceux connus en
extension,

– P : l’ensemble de règles de déduction qui déﬁnit les relations en intention. Cet en-
semble permet de modéliser les principes qui régissent la dérivation des relations
en intention à partir de celles en extension,

– Σ = Σedb ∪ Σidb : l’ensemble des dépendances de données composé de Σedb –
l’ensemble des dépendances sur edb – et de Σidb l’ensemble des dépendances sur
idb. Σ permet de modéliser des propriétés que les politiques de contrôle d’accès
doivent respecter.

Dans l’expression des formules de logique des règles requêtes conjonctives, des
règles DATALOG et des dépendances, nous omettrons de faire ﬁgurer les quantiﬁca-
teurs universels sous entendus. Les quantiﬁcateurs existentiels seront quant à eux notés
explicitement. Pour une politique de contrôle d’accès, instance d’un modèle AC nous
noterons :

– I : l’instance de edb qui satisfait Σedb. Il s’agit de la politique de contrôle d’accès

déﬁnie explicitement par les administrateurs,

– I′ : le plus petit point ﬁxe du programme P, c’est-à-dire l’instance de edb ∪ idb qui
satisfait P et Σ = Σedb ∪ Σidb. Il s’agit de la politique déﬁnie implicitement, qui
comprend les faits enregistrés par les administrateurs, mais aussi ceux déduits à
partir des principes du modèle.

Une règle de déduction DATALOG ou DATALOGC satisfait les restrictions syn-
taxiques imposées aux dépendances génératrices de tuples contraintes. Ainsi, nous
pouvons assimiler les règles à des dépendances particulières, qui sont satisfaites par I′.
Ainsi, l’instance I′ satisfait les règles P vues comme des dépendances. La réciproque de
cette proposition n’est en revanche pas valide : une dépendance de données peut ne pas
satisfaire les restrictions syntaxiques imposées aux règles DATALOGC. La dépendance
R(A, B) → ∃A′ S(A′, A), A′ ≥ B + A n’est pas exprimable en DATALOGC.

104

Chapitre 4. Structuration du contrôle d’accès

Dans un premier temps, nous déﬁnissons ce qu’est un modèle de contrôle d’accès
en termes de concepts et de relations formant son noyau. Dans un second temps, nous
caractériserons et développerons les différentes notions introduites dans les modèles
de contrôle d’accès.

4.2 Concepts et relations des modèles de contrôle d’accès

Cette section déﬁnit les schémas des modèles de contrôle d’accès. Nous réutilisons
les déﬁnitions de la section précédente et explicitons les notions de concepts et de rela-
tions dans le modèle relationnel. Cette section déﬁnit les composantes edb, Σedb et I de
la structuration relationnelle proposée.

4.2.1 Représentation des modèles de contrôle d’accès

La proposition suivante forme la brique de base sur laquelle nous développons la
suite de la thèse. Dans la généralisation proposée, nous supposons que le noyau d’un
modèle de contrôle d’accès est représentable par un schéma relationnel. Grâce à cette
proposition, nous déﬁnissons une politique structurée selon un modèle de contrôle
d’accès comme une instance du schéma associé.

Proposition. Représentation des modèles de contrôle d’accès

Un modèle de contrôle d’accès structuré AC, composé de concepts et de relations entre ces

concepts, est représenté par une structure relationnelle AC.

Le noyau de AC est représenté par un schéma relationnel en extension de contrôle d’ac-

cès edb.

Déﬁnition (Politique de contrôle d’accès). Une politique de contrôle d’accès I est une
instance d’un schéma en extension de contrôle d’accès.

Ces deux proposition sont fondamentales pour la thèse. Nous supposons la repré-
sentablité des noyaux par un schéma relationnel maintenant, pour pouvoir ensuite uti-
liser les règles de déduction et les dépendances de données qui seront construites au-
dessus du schéma. Elles permettent de déﬁnir les principes et les propriétés des mo-
dèles.

Aﬁn de différencier les concepts des modèles de contrôle d’accès présentés dans le

chapitre 2 et leur représentation dans la structuration relationnelle, nous notons :

– en police calligraphiée les concepts et relations d’un modèle de contrôle d’accès AC,
par exemple : S pour le concept de sujet, A pour celui d’action et U RA pour la
relation d’attribution de rôles aux utilisateurs déﬁnis dans les modèles RBAC,

Section 4.2. Concepts et relations des modèles de contrôle d’accès

105

– en police droite, la modélisation, grâce à des formes prédicatives3 de la logique du
premier ordre, des concepts et relations de de la structure relationnelle AC, par
exemple : Sujet, Action d’arité 1 et Habilite d’arité 2.

Déﬁnition (Représentation des concepts et des relations d’un modèle). Un concept C
dans un modèle de contrôle d’accès AC est représenté par une relation unaire C(ID), où ID est
appellé identiﬁant du concept. La relation en extension C(ID) appartient à edb.

Une relation n-aire R entre les concepts C1, . . . , Cn est exprimée par une relation en exten-
sion R ∈ edb : R(ID1, . . . , IDn) où les IDi sont respectivement les identiﬁants des concepts
C1, . . . , Cn.

D’après la déﬁnition d’un modèle de contrôle d’accès que nous avons proposée,
nous savons que dans toute expression relationnelle d’un modèle, il existera en exten-
sion au moins quatre relations unaires User(U), Sujet(S), Action(A) et Objet(O) mo-
délisant respectivement dans la base de données les concepts d’utilisateur (U), de sujet
(S), d’action (A) et d’objet (O).

Exemple 4.1 Schéma du modèle RBAC0

Le noyau du modèle RBAC0 peut être déﬁni à l’aide d’un schéma en extension edb
qui traduit dans le modèle relationnel les déﬁnitions ensemblistes proposées dans le
standard RBAC [Ferraiolo03b] (tableau 2.5). Dans les modèles RBAC le concept de
sujet est appelé session.
Le schéma relationnel edb est donné par la ﬁgure 3.1, il comporte :
– d’une part,

les concepts des modèles RBAC,

les relations unaires User(U),

Sujet(S), Role(R), Action(A), et Objet(O).

– d’autre part,

les relations entre les concepts Habilite(U, R), Repr ´esente(S, U),

Endosse(S, R) et A f f ecte(R, A, O).

Une politique jouet I instance de ce schéma est donnée par le tableau 3.1.

Les modèles de contrôle d’accès peuvent être déﬁnis à partir d’ensembles. Les rela-
tions unaires permettent de traduire l’appartenance des concepts à ces ensembles, et les
relation n-aires exprimant des relations entre ces ensembles. Le tableau 4.1 synthétise
l’application Ψ de représentation. Il résume nos choix fondamentaux de modélisation
relationnelle du contrôle d’accès.

4.2.2 Extension de la notion de concept et de relation

Nous pouvons autoriser la déﬁnition d’attributs aﬁn de permettre aux administra-
teurs de la sécurité d’enregistrer des informations qui ne sont pas prises en compte
pour les décisions de contrôle d’accès, mais qui peuvent être utiles à l’administration.

3C’est-à-dire les relations entre des ensembles du modèle relationnel.

106

Chapitre 4. Structuration du contrôle d’accès

Déﬁnition ensembliste → Structuration relationnelle

Ψ

AC → AC

concept C → forme prédicative unaire C(IDC)

relation n-aire R → forme prédicative n-aire R(ID1, . . . , IDn)

TAB. 4.1 – Application de représentation Ψ

Par exemple, au concept d’utilisateur, on aurait certainement besoin d’associer un nom,
un prénom, une adresse, un numéro de bureau, etc.

Pour permettre l’expression d’attributs qui ne participent pas à la prise de décision
d’accès, nous étendons les notions de concepts et relations d’un modèle en déﬁnissant
des dépendances fonctionnelles entre les identiﬁants de concepts et les attributs :

Déﬁnition (Concepts et relations étendus d’un modèle). Un concept C auquel est asso-
cié n attributs A1, . . . , An est exprimé par une relation (n + 1)-aire en extension de edb :
C(ID, A1, . . . , An) où ID est l’identiﬁant du concept.

On associe à tout concept C, une dépendance fonctionnelle de Σedb exprimant que ID est

clef de la relation C : C(ID, A1, . . . , An), C(ID, A′

1, . . . , A′

n) → A1 = A′

1, . . . , An = A′
n.

La prise en compte d’attributs supplémentaires n’est pas complexe, mais est fasti-
dieuse. En effet, nous imposons que ces attributs soient entièrement déductibles à l’aide
de dépendances fonctionnelles. Aﬁn de ne pas surcharger les expressions logiques de la
thèse, nous ne prendrons pas en compte les attributs dans la suite du développement.

4.2.3 Intégrité des schémas relationnels

Nous avons proposé une représentation des notions de concept et de relation des
modèles de contrôle d’accès. Maintenant, nous allons nous attacher aux liens entre ces
concepts. Nous allons imposer que les relations construites dans le modèle de contrôle
d’accès soient bien toutes reliées à des concepts du modèle. Cette propriété qui doit être
garantie dans la politique est représentée par une dépendance génératrice de tuples.

Les dépendances de données ont été déﬁnies comme des contraintes d’intégrité sur
les schémas de base de données. Nous mettons à proﬁt cette caractéristique pour déﬁnir
les propriétés structurelles que doivent respecter les noyaux des modèles de contrôle
d’accès. Il s’agit du premier pas vers la déﬁnition générique de l’intégrité des modèles
et des politiques de contrôle d’accès. Certaines des classes de dépendances peuvent être
directement prises en compte dans des systèmes de gestion de base de données grâce
aux mécanismes de clefs primaires et étrangères.

Déﬁnition (Dépendances structurelles des modèles). Pour chaque relation R n-aire entre
les concepts C1, . . . , Cn, chacun exprimé par une relation Cn(IDn), une dépendance génératrice

Section 4.2. Concepts et relations des modèles de contrôle d’accès

107

de tuples totale de Σedb exprime que chaque identiﬁant de concept est clef étrangère :

R(ID1, . . . , IDn) → C1(ID1), . . . , Cn(IDn)

Exemple 4.2 Dépendances structurelles du modèle RBAC0

Le schéma relationnel de RBAC0 est edb de RBAC0. Les dépendances génératrices
de tuples de Σedb permettent de s’assurer que les relations entre les concepts sont
bien fondées :
– Habilite(U, R) → User(U), Role(R),
– Repr ´esente(S, U) → Sujet(S), User(U),
– Endosse(S, R) → Sujet(S), Role(R),
– A f f ecte(R, A, O) → Role(R), Action(A), Objet(O).

Les dépendances structurelles permettent de s’assurer qu’une politique est bien
structurée selon le modèle dont elle est une instance. Cette approche permet de ras-
sembler dans un même cadre deux notions qui sont parfois traitées indépendamment :
– la conﬁdentialité des données : l’objectif principal du contrôle d’accès est de n’au-
toriser que les ayants droit à exécuter des actions sur les objets du système selon
une politique. Une partie de notre travail est de structurer cette politique,

– l’intégrité des données : les dépendances de données ont été proposées initiale-
ment pour s’assurer que les données enregistrées dans une base de données sont
correctes. Nous transposons cette approche au contrôle d’accès : nous déﬁnissions
quels sont les états légitimes des politiques à l’aide des dépendances.

Nous avons proposé une déﬁnition des propriétés que les schémas relationnels de
contrôle d’accès doivent respecter. On peut cependant en ajouter d’autres spéciﬁques
à chaque modèle. Il a été remarqué qu’il peut être proﬁtable de proposer une notion
de session dans les modèles RBAC plus restreinte que celle existante, dans laquelle un
utilisateur ne peut disposer que d’un seul sujet [Li07] :

Suggestion 2 The standard should accommodate RBAC systems that allow only
one role to be activated in a session.

Il s’agit d’un des cas où un modèle de contrôle d’accès peut donner trop de liberté, ce
qui rend difﬁcile son implémentation. Dans notre cadre, cette restriction est exprimable
par une dépendance génératrice d’égalité, que l’on ajoute à la modélisation existante
des modèles RBAC :

Endosse(User, Role1), Endosse(User, Role2) → Role1 = Role2

108

Chapitre 4. Structuration du contrôle d’accès

4.3 Principes des modèles de contrôle d’accès

Cette section déﬁnit les principes des modèles de contrôle d’accès. Il s’agit d’ex-
primer comment dériver les relations en intention, comme le triplet fondamental ou
la hiérarchisation de concepts, à partir de celles en extension de la section précédente.
Cette section déﬁnit les composantes idb, Σidb, P et I′ de la structuration relationnelle
AC proposée. Le schéma en intention idb est déﬁni par un ensemble P de règles de dé-
duction. On peut utiliser le modèle DATALOG ou DATALOGC pour exprimer ces règles,
mais l’on pourrait également utiliser tout fragment de la logique dont une plus petite
interprétation unique I′ calculable en un nombre ﬁni d’étapes existe.

4.3.1 Dérivation du triplet fondamental d’autorisation

Après avoir structuré les droits des utilisateurs dans le système, nous allons déﬁnir
comment dériver, à partir de la politique, le triplet d’autorisation utilisé par le moniteur.

Déﬁnition (Dérivation du triplet fondamental d’autorisation). Le triplet fondamental
d’autorisation ACCE SS ⊆ S × A × O, est dérivé par un ensemble ∆ ⊆ P de règles de déduc-
tion, appelées core-rules. Pour chaque règle δi ∈ ∆, la relation en intention Acc `es apparaît en
tête et des relations du modèle de contrôle d’accès apparaissent dans le corps :

ψi → Acc `es(Sujet, Action, Objet)

Ces règles sont également l’expression de jointures naturelles entre les relations ap-
paraissant dans ψi. Ces jointures sont satisfaites par I′. Cette déﬁnition généralise les
règles proposées pour déﬁnir les principes des modèles de contrôle d’accès. Pour les
modèles basés sur l’identité, la déﬁnition reste valide, mais le corps est vide. En effet,
ces modèles sont peu structurés et on enregistre directement les triplets d’autorisation
sans l’aide de concepts intermédiaires.

Pour plusieurs modèles de contrôle d’accès, l’ensemble ∆ est réduit à une seule core-
rule. Dans le cas général plusieurs de ces règles peuvent exister. La tableau 3.2 a donné
la core-rule du modèle RBAC0, qui déﬁnit la relation Acc `es(S, A, O) comme la jointure
des relations Endosse(S, R) et A f f ecte(R, A, O). L’ensemble ∆ est dans ce cas composé
d’une seule règle. Nous proposons comme autre exemple le modèle ORBAC présenté
en section 2.3.3.1. Si l’on ne tient pas encore compte de la notion de contexte, la core-rule
du modèle ORBAC est déﬁnie par la règle suivante [Miège05] :

Habilitation(Org, Role, Sujet), Consideration(Org, Activite, Action),
Utilisation(Org, Vue, Objet), OPermission(Role, Activite, Vue) →

Acc `es(Sujet, Objet, Action)

Section 4.3. Principes des modèles de contrôle d’accès

109

4.3.2 Dérivation des triplets orientés utilisateurs

En plus du triplet fondamental d’autorisation, il est intéressant de dériver les deux
autres triplets orientés utilisateurs DYN AMIC et ST AT IC. Le second est nécessaire
pour la comparaison statique de politiques.

Déﬁnition (Dérivation des triplets d’autorisation orientés utilisateurs). Le triplet d’au-
torisation orienté utilisateurs statique ST AT IC ⊆ U × A × O (resp. dynamique
DYN AMIC ⊆ U × A × O) sont dérivés par un ensemble de règles de déduction ∆S ⊆ P
i ∈ ∆D) la relation en intention Statique
(resp. ∆D ⊆ P). Pour chaque règle δS
(resp. Dynamique) apparaît en tête et des relations du modèle de contrôle d’accès apparaissent
dans le corps :

i ∈ ∆S (resp. δD

ψS
i → Statique(Utilisateur, Action, Objet)
ψD
i → Dynamique(Utilisateur, Action, Objet)

La tableau 3.2 a donné les règles qui permettent de dériver les triplets orientés uti-
lisateurs à partir des relations du modèle RBAC0. Les triplets orientés utilisateurs sont
utiles pour comparer les permissions accordées aux usagers des systèmes et non aux
entités logicielles qui les représentent. Comme nous avons imposé que chaque sujet ne
soit associé qu’à un et un seul utilisateur, les permissions autorisées d’un utilisateur à
un instant donné par l’intermédiaire des sujets qu’il endosse doivent être incluses dans
l’ensemble des permissions dont l’utilisateur dispose, soit DYN AMIC ⊆ ST AT IC.
La déﬁnition suivante exprime ce fait.

Déﬁnition (Inclusion des autorisations orientées utilisateurs). À partir des core-rules ∆
et des dépendances satisfaites dans le modèle, la dépendance suivante τ, appelée inclusion des
autorisations orientées utilisateurs doit être satisfaite par I′ :

Dynamique(U, A, O) → Statique(U, A, O)

Les procédures de preuves de l’implication logique des dépendances peuvent être
mises à proﬁt pour la déﬁnition de τ. En effet cette dépendance doit être satisfaite par I′,
deux cas peuvent se présenter. Soit τ est déﬁnie explicitement et fait partie de Σ, soit τ est
déjà satisfaite implicitement, si Σ ∪ P |= τ. Dans ce second cas, nul besoin de l’ajouter car
cela reviendrait à ajouter une expression redondante à Σ. Pour le modèle RBAC0, nous
avons montré que τ est implicitement satisfaite par la déﬁnition logique des principes
et des dépendances structurelle du modèle. Nous montrons comment le chase permet
d’effectuer cette vériﬁcation en annexe C.

110

Chapitre 4. Structuration du contrôle d’accès

4.3.3 Principe fondamental des modèles structurés

Nous introduisons maintenant une restriction sur les politiques de contrôle d’accès
interdisant l’affectation directe de permissions. En effet, l’intérêt des modèles structurés
est d’introduire des concepts intermédiaires entre sujets et permissions pour faciliter
l’administration des politiques. Permettre la déﬁnition directe des triplets d’autorisa-
tion, non seulement fait perdre l’intérêt de la structuration, mais surtout complique
l’analyse des politiques par les administrateurs et est une source considérable d’erreurs
que l’on souhaite éviter.

Déﬁnition (Principe fondamental des modèles structurés). Dans tout modèle de contrôle
d’accès où des concepts et relations intermédiaires sont déﬁnis entre sujets et utilisateurs d’une
part, et permissions d’autre part, il est interdit d’affecter directement des permissions.

Les modèles de contrôle d’accès structurés doivent satisfaire les dépendances du non-court-
circuit, où les variables apparaissant seulement en tête sont quantiﬁées existentiellement ( ˜∃).
i appartenant respectivement aux ensembles ∆, ∆S et ∆D, il
Pour chaque dépendance δi, δS
faut ajouter à Σ les dépendances suivantes :

i et δD

Acc `es(Sujet, Action, Objet) → ˜∃ ψi
Statique(Utilisateur, Action, Objet) → ˜∃ ψS
i
Dynamique(Utilisateur, Action, Objet) → ˜∃ ψD
i

Les dépendances σ3, σ4 et σ5 du tableau 3.9 sont des exemples de dépendances du
non-court-circuit. Elles expriment le fait que l’on ne puisse pas déﬁnir d’autorisations
dans les modèles RBAC sans utiliser de rôles. Pour le cas limite des modèles basés sur
l’identité, les dépendances du non-court-circuit sont des tautologies triviales.

4.3.4 Hiérarchisation des concepts

La hiérarchisation des concepts est un outil qui permet de limiter la redondance des
données de contrôle d’accès et de faciliter l’administration des politiques en calquant
leurs structures sur celle des organisations. L’objectif de cette section est de donner une
caractérisation générale, qui peut être utilisée pour déﬁnir des hiérarchies de concepts
multiples dans les modèles de contrôle d’accès. Dans les modèles RBAC, ce sont les
rôles qui sont hiérarchisés, dans les modèles MAC, ce sont les labels, dans les modèles
TBAC, ce sont les tâches. À l’aide de hiérarchies multiples, nous pouvons hiérarchiser
les objets en arbre pour représenter la structure d’un système de ﬁchier.

Déﬁnition (Concept hiérarchisé). Un concept C, exprimé par une relation unaire C(ID),
d’un modèle de contrôle d’accès est hiérarchisé si une relation binaire transitive, réﬂexive et
antisymétrique est déﬁnie sur C × C. La relation hiérarchique est déﬁnie en intention comme la
fermeture transitive et réﬂexive d’une relation de domination directe en extension.

Section 4.3. Principes des modèles de contrôle d’accès

111

Soit DomineC la relation de domination en extension. Soit H ´eriteC la relation d’héritage en

intention correspondante déﬁnie par les règles de déduction :

C(ID) → DomineC(ID, ID)
λR
DomineC(ID1, ID2) → H ´eriteC(ID1, ID2)
λH
λT DomineC(ID1, ID2), H ´eriteC(ID2, ID3) → H ´eriteC(ID1, ID3)

et la dépendance génératrice d’égalité :

λA

H ´eriteC(ID1, ID2), H ´eriteC(ID2, ID1) → ID1 = ID2

Exemple 4.3 Les multiples hiérarchies du GMSIH

Comme nombre d’établissements de santé, le CHM est membre du Groupement pour
la Modernisation du Système d’Information Hospitalier (GMSIH). Dans le modèle de
contrôle d’accès que ce groupement propose, deux hiérarchies sont présentes : celle
des rôles et celle des structures.
L’objectif de cette modélisation est de permettre d’organiser les droits selon la dé-
composition en structures et sous-structures des d’établissements de santé. Cette
modélisation permet d’associer à un même utilisateur des rôles différents dans des
structures différentes. Cependant, alors que la hiérarchie des rôles est un ordre par-
tiel général, la hiérarchie des structures doit former un arbre, ce qui peut être garanti
par des dépendances.

À l’aide des dépendances, nous pouvons restreindre les hiérarchies de concepts.
En effet, selon les variantes des modèles, ou selon les restrictions imposées par les im-
plémentations des mécanismes de contrôle d’accès, il peut être nécessaire de limiter la
hiérarchie à un arbre, un arbre inverse ou un treillis (section 2.3.2). Nous déﬁnissons les
dépendances qui permettent d’exprimer ces contraintes.

Déﬁnition (Hiérarchie limitée). Soit DomineC ⊆ C × C une relation de domination en
extension sur un concept C et H ´eriteC la relation d’héritage en intention associée, elle est :

– limitée en arbre si on ajoute la dépendance fonctionnelle :

λa : DomineC(ID, ID1), DomineC(ID, ID2) → ID1 = ID2

– limitée en arbre inverse si on ajoute la dépendance fonctionnelle :

λi : DomineC(ID1, ID), DomineC (ID2, ID) → ID1 = ID2

– limitée en treillis si on ajoute les dépendances génératrices de tuples :

λt : C(ID1), C(ID2)→∃ID⊥ H ´eriteC(ID1, ID⊥), H ´eriteC(ID2, ID⊥)
λb : C(ID1), C(ID2)→∃ID⊤ H ´eriteC(ID⊤, ID1), H ´eriteC(ID⊤, ID2)

112

Chapitre 4. Structuration du contrôle d’accès

Un modèle MAC est régi par deux core-rules présentées par le tableau 2.4 (sec-
tion 2.2.2) : « un sujet peut lire des informations dont la classiﬁcation est inférieure
ou égale à son accréditation » (No read up) et « un sujet peut écrire des informations
dont la classiﬁcation est supérieure ou égale à son accréditation » (No write down). À la
différence des modèles à rôles où les core-rules dérivent des permissions, les règles des
modèles MAC déterminent qu’elles sont les actions autorisées.

C’est donc à partir de la hiérarchisation des labels que l’on peut déterminer les
droits de lecture et d’écriture des sujets. L’annexe B propose une formalisation des mo-
dèles MAC. On déﬁnit la relation de domination en extension DomineL, la relation en
intention H ´eriteL associée puis formaliser les principes des modèles MAC avec les deux
règles suivantes :

Accred(S, L1), H ´eriteL(L1, L2), Classi f (O, L2) → Acc `es(S, read, O)
Accred(S, L1), H ´eriteL(L2, L1), Classi f (O, L2) → Acc `es(S, write, O)

Pour des raisons de lisibilité et de maintenabilité des principes d’un modèle, il peut
être judicieux de ne pas faire intervenir directement la hiérarchisation des rôles dans
l’expression des core-rules. On peut alors introduire des relations en intention intermé-
diaires utiles pour structurer la théorie logique P ∪ Σ.

4.4 Catégorisation des aspects des modèles

4.4.1 Aspects statiques et dynamiques

Les déﬁnitions proposées n’ont font pas de distinctions explicites entre les aspects
statiques et dynamiques des modèles de contrôle d’accès. Cette différenciation, faite dans
les modèles RBAC, n’est pas toujours proposée dans les autres modèles. Dans la struc-
turation relationnelle que nous proposons, les différences principales entre les aspects
statiques et dynamiques sont :

– la fréquence de mise à jour des relations : les aspects statiques stockent les droits
des utilisateurs de façon structurée. Dans les modèles RBAC ils comprennent par
exemple les déﬁnitions des utilisateurs, des actions, des objets. Il s’agit donc de
données stables vis-à-vis de l’exécution du système, qui ne sont pas modiﬁées
chaque fois qu’un utilisateur ouvre une session. Le contenu des concepts et re-
lations dynamiques quant à lui va être modiﬁé à chaque fois qu’un utilisateur
décide de s’identiﬁer dans le système,

– les droits sur les relations : les utilisateurs ﬁnaux n’ont pas de droits d’adminis-
tration sur la politique de sécurité et ne peuvent pas modiﬁer le contenu de la
politique. En revanche, par l’intermédiaire du gestionnaire de sessions, ils vont
ajouter (à l’ouverture), modiﬁer (en choisissant) et supprimer (à la fermeture) des
tuples dans les concepts et relations dynamiques.

Section 4.4. Catégorisation des aspects des modèles

113

Statique

Extention Factuel statique, Is
Intension Déduit statique, I′
s

Dynamique
Factuel dynamique, Id
Déduits dynamique, I′
d

I = Is ∪ Id
s ∪ I′
I′ = I′
d

TAB. 4.2 – Catégorisation des aspects des politiques de contrôle d’accès

Déﬁnition (Aspects statiques et dynamiques). Un aspect (concept, ou relation) d’un modèle
de contrôle d’accès est dit statique si et seulement si seuls les administrateurs peuvent déﬁnir
et modiﬁer les instances ou s’il est déduit uniquement d’autres aspects statiques.

Un aspect d’un modèle de contrôle d’accès est dit dynamique si les instances peuvent
être déﬁnies et modiﬁées par d’autres acteurs que les administrateurs ou s’il est déduit à partir
d’autres aspects dynamiques.

Nous entendons par autres acteurs les utilisateurs du système ou tout mécanisme
mis en œuvre dans les moniteurs. Cette distinciton permet de séparer les aspects qui
sont stables dans une politique de contrôle d’accès de ceux qui vont être modiﬁés fré-
quemment hors du contrôle des administrateurs. Les principaux concepts qui per-
mettent de structurer les droits sont généralement statiques. Les rôles dans les modèles
RBAC, les tâches dans TBAC, les zones géographiques dans GEORBAC et les organisa-
tions dans ORBAC sont tous statiques.

La différenciation en aspects statiques et dynamiques n’inﬂue pas sur la formali-
sation des modèles de contrôle d’accès. En revanche, la différenciation doit être prise
en compte dans les méthodologies de conception de politiques et surtout lors de l’im-
plémentation des modèles dans les systèmes. La séparation entre ce qui varie lors de
l’exécution de ce qui est stable est un principe général de modélisation en informa-
tique [Meyers05].

Tout modèle de contrôle d’accès devrait faire l’analyse de la variabilité. Selon les
utilisations d’un modèle, il peut être intéressant de n’intégrer que ses aspects statiques.
La distinction entre statique et dynamique conduit à mieux structurer les noyaux des
modèles. Pour les modèles RBAC, dont le seul concept dynamique est celui de session,
cette distinction n’a pas toujours été faite. Dans la critique du standard, on peut lire la
suggestion suivante [Li07] :

Suggestion 1 The notion of sessions should be removed from Core RBAC and in-
troduced in a separate component.

Nous intégrons cette suggestion en divisant les modèles en composants aux objectifs
clairement déﬁnis et séparés. Nous allons également introduire une nouvelle division
des composants entre factuels et déduits qui correspond également à une des critiques
formulées à l’encontre des modèles RBAC.

114

Chapitre 4. Structuration du contrôle d’accès

I′
s

Is

I′
d

Id

I′

Σidb

Intention

Extension

I

Σedb

Statique Dynamique

FIG. 4.1 – Catégorisation des composants de la structuration relationnelle

4.4.2 Aspects factuels et déduits

La catégorisation en aspects statiques et dynamiques nous permet de diviser les
propriétés que respectent les instances I et I′ entre celles qui doivent être vériﬁées lors
des opérations administratives de celles qui doivent l’être lors des accès au moniteur de
référence. Cette catégorisation est orthogonale à différenciation entre extension (factuel
I) et intention (déduit I′) comme l’illustre le tableau 4.2. Cette séparation est :

– naturelle, car elle suit l’évolution des recherches sur le contrôle d’accès, où l’on a
commencé par structurer les droits , exprimer des relations déduites puis imposer
des restrictions garantissant la validité des politiques [Halpern03],

– utile, car cette séparation permet de développer une méthodologie de conception
et d’évolution des modèles de contrôle d’accès. De plus, les aspects déduits sont
dérivables de façon automatisée et les administrateurs ne doivent pas y avoir
d’accès direct hormis pour l’interrogation.

La séparation entre factuel et déduit n’a pas été clairement identiﬁée en compte dans
les modèles RBAC, ce qui conduit à des difﬁcultés de modélisation et d’implémentation.
Nous citons deux des critiques adressées au standard à ce sujet [Li07] :

Suggestion 3 The standard should make a clear distinction between base relations
and derived relations.
Suggestion 4 The Reference Model should maintain a relation that contains the role
dominance relationships that have been explicitly added, and update this relation
when the role hierarchy changes.

Cette distinction a été faite dès la présentation du cadre que nous proposons.
La notion de role dominance relationship est ce que nous avons dénommé une rela-
tion de domination DomineC, à partir de laquelle est dérivée une relation d’héritage
DomineC ⊆ H ´eriteC. Comme il est indiqué par la suggestion quatre, cette distinction
permet de déﬁnir ce qui doit être recalculé lors des opérations administratives de ce
qui n’a pas besoin de l’être.

Section 4.5. Contraintes dans les modèles de contrôle d’accès

115

Les vériﬁcations qui portent sur les aspects statiques permettent de valider une po-
litique et assurer son intégrité quelles que seront les utilisations faites du système. On
peut donc diviser les instances I et I′ en deux sous-ensembles : un premier comprenant
les données qui concernent les concepts et relations statiques, un second qui concerne
les dynamiques. À chacune des quatre composantes du tableau 4.2 nous associons un
sous-ensemble de dépendances de Σ qui déﬁnit les états intègres de Is, Id, I′
d. Cette
correspondance est représentée par la ﬁgure 4.1. On divise donc la notion générale de
politique en quatre composants :

s et I′

– Is est la politique en extension statique que seuls les administrateurs ont le droit
de manipuler. Pour le modèle RBAC1, il s’agit des relations Habilite et A f f ecte de
la politique du tableau 3.1,

– Id est la politique en extension dynamique qui comporte les relations que les utili-
sateurs peuvent manipuler. Ce composant comporte le concept de sujet ainsi que
les relations qui le lient avec d’autres concepts. Pour le modèle RBAC1, il s’agit
des relations Endosse et Repr ´esente de la politique du tableau 3.1,
s est la politique en intention statique dérivée à partir de Is uniquement. Pour
le modèle RBAC1, la relation Statique du tableau 3.3 est un exemple d’instance
appartenant à I′
d est la politique en intention dynamique dérivée à partir de Is et de Id. Les
triplet d’autorisations Acc `es et Dynamique font partie de cet ensemble. Les admi-
nistrateurs n’ont pas d’accès à I′

s. Les administrateurs n’ont pas d’accès à I′

s\Is,

– I′

– I′

d\I.

4.5 Contraintes dans les modèles de contrôle d’accès

Plusieurs propositions ont exprimé des contraintes sur les politiques de contrôle
d’accès, dans le but de limiter les privilèges des utilisateurs. Nous avons remarqué
que selon les domaines d’application, l’exclusion mutuelle peut être déﬁnie différem-
ment. Nous proposons une modélisation générique de la notion de contrainte dans les
modèles de contrôle d’accès. Cette déﬁnition permet de représenter les différentes no-
tions d’exclusions mutuelles entre concepts et d’expliciter la différence entre ce type de
contraintes et les contraintes dites de prérequis.

4.5.1 Modélisation avec les dépendances

Déﬁnition (Contrainte dans un modèle de contrôle d’accès). Une contrainte dans un
modèle de contrôle d’accès est une dépendance génératrice de contraintes, où ψ(X) est une
conjonction d’atomes et c( ˜X) et c′( ˜X) des conjonctions de contraintes4 :

4c′( ˜X) peut éventuellement être une antilogie ⊥ dans le cas d’une NGD.

ψ(X), c( ˜X) → c′( ˜X)

116

Chapitre 4. Structuration du contrôle d’accès

Plusieurs modélisations logiques du contrôle d’accès ont représenté l’antilogie ⊥
par un prédicat 0-aire Error() et des règles DATALOG de la forme ψ(X), c( ˜X) → Error().
La vériﬁcation de l’intégrité d’une politique consiste alors à vériﬁer que le prédicat
Error() n’appartient pas à I′. Il devient alors difﬁcile d’identiﬁer dans l’ensemble de
formules logiques qui composent un modèle de contrôle d’accès, celles qui expriment
la déduction de faits, de celles qui permettent de garantir qu’un modèle soit valide.
Notre approche quant à elle sépare :

– la structure du modèle de contrôle d’accès : son noyau,
– son contenu : les politiques instances du modèle,
– ses principes : les règles qui permettent de dériver les autorisations,
– les propriétés du modèle : les dépendances qui déﬁnissent es politiques valides.

4.5.2 Contraintes d’exclusion mutuelle

Déﬁnition (Exclusion mutuelle entre concepts). Un concept C, exprimé par une relation
unaire C(ID), d’un modèle de contrôle d’accès est muni d’une relation d’exclusion mutuelle
si une relation binaire irréﬂexive et symétrique est déﬁnie sur C × C. La relation d’exclusion
mutuelle est déﬁnie en intention comme la fermeture symétrique d’une relation de d’exclusion
directe en extension.

Soit S ´eparationC la relation d’exclusion directe en extension, alors la relation d’exclusion

mutuelle en intention S ´eparationC ⊆ ExclusionC est déﬁnie par les règles de déduction :

S ´eparationC(ID1, ID2) → ExclusionC(ID1, ID2)
ExclusionC(ID1, ID2) → ExclusionC(ID2, ID1)

et la dépendance génératrice de nullité :

ExclusionC(ID, ID) → ⊥

Nous déﬁnissons ainsi les propriétés algébriques qu’une relation d’exclusion mu-
tuelle doit respecter. La déﬁnition suivante se base sur la précédente et déﬁnit com-
ment une relation d’exclusion mutuelle permet de limiter les instances valides d’une
politique de contrôle d’accès.
Déﬁnition (Sémantique de l’exclusion mutuelle). La sémantique associée à une relation
d’exclusion mutuelle ExclusionC est exprimable par une dépendance génératrice de nullité, où
ψ(X1) est une conjonction de relations, R une relation entre C et d’autres concepts, c( ˜X) une
conjonction contraintes sur les termes de l’hypothèse :

ψ(X1), R(. . . ID1 . . .), R(. . . ID2 . . .), ExclusionC(ID1, ID2), c( ˜X) → ⊥

Les dépendances γ1 à γ5 du tableau 3.10 déﬁnissent différentes sémantiques pos-
sible de l’exclusion mutuelle dans les modèles RBAC2. On peut ainsi exprimer que la
contrainte est statique, dynamique, orientée permission, objet, ou toute autre signiﬁca-
tion donnée à la relation d’exclusion dans le modèle de contrôle d’accès (section 3.4.6).

Section 4.5. Contraintes dans les modèles de contrôle d’accès

117

4.5.3 Exclusion en présence de hiérarchies

Il a été remarqué que les contraintes d’exclusion et les hiérarchies peuvent inter-
agir lorsque l’exclusion et la hiérarchie portent sur un même concept, celui de rôle en
particulier [Gavrila98, Gligor98]. Si les interactions avaient été identiﬁées dans les mo-
dèles RBAC, elles n’ont pas été prises en compte dans les autres modèles de contrôle
d’accès, alors que plusieurs d’entre eux proposent des contraintes d’exclusion et des
hiérarchies portant sur les mêmes concepts [Miège05, Barker03]. La généralisation que
nous proposons permet de se prémunir contre d’éventuels écueils d’administration.

Déﬁnition (Transmission de l’exclusion par hiérarchie). Soit une H ´eriteC relation hiérar-
chique sur un concept C, exprimé par une relation unaire C(ID), et une relation d’exclusion
mutuelle sur ce même concept ExclusionC. Alors, la dépendance génératrice suivante, appellée
transmission de l’exclusion par hiérarchie doit être satisfaite par I′ en l’ajoutant à P :

ExclusionC(ID1, ID2), H ´eriteC(ID, ID1) → ExclusionC(ID, ID2)

Dans les modèles RBAC3, les utilisateurs membres d’un rôle r sont implicitement
affectés aux rôles parents de r. Par exemple, si r ≻≻ r1 et r ≻≻ r2, alors auth_users(r1) ∪
auth_users(r2) ⊆ auth_users(r). La dépendance précédente permet de transmettre l’ex-
clusion par l’intermédiaire de la relation d’héritage. Si r1 et r2 sont en exclusion mu-
tuelle, alors la politique devient invalide [Gavrila98].

4.5.4 Relation de prérequis

Notre approche permet de déﬁnir les différentes formes de la relation d’exclusion
mutuelle selon les relations sur lesquelles elles portent, mais elle permet également de
déﬁnir la notion de prérequis. Cette notion a été introduite dans les premières proposi-
tions de RBAC [Sandhu96], mais ne font pas partie du standard. Certains auteurs les ont
cependant pris en compte dans leur modélisation [Hansen05]. Nous proposons dans
cette section des déﬁnitions de la notion de prérequis modélisée par des dépendances.

Déﬁnition (Relation de prérequis). Une relation de prérequis dans un modèle de contrôle
d’accès est exprimable par une dépendance génératrice de tuples contraintes de la forme suivante,
exprimant que si l’hypothèse (non vide) est vraie dans la politique, alors la conclusion (non vide
également) doit l’être aussi :

∀ ˜X R1(X1), . . . , Rn(Xn), c( ˜X) → ∃ ˜Z Q1(Y1), . . . , Qm(Ym), c′( ˜Y)

Les relations de prérequis sont utilisées dans les modèles de contrôle d’accès pour
l’expression de conditions à respecter avant l’exécution d’opérations administratives sur
les hiérarchies. Dans les modèles RBAC les conditions de prérequis sont déﬁnies sur
les relations du noyau : l’affectation de rôles aux utilisateurs (Habilite) et la relation
d’héritage des rôles (H ´erite) [Sandhu99, Ferraiolo03b].

118

Chapitre 4. Structuration du contrôle d’accès

Déﬁnition (Relation de prérequis intra-relation). Une relation de prérequis intra-relation,
porte sur une unique relation d’un schéma de contrôle d’accès. Elle est exprimable par une
dépendance de la forme suivante, où le quantiﬁcateur existentiel porte sur les variables de la
conclusion qui n’apparaissent pas en hypothèse :

∀ ˜X R(X1), . . . , R(Xn), c( ˜X) → ∃ ˜Z R(Y), c′( ˜Y)

Le pouvoir d’expression des classes de dépendances comme les dépendances gé-
nératrices de tuples contraintes est nécessaire pour la modélisation des relations de
prérequis. Cette classe permet en effet d’exprimer des prérequis qui ne sont pas mo-
délisables à l’aide de règles DATALOGC. Le tableau 3.6 résume les formes syntaxiques
logiques auxquelles se réfèrent les dépendances, on remarque que les plus générales
d’entre elles autorisent la présence de variables quantiﬁées existentiellement en conclu-
sion et de contraintes sur les termes de la conclusion, y compris ceux quantiﬁés existen-
tiellement. Cette expressivité nous permet de formaliser un aspect des extensions de
RBAC : le typage des rôles en sous-catégories à l’aide de prérequis intra-relation.

4.5.5 Combinaison de prérequis et de hiérarchies

Utilisés conjointement avec les relations de domination, les prérequis permettent la
formalisation de déﬁnitions alternatives des relations d’héritage entre concepts. Dans
les modèles basés sur les rôles, il a été proposé par exemple de spécialiser la relation
d’héritage de rôles en sous-relations qui imposent de nouvelles propriétés. On peut
différencier l’héritage selon que la hiérarchie de rôles représente [Crook03, Joshi02] :

– une hiérarchie fonctionnelle. C’est la hiérarchie est-un des professionnels de santé

que nous utilisons dans les exemples : médecin, généraliste, spécialiste, . . .

– une hiérarchie d’autorité. Un exemple de hiérarchie d’autorité est l’ordre total des
grades dans certaines administrations publiques : commissaire, inspecteur, pré-
posé puis agent. Cet ordre est modélisable par une hiérarchie, mais conceptuelle-
ment elle ne représente pas une relation est-un,

– une hiérarchie structurelle. Certains modèles proposent un organigramme des ser-
vices pour structurer les droits par exemple. Conceptuellement, il s’agit souvent
d’une relation d’inclusion. Une relation d’inclusion respecte les mêmes propriétés
algébriques qu’une relation hiérarchique.

Grâce aux classes de dépendances générales, il est possible d’exprimer les dif-
férentes propriétés sous-entendues par les spécialisations du concept de rôles. Plu-
sieurs hiérarchies aux sémantiques différentes peuvent être développées sur un même
concept. Les différences entre elles peuvent être exprimées comme des propriétés sup-
plémentaires que les relations de domination directes respectent.

Déﬁnition (Relation d’héritage spécialisée). Soient DomineC une relation de domination
sur un concept C et H ´eriteC sa relation d’héritage dérivée. La relation H ´eriteC est dite relation

Section 4.5. Contraintes dans les modèles de contrôle d’accès

119

d’héritage spécialisée si une contrainte de prérequis intra-relation de la forme suivante est
respectée, où R(. . . ID1 . . .) est une relation entre C et d’autres concepts :

DomineC(ID1, ID2), R(. . . ID1 . . .), c( ˜X) → ∃ID R(. . . ID . . .), c′( ˜Y)

Selon la relation R utilisée dans la déﬁnition d’une relation d’héritage spécialisée, on
peut exprimer des sémantiques complexes des relations d’héritage. Dans les modèles à
rôles, une hiérarchie d’autorité déﬁnit une contrainte sur l’héritage à l’aide de la relation
d’affectation des rôles aux utilisateurs. On peut ainsi exprimer « qu’il n’y a jamais de
subordonné sans chef ». Pour les hiérarchies fonctionnelles ou structurelles, on peut à
l’aide des relations d’héritage contraintes exprimer des dépendances sur la composition
des équipes ou des services.

Exemple 4.4 Il n’y a jamais de subordonné sans chef

Au CHM, le directeur d’établissement peut être assisté par un ou plusieurs directeurs
adjoints auxquels il délègue une partie de ses attributions. Imaginons que le CHM
mette en œuvre une extension du modèle de contrôle d’accès RBAC3 qui intègrerait
hiérarchie de rôles, exclusion mutuelle et prérequis.
Les administrateurs souhaitent spéciﬁer une contrainte exprimée en langue naturelle
par « s’il existe un directeur adjoint dans l’organisation, alors il existe aussi un autre
utilisateur directeur ». On peut ainsi poser une contrainte N ´ecessite sur la relation de
domination entre rôles Domine qui permet de la spécialiser :

N ´ecessite(Sub, Sup), Domine(Sup, Sub), Habilite(U, Sub) → ∃U′Habilite(U′, Sub)

Pour la déﬁnition de N ´ecessite on s’appuie sur une relation en extension D ´epend. On
déﬁnit alors la relation N ´ecessite comme transitive avec

D ´epend(R1, R2), N ´ecessite(R2, R3) → N ´ecessite(R1, R3)

L’expression de D ´epend(adjoint, directeur) dans la politique permet d’imposer un
directeur en présence d’un adjoint. Ce type de contrainte est exprimable en utilisant
une dépendance génératrice de tuples contraintes, ce qui n’est pas faisable en DATA-
LOGC ou dans les cadres théoriques qui se réduisent à ce dernier.
On pourrait également déﬁnir « qu’il n’existe pas d’anesthésiste sans chirurgien »
,D ´epend(anesth´esiste, chirurgien), ou toute autre propriété qui nécessite l’utilisa-
tion de la quantiﬁcation existentielle dans sa modélisation logique.

120

Chapitre 4. Structuration du contrôle d’accès

4.6 Modélisation du contexte

Avec l’évolution des besoins et des technologies, les systèmes contemporains in-
tègrent désormais espace, temps et d’autres données contextuelles. Ces informations
permettent de caractériser les situations et les interactions des utilisateurs avec les sys-
tèmes. Dans certains domaines d’application, comme les systèmes d’informations mo-
biles par exemple, la prise en compte de ces aspects fait partie intégrante de l’archi-
tecture des systèmes. Dans l’état de l’art, nous avons présenté deux formalisations des
aspects contextuels en DATALOGC :

– une première où des concepts et relations de contexte sont utilisés dans l’expres-

sion des core-rules,

– une seconde basée sur le conditionnement des données factuelles de I.
Nous avons montré que ces deux approches ne sont pas pleinement satisfaisantes.
La première brise la séparation entre aspects statiques et dynamiques : tous les triplets
d’autorisation fondamentaux deviennent dynamiques. La seconde rompt la catégori-
sation entre aspects factuels et déduits. Or ces deux séparations (tableau 4.2) ont été
identiﬁées comme fondamentales dans les modèles de contrôle d’accès [Li07].

4.6.1 Approche proposée

Nous proposons de modéliser le contexte comme des restrictions d’accès. Plutôt que
de modiﬁer les core-rules (première approche) ce qui alourdit la modélisation, ou de
conditionner l’existence de tuples par des données contextuelles (seconde approche) ce
qui impose des recalculs fréquents de I′, nous proposons de représenter les contextes
comme des restrictions sur les états intègres des politiques à vériﬁer à l’exécution seule-
ment.

Dans la modélisation proposée, nous nous basons sur une politique intègre I′, qui
satisfait les dépendances du modèle que nous avons déﬁnies jusque ici I′ |= Σ ∪ P.
Cette politique déﬁnit l’ensemble des droits dont les utilisateurs disposent. Nous allons
ajouter à Σ des dépendances pour restreindre l’ensemble des permissions utilisables selon
des critères contextuels. En d’autres termes, une fois dérivées les matrices de contrôle
d’accès, c’est-à-dire les triplets fondamentaux d’autorisations, nous allons limiter les
accès des sujets hors contextes en interdisant l’accès à certaines colonnes de la matrice.

Déﬁnition (Contraintes d’accès contextuelles). Une contrainte d’accès contextuelle
est modélisable par une dépendance génératrice de nullité, où ψcontexte(X1) est une conjonc-
tion d’aspects dynamiques représentant les informations de contexte, φ(X2) une conjonction
de concepts et relations dynamiques du modèle de contrôle d’accès et c( ˜X) une conjonc-
tion de contraintes sur des variables de ψcontexte(X1) et φ(X2). Les valeurs des variables de
ψcontexte(X1) à un instant donné forment un état de contexte :
ψcontexte(X1), φ(X2), c( ˜X) → ⊥

Section 4.6. Modélisation du contexte

121

Utilisateur

Rôle

Alice

Alice
Bob
Bob

Charly
Charly
Denise

Infirmier

M´edecin
Infirmier
Gastrologue

Infirmier
P´ediatre
Secr´etaire

Heure(H), H < 8,
Endosse(S, M´edecin)→⊥
Heure(H),H > 20,
Endosse(S, M´edecin)→⊥
Heure(H), H < 6, Endosse(S, Gastrologue)→⊥
Heure(H),H > 22,Endosse(S, Gastrologue)→⊥
Heure(H),H < 12,
Endosse(S, P´ediatre)→⊥
Endosse(S, P´ediatre)→⊥
Heure(H),H > 18,

TAB. 4.3 – Instance de la relation Habilite et contraintes contextuelles

4.6.2 États de contexte

Illustrons la déﬁnition des états de contexte par une modélisation du temps reprise
du modèle TRBAC. Nous supposons la relation Habilite d’affectation de rôles aux utili-
sateurs du tableau 4.3. Les lignes grisées de ce tableau indiquent des rôles qui peuvent
être endossés uniquement pendant les horaires d’ouverture des services de soin concer-
nés.

Nous exprimons ces restrictions par des dépendances portant sur la relation dyna-
mique Endosse modélisant les rôles endossés dans les sessions. Nous supposons l’exis-
tence d’un concept de contexte Heure(H) dont la valeur est l’heure actuelle. Les dépen-
dances du tableau 4.3 modélisent ces restrictions, où ψcontexte est Heure(H) et c( ˜X) est
composé d’inégalité sur les heures.

Avec cette approche, la vériﬁcation de contexte se fait donc à l’ouverture des ses-
sions. Quand un utilisateur u ouvre une session s, dans laquelle il désire endosser le
rôle r, il faut vériﬁer que l’ajout du tuple Endosse(s, r) ne viole pas les contraintes d’ac-
cès contextuelles5. Si tel était le cas, la demande de session initiée par l’utilisateur serait
refusée.

Le tableau 4.4 est un extrait du tableau 3.3 limité aux utilisateurs Alice et Bob, dans
lequel nous faisons ﬁgurer en gris les permissions qui sont accessibles qu’entre 8h et
20h. Nous y ajoutons également une colonne qui indique par quel rôle Alice ou Bob
acquiert le privilège. Selon l’état de contexte, la représentation en tableau du triplet
U × A × O × R sera composée de plus ou moins de lignes. Le principe consiste à limiter
les instances autorisées des aspects dynamiques.

On peut imaginer que, aﬁn de faciliter la gestion des contraintes contextuelles,
on pourrait déﬁnir des règles DATALOGC comme Heure(H), H ≤ 20, H ≥ 8 →
HoraireOuverture(), or cette modélisation impose de recalculer à chaque changement
d’heure l’instance I′. Notre proposition évite ce problème en modélisant les contraintes
d’accès uniquement comme des instances invalides, sans passer par des règles de dé-

5Il faut, bien sûr, vériﬁer que le rôle r fait bien partie de ceux attribués à l’utilisateur.

122

Chapitre 4. Structuration du contrôle d’accès

Utilisateur Action

Objet

Rôle

Alice
Alice
Alice
Alice
Bob
Bob
Bob
Bob
Bob

Bob
Bob

r
r
r
w
r
r
r
r
w

w
x

Fichier1
Fichier2
Fichier3
Fichier1
Fichier1
Fichier2
Fichier3
Fichier4
Fichier2

Fichier4
Fichier4

Infirmier
Infirmier
Infirmier
M´edecin
Infirmier
Infirmier
Infirmier
Gastrologue
Gastrologue

Gastrologue
Gastrologue

TAB. 4.4 – Restrictions de permissions hors-contexte

duction. On pourrait éventuellement rafﬁner la catégorisation en aspects statiques et
dynamiques pour séparer les aspects contextuels.

4.7 Discussion et synthèse

4.7.1 Limitations de la notion de contrainte

Un type de contrainte régulièrement proposé dans la littérature porte sur la cardina-
lité. Ces contraintes permettent de limiter le nombre d’instances de relations autorisées
dans la politique de contrôle d’accès. Dans les implémentations des modèles RBAC, il
est courant de pouvoir associer à chaque rôle une cardinalité, déﬁnissant le nombre
maximum d’utilisateurs qui peuvent être affectés aux rôles. Les dépendances fonction-
nelles permettent d’exprimer le cas dégénéré des contraintes d’unicité, cependant, dans
le cas général, il est difﬁcile de les modéliser [Calvanese94]. Une solution à ce problème
serait des dépendances génératrices de la forme suivante, exprimant que le nombre de
concepts reliés à c par la relation R est limité à n :

R(C1, c), . . . , R(Cn+1, c), C1 6= C2, . . . , C1 6= Cn+1, . . . , Cn 6= Cn+1 →⊥

Or cette modélisation n’est pas satisfaisante. D’une part, le nombre d’inégalités dans
le corps (égal à C2
n+1 = n(n + 1)/2) rend la solution impraticable dès que n est grand.
D’autre part nous perdons l’aspect déclaratif de la proposition : pour chaque contrainte
de cardinalité il va falloir créer une dépendance spéciﬁque. Ceci conduit à augmenter
le nombre de dépendances et à compliquer le travail d’analyse des administrateurs de
la politique, ce qui s’oppose aux objectifs que nous nous sommes ﬁxés.

De plus, nous ne pouvons pas exprimer de relations entre les cardinalités, comme
dans les modèles RBAC « tout rôle a une contrainte de cardinalité plus restrictive que

Section 4.7. Discussion et synthèse

123

ceux dont il hérite ». En conclusion, nous reléguons à des mécanismes techniques la
vériﬁcation des contraintes de cardinalité, et nous ne pourrons pas vériﬁer l’implication
logique de propriétés faisant intervenir des contraintes de cardinalité.

4.7.2 Synthèse

Ce chapitre propose une généralisation des différentes notions développées dans les
modèles de contrôle d’accès. À partir de déﬁnitions communes aux modèles de contrôle
d’accès, issues de la littérature ou proposées à notre initiative, nous avons successive-
ment déﬁnis :

1. la séparation entre les modèles et les politiques de contrôle d’accès,
2. la catégorisation en aspects factuels et déduits d’une part, et statiques et dynamiques
d’autre part, qui permet de diviser les modèles de contrôle d’accès en composants,

3. les notions de triplets d’autorisation, qui sont à la base de tout modèle,
4. la notion de schéma de contrôle d’accès , la structure principale qui représente le

noyau d’un modèle de contrôle d’accès,

5. les notions de principes fondamentaux et des règles de dérivations, qui expriment

comment à partir d’un schéma dériver les triplets d’autorisation,

6. les notions de hiérarchisation de concepts, qui permettent de réduire le nombre de
concepts et de faire correspondre la structuration des droits aux structures des
organisations,

7. les notions de contraintes dans les modèles de contrôle d’accès comme l’exclusion

mutuelle et les prérequis : des propriétés que les politiques doivent satisfaire,

8. la notion de contexte et d’état de contexte, en proposant une modélisation qui ne

rompt pas avec la catégorisation des aspects des modèles.

Notre proposition est basée sur le cadre des dépendances. Ce cadre expressif permet
de représenter de façon homogène les notions sus-citées. Informellement, nous dirions
que nous avons fait correspondre des composants des modèles de contrôle d’accès aux
briques élémentaires des modèles relationnels. Le tableau 4.5 synthétise cette corres-
pondance.

Si nous avons jusqu’à présent déﬁni le quoi du contrôle d’accès, nous n’avons pas
proposé de comment. Notre modélisation a séparé les modèles des politiques, le chapitre
suivant va renforcer cette séparation. Il propose des outils relatifs à :

– la conception des modèles de contrôle d’accès, c’est-à-dire la manipulation de la
structure et des principes de l’organisation des droits d’un point de vue générique,
quelles que soient les politiques qui en sont instances,

– la conception des politiques, c’est-à-dire la déﬁnition progressive des données qui
composent la politique. Cette conception peut se faire à partir de droits existants
dans le cas d’évolution du contrôle d’accès,

124

Chapitre 4. Structuration du contrôle d’accès

Modèle de contrôle d’accès Structuration relationnelle

noyau

principes
propriétés

politique factuelle
politique déduite

schéma

règles de déduction

dépendances

instance

point ﬁxe de la déduction

TAB. 4.5 – Correspondance entre contrôle d’accès et structuration relationnelle

– l’administration des politiques, c’est-à-dire la manipulation des données ins-

tances d’un modèle de contrôle d’accès donné.

Whentheonlytoolyouhaveisahammer,everythingbeginstolooklikeanail.

Anonymous

5

Mise en œuvre de la structuration

⊲ Dans le chapitre précédent, nous avons développé une vision abstraite de l’organisation des droits
dans les systèmes. Dans ce chapitre, nous proposons une vision pragmatique, orientée selon l’utilisation
qui est faite du cadre logique proposé pour le contrôle d’accès. Les contributions que nous présentons
relèvent de trois ordres :

– nous proposons une structuration en niveaux d’abstraction pour situer et déﬁnir les activités de

conception et d’administration du contrôle d’accès,

– nous proposons des outils permettant d’assister ces deux activités. Il s’agit d’exploiter les possibi-

lités offertes par les procédures de preuve et de satisfaction pour les dépendances pour :
– la vériﬁcation et la simpliﬁcation de modèles de contrôle d’accès dans notre cadre logique,
– la vériﬁcation que les politiques satisfont bien aux propriétés des modèles,

– nous abordons la problématique du cycle de vie et de l’évolution des droits avec :

– une représentation graphique des principes et des propriétés des modèles de contrôle d’accès,

ainsi que la visualisation l’exécution des procédures de preuve,

– une automatisation de la découverte de concepts intermédiaires hiérarchisés présents implicite-

ment dans des politiques existantes.

Ce chapitre va justiﬁer a posteriori les choix des termes de concepts et de relations que nous avons
utilisés pour la déﬁnition générique des modèles de contrôle d’accès. De plus, nous mettons en lumière et
exploitons les liens qui existent entre plusieurs domaines de recherche : les dépendances de données, les
graphes conceptuels et l’analyse de concepts formels.

L’implémentation des procédures que nous utilisons dans ce chapitre a été réalisée et fait l’objet de la
section 6.2 du chapitre suivant. En déﬁnissant les activités de conception et d’administration de contrôle
d’accès nous voyons apparaître le problème de l’organisation des droits des administrateurs qui fait l’objet
d’une des perspectives présentées dans le chapitre 7.

Une trace d’inférence de la simpliﬁcation exposée en section 5.2.5 est proposée en annexe C. ⊳

126

Chapitre 5. Mise en œuvre de la structuration

Plan du chapitre

5.2 Conception de modèles . .
. .

. .

5.3 Administration des politiques . .

.
.

.
.

. .
. .

5.1

5.5

.

. .

. .

.

. .
. .

. .
. .

5.3.1
5.3.2
5.3.3
5.3.4
5.3.5

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
.

Structuration en couches
. .
. .
5.1.1 Objectifs de la structuration . .
. .
5.1.2 Décomposition en couches .
. .
. .
. .
.
. .
5.2.1 Déﬁnition .
.
. .
. .
5.2.2 Méthodologie de conception .
. .
5.2.3
. .
.
Primitives de conception .
. .
. .
5.2.4
Intégrité des modèles .
.
. .
. .
. .
5.2.5
Simpliﬁcation de modèles .
. .
. .
.
. .
Conception des politiques .
. .
. .
Primitives d’administration . .
. .
. .
Intégrité des politiques . .
. .
Correction des politiques
. .
. .
Comparaison statique de politiques .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
Rôles hiérarchisés et treillis des concepts formels . .

. .
. .
.
. .
. .
.
. .
. .
.
. .
. .
.
. .
. .
.
. .
. .
.
. .
. .
.
. .
. .
.
. .
. .
.
. .
. .
.
. .
. .
.
. .
. .
.
. .
. .
.
. .
. .
.
. .
. .
.
. .
. .
.
. .
. .
5.4.1 Graphes conceptuels .
.
Correspondance avec les dépendances . .
. .
5.4.2
.
Représentation graphique de dépendances .
5.4.3
.
Raisonnement avec les graphes . .
. .
5.4.4
.
. .
. .
Ingénierie de rôles hiérarchisés . .
.
5.5.1
. .
. .
. .
.
5.5.2 Matrice de contrôle d’accès et contexte formel
.
5.5.3
.
5.5.4 Analyse de concepts formels et ingénierie des rôles .
.
5.5.5 Automatisation de l’ingénierie des rôles .
. .
.
.
. .
. .
.

Ingénierie des rôles . .

. .
. .
. .
. .

. .
. .
. .
. .

. .
. .
. .
. .

. .
. .
. .

. .
. .
. .

. .
. .

5.6 Discussion et synthèse .

. .
5.6.1 Outils pour le contrôle d’accès
5.6.2

. .
. .
Vers l’évolution du contrôle d’accès

. .

. .

. .

.

. .
. .
.

5.4 Représentation graphique de modèles .
. .

. .

.

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. 128
. 128
. 128
. 129
. 129
. 130
. 131
. 132
. 135
. 137
. 137
. 138
. 139
. 140
. 142
. 143
. 143
. 144
. 147
. 149
. 152
. 153
. 155
. 157
. 159
. 162
. 167
. 167
. 168

127

Note sur les dépendances

POUR les vériﬁcations de propriétés que nous proposons dans ce chapitre, nous consi-

dérons les règles de déduction DATALOG comme des dépendances génératrices de
tuples totales. Les règles DATALOGC sont des restrictions des dépendances génératrices
de tuples contraintes, sans variables quantiﬁées existentiellement et sans contraintes en
conclusion.

La structuration relationnelle d’un modèle de contrôle d’accès AC = (sch, P, Σ) est
composée d’un schéma sch, d’un ensemble de règles de déduction P qui permet de
dériver les relations en intention et d’un ensemble de dépendances Σ qui permettent de
déﬁnir l’intégrité des relations.

L’ensemble de formules closes P est considéré comme un ensemble de dépendances
génératrices de tuples totales. L’instance I′ est déﬁnie par P, elle satisfait par déﬁnition
les règles de P prises comme des dépendances. Nous avons donné les éléments qui
nous autorisent à faire ces considérations en section 4.1.3.

Pour les vériﬁcations de l’implication logique d’un expression σ, c’est-à-dire des
preuves de P ∪ Σ |= σ ou de P ∪ Σ 6|= σ, nous utiliserons uniformément les procé-
dures de preuves des dépendances, sans faire de distinction entre les principes et les
propriétés des modèles. Pour les vériﬁcations de la satisfaction d’une propriété par une
instance, c’est-à-dire des preuves d’implication ou de non implication I |= σ ou de
|= σ, nous considérons également les règles DATALOG et DATALOGC comme des
I′
dépendances.

Selon le fragment logique utilisé pour la modélisation du contrôle d’accès, diffé-
rentes procédures de preuves peuvent être utilisées. Les procédures de [Maher96] ou
de [Wang02] peuvent terminer pas un cas spéciﬁque à la présence de contraintes en
conclusion des formules. Cette terminaison par vacuité est le cas où une formule in-
satisfaisable ⊥ est contenue dans le magasin de contraintes. Pour les applications que
nous proposons, ce cas de terminaison indique la présence d’une erreur manifeste dans
la théorie logique.

La déﬁnition d’un modèle de contrôle d’accès que nous proposons est un ensemble
de formules closes de la logique du premier ordre, c’est-à-dire une théorie logique du pre-
mier ordre. Le vocabulaire sur lequel est déﬁnie cette théorie est composé des noms de
relations en intention et en extension, déﬁnies par les concepteurs du modèle. L’objectif
de la théorie et de formaliser les notions utiles à la déﬁnition d’un modèle de contrôle
d’accès. La différence d’utilisation entre principes et propriétés d’intégrité des modèles
de contrôle d’accès est importante. En revanche, du point de vue de la sémantique lo-
gique, elle est moindre. La théorie que nous considérons T = P ∪ Σ est composée de
deux sous-ensembles de formules : les principes P et les propriétés Σ.

128

Chapitre 5. Mise en œuvre de la structuration

5.1 Structuration en couches

Depuis l’identiﬁcation d’un cadre logique d’intérêt pour la modélisation du contrôle
d’accès, nous avons étendu les propositions existantes de modélisation basées principa-
lement sur DATALOG en intégrant des dépendances de plus en plus expressives. Dans
notre structuration du contrôle d’accès, nous avons séparé :

– les relations de base des modèles,
– les relations dérivées des relations de base,
– les propriétés que les relations doivent respecter.
Cette séparation est un ﬁl conducteur la thèse. Elle est encouragée par plusieurs pro-
positions du domaine [Halpern03, Li07]. Nous avons utilisé le cadre logique relation-
nel des dépendances pour déﬁnir une modélisation générique, qui intègre les proprié-
tés déﬁnies comme fondamentales des modèles de contrôle d’accès et les suggestions
d’amélioration proposées pour les modèles RBAC.

5.1.1 Objectifs de la structuration

Jusqu’à présent nous avons principalement spéciﬁé formellement ce que sont les
modèles de contrôle d’accès, en généralisant les notions et les éléments de modéli-
sation logique existants. Nous allons désormais déﬁnir comment mettre en œuvre le
contrôle d’accès et exploiter les outils développés pour les dépendances. Il nous faut
donc situer les différentes activités qui surviennent lors de l’utilisation des modèles et
des politiques de contrôle d’accès.

5.1.2 Décomposition en couches

Aﬁn de situer la conception de modèles de contrôle d’accès, nous mettons en paral-
lèle le cycle de développement d’applications orientées objet et celui du développement
du contrôle d’accès. L’organisation des logiciels est divisée en couches allant de l’abs-
traction la plus générale à la réalisation concrète. Pour les applications orientées objet,
ces niveaux vont du métamodèle d’UML jusqu’au code compilé (tableau 5.1).

Cette stratiﬁcation encourage la séparation entre les différents niveaux d’abstrac-
tion qui interviennent dans la conception d’applications. Cette section transpose cette
stratiﬁcation en niveaux au contrôle d’accès. L’objectif est de pouvoir identiﬁer et struc-
turer les différents activités qui surviennent lors de la mise en œuvre de notre modèle
logique générique d’organisation des droits. Le tableau 5.1 met en parallèle le déve-
loppement d’applications orientées objet et la stratiﬁcation en niveaux d’abstraction du
contrôle d’accès :

Section 5.2. Conception de modèles

129

Développement logiciel

Contrôle d’accès

3 meta-modèle UML, qui déﬁnit la

2

syntaxe graphique
conception d’application avec des
diagrammes UML

1 développement de l’application
0 déploiement de l’application

déﬁnition générique des modèles
de contrôle d’accès
conception de modèle de contrôle
d’accès
déﬁnition de la politique
déploiement du contrôle d’accès

3

2

1
0

TAB. 5.1 – Abstraction en couches pour le contrôle d’accès

– le niveau le plus haut (numéroté 3 du tableau 5.1) est le modèle générique pré-
senté dans le chapitre 4. Passer de ce niveau au niveau inférieur est l’étape que
nous désignons par la conception de modèle,

– le niveau inférieur (2 du tableau 5.1) est une instance du modèle générique, c’est-
à-dire un modèle de contrôle d’accès donné, exprimé dans le cadre que nous pro-
posons. Un tel modèle peut être RBAC, ORBAC, celui proposé par le GMSIH pour
les systèmes d’information hospitaliers ou tout modèle conçu sur mesure. Le pas-
sage au niveau inférieur est l’étape de conception de politique,

– le niveau suivant (1 du tableau 5.1) est la politique de contrôle d’accès, c’est-à-
dire un ensemble de faits déterminé par les administrateurs, organisé selon les
concepts et les relations déﬁnis dans le modèle de contrôle d’accès,

– le niveau le plus bas est celui de la réalisation effective du contrôle d’accès, c’est-
à-dire la mise en production du modèle et de la politique. C’est pendant et après
le déploiement du contrôle d’accès qu’a lieu l’administration des politiques.

5.2 Conception de modèles

5.2.1 Déﬁnition

Nous avons déﬁni le niveau le plus haut de la structuration abstraite du contrôle
d’accès , c’est le modèle générique du chapitre précédent. Nous déﬁnissons l’opération
d’instanciation du modèle générique en un modèle donné, c’est-à-dire la conception.

Déﬁnition (Conception de modèle de contrôle d’accès). La conception d’un modèle de
contrôle d’accès est l’activité qui consiste en l’identiﬁcation et la déﬁnition :

– des concepts et relations utilisés pour structurer les droits qui forment le noyau,
– des principes qui régissent la dérivation des relations déduites à partir du noyau,
– des propriétés que les politiques doivent respecter.

Cette déﬁnition identiﬁe trois sous-activités principales de la conception de mo-
dèles de contrôle d’accès L’étape de conception de modèle est fondamentale pour que

130

Chapitre 5. Mise en œuvre de la structuration

le modèle construit réponde bien au cahier des charges de l’organisation. Comme il
est difﬁcile dans le cas général de proposer un modèle consensuel d’organisation des
droits, nous proposons un modèle qui permette de concevoir des modèles de contrôle
d’accès sur mesure.

La démarche d’analyse, de spéciﬁcation et de conception menée par Anas Abou El
Kalam dans sa thèse a conduit à la déﬁnition du modèle ORBAC [Abou El Kalam03].
L’objectif était de concevoir une politique de sécurité pour les systèmes d’information
et de communication en santé et social.

Dans cette perspective, l’état de l’art et le modèle générique du chapitre 4 peuvent
être abordés comme une bibliothèque référençant les principaux modèles de contrôle
d’accès existants et les notions qu’ils intègrent. Grâce à cette bibliothèque, les concep-
teurs disposent des principaux concepts et relations pour construire de nouveaux mo-
dèles de contrôle d’accès, en utilisant les dépendances comme cadre logique sous-
jacent.

5.2.2 Méthodologie de conception

La conception d’un modèle de contrôle d’accès couvre un domaine très large, qui va
de la catégorisation des ressources du système en classes de conﬁdentialité à la forma-
lisation d’aspects sémantiques. La ﬁgure 5.1 identiﬁe quatre étapes qui interviennent
lors de la conception de contrôle d’accès :

1. l’analyse des besoins de sécurité de l’organisation. Plusieurs méthodologies ont
été proposées pour aider les responsables de la sécurité à identiﬁer les points
stratégiques des organisations, à évaluer les risques ou à classer les ressources
selon leur valeur et leur conﬁdentialité [Ferraiolo03b, Solomon05, Benantar06,
Deswarte03]. Cette étape aboutit à l’établissement d’une politique générale de
sécurité qui déﬁnit les objectifs et les moyens à mettre en œuvre pour garantir les
objectifs de sécurité,

2. l’analyse de l’existant et l’identiﬁcation des concepts et relations à intégrer dans
le contrôle d’accès. Cette étape déﬁnit selon quels principes les droits des utili-
sateurs vont être organisés, quelles règles vont régir comment un utilisateur va
acquérir des privilèges, et surtout quelles sont les propriétés attendues que les
droits vont devoir respecter,

3. la déﬁnition formelle du modèle de contrôle d’accès. Cette étape déﬁnit de ma-
nière univoque la structure, les principes et les propriétés exprimées en langue na-
turelle lors de l’étape précédente. Le précédent et le présent chapitre interviennent
à ce niveau. Nous proposons un cadre formel et un panel d’outils pour les concep-
teurs grâce auxquels ils peuvent déﬁnir et vériﬁer leur modèle de contrôle d’accès,

Section 5.2. Conception de modèles

131

FIG. 5.1 – Étapes de la conception d’un modèle

4. la déﬁnition de la politique. Dans cette dernière étape interviennent les admi-
nistrateurs qui vont établir les droits d’accès par l’intermédiaire des concepts et
relations déﬁnis par les concepteurs.

Lors de la conception d’un modèle de contrôle d’accès, les concepteurs peuvent
déﬁnir de nombreux concepts, relations, principes et propriétés. De plus, ces déﬁnitions
peuvent éventuellement se contredire ou être redondantes. Des outils de vériﬁcation et
d’analyse des modèles et des politiques permettent de répondre à ces problèmes.

5.2.3 Primitives de conception

L’étape de conception de modèle de contrôle d’accès consiste en la déﬁnition lo-
gique du schéma, des principes et des propriétés du contrôle d’accès. Il s’agit donc
d’une activité où l’on utilise les notions présentées dans le chapitre précédent pour mo-
déliser l’organisation des droits dans un système.

Déﬁnition (Primitives de conception). Une primitive de conception est toute opération
qui permette la création, la modiﬁcation ou la suppression des concepts, relations, principes et
propriétés d’un modèle de contrôle d’accès.

132

Chapitre 5. Mise en œuvre de la structuration

dérivation

fermeture

propriété

limitation

contrainte

s
e
p
i
c
n
i
r
P

s
é
t
é
i
r
p
o
r
P

Objectif de modélisation
triplets d’autorisation
triplets d’autorisation orientés utilisateurs
symétrie d’une relation
transitivité d’une relation
réﬂexivité d’une relation
relations en intention techniques
antisymétrie d’une relation
irréﬂexivité d’une relation
structurelle du noyau
hiérarchie en arbre
hiérarchie en arbre inverse
hiérarchie en treillis
prérequis
exclusion mutuelle
interaction hiérarchie/exclusion
spécialisation de hiérarchie
dépendances techniques

TAB. 5.2 – Classiﬁcation de la théorie du premier ordre

L’aide d’outils graphiques permet de manipuler plus facilement la formalisation
logique que nous proposons dans la thèse. Dans ce sens, nous proposons en section 5.4
une représentation des formules logiques qui permet d’exprimer graphiquement les
modèles de contrôle d’accès.

5.2.4 Intégrité des modèles

Le tableau 5.2 présente des objectifs de modélisation respectifs aux deux sous-
ensembles de la théorie. Des principes et des propriétés techniques peuvent être in-
troduits, pour servir d’intermédiaires dans la modélisation logique. Dans les modèles
RBAC on déﬁnit généralement deux relations en intention intermédiaires pour repré-
senter logiquement les applications auth_perms et auth_users déﬁnies à partir des re-
lations hiérarchiques entre rôles (section 2.3.2). Il faut s’assurer que les différentes ex-
pressions de P et Σ soient cohérentes.

Section 5.2. Conception de modèles

133

5.2.4.1 Déﬁnition

En présence d’une théorie logique de taille conséquente,les règles et les dépen-
dances peuvent s’avérer contradictoires. Ceci est particulièrement vraisemblable quand
plusieurs concepteurs interviennent. L’étape préalable à la vériﬁcation des modèles est
la déﬁnition de l’intégrité d’un modèle de contrôle d’accès.

Déﬁnition (Modèle non intègre de contrôle d’accès). Un modèle de contrôle d’accès AC =
(edb ∪ idb, P, Σ) de théorie T = P ∪ Σ est dit non intègre s’il n’existe pas de politique I′ modèle
de T où chaque relation de edb est instanciée.

S’assurer de l’intégrité d’un modèle de contrôle d’accès est une vériﬁcation de l’exis-
tence d’un modèle particulier de la théorie logique. Cette vériﬁcation doit être effectuée
quelle que soit la politique déterminée par les administrateurs. C’est donc une preuve
qui fait abstraction des politiques et qui ne concerne que le modèle de contrôle d’accès
lui-même. La déﬁnition présentée est une spécialisation de la notion de satisfaisabilité
d’une théorie logique (annexe A), à laquelle nous avons imposé une contrainte supplé-
mentaire, instanciation de chaque relation en extension.

5.2.4.2 Principe de la vériﬁcation

Nous souhaitons utiliser les procédures de preuves comme le chase pour automati-
ser une partie de la vériﬁcation de l’intégrité d’un modèle. La vériﬁcation est basée sur
la construction d’une dépendance σ puis sur la vériﬁcation à l’aide d’une procédure de
preuve qu’il est impossible de dériver σ à partir de la théorie, soit P ∪ Σ 6|= σ.

L’hypothèse φ de σ est construite à partir du schéma en extension edb composé des
concepts {C1 . . . Cn} et des relations {R1, . . . , Rm}. φ exprime que chaque relation de
edb est instanciée. La conjonction φ est déﬁnie comme une conjonction où toute relation
et tout concept de edb apparaisse, soit une expression de la forme :

C1(ID1), . . . , Cn(IDn), R1(. . . IDi . . .) . . . , Rm(. . . IDj . . .)

La conclusion de σ est une antilogie ⊥. Il s’agit donc d’une forme de preuve par
l’absurde : si l’on arrive à dériver σ, on dérive une antilogie, c’est donc que la théorie
logique n’est pas correcte pour une instance I quelconque.

Certaines procédures de preuves n’étant que semi-décidables, une preuve négative
peut ne pas être fournie. Dans la pratique, si une procédure n’est pas parvenue à une ré-
ponse en un nombre déterminé d’étapes, nous considérons par principe de précaution
que le modèle n’est pas intègre.

Nous avons déﬁni la non-intégrité d’un modèle de manière générale. Des éléments
pour une déﬁnition plus précise de l’intégrité et d’une dépendance σ qui la modélise
sont proposés comme discussion et perspective en section 7.3.4. Il s’agit d’un problème
difﬁcile qui dépasse nos compétences en informatique théorique.

134

Chapitre 5. Mise en œuvre de la structuration

La déﬁnition générale de l’intégrité et la construction d’une dépendance σ qui la re-
présenterait nécessitent d’être poursuivies. Cependant, la déﬁnition actuelle nous per-
met d’effectuer une vériﬁcation intéressante : la vériﬁcation de l’intégrité d’un modèle
RBAC3 comportant la déﬁnition d’un rôle particulier root.

5.2.4.3 Application de la vériﬁcation

Supposons la conception d’un modèle de type RBAC3, comportant le concept de rôle
Role(R), une relation d’héritage entre rôles H ´erite(R1, R2) et une exclusion mutuelle
entre rôles Exclusion(R1, R2). De multiples concepteurs ont déﬁni successivement dans
la même théorie P ∪ Σ trois expressions logiques :

1. σ1 la dépendance Exclusion(R1, R2), H ´erite(R, R1), H ´erite(R, R2) → ⊥ imposée

par la présence d’une relation d’exclusion et d’une hiérarchie sur les rôles,

2. σ2 la dependance structurelle Exclusion(R1, R2) → Role(R1), Role(R2),
3. τ la règle de déduction Role(R) → H ´erite(root, R) qui modélise l’existence d’un

rôle particulier root qui hérite de tous les autres.

Considérons une dépendance qui permette de vériﬁer l’intégrité de la modélisa-
tion. Cette dépendance σ est de la forme Role(R), . . . , Exclusion(R1, R2) → ⊥ : nous
allons vériﬁer la non-contradiction de la théorie. La présence de deux rôles exclusive-
ment mutuels dans la politique va rendre la politique inconsistante. Un tel modèle de
contrôle d’accès n’est pas intègre à cause de la déﬁnition du rôle root. Cette vériﬁca-
tion est automatisable avec une procédure de preuve. Les étapes de la dérivation sont
successivement :

1. on suppose l’existence de deux tuples Role(r) et Exclusion(r1, r2),
2. par application de σ2 il existe deux rôles Role(r1) et Role(r2),
3. en appliquant deux fois τ on déduit H ´erite(root, r1) et H ´erite(root, r2),
4. on peut donc appliquer σ1 et dériver ⊥.

On a ainsi démontré que P ∪ Σ |= σ et la non intégrité de la modélisation. Plu-
sieurs corrections sont envisageables. On peut modiﬁer la règle τ pour déﬁnir le rôle
root autrement ou supprimer cette règle. On peut également modiﬁer les propriétés de
l’exclusion mutuelle ou éventuellement y renoncer. L’analyse de la trace de la preuve
peut donner des informations aux concepteurs pour choisir la meilleure correction. On
remarque que c’est la déﬁnition conjointe de σ1 et de τ qui est une des sources du pro-
blème.

Cette démonstration automatisée complète les résultats [Gavrila98]. Cette vériﬁca-
tion de l’intégrité d’un modèle RBAC3 a été proposée dans [Benantar06] comme discus-
sion sur l’impact de l’exclusion d’où est extraite la citation suivante :

Section 5.2. Conception de modèles

135

Exemple 5.1 Un modèle expoitable pour le CHM

Dans la quête d’un modèle de contrôle d’accès qui leur conviennent, les informaticiens
du CHM ont interrogé plusieurs des responsables administratifs pour comprendre leurs
besoins de modélisation des droits.
Il a été admis que les services de l’établissement sont hiérarchisés, mais aussi que
certains rôles ne peuvent pas être endossés dans des services différents. Il est clai-
rement spéciﬁé que l’on ne peut pas cumuler les fonctions de responsable dans plu-
sieurs services. Les concepteurs du contrôle d’accès tâchent ainsi d’exprimer une
forme d’exclusion mutuelle.
La vériﬁcation de l’intégrité d’un modèle permet aux concepteurs de s’assurer que
leur modélisation de l’exclusion de rôles entre services est correcte, et qu’une fois en
production, ils pourront effectivement exploiter la relation d’exclusion qu’ils ont déﬁnie.

The implication of the above property is that a role graph can have a “root” role (i.e.,
a role that inherits from every other role) only when no pair of roles in the entire
role hierarchy is in any separation of duty relation.

5.2.5 Simpliﬁcation de modèles

Quand plusieurs concepteurs interviennent lors de la déﬁnition d’un modèle de
contrôle d’accès, on peut aboutir à une théorie logique de taille conséquente. Nous
avons vu que les expressions logiques peuvent concerner des relations communes à un
même concept et interagir entre elles, jusqu’à rendre le modèle non intègre. Cependant,
les formules de la théorie peuvent être seulement redondantes et donc inutiles. Réduire
le nombre de règles de la théorie logique d’un modèle de contrôle d’accès permet de le
simpliﬁer. Ceci facilite la compréhension du modèle et les tâches ultérieures d’adminis-
tration des politiques.

Nous avons montré pour les modèles RBAC3 que certaines déﬁnitions de l’exclu-
sion mutuelles en impliquent d’autre en section 3.4.6, et que le triplet d’autorisation
orienté utilisateurs dynamique est inclus dans le triplet statique. Les procédures de
preuves pour les dépendances permettent de simpliﬁer les théories en éliminant les
dépendances ou les règles redondantes.

Déﬁnition (Redondance dans un modèle de contrôle d’accès). Soit T la théorie logique
d’un modèle de contrôle d’accès. Soit σ ∈ T, si T\{σ} |= σ alors la formule logique σ est dite
redondante. De plus, T\{σ} et T ont les mêmes modèles.

La sémantique logique d’une théorie dont ont été éliminées les règles redondantes
reste inchangée par le procédé d’élimination. C’est-à-dire que l’ensemble des politiques
autorisées, instances valides du modèle, reste le même. L’approche que nous proposons
permet une simpliﬁcation intéressante des propriétés d’intégrité des politiques RBAC3.
Ce résultat a été prouvé manuellement par les auteurs de [Gavrila98].

136

Chapitre 5. Mise en œuvre de la structuration

Les propriétés identiﬁées concernent seulement les modèles à rôles du type RBAC3.
De plus, elles ne prennent pas en compte certaines extensions qui ont depuis été large-
ment adoptées, comme la hiérarchisation des objets. La thèse vise un objectif plus large
de conception de modèles de contrôle d’accès, pour lequel il est proﬁtable de dispo-
ser de résultats similaires à ceux obtenus dans [Gavrila98]. Dans la mesure du possible
nous essayons de dériver de tels résultats automatiquement à l’aide de procédures de
preuve.

Exemple 5.2 Automatisation de la simpliﬁcation de modèle

Les auteurs de [Gavrila98] ont établi un ensemble de propriétés qui doivent être véri-
ﬁées par toute politique RBAC3. Cet ensemble inclut une exclusion mutuelle statique
orientée utilisateur (Static Separation of Duties – SSD – prédicat Exclusion) et la hié-
rarchisation des rôles (prédicat H ´erite). Un extrait de ces propriétés formulées en
logique et traduites dans notre formalisation est donné par le tableau suivant :

Description

σ1

σ2

any two roles assigned for a same user are not in separation of duties
Habilite(User, Role1), Habilite(User, Role2), Exclusion(Role1, Role2) → ⊥
no role is mutually exclusive with itself
Exclusion(Role, Role) → ⊥

σ3 mutual exclusion is symetric

σ4

σ5

σ6

Exclusion(Role1, Role2) → Exclusion(Role2, Role1)
any two roles in ssd do not inherits one another
H ´erite(Role1, Role2), Exclusion(Role1, Role2) → ⊥
there is no role inheriting two roles in ssd
Exclusion(Role1, Role2), H ´erite(Senior, Role1), H ´erite(Senior, Role2) → ⊥
If a role inherits another role and that role is in SSD with a third one,
then the inheriting role is in SSD with the third one.
H ´erite(Senior, Role1), Exclusion(Role1, Role2) → Exclusion(Senior, Role2).

Soit Σ = {σ1, σ2, σ3, σ4, σ5, σ6}, les exécutions des procédures comme le chase per-
mettent de prouver que les propriétés σ4 et σ5 sont redondantes et qu’on peut donc
réduire la taille de la théorie :
– Σ\{σ4} |= σ4, par application de σ3, σ6 et σ2,
– Σ\{σ5} |= σ5, par application de σ3, σ6, σ3, σ6 et σ2
– et même Σ\{σ4, σ5} |= σ4, σ5.
Une trace commentée de la seconde preuve obtenue avec notre prototype LIBDEPEN-
DENCIES est proposée en annexe C.

Section 5.3. Administration des politiques

137

5.3 Administration des politiques

Nous avons fait ﬁgurer dans l’illustration 5.1 des « outils de vériﬁcation et d’ana-
lyse » des politiques et des modèles. Dans la section précédente, nous avons répondu à
des problèmes de vériﬁcation et de simpliﬁcation survenant lors de la conception de mo-
dèles de contrôle d’accès, nous allons désormais nous attacher aux problèmes qui sur-
viennent lors de l’administration des politiques, une fois le modèle conçu. Vériﬁer que
les politiques sont intègres est une fonctionnalité importante d’un système de contrôle
d’accès, qui permet d’éliminer des erreurs d’administration.

5.3.1 Conception des politiques

FIG. 5.2 – Etapes de la conception d’une politique de contrôle d’accès

Nous avons décrit les étapes de la conception d’un modèle de contrôle d’accès, mais
une fois ce modèle déterminé et validé, il reste à déﬁnir la politique. En présence de
hiérarchies multiples, de plusieurs types de contraintes ou encore de concepts inter-
médiaires multiples entre utilisateurs et permissions, l’établissement d’une politique
doit suivre une méthodologie pour être mené à bien. La méthodologie de conception
proposée par [Ferraiolo03b] est illustrée par la ﬁgure 5.2 :

1. la déﬁnition des concepts principaux du modèle, sans hiérarchisation,
2. la réorganisation des concepts en hiérarchie,
3. la déﬁnition des contraintes statiques,
4. la déﬁnition des contraintes dynamiques.

Lors de la conception d’une politique instance d’un modèle de contrôle d’accès, les
administrateurs déﬁnissent des concepts et des relations en extension du modèle. Dans
les quatre principales étapes de la conception, les administrateurs ont besoin d’outils
permettant :

– de manipuler la politique : saisir, modiﬁer et supprimer des données,
– d’interroger la politique déﬁnie jusqu’à présent,
– de vériﬁer que la politique respecte bien les propriétés du modèle.

138

Chapitre 5. Mise en œuvre de la structuration

5.3.2 Primitives d’administration

Dans un premier temps, nous déﬁnissons ce que sont les primitives d’administra-
tion : des opérations sur les politiques qui sont nécessaires pour l’administration du
contrôle d’accès. Des primitives ont été déﬁnies pour les modèles à rôles dans le stan-
dard RBAC [Ferraiolo03b]. Elles déﬁnissent les fonctionnalités – minimales – nécessaires
aux tâches d’administration.

En considérant les noyaux des modèles de contrôle d’accès comme des schémas
relationnels et les politiques comme des instances de ces schémas, les langages de ma-
nipulation de données d’interrogation des systèmes de gestion de bases de données
fournissent certaines de ces primitives.

Déﬁnition (Primitive d’administration). Une primitive d’administration est toute opéra-
tion sur une polique instance d’un modèle de contrôle d’accès qui permet soit :

– la modiﬁcation de la politique en extension, c’est une primitive de manipulation.
– l’interrogation de la politique en intention, c’est une primitive de revue.

5.3.2.1 Manipulation de politiques

Cette première catégorie de primitives recouvre celles offertes par les langages de
manipulation de données dans les systèmes de gestion de base de données. C’est grâce
à ces fonctions que les administrateurs peuvent manipuler la politique en extension I.

Déﬁnition (Primitive de manipulation). Une opération (ou primitive) administrative
sur une politique de contrôle d’accès est une opération permettant l’ajout, la modiﬁcation ou la
suppression de tuples dans une instance d’un modèle de contrôle d’accès.

Dans le cadre que nous proposons, les opérations administratives recouvrent les
opérations insert (ajout), update (modiﬁcation) et delete (suppression) classiques des
systèmes de gestion de bases de données. Elles permettent de manipuler I.

Ces opérations permettent de manipuler uniquement I et pas la partie déduite I′\I.
Les dépendances du non-court-circuit proposées en section 4.1.3, permettent d’interdire
explicitement des manipulations de I′\I qui ajouteraient des droits. Ces dépendances
contribuent à garantir le principe d’administration des modèles structurés.

Déﬁnition (Principe d’administration des modèles structurés). Les administrateurs ne
peuvent déﬁnir que des relations en extension du schéma edb d’un modèle de contrôle d’accès
AC. Il ne peuvent pas manipuler l’ensemble en intention I′\I.

Section 5.3. Administration des politiques

139

5.3.2.2 Revue de politiques

Une des fonctionnalités attendues d’un système de gestion de politiques de contrôle
d’accès est de permettre l’interrogation des politiques. Cette fonctionnalité est appelée
la revue de politique. Il s’agit d’une des primitives fonctionnelles déﬁnies dans les stan-
dards d’implantation des modèles RBAC. Dans le cadre proposé, nous déﬁnissons la
notion de revue en étendant celle de [Barker03] :

Déﬁnition (Revue d’une relation de politique de contrôle d’accès). Une revue d’une rela-
tion R de politique de contrôle d’accès est l’évaluation d’une requête conjonctive, éventuellement
récursive, sur I′ faisant intervenir la relation R dans son corps ψ :

{e1, . . . , en | ψ}

Pour l’évaluation des requêtes récursives, nous pouvons utiliser les algorithmes
proposés pour l’évaluation des programmes DATALOG [Abiteboul95]. La formulation
proposée permet de déﬁnir sans ambiguïté la notion de revue. Par exemple, quand
d’aucuns traitent de revue des affectations de rôles aux utilisateurs dans les modèles
RBAC, nous déﬁnissons qu’ils entendent l’ensemble des requêtes exprimables sur la
relation Habilite.

De plus, nous déﬁnissons la revue de façon générique, sans avoir à spéciﬁer concept
par concept et relation par relation l’ensemble des opérations déﬁnies sur le modèle,
comme cela a été fait dans le standard RBAC [Ferraiolo03b, Ferraiolo01]. En effet, si
l’approche exhaustive du standard est applicable sur le modèle RBAC3 qui comporte
cinq concepts, cinq relations principales, une relation de domination et deux relations
d’exclusion, elle l’est déjà moins sur des modèles comme ORBAC.

5.3.3 Intégrité des politiques

Des primitives nécessaires à la conduite des activités d’administration ont été dé-
ﬁnies pour les modèles RBAC. Nous proposons maintenant de vériﬁer que les opéra-
tions effectuées par les administrateurs ne violent pas les propriétés que les politiques
doivent respecter. Ces propriétés sont déﬁnies dans le modèle de contrôle d’accès par
Σ. Nous déﬁnissons la condition à laquelle une politique est intègre vis-à-vis de ces
propriétés.

Déﬁnition (Politique intègre de contrôle d’accès). Soit I une politique instance du schéma
edb d’un modèle de contrôle d’accès AC. Soit P un ensemble de règles déﬁnissant les relations
en intention idb, I′ le plus petit modèle de P contenant I et Σ un ensemble de propriétés du
modèle de contrôle d’accès. La politique de contrôle d’accès I est intègre si et seulement si I′ est
un modèle de Σ.

140

Chapitre 5. Mise en œuvre de la structuration

La déﬁnition de l’intégrité d’une politique que nous proposons se base sur la notion
de modèle de la théorie du premier ordre qui déﬁnit un modèle de contrôle d’accès et
la satisfaction de l’ensemble de dépendances Σ par ce modèle I′ |= Σ.

Dans le chapitre 3, nous avons donné le schéma edb du modèle RBAC0 avec la ﬁ-
gure 3.1 ainsi qu’une politique jouet I déﬁnie sur ce schéma avec le tableau 3.1. Nous
avons également donné les règles de déductions P des triplets d’autorisations avec le
tableau 3.2 ainsi que l’ensemble des dépendances Σ que les politiques doivent respecter
avec le tableau 3.9.

Nous disposons ainsi d’une formalisation relativement complète du modèle RBAC0.
On peut calculer I′ connaissant P et I. On peut utiliser pour cela un algorithme de calcul
du point ﬁxe d’un programme DATALOG. Ensuite, on peut mettre en œuvre le chase
pour vériﬁer que I′ |= Σ.

On peut, comme cela est fait dans les programmes PROLOG, construire un ensemble
de dépendances Γ où l’hypothèse de chaque dépendance est une tautologie et la conlu-
sion un tuple de I′. Ensuite, pour chaque σ ∈ Σ, on lance le chase pour vériﬁer que
Γ |= σ. L’étape de construction de I′ et le chase peuvent être combinés dans une seule
et même procédure de vériﬁcation de la satisfaction. C’est l’exploitation des fonction-
nalités logicielles communes entre les différentes procédures proposées sur le modèle
relationnel qui nous a conduit à implémenter la LIBDEPENDENCIES que nous décrivons
en section 6.2.

Selon la dépendance non satisfaite, les administrateurs devront corriger la politique,
ou éventuellement demander aux concepteurs du modèle de revoir leurs déﬁnitions
des propriétés ou des principes. Selon le type de dépendance non satisfaite, on peut
apporter différentes corrections.

5.3.4 Correction des politiques

Le tableau 5.3 propose un ensemble de corrections types, réalisables grâce aux pri-
mitives de manipulation, selon le type de propriétés du modèle de contrôle d’accès que
la politique ne respecte pas. Selon le type de propriété, différentes classes de dépen-
dances peuvent être utilisées pour la représenter. La sémantique des dépendances gé-
nératrices de tuples impose la présence de tuples, alors que les autres limitent les valeurs
possibles. L’intégrité d’une politique peut donc être divisée en deux sous-propriétés
selon qu’on s’intéresse à la satisfaction des dépendances génératrices [Graham86] :

– de tuples, c’est la complétude1 d’une politique,
– de nullité ou de contraintes, c’est la consistance2 d’une politique.
Pour réparer une politique incomplète ou inconsistante, les administrateurs doivent
analyser la source de non intégrité. Pour cela, ils doivent suivre les étapes de l’algo-

1Le nom complétude ne désigne pas ici l’abscence de propositions indécidables.
2Le nom consistance ne désigne pas ici l’ascence de propositions contradictoires.

Section 5.3. Administration des politiques

141

rithme qui a déterminé que la politique n’est pas intègre, puis modiﬁer la politique en
conséquence. Ce travail d’analyse et de débogage peut être compliqué par la présence
de réécritures des formules de la théorie et l’absence de trace de l’exécution.

En utilisant des algorithmes qui manipulent les dépendances sans les modiﬁer,
chaque étape de l’inférence possède une signiﬁcation exprimable en termes de concepts
et de relations du modèle de contrôle d’accès. Chaque nouvelle dérivation dans l’infé-
rence correspond à l’application d’une formule de la théorie du modèle de contrôle
d’accès. Les procédures dédiées aux dépendances ne les transforment pas. On évite
ainsi des transformations techniques de la théorie par les algorithmes d’inférence :

– l’introduction de fonctions de Skolem lors de la suppression des quantiﬁcateurs

existentiels, qui introduisent des symboles arbitraires supplémentaires,

– la décomposition des dépendances à têtes multiples en clauses de Horn, qui ne
comportent qu’un seul atome en conclusion. Des sous-formules techniques ne
sont pas introduites et le nombre de formules de la théorie n’est pas augmenté,

– la production de formules intermédiaires dans l’inférence, comme les résolvantes

avec la SLD-Resolution (Selective Linear Deﬁnite clause resolution) de PROLOG.

Deux grandes classes de vériﬁcation de l’intégrité sont envisagées, selon l’impact

en termes de coût de calcul lors de l’exécution du moniteur de contrôle d’accès :

– la vériﬁcation statique des politiques, qui concerne la partie de la politique inva-
riante par exécution du moniteur. Cette vériﬁcation est à effectuer avant la valida-
tion d’une opération administrative,

– la vériﬁcation dynamique des politiques, qui concerne la partie de la politique va-
riante lors de l’exécution du moniteur. Cette vériﬁcation est à effectuer avant la
validation d’une opération sur la politique demandée à l’initiative d’un acteur
autre qu’un administrateur.

propriété

limitation

contraintes

Dépendance
antisymétrie
irréﬂexivité
hiérarchie en arbre
hiérarchie en arbre inverse
hiérarchie en treillis
prérequis
Suppression d’affectations
exclusion
hiérarchie/exclusion
Suppression d’affectations
spécialisation de hiérarchie CTGD Suppression d’affectations

Type Correction possible
Suppression de cycles
EGD
Suppression d’une arête
NGD
Suppression de pères
EGD
Suppression de ﬁls
EGD
TTGD Ajout de relations
CTGD Ajout du prérequis
NGD
NGD

TAB. 5.3 – Corrections possibles d’une politique non intègre

142

Chapitre 5. Mise en œuvre de la structuration

5.3.5 Comparaison statique de politiques

Dans le chapitre 4, nous avons montré que les modèles de contrôle d’accès partagent
de nombreux traits communs. Une des caractéristiques partagées est que les modèles
doivent permettre de dériver les triplets d’autorisation Acc `es, Statique et Dynamique.

Dans le cas général, le caractère variable des triplets dynamiques interdit de pou-
voir raisonnablement envisager l’exécution d’algorithmes coûteux lors de l’exécution
du moniteur. Cette évaluation est en revanche tout à fait réalisable pour des modèles de
contrôle d’accès au périmètre limité. Les principaux goulots d’étranglement que nous
avons constatés expérimentalement sont le nombre de contraintes arithmétiques et les
interactions entre hiérarchies multiples.

Ainsi, hormis pour les modèles basés sur l’identité dans lesquels sujets et utilisa-
teurs sont confondus, dans le cas général on va principalement comparer des politiques
du point de vue statique, c’est-à-dire comparer des triplets Statique obtenus avec diffé-
rentes politiques, voire différents modèles.

Déﬁnition (Comparaison statique de politiques). Soient deux politiques de contrôle d’accès
I1 et I2 intègres, exprimées respectivement sur les modèles de contrôle d’accès AC1 et AC2.
Soient Statique1 les autorisations statiques de la première politique et Statique2 celles de la
deuxième. Statique1 ∈ I′

1 ⊇ I1 et Statique2 ∈ I′

2 ⊇ I2.

La politique de contrôle d’accès I1 est dite plus restrictive que I2 si et seulement si :

Statique1 ⊆ Statique2

La politique de contrôle d’accès I1 est dite plus permissive que I2 si et seulement si :

Statique1 ⊇ Statique2

Les politiques de contrôle d’accès I1 et I2 sont dites équivalentes si et seulement si :

Statique1 ⊆ Statique2 et Statique1 ⊇ Statique2

Lors de l’évolution des modèles de contrôle d’accès – lorsque de nouveaux concepts
intermédiaires sont ajoutés par exemple – la comparaison permet de s’assurer que les
droits qui existaient avant modiﬁcation du noyaux sont bien les mêmes que ceux après
évolution. Pour la réalisation de la comparaison de politique, on peut s’appuyer sur la
comparaison de l’évaluation d’une requête de sélection sur Statique1 et Statique2.

La section 5.5 propose une méthode permettant l’identiﬁcation de nouveaux
concepts intermédiaires hiérarchisés, implicitement présents dans des relations exis-
tantes qui garantit que la politique obtenue après l’introduction du nouveau concept est
statiquement équivalente à l’ancienne. Le cas de l’introduction d’une nouvelle relation
intermédiaire hiérarchisée dans un modèle de contrôle d’accès nécessite de manipuler
le schéma du modèle de contrôle d’accès et de modiﬁer la théorie associée. Nous avons
déﬁni les primitives qui permettent cette manipulation.

Section 5.4. Représentation graphique de modèles

143

Si la manipulation d’un schéma est une opération relativement simple pour un non-
logicien, la déﬁnition d’une théorie logique ne l’est pas. La section suivante propose une
représentation graphique des théories logiques qui permet aux concepteurs de modèles
et aux administrateurs de visualiser schémas, principes et propriétés des modèles de
contrôle d’accès.

5.4 Représentation graphique de modèles

Le processus de conception de modèle est complexe, à la croisée de plusieurs dis-
ciplines comme l’ingénierie, la qualité, la conception logicielle et la représentation des
connaissances. Pour concevoir un modèle de contrôle d’accès efﬁcace, il est nécessaire
de formaliser certains aspects des organisations.

Aﬁn de pouvoir mener à bien la conception de modèles sur mesure comme celui du
GMSIH, il est nécessaire de proposer une représentation des modèles, qui permette une
visualisation et une manipulation graphique de la théorie logique P ∪ Σ.

Les auteurs de [Ferraiolo03a] ont proposé un Role Control Center spéciﬁque pour
l’administration de politiques de contrôle d’accès à rôles. Cette approche ad hoc ne pro-
pose pas d’outils pour la vériﬁcation des modèles et des politiques. Contrairement à
cette proposition, nous proposons une représentation de modèles de contrôle d’accès
générique ainsi que des outils pour inférer graphiquement. Nous pensons qu’une in-
terface de conception de modèle doit :

– avoir une interface graphique appropriée,
– être capable d’exprimer une grande variété de concepts, relations, principes et

propriétés des modèles de contrôle d’accès,

– disposer de mécanismes permettant de suivre graphiquement les raisonnements

automatisés effectués sur les politiques,

Nous avons presenté, en section 2.6.3 de l’état de l’art, les principales propositions
de modélisation graphiques génériques du contrôle d’accès. Nous allons dans cette sec-
tion présenter une représentation visuelle des modèles de contrôle d’accès en corres-
pondance directe avec le cadre logique que nous avons utilisé. Nous allons pour cela
nous appuyer sur les graphes conceptuels.

5.4.1 Graphes conceptuels

Les graphes conceptuels sont un modèle de représentation et d’inférence graphique.
Ils ont été introduits au début des années 80 par John Sowa pour la représentation des
connaissances [Sowa84]. Depuis, ils ont été considérablement développés et enrichis. Il
s’agit d’un modèle formellement bien fondé doté d’une sémantique logique [Chein92].
La ﬁgure 5.3 est un exemple de graphe conceptuel. Formellement, les graphes concep-
tuels sont déﬁnis comme des graphes bipartis non orientés :

144

Chapitre 5. Mise en œuvre de la structuration

– deux types de sommets existent : les concepts (rectangles) et les relations (ellipses),
– deux concepts ou deux relations ne peuvent pas être relié(e)s directement,
– un vocabulaire des types de concepts et de relations forme le support. Types de

concepts et de relations sont organisés en treillis,

– à chaque sommet du graphe sont associés un type de concept ou de relation ainsi

qu’un marqueur qui est soit :
– le marqueur générique ∗ permet d’exprimer que le sommet est d’un type, mais

sans l’identiﬁer spéciﬁquement,

– un marqueur individuel qui permet d’identiﬁer le sommet.

De plus, on peut déﬁnir dans le cadre des graphes conceptuels des règles de graphes
avec le connecteur →. Les règles de graphes permettent de dériver de nouvelles
connaissances à partir de celles connues. Une règle est composée de deux graphes :
un qui forme l’hypothèse et l’autre la conclusion de la règle. Si plusieurs marqueurs
génériques sont déﬁnis dans une règle, on les différencie par un identiﬁant apposé au
marqueur générique, comme ∗a ou ∗b. Les ﬁgures 5.4 et 5.5 sont des règles de graphes
conceptuels.

Nous ne détaillerons pas plus le cadre théorique des graphes conceptuels. Nous
laisserons de côté la formalisation issue de la théorie des graphes, car nous mettrons
principalement à proﬁt les liens entre règles de graphes conceptuels et logique.

5.4.2 Correspondance avec les dépendances

Les graphes conceptuels sont en correspondance directe avec un fragment de la
logique du premier ordre. Les opérations classiques de la logique trouvent leurs équi-
valents en graphes conceptuels [Coulondre98, Wermelinger95]. La notion centrale
d’uniﬁcation logique correspond à la notion d’isomorphisme de graphes. Les règles de
graphes sont de même à mettre en correspondance avec des formules de la logique du
premier ordre ne comportant qu’un seul symbole d’implication.

5.4.2.1 Fragment de la logique

Le fragment considéré est en fait celui des dépendances génératrices de tuples sans
contraintes. Ceci a permis d’exploiter certains résultats développés pour les graphes
aux dépendances de données, notamment la notion de pièce de graphe. Une procédure
de preuve en marche arrière pour les dépendances génératrices de tuples a été déve-
loppée ainsi [Coulondre03]. Nous allons mettre à proﬁt la correspondance entre dépen-
dances et graphes pour la représentation des principes et des propriétés des modèles
de contrôle d’accès.

Nous sommes cependant limités au fragment logique des dépendances génératrices
de tuples sans contraintes. Cette classe de dépendances permet cependant d’exprimer
les principes et les propriétés des modèles RBAC. La principale limitation pour disposer

Section 5.4. Représentation graphique de modèles

145

logique du premier ordre

Φ

←− graphes conceptuels
Φ−1
−→

relation unaire
relation n-naire
symbole de prédicat
symbole de constante
variable
faits (sans variable)
base de données
procédure de preuve
dépendance

type de concept
type de relation
type de concept ou de relation
marqueur individuel
marqueur générique ∗
graphe faits (sans générique)
base de connaissance
chaînage
règle de graphes

TAB. 5.4 – Applications de correspondance Φ et Φ−1

d’un cadre graphique plus expressif qui comprendrait en son sein les graphes concep-
tuels est l’impossibilité d’exprimer des contraintes arithmétiques dans les graphes. Mal-
gré la restriction au fragment des dépendances génératrices de tuples, les graphes dis-
posent d’un pouvoir sufﬁsant pour représenter les notions du chapitre précédent, à
l’exception des aspects contextuels et des prérequis. Nos arguments en faveur de l’uti-
lisation des graphes conceptuels sont :

– les graphes conceptuels sont munis d’une sémantique logique. Une fonction
Φ permettant de passer des graphes conceptuels et des règles de graphes à
leurs pendants logiques. Sa réciproque Φ−1 étant déﬁnie également [Chein92,
Wermelinger95]. Le tableau 5.4 illustre ces applications,

– le marqueur générique est équivalent aux quantiﬁcateurs existentiels et univer-
sels, selon sa présence en hypothèse ou conclusion des règles de graphes. Ce
marqueur permet de représenter les principes et les propriétés des modèles,

– les graphes ont un pouvoir d’expression supérieur aux règles DATALOG,
– les mécanismes d’inférence dédiés, le chaînage de graphes, permettent une re-
présentation des raisonnements fondés sur des opérations graphiques élémen-
taires [Chein92, Salvat96].

Nous découvrons que le choix fait a priori du terme de concept et de celui de relation
n’était pas anodin. En effet, la signiﬁcation que nous leur avons donnée – c’est-à-dire
respectivement des relations unaires et n-aires – est celle des graphes conceptuels. Nous
avons fait ce choix, car il conforte l’intuition qu’un grand nombre de connaissances,
dont les modèles de contrôle d’accès font partie, peuvent être exprimées en termes de
concepts et de relations. La possibilité de représentation est un des postulats fondamen-
taux des graphes conceptuels [Sowa84].

146

Chapitre 5. Mise en œuvre de la structuration

(a) Hiérarchie de rôles

(b) Affectations

FIG. 5.3 – Représentation de faits avec les graphes conceptuels

5.4.2.2 Support des graphes conceptuels

Le support des graphes conceptuels permet de modéliser des relations d’héritage
entre types de concepts. Nous avons choisi de ne pas utiliser cette fonctionnalité pour
représenter les concepts hiérarchisés des modèles de contrôle d’accès, déﬁnis en sec-
tion 4.3.4. Deux arguments nous ont conduits à effectuer ce choix :

– d’une part on évite le risque une explosion combinatoire du nombre de concepts
à cause de la structure de treillis et à cause des affectations multiples possibles de
rôles aux utilisateurs. En modélisant les rôles d’un modèle RBAC avec le treillis de
concept, pour chaque affectation multiple de rôles à un utilisateur donné, comme
d’utilisateurs multiples à un même rôle, il faut créer un sous-rôle dans le support,
– d’autre part, modéliser la hiérarchisation d’un concept avec le treillis de concepts
rompt les liens exploités avec l’application de correspondance Φ. En effet, si
chaque rôle devient un type, il serait alors un symbole de prédicat dans l’équi-
valent logique du graphe. Cette approche interdit de quantiﬁer des variables re-
présentant des rôles. C’est une critique que nous avons formulée à l’encontre de
la modélisation de [Halpern03].

En revanche, le support des graphes conceptuels permet de pour sous-typer les
concepts et les relations d’un modèle de contrôle d’accès. En section 3.4.6 nous avons
montré que la notion d’exclusion mutuelle peut être sous-typée selon les restrictions
qu’elle impose. De même, en section 4.5.5, nous avons proposé de rafﬁner la notion de
domination de rôles avec des contraintes supplémentaires.

Les treillis de concepts ou de relations permettent ainsi d’exprimer des dépendances
entre des aspects des modèles de contrôle d’accès. On peut grâce à eux, exprimer des
règles de la forme R1(X1) → R2(X2) qui expriment qu’une relation R1 « est une »
relation R2. Cette approche a été proposée dans [Bertino03] pour organiser entre eux
des concepts et relations d’un modèle de contrôle d’accès.

Section 5.4. Représentation graphique de modèles

147

Exemple 5.3 Professionnels de santé et patients

Un nouveau projet du CHM a pour but de réorganiser les droits d’une application de
gestion de dossiers patients. Depuis la loi du 30 mars 2001, il doit être permis aux
patients d’accéder à leurs dossiers. Le projet a pour but de rendre cet accès possible.
Dans le modèle de contrôle d’accès, on déﬁnit ainsi deux sous-catégories du concept
d’utilisateur : les professionnels de santé et les patients.
Ce sous-typage du concept d’utilisateur (symbole de prédicat User) est représentable
par deux dépendances qui ont leur correspondance dans le treillis des concepts des
graphes conceptuels :
– Patient(U) → User(U)
– Pro f essionnel(U) → User(U)

5.4.3 Représentation graphique de dépendances

(a) Réﬂexivité

(b) Fermeture

(c) Transitivité

FIG. 5.4 – Hiérarchisation de rôles avec les graphes

Les fragments de la logique du premier ordre des différentes classes de dépen-
dances de données sont au centre de notre formalisation du contrôle d’accès. Les pro-
cédures de preuve de l’implication constituent quant à elles le cœur des mécanismes
de vériﬁcation que nous proposons. Représenter graphiquement ces deux composants
théoriques est un premier pas vers la conception d’un atelier logiciel pour la conception
et l’administration de politiques. Disposer d’une représentation graphique associée au
cadre logique que nous utilisons améliore l’utilisabilité de notre proposition.

148

Chapitre 5. Mise en œuvre de la structuration

Comme dans le chapitre 3 et le chapitre 4, nous avons à plusieurs reprises illustré
notre proposition avec son application aux modèles RBAC. Nous allons reprendre ces
éléments de modélisation avec les graphes conceptuels. Nous allons faire correspondre
aux dépendances que nous avons construites des règles de graphes conceptuels. No-
tons que pour le cas des dépendances génératrices de nullité, il faut faire correspondre
à l’antilogie ⊥ un type de concept spéciﬁque.

Hiérarchisation de concepts En section 4.3.4 nous avions proposé une généralisation
de la notion de hiérarchie des concepts. La ﬁgure 5.4 illustre l’utilisation des
graphes conceptuels pour représenter graphiquement les règles qui permettent
de déﬁnir qu’une relation d’héritage soit la fermeture transitive et réﬂexive d’une
relation de domination directe. Ils sont en relation, par l’intermédiaire de la fonc-
tion Φ, avec les dépendances suivantes :
– ﬁgure 5.4 (a) : Role(X) → Role(X), H ´erite(X, X),
– ﬁgure 5.4 (b) : Domine(X, Y) → H ´erite(X, Y),
– ﬁgure 5.4 (c) : Domine(X, Z), H ´erite(Z, Y) → H ´erite(X, Y).

Principe fondamental La core-rule des modèles RBAC déﬁnit comment dériver les au-
torisations statiques des utilisateurs. Ce principe fondamental peut être exprimé
par la règle de graphes de la ﬁgure 5.5 ou l’expression logique associée :

∀U, Ru, Rp, A, O User(U), Role(Ru), Role(Rp), Action(A), Objet(O)
Habilite(U, Ru), H ´erite(Ru, Rp), A f f ecte(Rp, A, O) → Statique(U, A, O)

FIG. 5.5 – Core-rule des modèles RBAC

Section 5.4. Représentation graphique de modèles

149

Représentation des politiques Les graphes conceptuels sont des outils de représenta-
tion et de manipulation de connaissance. L’ensemble des faits connus dans la base
est représenté par des graphes simples, qui ne comportent pas de marqueur gé-
nérique. Grâce aux règles de graphes, de nouvelles connaissances, c’est-à-dire de
nouveaux graphes, peuvent être déduites. La ﬁgure 5.3 présente des graphes de
faits, c’est-à-dire la représentation visuelle d’une politique I. Deux sous graphes
sont présentés, le premier est un extrait de hiérarchie de rôle (a), le second est un
exemple d’affectation de rôles à des utilisateurs et de permissions à ces rôles.

5.4.4 Raisonnement avec les graphes

Les procédures de preuves dédiées aux graphes, les chaînages, sont déﬁnies en
termes d’opérations élémentaires sur les graphes comme la fusion et la scission de som-
mets. On peut donc visualiser les différentes étapes effectuées par les algorithmes de
chaînage. Ceci facilite l’analyse des étapes des raisonnements effectués sur les graphes
conceptuels.

Supposons que l’on souhaite vériﬁer s’il existe un utilisateur disposant du droit
d’ex´ecution et de celui d’´ecriture sur les examens dans une politique. Ce raisonne-
ment fait intervenir les règles de graphes ainsi que la politique jouet précédemment
présentée. Nous allons utiliser une preuve en marche arrière qui répond positivement
à cette vériﬁcation. Ce chaînage tâche d’identiﬁer successivement des isomorphismes
de graphes entre les hypothèses des règles et la base de connaissance.

Le processus qui conduit à prouver qu’effectivement, il existe bien un utilisateur qui
dispose de deux droits est décomposable en dix étapes. À chaque étape, une seule règle
de graphe est appliquée. Les sous-buts successifs que la procédure essaie de prouver
sont entourés en pointillés dans les ﬁgures 5.6 et 5.7. Les étapes sont les suivantes :

1. pour prouver qu’un utilisateur dispose des droits d’ex´ecution et d’´ecriture, il

faut chercher des rôles qui disposent de ces permissions (étapes 1 à 3),

2. le rôle de soignant dispose d’une de ces permissions (étapes 3 à 4),
3. le rôle de m´edical dispose également de ces permissions (étapes 3 à 4),
4. les rôles héritent des permissions de leurs parents. Le rôle Infirmier hérite à la

fois de soignant et de m´edical, (étapes 4 à 8),

5. Alice et Bob disposent de ce rôle (étapes 8 à 10).

150

Chapitre 5. Mise en œuvre de la structuration

FIG. 5.6 – Procédure de preuve en marche arrière sur les graphes (1/2)

Section 5.4. Représentation graphique de modèles

151

FIG. 5.7 – Procédure de preuve en marche arrière sur les graphes (2/2)

152

Chapitre 5. Mise en œuvre de la structuration

Ainsi, il existe bien au moins un utilisateur, en l’occurrence identiﬁé par le marqueur
individuel Alice ou Bob, qui dispose des deux droits. Techniquement, la procédure à
réussi à dériver le but vide et les étapes de l’inférence forment une trace linéaire. La
linéarité de la trace est un argument en faveur de l’utilisation du chaînage par des
utilisateurs qui ne sont pas spécialistes de la logique.

Une des rencontres principales sur les graphes conceptuels est l’International Confe-
rence on Conceptual Structures (ICCS). C’est en participant à cette rencontre que nous
avons découvert le cadre de l’analyse de concepts formels, qui nous a permis de dé-
velopper une méthode de découverte de concepts hiérarchisés implicitement présents
dans les politiques de contrôle d’accès.

5.5 Ingénierie de rôles hiérarchisés

Quand les organisations évoluent, les politiques de contrôle d’accès doivent reﬂé-
ter les changements qui surviennent. Les évolutions mineures peuvent être prises en
compte en mettant à jour les politiques sans changer les modèles. Cette approche est
acceptable pour les restructurations où les fonctions des salariés changent au sein de
l’organisation. Dans le cas d’évolutions majeures cependant, il faut modiﬁer le modèle
de contrôle d’accès lui-même.

Exemple 5.4 Fusion d’organisations

Supposons, dans le cadre d’un remaniement ministériel majeur, que le CHM jusque-là
autonome soit regroupé avec un ou plusieurs autres établissements de santé pour
former une nouvelle entité régionale. Cette fusion d’organisations impose de complè-
tement réorganiser les systèmes d’information de santé existants pour en créer un
nouveau à l’échelle de la région.
Chaque établissement disposait de son propre modèle de contrôle d’accès. Lors de
la fusion, il va falloir réorganiser les droits, pour disposer d’un modèle de contrôle
d’accès commun et homogène au nouvel établissement issu de la fusion, par exemple
le Centre Hospitaler Commun Drômardèchois (CHCD).
La déﬁnition d’un nouveau modèle global, en adéquation avec la nouvelle organisation
administrative du CHDC, va fortement impacter les politiques déjà existantes. Dans le
modèle de contrôle d’accès commun, on va introduire de nouveaux concepts inter-
médiaires pour représenter la nouvelle structure administrative. On peut légitimement
introduire tout ou partie des concepts et relations des modèles ORBAC ou du GMSIH.

Les tâches d’administrations qui résultent de changements dans la structuration
des droits sont lourdes : reprise des droits existants, vériﬁcation de non-régression ou
vériﬁcation de l’intégrité de la nouvelle politique. Ces activités sont représentées par
les boucles de rétroaction de la ﬁgure 5.2.

Section 5.5. Ingénierie de rôles hiérarchisés

153

Dans les modèles de contrôle d’accès structurés, la hiérarchisation des concepts joue
un rôle prépondérant dans l’administration des politiques : c’est un élément pivot qui
doit reﬂéter la structure de l’organisation qui met en œuvre le contrôle d’accès.

L’introduction de nouveaux concepts intermédiaires hiérarchisés dans un modèle
(ou la hiérarchisation de concepts organisés à plat) est un problème commun aux mo-
dèles de contrôle d’accès hiérarchisés. Il est important de proposer des outils permet-
tant d’assister cette tâche. Dans le cadre des modèles à rôles, cette activité est appelée
l’ingénierie des rôles. Cette section propose une automatisation – partielle – de cette acti-
vité, généralisée au cadre relationnel de contrôle d’accès que nous proposons.

5.5.1 Ingénierie des rôles

Un des arguments principaux en faveur d’une gestion des droits basée sur
des rôles hiérarchisés est que les coûts de l’administration des politiques sont ré-
duits [Crampton03a, Ferraiolo03b]. La hiérarchisation permet en effet de réduire la
taille des politiques I en proposant des affectations implicites déduites à partir des pro-
priétés algébriques de la relation d’héritage entre rôles. Malheureusement, la déﬁnition
de rôles hiérarchisés dans l’organisation des droits est une activité coûteuse en termes :
– de conception de modèle. L’introduction d’un nouveau concept hiérarchisé dans
un modèle existant impose l’identiﬁcation et la déﬁnition de nouveaux principes
et propriétés du modèle,

– de conception de politique, c’est-à-dire le coût de l’identiﬁcation et de déﬁnition

des relations entre les concepts par les administrateurs.

5.5.1.1 Probématique

Le travail d’Edward Coyne est à l’origine du terme ingénierie des rôles [Coyne96]. Sa
proposition centre l’activité d’ingénierie comme la déﬁnition des affectations de per-
missions aux rôles, sous-entendant aussi celles de rôles aux utilisateurs :

The concept of role engineering (RE) is an approach to deﬁning roles and assigning
permissions to the roles. RE must capture the organization’s business rules, as these
relate to access control, . . .

L’ingénierie des rôles est entreprise lors de la conception d’une politique de contrôle
d’accès RBAC. Si l’ingénierie des rôles est une activité essentielle pour que l’établisse-
ment d’une politique RBAC soit fructueux, c’est également l’activité la plus coûteuse et
la plus longue. Un rapport du NIST indique que le coût d’identiﬁcation de chaque rôle
est évalué à environ 5.000 dollars [Gallaher02].

La thèse de Pete Epstein a considérablement étendu Coyne [Epstein02]. L’activité
d’ingénierie des rôles déﬁnie par Epstein peut être résumée par « l’identiﬁcation d’un
ensemble de rôles qui soit complet, correct et efﬁcace ».

154

Chapitre 5. Mise en œuvre de la structuration

FIG. 5.8 – Approches d’ingénierie des rôles [Epstein02]

Pour ses besoins méthodologiques, Epstein a étendu le modèle RBAC1 en introdui-
sant trois nouveaux concepts intermédiaires entre rôles et permissions : Jobs, WorkPat-
terns et Tasks. Ce nouveau modèle a été baptisé Role Permission Assignment Model 2001
(RPAM1). Ce modèle a permis à Epstein d’identiﬁer et de développer deux principales
stratégies d’identiﬁcation des rôles, illustrées par la ﬁgure 5.8 :

– l’approche descendante est basée sur la décomposition des rôles en concepts in-
termédiaires. Cette approche se base sur la structure de l’organisation, mais pas
sur les privilèges existants. Elle a été appliquée avec succès dans de grandes struc-
tures [Roeckle00], et étendue par des méthodes à base de scénarios et de cas d’uti-
lisation [Neumann02]. Cette approche, basée sur une modélisation rigoureuse des
processus métiers, n’a pas à notre connaissance été automatisée. Elle est adaptée
aux organisations qui déploient un modèle RBAC ex nihilo,

– l’approche ascendante, dite role-mining [Kuhlmann03] est une identiﬁcation des
rôles implicitement présents dans le système. Cette approche est basée sur l’agré-
gation des permissions existantes, sans tenir compte cependant de la structure de
l’organisation. Cette approche se base sur des droits existants.

5.5.1.2 Objectifs

Il est rare qu’une organisation mette en place un modèle de contrôle d’accès RBAC
sans se baser sur des droits existants. Un des objectifs des travaux en ingénierie des
rôles est d’automatiser l’approche ascendante d’identiﬁcation des rôles et de leurs hié-
rarchies. Le but est de faciliter et de réduire la durée et le coût de l’ingénierie des rôles.
La proposition de cette section va dans ce sens en proposant une méthode ascendante
d’identiﬁcation automatisée de rôles.

Nous considérerons les modèles de contrôle d’accès comme des moyens pour struc-
turer des politiques. L’objectif de tout modèle de contrôle d’accès est de permettre la
dérivation du triplet fondamental ACCE SS ⊆ S × A × O. Nous avons également dé-
ﬁni un triplet statique Statique entre utilisateurs, actions et objets. Nous envisageons
ansi l’activité d’ingénierie des rôles comme une activité de rétroconception qui tâche
d’identiﬁer des relations intermédiaires dans une relation Statique existante.

Section 5.5. Ingénierie de rôles hiérarchisés

155

La notion de rôle dans les modèles RBAC diffère de la notion de groupe : un groupe
est essentiellement une collection d’utilisateurs alors que le rôle est à la fois une collec-
tion d’utilisateurs et de permissions [Sandhu96]. C’est donc un concept qui peut être
déﬁni soit par son intention – les permissions dont dispose le rôle – soit par son ex-
tension – les utilisateurs qui l’endossent. Cette déﬁnition nous sert de base pour notre
démarche. Nous allons assimiler la notion de rôle dans les modèles RBAC à celle de
concept formel de l’analyse de concepts formels (Formal Concept Analysis – FCA).

5.5.1.3 Méthode

Nous mettons en correspondance la formalisation des modèles de contrôle d’ac-
cès RBAC et celle de l’analyse de concepts formels. Basés sur la correspondance entre
rôle et concept formel, nous développons le parallèle entre ces deux domaines jusqu’à
parvenir à déﬁnir l’ingénierie des rôles en terme d’extraction de concepts formels. Les
concepts formels sont présentés comme des rôles potentiels calculés. La hiérarchie de
rôles obtenue est une base de travail pour les concepteurs de politique. Dans le cas gé-
néral les concepts formels sont des intermédiaires à identiﬁer dans une relation binaire
existante.

Cette section décrit successivement les contextes fomels et les treillis de concepts.
Nous exprimerons ensuite l’ingénierie des rôles en termes de concepts formels que
nous mettons en parallèle avec la décomposition d’une relation binaire entre utilisa-
teurs et permissions. Nous décrivons enﬁn l’algorithme utilisé pour identiﬁer les rôles.
Comme nous l’avons fait en section 5.3.5 et avec les mêmes arguments, nous nous limi-
terons à l’identiﬁcation de concepts hiérarchisés statiques.

5.5.2 Matrice de contrôle d’accès et contexte formel

Le tableau 2.2 est un exemple jouet de matrice de contrôle d’accès, impliquant
quatre sujets (en lignes), quatre objets (en colonnes) et trois actions (r pour read, w pour
write et x pour execute). Pour l’application présentée, on identiﬁe les sujets de cette ma-
trice à des utilisateurs.

5.5.2.1 Restriction à une relation binaire

Tout d’abord, nous décomposons la relation ternaire Statique en deux relations à
l’aide du concept de permission. Le concept de permission P est déﬁni par les paires
d’actions et d’objets utilisées dans la politique de contrôle d’accès. On déﬁnit ainsi une
relation Permet ⊆ U × P qui est une restriction de la relation Statique. En effet, dans les
modèles basés sur RBAC, on n’affecte jamais directement d’action ou d’objet à un rôle,
on affecte des couples d’action et d’objet, c’est-à-dire des permissions.

Statique(U, A, O) ↔ ∃P Perm(P, A, O), Permet(U, P)

156

Chapitre 5. Mise en œuvre de la structuration

Nous déﬁnissons également les deux dépendances fonctionnelles suivantes qui im-
posent l’équivalence entre un identiﬁant de permission et un couple d’action et d’objet :

Perm(P, A, O), Perm(P, A′, O′) → A = A′, O = O′
Perm(P, A, O), Perm(P′, A, O) → P = P′

L’intérêt de cette transformation est de pouvoir ensuite manipuler une matrice boo-
léenne, car de nombreux problèmes de fouille de données ont été caractérisés sur de
telles structures et de nombreux algorithmes sont disponibles. De plus, dans plusieurs
cas d’utilisation on a seulement accès aux identiﬁants de permissions et pas à leur dé-
composition en action et objet.

Le tableau 5.5 présente graphiquement la relation Permet construite à partir de la re-
lation Statique du tableau 2.2. Nous avons pris comme identiﬁant de chaque permission
la concaténation des identiﬁants d’action et d’objet. Ainsi, r1 indique le droit de lecture
sur le ﬁchier Fichier1. Cette relation Permet est interprétée dans notre approche, soit
comme une restriction de la matrice de Lampson, soit comme un contexte formel.

5.5.2.2 Contexte formel

La formalisation de l’analyse de concepts formels part d’un contexte formel

:
une relation binaire entre objets et attributs. L’opération d’analyse consiste, à partir
d’un contexte formel, à identiﬁer une hiérarchie de concepts aux propriétés particu-
lières [Wille97].

Déﬁnition (Contexte formel et application α et ω). Un contexte formel est un triplet
K = (O, A, J) où O est l’ensemble des objets, A l’ensemble des attributs et J ⊆ O × A la
relation d’incidence. La relation d’incidence J induit deux applications α et ω qui relient 2O et
2A.

∀X ∈ 2O, α(X) = {y ∈ A | ∀ x ∈ X, (x, y) ∈ J}
∀Y ∈ 2A, ω(Y) = {x ∈ O | ∀ y ∈ Y, (x, y) ∈ J}

Les applications α et ω déﬁnissent une correspondance de Galois entre 2O et 2A. Les
applications α ◦ ω et ω ◦ α déﬁnissent deux opérateurs de fermeture sur 2O et 2A respectivement.

Pour l’application à la découverte de rôles, les objets de la FCA sont des utilisateurs et
les attributs des permissions. La relation d’incidence indique quels sont les droits dont
les utilisateurs disposent. Nous pouvons ainsi décrire le contexte formel K : ce serait la
matrice des droits d’accès du système, la relation Permet du tableau 5.5.

Les applications α (resp. ω) s’interprètent alors comme l’application qui à un en-
semble d’utilisateurs (resp. de permissions) fait correspondre l’ensemble des permis-
sions (resp. d’utilisateurs) avec lesquelles tous les utilisateurs (resp. permissions) de
l’ensemble sont en relation.

Section 5.5. Ingénierie de rôles hiérarchisés

157

r1 w1 r2 w2 r3 w3 r4 w4 x4

Alice × × ×

Bob ×
Charly ×
Denise

×
× × ×
×

× × ×
× × × × ×
×

×

TAB. 5.5 – Contexte formel jouet

5.5.3 Rôles hiérarchisés et treillis des concepts formels

Les sous-ensembles fermés de O et de A, notés Co et Ca, présentent deux propriétés
fondamentales de la FCA : α et ω sont des bijections entre ces familles, appelées cor-
respondances de Galois. De plus, ces familles munies de l’inclusion ensembliste forment
deux treillis complets isomorphes, appelés treillis de Galois. Pour notre application cela
signiﬁe que grâce à α et ω, on va pouvoir identiﬁer des couples d’utilisateurs et de per-
missions (u, p) qui sont organisés selon un treillis. Avec (u, p) et la déﬁnition que nous
avons donnée de P nous pouvons retrouver le triplet (u, a, o).

La hiérarchie des rôles est une des innovations proposées dans les modèles RBAC.
Elle permet de réduire le nombre de rôles et d’affectations (entre rôles et utilisateurs, ou
entre rôles et permissions) en introduisant une relation binaire d’héritage entre rôles.

La formalisation ensembliste de RBAC est résumée par le tableau 2.5. Les applica-
tions assigned_users et assigned_perms (affectés) ainsi que par auth_users et auth_perms
(autorisés) fondées sur ces ensembles et la relation d’ordre partiel sur les rôles sont don-
nées en section 2.3.2. Nous allons mettre ces applications en correspondance avec celles
de l’analyse de concepts formels.

5.5.3.1 Treillis des concepts formels

Déﬁnition (Concept formel et treillis). Une paire d’ensembles en correspondance c = (X, Y)
tels que Y = α(X) (ou X = ω(Y)) est appelée concept formel.

L’ensemble des concepts C muni de la relation d’ordre partiel ≤C: (X1, Y1) ≤C (X2, Y2) ⇔

X1 ⊆ X2 (ou Y2 ⊆ Y1) forme un treillis de Galois appelé treillis de concepts.

L’analyse de concepts formels déﬁnit les concepts comme des ensembles maximaux
d’objets partageant les mêmes attributs. Chaque concept c = (X, Y) déﬁnit ainsi deux
relations : une première entre objets et concept et une seconde entre concept et attributs.
L’ensemble X des objets d’un concept est appelé extension (complète), l’ensemble Y des
attributs est appelé intention (complète).

Théorème (Théorème fondamental de la FCA). L’ensemble C de tous les concepts qui
peuvent être construits sur un contexte formel K = (O, A, J) donné forme un treillis com-
plet quand il est ordonné par l’inclusion ensembliste.

158

Chapitre 5. Mise en œuvre de la structuration

Analyse de concepts

concept

objet
attribut

Contrôle d’accès

concept intérmédiaire

utilisateur
permission

relation d’ordre partiel

relation d’héritage

extension réduite
intention réduite
extension complète
intention complète
concepts ancêtres

concepts descendants

utilisateurs explicitement affectés
permissions explicitement affectées
utilisateurs implicitement affectés
permissions implicitement affectées

rôles dont hérite un rôle
rôles héritant d’un rôle

TAB. 5.6 – Identiﬁcation des termes de FCA et de RBAC

Appliqué au contrôle d’accès, le treillis3 des concepts déﬁnit deux relations entre
utilisateurs et concepts d’une part, et concepts et permissions d’autre part. Ces deux
relations correspondent respectivement aux relations Habilite et A f f ecte, qui relient
rôles et utilisateurs et rôles et permissions. L’extension d’un rôle est l’ensemble de ses
utilisateurs autorisés, son intention ses permissions autorisées. La relation d’ordre ≤C est
considérée comme un ordre partiel entre les rôles : la relation d’héritage H ´erite.

5.5.3.2 Mise en correspondance des applications

Pour l’application que nous proposons, nous utilisons indifféremment utilisateur
pour objet ou permission pour attribut, selon que l’on s’exprime en termes d’ingénierie des
rôles ou d’analyse de concepts formels. En prolongeant la correspondance, on peut expri-
mer les quatre applications déﬁnies avec la hiérarchie RBAC avec les termes de la FCA.
Pour un rôle r donné :

– assigned_users : R → 2U , fait correspondre au rôle r son l’extension réduite,
– auth_users : R → 2U , fait correspondre à r son extension complète,
– assigned_perms : R → 2P, fait correspondre à r son son intention réduite,
– auth_perms : R → 2P, fait correspondre à r son son intention complète.
Nous arrivons ainsi à la déﬁnition d’un rôle formel : un couple d’utilisateurs et
d’attributs en correspondance par d’une part, l’application AuthUsers et AuthPerms
d’autre part. Le tableau 5.6 résume les principales correspondances que nous déﬁnis-
sons et mettons en œuvre entre RBAC et FCA.

3Un treillis est un ensemble partiellement ordonné tel que chaque couple d’éléments admette une borne

supérieure et une borne inférieure.

Section 5.5. Ingénierie de rôles hiérarchisés

159

5.5.4 Analyse de concepts formels et ingénierie des rôles

L’intérêt des concepts intermédiaires entre utilisateurs et permissions est de per-
mettre le regroupement de privilèges. Le tableau 5.5 présente en grisé le regroupement
des permissions r1, r2 et r3, dont les utilisateurs Alice, Bob et Charly disposent tous
les trois. Ces groupements d’utilisateurs X = {Alice, Bob, Charly} et de permissions
Y = {r1, r2, r3} sont tels que α(X) = Y et α(Y) = X. Le couple (X, Y) est par déﬁnition
un concept formel.

Dans un modèle de contrôle d’accès RBAC, ce regroupement est un rôle, disons
Infirmier, attribué aux trois utilisateurs. C’est ce qu’illustre le tableau 5.7. On voit
donc l’intérêt d’identiﬁer des rôles : si un nouvel inﬁrmier intègre l’organisation, il suf-
ﬁra de lui attribuer le rôle correspondant. Les administrateurs vont ainsi ajouter un seul
tuple à la relation Habilite entre utilisateurs et rôles. Dans la gestion classique basée sur
les identités, on aurait dû déﬁnir explicitement trois tuples dans la relation Statique :
une pour chaque permission attribuée au rôle Infirmier.

5.5.4.1 Déﬁnition de l’ingénierie des rôles

Lors de l’introduction de la notion de rôle dans le contrôle d’accès on doit s’assurer
que les utilisateurs disposent bien de tous les droits qu’ils avaient avant et seulement
ceux-ci. L’objet de l’ingénierie de rôle est donc de décomposer une relation Statique
existante en trois sous-relations.
Déﬁnition (Ingénierie des rôles hiérarchisés). Soit Statique une matrice de contrôle d’accès
statique existante. L’ingénierie de rôles hiérarchisés est l’activité qui consiste à identiﬁer4 :

– un ensemble de rôles R,
– une relation Habilite ⊆ U × R et une relation A f f ecte ⊆ R × A × O
– une relation d’héritage H ´erite ⊆ R × R réﬂexive, transitive et antisymétrique,
– avec Habilite ⋊⋉ H ´erite ⋊⋉ A f f ecte = Statique

Si l’on ne prend pas en compte la hiérarchie, c’est-à-dire si l’on s’intéresse seulement
à trouver Habilite et A f f ecte tels que Habilite ⋊⋉ A f f ecte = Statique, l’ingénierie de
rôles a pour but de représenter la relation Permet du tableau 5.5 sous forme de deux
relations binaires présentées dans le tableau 5.7. Ces deux dernières relations forment
un exemple de résultat que l’on souhaite obtenir automatiquement. Dans cet exemple,
cinq rôles (Infirmier (I), M´edecin (M), Gastrologue (G), P´ediatre (P) et Secr´etaire
(S)) ont été identiﬁés pour structurer les droits du tableau 5.5.

La structure du treillis des concepts est beaucoup trop restrictive pour notre applica-
tion. C’est une restriction importante portant sur la relation HeriteR que l’on cherche à
identiﬁer. La structure de treillis impose que pour chaque couple de rôles (r1, r2), ∈ R2
il existe deux rôles r⊤ et r⊥ tels que r⊤ (cid:23) r1 ∧ r⊤ (cid:23) r2 et r1 (cid:23) r⊥ ∧ r2 (cid:23) r⊥ .

4L’opérateur ⋊⋉ désigne la jointure naturelle de deux relations.

160

Chapitre 5. Mise en œuvre de la structuration

I M G P S

Alice × ×

Bob ×
Charly ×
Denise

×

×

×

Infirmier
M´edecin
Gastrologue
P´ediatre
Secr´etaire

r1 w1 r2 w2 r3 w3 r4 w4 x4
×

×

×

×

×

× × ×
× × × ×

×

×

TAB. 5.7 – Affectations de rôles aux utilisateurs et de permissions aux rôles

5.5.4.2 Sous-hiérarchie de Galois

Avec une structure de treillis, on risque de multiplier les rôles dans la politiques.
Or ces rôles « imposés » par la structure de treillis et n’ont pas nécessairement d’uti-
lisateurs ou de permissions affectés. La sous-hiérarchie de Galois (SHG) a été introduite
par Godin [Godin95] dans le cadre de la restructuration de hiérarchies de classes, pour
réduire le nombre de concepts du treillis des concepts formels. En effet, dans le pire des
cas on peut obtenir jusqu’à 2min(|O|,|A|) concepts formels. Pour l’application au contrôle
d’accès, une hiérarchie d’une telle taille n’est pas concevable.

Déﬁnition (Sous-hiérachie de Galois). Un concept C′ est dit ancêtre (resp. descendant) d’un
concept C ssi C′ <C C (resp C′ >C C). Un objet (resp. un attribut) x est dit être introduit par
un concept si x fait partie de l’extension (resp. de l’intention) de ce concept et qu’aucun ancêtre
(resp. descendant) de ce concept ne contient x dans son extension (resp. intention). C’est le
concept-objet (resp. concept-attribut) de x.

La SHG d’un treillis de Galois (C, ≤C) est le plus petit sous-ordre qui ne contient que les

concepts-objets et les concepts-attributs du treillis de Galois.

Les objets introduits par un concept forment son extension réduite, ses attributs son
intention réduite. La sous-hiérarchie de Galois supprime donc les concepts qui ne sont
ni concepts objets ni concepts attributs. C’est concepts peuvent être supprimés, car ils ne
véhiculent pas d’information. Ils sont seulement imposés par la structure particulière
de treillis. Pour un concept donné, l’extension réduite est l’ensemble des objets qu’il
introduit explicitement, soit pour le contrôle d’accès, ses utilisateurs affectés.

Pour le contrôle d’accès, cette propriété est particulièrement intéressante, car la SHG
va supprimer de (C, ≤C) tous les rôles qui n’ont ni d’utilisateurs ni de permissions
affectés. En d’autres termes, des rôles artiﬁciels que très peu d’administrateurs auraient
volontairement déﬁnis.

Avec la sous-hiérarchie, on ne garde ainsi que les rôles-utilisateurs (auxquels des uti-
lisateurs sont affectés explicitement) et les rôles-permissions (auxquels des permissions
sont affectées explicitement). Le choix de la sous-hiérarchie de Galois par rapport à la
structure du treillis de concept permet d’assurer les critères de correction, complétude
et d’efﬁcacité qui contribuent à former une « bonne hiérarchie » de rôles.

Section 5.5. Ingénierie de rôles hiérarchisés

161

5.5.4.3 Dérivation des autorisations

Nous avons déﬁni qu’un modèle de contrôle d’accès doit permettre de dériver le
triplet Statique qui est toujours un surensemble des permissions actives des utilisateurs
Dynamique. Dans les modèles RBAC, il est interdit d’attribuer directement des permis-
sions aux utilisateurs. En d’autres termes, on ne peut pas manipuler la matrice 2.2 di-
rectement. On doit dériver Statique à partir des relations Habilite, H ´erite et A f f ecte.

On assimile l’application auth_users à une relation qui contient chaque paire (r, u)
telle que u ∈ auth_users(r). La déﬁnition relationnelle de cette relation en intention est
expressible par la règle de déduction

Habilite(U, R), H ´erite(R, R′) → AuthUsers(R′, U)

On peut effectuer le même procédé pour déﬁnir la relation AuthPerms(R, A, O). Ces
règles sont également l’expression de jointures naturelles entre une relation en exten-
sion et la relation en intention H ´erite.

Déﬁnition (Dérivation des autorisations dans les modèles RBAC). Les autorisations des
utilisateurs sont dérivées à partir des affectations et de la hiérarchie de rôles :

Statique(U, A, O) ↔

∃R AuthUsers(R, U) ∧ AuthPerms(R, A, O)

Cette déﬁnition proposée est déduite à partir de [Ferraiolo03b] où elle ne ﬁgure
pas explicitement, du moins formellement. Nous proposons une équivalence entre le tri-
plet Statique et la présence d’un rôle dans la politique RBAC. L’implication de droite
à gauche exprime comment dériver les autorisations. En revanche, l’implication de
gauche à droite signiﬁe que l’affectation à un rôle est obligatoire pour obtenir une per-
mission dans une politique RBAC [Ferraiolo03b].

La question que nous nous posons est « qu’elle est la relation entre la sous-hiéarchie
et le principe de dérivation des autorisations ? ». Nous remarquons que chaque utilisa-
teur ou chaque permission n’apparait que dans un seul concept de la sous-hiérarchie.
L’extraction des concepts-objets et concepts-attributs de la matrice de contrôle d’accès
peut donc s’exprimer comme la recherche d’un ensemble partiellement ordonné tel que
chaque utilisateur ne soit associé qu’à un seul et unique rôle, et chaque permission à un
seul et unique rôle également.

Statique(U, A, O) ↔

!∃R AuthUsers(R, U) ∧ AuthPerms(R, A, O)

Nous allons donc proposer une heuristique pour supprimer cette contrainte d’uni-
cité du rôle qui n’a pas lieu d’être dans une politique RBAC. En effet, les affectations
multiples (de rôles aux utilisateurs comme de permissions aux rôles) sont autorisées.
Cette redondance de l’information répond à des besoins pratiques d’administration du
contrôle d’accès [Crampton03a].

162

Chapitre 5. Mise en œuvre de la structuration

5.5.5 Automatisation de l’ingénierie des rôles

L’analyse des relations binaires pour la recherche des ensembles fermés, dont
font partie les concepts formels, est un domaine de recherche actif, en France no-
tamment [Pasquier99, Nourine02]. Maintenant que nous avons établi le cadre pour
l’ingénierie de rôle basé sur les concepts formels, nous allons pouvoir mettre à proﬁt
les résultats sur l’analyse des relations binaires.

5.5.5.1 Choix d’un algorithme

Les auteurs de [Arévalo07] ont proposé un algorithme PLUTON qui permet de cal-
culer la sous-hiérarchie d’un contexte formel. Cet algorithme fait suite à [Berry05] qui
propose une technique issue des graphes pour calculer une extension linéaire de la
sous-hiérarchie de Galois. PLUTON est composé de trois sous-algorithmes TOMTHUMB,
TOLINEXT et TOGSH :

– l’algorithme TOMTHUMB prend en entrée un contexte formel et retourne une liste
ordonnée des labels5 présents dans la SHG. Cette extension linéaire est un ordre
total compatible avec l’ordre partiel (C, ≤C),

– l’algorithme TOLINEXT prend en entrée la liste résultat de TOMTHUMB et fu-
sionne les paires extension et intention consécutives de cette liste qui appar-
tiennent à un même concept. On obtient ainsi un tri topologogique de (C, ≤C),

– l’algorithme TOGSH calcule la SHG à partir du tri topologogique de TOLINEXT.
Pour notre application, nous avons modiﬁé cet algorithme pour qu’il calcule aussi
les extensions et intentions complètes. Le surcoût engendré par ce calcul est né-
gligeable face à la complexité de TOGSH [Arévalo07].

La complexité en temps théorique de TOMTHUMB est évaluée en O(|J|), l’implé-
mentation brutale de TOLINEXT est décrite dans [Berry05] avec une complexité de
O((|O| + |A|)3), enﬁn la complexité de TOGSH a été évaluée en O((|O| + |A|)2 ∗
max(|O|, |A|)2). D’autres algorithmes ont été proposés pour calculer la sous-hiérarchie
de Galois, cependant PLUTON offre de bonnes performances vis-à-vis de ses concur-
rents [Arévalo07]. La ﬁgure 5.9 (a) est la sous-hiérarchie obtenue par TOGSH à partir
du contexte formel du tableau 5.5.

5.5.5.2 Étapes de la méthode proposée

Nous proposons à l’expert du domaine chargé du chantier de d’ingénierie des rôles
de mettre en œuvre notre approche semi-automatisée pour les assister dans leur tra-
vail. En effet, comme plusieurs hiérarchies de concepts potentielles permettent de cou-
vrir entièrement une relation binaire, le choix ﬁnal et les éventuelles modiﬁcations à

5Les labels sont des identiﬁants de lignes (ou de colonnes) identiques

Section 5.5. Ingénierie de rôles hiérarchisés

163

Description du critère

FCA
cardinalité de l’extension complète
cardinalité de l’extension réduite
cardinalité de l’intention complète
cardinalité de l’intention réduite
surface complète
surface réduite
concepts immédiatement supérieurs
concepts immédiatement inférieurs

RBAC
utilisateurs autorisés
utilisateurs affectés
permissions autorisés
permissions affectées
utilisateurs × permissions autorisés
utilisateurs × permissions affectées
nombre de pères
nombre de ﬁls

TAB. 5.8 – Critères principaux proposés pour le classement des concepts

apporter au contexte formel si besoin, dépendent des besoins des organisations. Notre
approche est décomposable en cinq étapes :

1. obtenir la matrice des droits d’accès du système sous forme de contexte formel,
2. calculer la sous-hiérarchie de Galois associée à l’aide de PLUTON, qui comporte les

concepts potentiels du système.

Ces deux premières étapes forment le corps de l’automatisation. Les trois étapes
suivantes sont itérées à partir du tri topologique de la sous-hiérarchie. L’intérêt est de
proposer le processus d’élagage suivant comme un « calque » sur le tri topologogique
des concepts formels. Cela permet à l’expert de faire varier ce calque en sélectionnant
une mesure de pertinence. Nous pouvons ainsi garder en mémoire le tri topologique
qui comporte toutes les unions et intersections pertinentes préalablement calculées.

3. classer les concepts obtenus selon une mesure de pertinence choisie. Le tableau 5.8

propose huit critères principaux selon lesquels classer les concepts,

4. élaguer la sous-hiérarchie aﬁn de réduire sa taille en vue d’obtenir un diagramme

de Hasse6 représentable en relachant les restrictions de la sous-hiérarchie,

5. proposer cette hiérarchie de concepts à l’expert pour évaluation et analyse et itérer

le processus pour rafﬁner la hiérarchie de rôles par élagages successifs.

La ﬁgure 5.9 (a) est la sous-hiérarchie obtenue à partir de la matrice du tableau 5.5.
La ﬁgure 5.9 (b) est la hiérarchie obtenue après élagage en se limitant à six concepts. Le
tri de pertinence est la taille de l’extension réduite. Le second tri pris en compte pour
des concepts ayant même extension réduite est leur intention réduite.

6Un diagramme de Hasse est une représentation visuelle d’un ordre ﬁni qui en facilite la compréhen-

sion. Hormis les annotations, les illustrations de la ﬁgure 5.9 sont de tels diagrammes.

164

Chapitre 5. Mise en œuvre de la structuration

Z

S

X

P

I

M

users : 0(3)
props : 2(3)
logins : 
rights : r1 r2

users : 1(1)
props : 1(4)
logins : A
rights : w1

G

users : 0(4)
props : 1(1)
logins : 
rights : r3

users : 1(3)
props : 1(2)
logins : D
rights : r4

users : 0(2)
props : 2(6)
logins : 
rights : w4,x4

users : 1(1)
props : 1(4)
logins : A
rights : w1

G

I

S

M

users : 0(3)
props : 3(3)
logins : 
rights : r1,r2,r3

X

P

users : 1(3)
props : 2(2)
logins : D
rights : r3 r4

users : 0(2)
props : 2(6)
logins : 
rights : w4,x4

users : 1(1)
props : 1(7)
logins : B
rights : w2

users : 1(1)
props : 1(7)
logins : C
rights : w3

users : 1(1)
props : 1(7)
logins : B
rights : w2

users : 1(1)
props : 1(7)
logins : C
rights : w3

(a) Sous-hiérarchie de Galois

(b) Hiérarchie élaguée

FIG. 5.9 – Hiérarchies issues du contexte du tableau 5.5

Dans ces deux diagrammes, les six rôles potentiels sont représentés par des losanges
et identiﬁés par les rôles du tableau 5.7. Les rôles identiﬁés par X et Z sont des concepts
qui ne faisaient pas partie des cinq rôles initialement déﬁnis. Une note est également
associée au dessous de chaque rôle potentiel indiquant :

– le nombre d’utilisateurs affectés explicitement et implicitement,
– le nombre de permissions affectées explicitement et implicitement,
– la liste des utilisateurs affectés explicitement,
– la liste des permissions affectées explicitement,

5.5.5.3 Obtention d’une relation binaire

La première étape que nous avons identiﬁée dans la méthode est celle de l’obtention
de la relation binaire à décomposer. Pour des raisons pratiques évidentes, les droits
des utilisateurs ne sont pas directement gérés avec une telle matrice : il faut dériver et
croiser des informations existantes sur les privilèges pour l’obtenir.

Le cas des systèmes qui utilisent des politiques sous forme de listes, comme les
Access Control Lists ou les Capability Lists est facile à traiter : chaque liste représente
soit une colonne soit une ligne de la matrice des droits. Cependant, il peut exister des
dépendances implicites entre les permissions du système. Par exemple, il existe des rela-
tions implicites dans certains systèmes de gestion de bases de données Oracle. Donner

Section 5.5. Ingénierie de rôles hiérarchisés

165

Entrée : L : un tri topologique de la SHG
Sortie : G′ = (V′, E′) : la SHG élaguée
begin

{initialisation}
soit M de taille |O| × |A| : une matrice d’élagage
for c = (Oc, Ac) ∈ L do

for o ∈ Oc do

for a ∈ Ac do

M[o, a] ← M[o, a] + 1

{boucle principale}
for c = (Oc, Ac) ∈ L du moins au plus pertinent do

for o ∈ Oc do

for a ∈ Ac do

if M[o, a] > 1 (si c est supprimable) then

M[o, a] ← M[o, a] − 1
L ← L − c

end
{tous les concepts supprimables de L ont été supprimés}
utiliser TOGSH sur L pour reconstruire le graphe G′ = (V′, E′)

FIG. 5.10 – Élagage de la SHG à partir d’une liste ordonnée

le droit de création de table à un utilisateur lui attribue implicitement les autres droits
de manipulation de données sur cette table. L’obtention d’une matrice nécessite donc une
étape de traitement préalable dans le cas général.

5.5.5.4 Classement des concepts

Le nombre de concepts de la sous-hiérarchie peut être bien supérieur au nombre
d’utilisateurs du système. Il faut donc réduire ce nombre en supprimant les concepts
les moins pertinents comme rôles potentiels. Selon les organisations, l’expert peut pri-
vilégier de minimiser le nombre de rôles dans la hiérarchie, le nombre d’affectations de
permissions aux rôles ou encore le nombre d’affectations de rôles aux utilisateurs.

Le tableau 5.8 présente huit critères utilisables pour classer les concepts selon leur
pertinence. La notion de surface d’un concept, c’est-à-dire le nombre de croix qu’il
couvre dans le contexte formel, est un indicateur pertinent. Une telle mesure est compo-
sée : c’est le produit de l’extension complète par l’intention complète. D’autres mesures
peuvent être composées à partir de la liste de critères du tableau 5.8.

166

Chapitre 5. Mise en œuvre de la structuration

5.5.5.5 Élagage de la sous-hiérarchie de Galois

Une fois les concepts ordonnés, nous supprimons du tri topologogique de la sous-
hiérarchie les concepts considérés comme les moins pertinents. Comme nous voulons
que notre approche soit correcte, il faut que la hiérarchie élaguée comporte toute l’in-
formation contenue dans le contexte formel d’origine. Le processus d’élagage va donc
introduire des affectations multiples dans la hiérarchie aﬁn de réduire le nombre de
rôles. Le principe de l’algorithme de la ﬁgure 5.10 est le suivant :

1. calculer une matrice outil M de taille |O| × |A|, qui stocke pour chaque couple

objet × attribut le nombre de concepts où il est présent,

2. pour chaque concept c = (Oc, Ac), du moins pertinent au plus pertinent, le sup-

primer s’il n’entraîne pas de perte d’information et mettre à jour M,

3. une fois la liste des concepts réduite, utiliser l’algorithme TOGSH pour recons-

truire le graphe simpliﬁé G′ = (V′, E′),

5.5.5.6 Généricité de l’approche

Les modèles RBAC ont été étudiés et approfondis sur de nombreux aspects. C’est à
notre connaissance le seul modèle où l’on a essayé d’automatisé un processus de retro-
conception de politique à partir de droits existants. Pour l’application à la découverte
d’une hiérarchie de rôles potentielle, la structure de sous-hiérarchie de Galois extraite
avec l’algorithme PLUTON est adéquate, car :

– la notion de concept peut être une caractérisation formelle de la notion de rôle :
une abstraction déﬁnissable par ses affectations d’utilisateurs et de permissions,
– les concepts sont des regroupements maximaux d’objets et d’attributs, ce qui ré-
pond à un besoin en terme d’ingénierie : les rôles doivent comporter le maximum
d’utilisateurs et de permissions,

– l’analyse de concepts bénéﬁcie d’une caractérisation formelle. De plus, la sous-
hiérarchie lève la restriction de treillis et forme ainsi une structure utilisable sur
laquelle on effectue des traitements a posteriori,

– PLUTON offre des performances sufﬁsantes pour le mettre en œuvre sur des poli-

tiques considérables : dizaines de milliers d’utilisateurs et de permissions.

Notons que dans le cas général, la relation à décomposer peut être une autre re-
lation que celle entre utilisateurs et permissions. Dans le modèle de contrôle d’accès
introduit par Epstein représenté par la ﬁgure 5.8 trois utilisateurs intermédiaires ont
été introduits entre rôles et permissions. En utilisant les outils de l’analyse de concepts
formels, nous généralisons l’ingénierie de rôles à celle de l’identiﬁcation de concept
dans le cadre relationnel proposé dans la thèse.

Déﬁnition (Ingénierie de concepts hiérarchisés). Soient deux concepts C1 et C2, et R une
relation existante entre ces concepts R ⊆ C1 × C2. L’ingénierie de concepts hiérarchisés est
l’activité qui consiste à identiﬁer R1 ⋊⋉ HeriteC ⋊⋉ R2 = R avec :

Section 5.6. Discussion et synthèse

167

– un concept C,
– une relation R1 ⊆ C1 × C ,
– une relation réﬂexive, transitive et antisymétrique HeriteC ⊆ C × C,
– une relation R2 ⊆ C × C2.

Le problème général consiste à identiﬁer l’ensemble C et les relations R1 et R2 mais
aussi une relation hiérarchique HeriteC binaire interne sur C qui représente la hiérarchie
des concepts. La relation HeriteC doit respecter les propriétés imposées aux hiérarchies.

5.6 Discussion et synthèse

Dans ce chapitre, nous avons utilisé la structuration relationnelle déﬁnie au cha-
pitre 4 pour aborder les problèmes de conception et d’administration du contrôle d’ac-
cès. Nous divisons cette synthèse en deux parties : le résumé de notre contribution en
termes d’outils pour le contrôle d’accès, puis le positionnement de ces outils dans la
perspective générale de l’évolution des modèles et des politiques.

5.6.1 Outils pour le contrôle d’accès

Nous regroupons sous le terme d’outils l’ensemble des propositions d’aide à la
conception et à l’administration faites dans ce chapitre. En effet, si le contrôle d’accès
était un objet, les procédures de vériﬁcation et d’identiﬁcation de concepts, les primi-
tives de manipulation et d’interrogation seraient des outils qui permettraient de créer,
modiﬁer, utiliser et réparer cet objet.

Le tableau 5.9 synthétise les différents besoins rencontrés lors de la conception et de
l’administration du contrôle d’accès et résume les réponses que nous apportons à ces
problèmes. Nous avons catégorisé les besoins en deux parties : ceux qui concernent les
modèles de contrôle d’accès et ceux qui concernent les politiques qui en sont instances.
Nous proposons un ensemble d’outils et de méthodes qui permettent aux concepteurs
et aux administrateurs d’organiser et de réaliser efﬁcacement leurs activités. Nous dif-
férencions ainsi le travail de ces deux acteurs du contrôle d’accès :

– le concepteur de modèle a pour tâche de déﬁnir une organisation des droits qui soit
correcte, expressive, adaptée à son client et dont les conditions d’intégrité sont
déﬁnies formellement. Les outils que nous proposons au concepteur utilisent les
procédures de preuve de l’implication logique,

– l’administrateur de politiques déﬁnit et modiﬁe les droits des utilisateurs dans le
modèle, et vériﬁe qu’ils sont corrects. De plus, si le concepteur est amené à modi-
ﬁer le modèle, l’administrateur doit répercuter ces changements en restructurant
la politique pour la faire correspondre au nouveau modèle. Les outils que nous
proposons à l’administrateur utilisent les procédures de vériﬁcation de la satisfac-
tion.

Besoin
déﬁnition

168

e
l
è
d
o
M

e
u
q
i
t
i
l
o
P

Chapitre 5. Mise en œuvre de la structuration

Outil et méthode
primitive de déﬁnition de données pour le noyau et
déﬁnition logique des dépendances
construire σ et prouver que P ∪ Σ 6|= σ
prouver que P ∪ Σ\{λ} |= λ
transformation avec Φ et Φ−1
utiliser le chaînage de graphes pour |=
primitive d’interrogation de données sur I et I′
primitive de manipulation de données sur I

vériﬁcation de l’intégrité
simpliﬁcation
représentation graphique
raisonnement graphique
interrogation
administration
hiérarchisation de concepts PLUTON, classement et élagage
vériﬁcation de l’intégrité
correction
comparaison statique

prouver que I′ 6|= ⊥
modiﬁer I pour que I′ |= Σ
comparaison des triplets Statique(U, A, O)

TAB. 5.9 – Outillage pour le contrôle d’accès

On peut également imaginer une activité de retroconception de modèle, dont l’ob-
jectif serait de formaliser des mécanismes de contrôle d’accès existants pour pouvoir
utiliser le panel d’outils que nous proposons. On pourrait ainsi vériﬁer des politiques
déﬁnies dans des systèmes de gestion de base de données, des systèmes d’exploitation
ou des systèmes de gestion de ﬁchiers.

Notons que le rôle du concepteur de modèle est une fonction hypothétique que nous
imaginons. En effet pour l’instant, son activité serait réduite au choix d’un modèle exis-
tant. Cependant la tendance vers la composition sur mesure de modèles de contrôle
d’accès, comme en témoigne le modèle proposé par le GMSIH, laisse à penser que nous
ne sommes pas dans la pure spéculation : déjà des consultants et des experts doivent
déﬁnir et adapter des modèles de contrôle d’accès.

5.6.2 Vers l’évolution du contrôle d’accès

La diversité des activités humaines multiplie les structures et les organisations du
travail, chacune s’adaptant à différents besoins pour faciliter la gestion des biens ou
améliorer l’efﬁcacité et la productivité des acteurs. Avec l’évolution des technologies
comme celle des marchés et des enjeux politiques, les organisations sont amenées à
être modiﬁées, restructurées. Aﬁn d’être gérés efﬁcacement, les droits d’accès doivent
reﬂéter ces évolutions des structures.

Un cas d’utilisation qui amène de profonds changements dans les organisations
est celui des plans d’acquisition ou de fusion d’entreprises. Des entités indépendantes

Section 5.6. Discussion et synthèse

169

qui avaient développé leurs propres systèmes d’information se retrouvent à coopérer
étroitement. Un nouveau modèle de contrôle d’accès commun doit alors être conçu.

Ces problématiques font intervenir le concepteur de modèle qui doit développer
une nouvelle organisation des droits, mais aussi l’administrateur qui va restructurer
les droits existants. Lors du cas d’utilisation où l’on doit ajouter le concept de structure
dans un modèle qui ne l’intègre pas, les outils de comparaison et de hiérarchisation
automatisée assistent les activités de rétroconception de politiques.

La ﬁgure 5.11 présente les besoins qui surviennent lors de l’évolution des modèles.
Les outils formels que nous avons proposés sont ainsi mis dans la perspective plus
générale de l’évolution du contrôle d’accès. L’axe vertical de l’illustration résume les
principales activités de conception et d’administration d’une organisation des droits.
L’axe horizontal représente les changements et leurs impacts sur les droits existants.
On remarque que plus un changement survient tôt dans le contrôle d’accès, plus il
impacte d’activités.

Le recul porté sur la place des modèles de contrôle d’accès lors de l’évolution des
structures fait surgir de nouveaux problèmes : comment découvrir des schémas glo-
baux qui permettent d’uniﬁer plusieurs modèles de contrôle d’accès utilisés indépen-
damment ? Si un schéma global est déﬁni, comment passer d’un schéma local à un
autre ? Comment vériﬁer des propriétés qui portent sur différents schémas locaux ? Ou
encore, comment organiser les droits des administrateurs locaux dans le schéma glo-
bal ?

La thèse a déﬁni comment structurer logiquement l’organisation des droits dans un
système. Les problématiques d’évolution et de coopération que nous venons d’intro-
duire font intervenir quant à elles plusieurs modèles de contrôle d’accès. Si nous trans-
posons cette problématique en termes de bases de données, on voit apparaître la notion
de correspondance de schéma et d’intégration de données. Ces problèmes complexes
ont été abordés dans la littérature sur les bases de données relationnelles. Nous espé-
rons que ces résultats apporteront des éléments de réponses applicables aux problé-
matiques d’évolution et de coopération du contrôle d’accès [Calì04, Fagin06, Fagin03,
Lenzerini02]. Ces perspectives sont développées dans le chapitre 7.

170

Chapitre 5. Mise en œuvre de la structuration

FIG. 5.11 – Évolution des modèles et des politiques de contrôle d’accès

Object-oriented programming is an exceptionally bad idea which could only
haveoriginatedinCalifornia.

Edsger Dijkstra

6

Aspects techniques et réalisations

⊲ Dans le chapitre précédent, nous avons déﬁni les problématiques qui relèvent de l’utilisation de la
structuration relationnelle du contrôle d’accès de la thèse. Après avoir identiﬁé les besoins des concepteurs
et des administrateurs, nous avons proposé d’utiliser des outils algorithmiques pour l’automatisation
d’une partie des activités conduites sur les modèles et les politiques.

Dans ce chapitre, nous abordons l’implémentation de ces outils et la plaçons dans une architecture
du contrôle d’accès organisée. Un des composants logiciels que nous avons identiﬁé pour la réalisation
est une bibliothèque d’outils algorithmiques pour les dépendances, elle fait l’objet de la section 6.2.

La section 6.3 présente un cas d’étude de conception du contrôle d’accès du GMSIH. La suivante

détaille l’implémentation de l’ingénierie des rôles et évalue ses performances. ⊳

172

Chapitre 6. Aspects techniques et réalisations

Plan du chapitre

.

6.2

6.3 Cas d’étude .

6.1 Architecture du contrôle d’accès .

.

. .
. .

. .
. .

. .
. .

6.1.1
6.1.2
6.1.3 Gestion des politiques . .
. .
Bibliothèque pour les dépendances . .
6.2.1
6.2.2

. .
. .
Composants de l’architecture .
. .
Systèmes de gestion de base de données .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
Environnement de développement . .
Procédures de preuve . .
. .
. .
. .
6.3.1
Conception du modèle du GMSIH . .
6.3.2 Détermination du type de hiérarchie .
. .
. .
. .
. .

. .
. .

. .
. .

. .

. .

. .

. .

. .

. .

.
.

6.4 Réalisation de l’identiﬁcation de concepts
. .
. .
. .

Travaux connexes .
. .
Évaluation de la proposition . .
. .

6.4.1
6.4.2
Synthèse .

6.5

. .

. .

. .

. .

. .

. .

. .

. .

.

.

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

.
.
.
.
.
.
.
.
.
.
.
.
.
.

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. 173
. 173
. 174
. 177
. 180
. 181
. 182
. 184
. 184
. 187
. 189
. 189
. 190
. 194

Section 6.1. Architecture du contrôle d’accès

173

LA thèse a déﬁni une organisation générique des droits dans les systèmes ainsi qu’un

ensemble d’outils de conception et d’administration du contrôle d’accès. Nos pro-
positions ont essayé d’analyser puis de synthétiser le contrôle d’accès. Depuis le choix
du cadre des dépendances au chapitre 3, jusqu’aux outils du chapitre 5, en passant par
les déﬁnitions génériques du chapitre 4, nous avons fait correspondre le contrôle d’ac-
cès à une structuration relationnelle.

6.1 Architecture du contrôle d’accès

Cette section propose une architecture générique du contrôle dans les systèmes.
Cette architecture est fondée sur la correspondance entre modèles de contrôle d’accès et
schéma relationnel d’une part, et politiques de contrôle d’accès et instances de schéma
d’autre part. Nous décrivons une architecture du contrôle d’accès en deux temps. En
premier lieu nous décrivons comment utiliser les systèmes de gestion de base de don-
nées relationnelles pour stocker les politiques I. Ensuite, nous abordons le problème du
calcul de I′ et de l’implémentation des outils algorithmiques utilisés au chapitre 5

Il ne s’agit pas de concevoir une architecture de contrôle d’accès pour les systèmes
de gestion de base de données relationnelles, mais plutôt de concevoir une architecture
avec ces modèles et ces outils. L’objectif est de s’affranchir des problèmes techniques
relatifs au stockage des données, pour ensuite raisonner sur le contrôle d’accès. Cette
approche, guidée par le critère d’utilisabilité, est un premier pas vers une industrialisa-
tion de la thèse.

6.1.1 Composants de l’architecture

Actuellement, les dimensions des systèmes d’information des grandes organisa-
tions deviennent gigantesques : des dizaines de milliers d’utilisateurs, d’applications
et de permissions peuvent y être impliqués. Une architecture du contrôle d’accès doit
être en mesure de prendre en compte des politiques de contrôle d’accès de grandes
dimensions. Une telle architecture doit également s’intégrer le plus harmonieusement
possible dans les systèmes d’information existants.

6.1.1.1 Objectifs

Depuis plusieurs dizaines d’années, les systèmes de gestion de base de données sont
une des pierres angulaires des systèmes d’information. Grâce aux bases de données, les
organisations sont capables de collecter, stocker, gérer, traiter et diffuser de très grandes
quantités d’information.

S’il fallait développer une architecture de contrôle d’accès ex nihilo, nous devrions
prendre en compte de nombreuses fonctionnalités pour parvenir à une implémentation

174

Chapitre 6. Aspects techniques et réalisations

satisfaisante : stocker des données en s’assurant de leur validité, gérer la concurrence
d’accès, garantir la disponibilité du système et offrir de bonnes performances.

Ces différents objectifs sont pris en compte dans les systèmes de gestion de bases
de données. Développer une architecture de contrôle d’accès avec les bases de données
permet de s’affranchir d’une partie de ces contraintes techniques, en les reléguant aux
systèmes de gestion de bases de données eux-mêmes.

6.1.1.2 Catégorisation des aspects des modèles

Le cadre logique que nous avons proposé a déﬁni les aspects des modèles de
contrôle d’accès comme des relations mathématiques1 entre des données. En section 4.4,
nous avons catégorisé les aspects des modèles selon deux axes transversaux : la dyna-
micité des données et leurs déﬁnitions logiques. Une donnée d’un modèle de contrôle
d’accès, c’est-à-dire une instance d’une relation, peut être :

– statique ou dynamique, selon la fréquence de mise à jour de la relation et les droits

que les administrateurs ont sur cette relation,

– factuelle ou déduite, selon que l’on puisse déduire la donnée ou au contraire qu’on

la déﬁnisse en extension.

En opérant ces deux divisions sur les relations des modèles, on aboutit à déﬁnir
d. L’intégrité de chacun

quatre fragments des politiques de contrôle d’accès : Is, Id, I′
de ces fragments est assurée par un ensemble associé de dépendances.

s et I′

Les systèmes de gestion de base de données permettent de gérer les données fac-
tuelles et leur structuration. Cette catégorie comprend les sous-politiques Is et Id mais
aussi le schéma edb(AC) qui permet de les déﬁnir. Les systèmes de gestion permettent
de s’assurer de contraintes d’intégrité sur ces données. Il sont en revanche limités à
des sous-classes des dépendances fonctionnelles et d’inclusion : les clefs primaires et
étrangères.

6.1.2 Systèmes de gestion de base de données

Il est important de disposer d’un cadre logique pour formaliser puis inférer sur le
contrôle d’accès. Cependant, pour être utilisable, une architecture de contrôle d’accès
doit disposer de mécanismes qui sortent du cadre strict de la logique. Dans le chapitre 5
nous avons déﬁni plusieurs notions qui n’interviennent pas directement dans la modé-
lisation logique, comme les langages de déﬁnition et de manipulation de données.

1Dans ce chapitre la notion de relation est entendue au sens mathématique du terme – c’est-à-dire

comme dans l’annexe A – et non plus comme un lien entre des concepts.

Section 6.1. Architecture du contrôle d’accès

175

6.1.2.1 Fonctionnalités offertes

C’est lors de l’utilisation des données que de nouveaux problèmes relatifs à l’exé-
cution surviennent. La concurrence, la rapidité, la distribution ou la performance des
accès n’ont pas été prises en compte dans la thèse. Deux raisons ont guidé ce choix.
D’une part, ces critères auraient trop étendu le périmètre de nos travaux. D’autre part,
ces problèmes ont déjà été traités dans le domaine des bases de données. Des proposi-
tions qui les résolvent – du moins partiellement – sont implémentées couramment dans
les systèmes de gestion de bases de données actuels. Ainsi, le choix d’une architecture
fondée sur les bases de données permet de s’appuyer sur les mécanismes offerts de :

persistance des données. C’est bien sûr une des fonctions essentielles d’un système de
gestion de bases de données. Les systèmes de gestion de bases de données actuels
se conforment dans leur grande majorité au standard SQL [ISO99]. Ce support gé-
néralisé permet de s’appuyer sur les nombreuses bibliothèques existantes d’accès
aux données,

accès distants aux données. L’architecture client-serveur des systèmes de gestion offre
des primitives d’accès distantes transparentes aux utilisateurs. Des interfaces
d’administration sont développées sur ces primitives,

gestion d’accès concurrents aux données. Des mécanismes de gestion transactionnelle
des accès sont offerts par les systèmes. On dispose grâce à eux de moyens d’inter-
venir sur les éventuels blocages qui peuvent survenir en présence d’accès mul-
tiples aux données,

manipulation des données. Le standard SQL comprend un langage de manipulation
de données qui offre de très nombreuses fonctionnalités. Ce langage est néces-
saire pour la réalisation des primitives d’administration des politiques de contrôle
d’accès,

interrogation des données. Le standard SQL propose un langage d’interrogation de
données. Non seulement ce langage est connu de beaucoup d’acteurs de l’infor-
matique, mais en plus les implémentations sont robustes et efﬁcaces,

maintien des données. Les mécanismes existants permettent de vériﬁer la satisfac-
tion de dépendances fonctionnelles par l’intermédiaire des clefs primaires. Se-
lon les implémentations, des restrictions plus ou moins sévères de ces classes
peuvent être utilisées. De même, certaines sous-classes des dépendances d’inclu-
sion peuvent être exprimées comme des clefs étrangères,

performance des accès aux données. Les systèmes de gestion de bases de données
doivent permettre un accès efﬁcace aux données, mais aussi aux fonctionnalités
qu’ils offrent. Les mécanismes d’indexation et les implémentations optimisées des
principaux algorithmes d’interrogation offrent des performances qui permettent
la gestion de politiques en extension de grand volume,

disponibilité des données. Comme les systèmes d’information reposent sur les sys-
tèmes de gestion de bases de données, ces derniers doivent offrir des mécanismes

176

Chapitre 6. Aspects techniques et réalisations

pour garantir la sécurité des données qu’ils stockent. La possibilité de dupliquer
et de répartir les données ainsi que les mécanismes de redondances et de reprise
sur panne permettent de renforcer l’intégrité et la disponibilité des données.

Enﬁn, les systèmes de gestion de bases de données proposent une fonctionnalité
majeure que nous n’avons pas abordée : la possibilité de contrôler les accès aux données
qu’ils stockent. En effet, les systèmes de gestion de base de données mettent en œuvre
des modèles de contrôle d’accès et proposent des langages de contrôle de données. Ces
langages permettent de gérer les droits des utilisateurs.

6.1.2.2 Mécanismes de contrôle d’accès existants

Dans notre approche où les politiques en extension sont des données relationnelles,
ces utilisateurs sont les administrateurs. Dans l’architecture que nous proposons, les
modèles de contrôle d’accès proposés par les systèmes de gestion de bases de données
sont en fait les modèles d’administration qui gouvernent les droits des administrateurs
sur les politiques.

Les systèmes de gestion de base de données divisent les permissions qu’ils pro-

posent en deux catégories :

– les privilèges systèmes concernant la création, la modiﬁcation et la suppression
d’objets. Il s’agit des actions autorisées sur les structures de données : les éléments
logiques des bases de données, mais non sur les instances elle-mêmes. C’est donc
l’accès aux primitives de déﬁnition de données qui est contrôlé avec ces privi-
lèges : droits de création, de modiﬁcation et de suppression d’index, de tables, de
vues, etc. Dans notre modélisation du contrôle d’accès, il s’agit du contrôle des
accès aux primitives de conception des modèles,

– les privilèges objets concernant la manipulation d’objets. C’est-à-dire les actions
autorisées sur les données, une fois le modèle de données déﬁni. C’est donc l’ac-
cès aux primitives d’interrogation et de manipulation de données qui est contrôlé
avec ces privilèges : droits de sélection, d’insertion, de mise à jour et de suppres-
sion de tuples. Dans notre modélisation du contrôle d’accès, il s’agit du contrôle
des primitives d’administration des politiques.

Selon les systèmes industriels, différents modèles de contrôle d’accès sont implé-
mentés pour gérer les privilèges systèmes et objets. Les modèles basés sur l’identité
et discrétionnaires sont historiquement présents. Depuis quelques années les modèles
à rôles sont mis en œuvre. Pour la plupart, ce sont des modèles basés sur RBAC1 ou
RBAC2 sans hiérarchisation des concepts qui sont utilisés [Bertino05]. Certains systèmes
aux contraintes de sécurité fortes proposent une gestion mandataire des droits comme
les mécanismes Oracle Label Security d’Oracle, Label-Based Access Control de DB2, ou La-
bel Security de Microsoft SQL-Server.

Section 6.1. Architecture du contrôle d’accès

177

Les mécanismes de vues permettent de restreindre l’accès aux relations, mais sont
trop statiques et rigides. Par contre, certaines extensions relativement récentes per-
mettent un contrôle d’accès ﬁn et dynamique sur les relations. Des mécanismes de
réécriture de requêtes sont implémentés pour contrôler les accès aux colonnes et aux
lignes des relations. Les Virtual Private Databases (VPD) introduites depuis Oracle 8i
permettent ces restrictions. Ces fonctionnalités ont été étendues avec la version 10g.

Ces différents mécanismes permettent de contrôler les accès des administrateurs

aux politiques, mais aussi ceux des concepteurs aux modèles.

6.1.3 Gestion des politiques

Nous allons nous intéresser à la réalisation de la base de données de contrôle d’ac-
cès que nous proposons. Les systèmes de gestion de bases de données permettent de
répondre aux besoins techniques par leur performance et le nombre de fonctionnali-
tés qu’ils supportent. En revanche, les cadres logiques qu’ils implémentent sont très
réduits comparés à l’expressivité des classes comme les dépendances génératrices de
tuples contraintes. Nous nous intéressons à comment déﬁnir et accéder aux instances
Is, Id, I′

d déﬁnies dans le modèle générique du contrôle d’accès.

s et I′

6.1.3.1 Aspects factuels

Les systèmes de gestion de bases de données permettent de gérer les politiques en
extension. La partie statique des politiques (Is) est complètement prise en charge par les
systèmes de gestion. Les concepteurs de modèles disposent du langage de déﬁnition de
données pour créer la structure des droits et les relations en extension. Les administra-
teurs peuvent quant à eux concevoir et administrer la politique en extension statique
avec les primitives de manipulation et d’interrogation de données.

Les aspects dynamiques sont ceux sur lesquels des changements fréquents sur-
viennent, ou sur lesquels les administrateurs de la politique ne sont pas seuls à disposer
de droits de manipulation. C’est le cas des relations qui permettent de stocker des états
de contexte, comme l’heure globale du système.

Les systèmes de gestion actuels supportent des accès fréquents et multiples aux
données. Il est donc possible de mettre à jour fréquemment Id au regard de la durée de
vie des politiques. Ce sont principalement les relations sur lesquelles les utilisateurs in-
terviennent lors de l’exécution du moniteur de références qui sont modiﬁées fréquem-
ment. C’est le cas des relations portant sur le concept de sessions dans les modèles
RBAC.

Certains des aspects contextuels qui nécessitent l’interrogation très fréquente de
données, comme la position des usagers ou des informations sur les états d’exécution

178

Chapitre 6. Aspects techniques et réalisations

des systèmes. Avec la prise en compte des requêtes continues dans Oracle par exemple,
il peut être envisageable d’interroger de telles données [Witkowski07].

6.1.3.2 Aspects déduits

La prise en compte des données déduites (I′) à l’aide des systèmes de gestion de
base de données est plus difﬁcile. La politique en intention est déﬁnie à l’aide du frag-
ment de logique DATALOG ou DATALOGC. Or, les systèmes industriels se limitent gé-
néralement au standard SQL de 1999 qui n’offre pas les possibilités de déduction de
DATALOG. Il n’est pas possible d’utiliser un système SQL pour calculer I′ tel que nous
l’avons déﬁni dans le cas général, avec récursion.

Le cadre logique utilisé dans notre proposition est plus expressif que DATALOG.
Cependant, les dépendances sont divisées en classes à l’expressivité de plus en plus
grande. Au ﬁl de notre proposition, nous avons indiqué à quelle classe appartient
chaque formule. On peut donc choisir de restreindre l’étendue du cadre logique en se
limitant à des restrictions des dépendances. En imposant des restrictions fortes sur les
formes syntaxiques autorisées qui modélisent les principes et les propriétés du contrôle
d’accès, on limite l’expressivité de notre proposition, mais on s’assure de disposer de
mécanismes efﬁcaces et déjà implémentés.

Nous pouvons identiﬁer quatre approches principales pour la réalisation de l’éva-

luation de requêtes sur les politiques en intention I′ :

Utiliser les requêtes et vues récursives Les implémentations récentes de SQL per-
mettent la déﬁnition de requêtes récursives. Le mécanisme Common Table Expres-
sion (CTE) fourni par Microsoft SQL-Server offre cette fonctionnalité. En revanche,
les requêtes récursives proposées ne sont pas aussi expressives DATALOG, car res-
treintes en récursions et en opérations ensemblistes sur les relations. On doit donc
limiter l’expressivité des politiques au fragment offert par les CTE. Le mécanisme
d’évaluation implémenté reste relativement coûteux.

Utiliser les procédures stockées Les systèmes de gestion de base de données per-
mettent de déﬁnir des procédures qui sont exécutées avant ou après la manipu-
lation de données. On peut grâce à eux programmer des traitements lors de la
modiﬁcation des données en extension pour déduire de nouveaux faits. Cette
approche est délicate, car les langages de programmation de procédures stockées
sont souvent spéciﬁques aux systèmes et, car ils peuvent manquer de fonction-
nalités. De plus, nous diminuons l’intérêt de l’utilisation d’un cadre logique : il
faudrait représenter les programmes P par des procédures spéciﬁques.

Utiliser un moteur DATALOG Pour la réalisation effective des mécanismes d’évalua-
tion des requêtes, on peut se baser sur un moteur de bases de données déductives
DATALOG ou DATALOGC. Ces systèmes permettent de calculer le plus petit mo-
dèle I′ d’un programme DATALOG. Ils proposent un langage de requêtes récur-

Section 6.1. Architecture du contrôle d’accès

179

sives pour interroger la politique et des contraintes d’intégrité expressives comme
les FTGD avec contraintes. Des implémentations abouties de ces moteurs existent
comme DLV2 ou XSB 3.

Développer un moteur externe Le principe est de développer un programme externe
au système de gestion qui calcule le point ﬁxe I′ à partir de I et du programme P
qui déﬁnit les principes du modèle. Plus le fragment de logique pour l’expression
des principes est expressif, plus le développement et l’exécution du programme
de calcul du point ﬁxe sont coûteux. Une fois vériﬁée, on peut éventuellement
enregistrer I′
s dans le système aﬁn de pouvoir disposer d’un accès performant à
la politique grâce à un système de cache. On déﬁnirait alors tout ou partie du
schéma en intention idb(AC) dans la base de données de contrôle d’accès. Cette
approche n’est pas acceptable pour la partie dynamique des politiques déduites
I′
d, car elle imposerait de les recalculer trop souvent.

Les deux premières approches n’ont pas été réalisées. La troisième a été implémen-
tée dans un prototype basé sur un moteur existant. En revanche, la dernière a reçu toute
notre attention : c’est celle que nous avons développée.

6.1.3.3 Outils algorithmiques

Avec l’utilisation des systèmes de gestion de base de données existants, nous nous
sommes intéressés au stockage de I ainsi qu’à la construction et à l’interrogation de
I′. Si ces fonctionnalités sont incontournables pour réaliser l’architecture du contrôle
d’accès, nous n’avons pas abordé l’implémentation de deux outils algorithmiques au
centre de la thèse : les procédures de vériﬁcation de la satisfaction et celles de preuve
de l’implication pour les classes de dépendances générales.

Procédures de satisfaction

Le premier outil algorithmique concerne la vériﬁcation des politiques de contrôle
d’accès. Les procédures de vériﬁcation de la satisfaction d’un ensemble de dépendance
par une politique I ou I′ permettent de s’assurer de l’intégrité des données de contrôle
d’accès. Or, seules des classes de dépendances dégénérées sont vériﬁées par les moteurs
de gestion des données traditionnels.

Chacune des quatre méthodes proposées pour le calcul de I′ permet de réaliser
la vériﬁcation de la satisfaction pour des classes dont l’expressivité est équivalente à
DATALOG ou DATALOGC, c’est-à-dire les dépendances génératrices de tuples totales
à simple tête, éventuellement agrémentées de contraintes en hypothèse. En revanche,
dans le cas général pour les TGD, les CTGD et les DCTGD sans restrictions, il faut pro-
grammer la vériﬁcation de la satisfaction. Notons que quelle que soit la classe, une telle

2http://www.dbai.tuwien.ac.at/proj/dlv/
3http://xsb.sourceforge.net/

180

Chapitre 6. Aspects techniques et réalisations

vériﬁcation est décidable. En effet, cette vériﬁcation est réalisable naïvement en parcou-
rant l’ensemble des données sans les modiﬁer et sans en générer de nouvelles.

Procédures de preuve de l’implication

Le second outil algorithmique concerne la vériﬁcation des modèles de contrôle d’ac-
cès. C’est ce que d’aucuns appelleraient des vériﬁcations abstraites, indépendantes des
politiques. Les procédures de preuve de l’implication des dépendances ont été mises
à proﬁt pour ces vériﬁcations. Certaines de ces procédures, ou des algorithmes qui
en sont proches sont implémentés par les ateliers de conception de base de données.
Ils permettent aux développeurs qui conçoivent des schémas de s’assurer de certaines
propriétés de ces schémas, comme les formes normales. Or, dans la conception de base
de données, c’est principalement l’inférence sur les dépendances fonctionnelles qui est
mise en œuvre : un fragment qui ne permet que l’expression de modèles de contrôle
d’accès simples comme RBAC0.

Nous avons implémenté différentes procédures de preuves sur les dépendances. En
réalisant ces procédures, nous nous sommes aperçus qu’elles partagent de nombreuses
fonctionnalités logicielles communes, que ce soient les structures de données ou les al-
gorithmes élémentaires. Nous nous sommes ainsi orientés vers le développement d’une
bibliothèque pour les dépendances de données.

6.2 Bibliothèque pour les dépendances

Nous avons choisi de développer une bibliothèque pour la manipulation et l’infé-
rence sur les dépendances de données. Nous nous sommes limités au fragment logique
des dépendances génératrices de tuples contraintes. Cette expérience nous a cepen-
dant permis d’effectuer des vériﬁcations non triviales, comme la vériﬁcation d’inté-
grité de modèle de [Benantar06], proposée en section 5.2.4. La réduction du nombre de
contraintes d’intégrité de [Gavrila98], proposée en section 5.2.5 a également été effec-
tuée à l’aide de cette bibliothèque.

La bibliothèque, nommée LIBDEPENDENCIES, consiste principalement en l’implé-
mentation de quatre procédures de preuves pour les dépendances. Les algorithmes et
les structures de données que nous avons réalisés pour ces procédures permettent éga-
lement d’effectuer la vériﬁcation de la satisfaction des dépendances. Les autres réalisa-
tions que comprend la LIBDEPENDENCIES ont réutilisé les primitives que nous avons
développées pour les procédures de preuves. La bibliothèque LIBDEPENDENCIES a été
successivement rafﬁnée en trois versions :

1. la première version a été implémentée en C à partir d’un prototype écrit en Py-
thon par Stéphane Coulondre. Ce prototype implémentait la première procédure
de preuve de [Maher96]. Sa réimplémentation a amélioré l’efﬁcacité globale du
prototype et l’interfaçage avec les bibliothèques utilisées,

Section 6.2. Bibliothèque pour les dépendances

181

2. la seconde version a été celle du portage de la LIBDEPENDENCIES en C++ et de la
compatibilité entre Linux et Windows. Le passage en programmation orientée ob-
jet a permis une meilleure réutilisation des sous-algorithmes. La Standard Template
Library (STL) à été utilisée pour les structures de données,

3. la troisième version est celle sur laquelle ont été réalisées les expérimentations
et les principaux développements de recherche. Une refonte du moteur et une
nouvelle organisation du code ont été effectuées. Trois procédures de preuves
supplémentaires ont été implémentées sur cette version.

Le projet de la LIBDEPENDENCIES est sufﬁsamment conséquent, en termes de vo-
lume, du nombre d’interfaces et d’objectifs fonctionnels, pour que sa réalisation né-
cessite la mise en place d’un environnement de développement relativement complet
allant de l’infrastructure de projet, aux choix des logiciels de développement et des
bibliothèques.

6.2.1 Environnement de développement

Nous avons fait le choix technique du C++ pour réaliser la LIBDEPENDEN-
CIES [Stroustrup97]. Cette décision conditionne l’ensemble des mesures techniques
que nous entreprenons dans la réalisation de la bibliothèque. Plusieurs critères ont
guidé ce choix :

– de nombreux outils de qualité sont disponibles pour ce langage ou pour le C. Une
suite complète de compilation (toolchain) est disponible avec gcc et ses projets
périphériques,

– la standardisation internationale et le caractère non-propriétaire du langage C++.
La suite gcc ainsi que la grande majorité des outils que nous avons utilisés pen-
dant la thèse sont sous licence GNU General Public License (GPL) ou une autre
licence libre,

– la portabilité du langage entre de nombreuses architectures matérielles et logi-

cielles offertes par la suite gcc et les autres outils utilisés dans le prototype,

– la vitesse d’exécution, le compilateur gcc pour le langage C++ offre de très
bonnes performances. Le prix à payer pour l’efﬁcacité et la versatilité du langage
est une réelle difﬁculté à le maîtriser,

– la qualité générale et la disponibilité de bibliothèques comme la STL ou BOOST.
De plus, le grand nombre d’interfaces en C/C++ nous a permis de réutiliser de
nombreux composants logiciels,

– c’est un langage multiparadigme. Le mécanisme d’instanciation des templates per-
met la programmation générique ou la métaprogrammation. Ce mécanisme a été
découvert comme complet au sens de Turing [Alexandrescu01] .

182

Chapitre 6. Aspects techniques et réalisations

6.2.1.1 Environnement de programmation

Nous avons utilisé la suite logicielle gcc4 pour la compilation des programmes.
Cette suite propose, en plus du compilateur, des outils pour le débogage, le proﬁlage
et la couverture des tests fonctionnels. Comme interface graphique nous avons utilisé
l’environnement de développement intégré KDevelop5 qui permet la gestion de grands
projets. Le générateur de documentation Doxygen6 a été utilisé pour les manuels.

6.2.1.2 Bibliothèques utilisées

Nous avons utilisé trois grandes familles de bibliothèques pour la réalisation de la
LIBDEPENDENCIES : pour l’analyse syntaxique des dépendances, pour les structures de
données et les algorithmes bas niveau et pour la résolution des contraintes.

Analyse des formules logiques. Nous avons utilisé le couple Flex7 pour l’analyse lexi-
cale et Bison8 pour l’analyse syntaxique des ensembles de dépendances. Tous
deux permettent de générer des analyseurs C++. Marginalement, l’analyseur
Xerces9 a été utilisé pour l’analyse syntaxique de ﬁchiers XML.

Algorithmes et structures de données. Nous avons exploité la STL qui propose des
structures de données et des algorithmes génériques performants pour le C++.
Cette bibliothèque a été complétée par Boost pour certaines fonctionnalités outils :
interface ligne de commande, manipulation de chaînes de caractères, structure
de tuple. Cette bibliothèque exhaustive propose une excellente bibliothèque de
graphes Boost Graph Library (BGL) que nous avons utilisée également [Sieka01].
Résolution des contraintes. Le moteur SWI-PROLOG a été interfacé à la LIBDEPEN-
DENCIES pour son solver de contraintes, mais pas pour ses mécanismes d’uniﬁca-
tion. Le solver est développé comme une bibliothèque à ce moteur [Christian95]
Nous avons également utilisé le moteur DATALOG XSB pour des prototypes inter-
médiaires et des validations expérimentales mais par pour la LIBDEPENDENCIES.

6.2.2 Procédures de preuve

Les procédures de preuves forment le cœur de la LIBDEPENDENCIES. Actuellement
les données commes le ensembles de formules logiques sont simplement enregistrées
dans des ﬁchiers texte. Le couple Flex/Bison analyse ces entrées et permet de les char-
ger en mémoire dans nos structures. Les procédures de preuve et de satisfaction ex-

4http://gcc.gnu.org/
5http://www.kdevelop.org
6http://www.stack.nl/~dimitri/doxygen/
7http://flex.sourceforge.net/
8http://www.gnu.org/software/bison/
9http://xerces.apache.org/

Section 6.2. Bibliothèque pour les dépendances

183

ploitent alors ces données et produisent des traces d’exécution qui sont utilisées pour
la vériﬁcation et l’analyse des inférences.

6.2.2.1 Procédures implémentées

Quatre procédures de preuves issues de la littérature sur les dépendances ont été
implémentées dans la LIBDEPENDENCIES. L’intérêt est d’une part de disposer d’élé-
ments de comparaison entre ces procédures, en termes de performance, d’expressivité
et de traces d’exécution, et d’autre part d’identiﬁer et réutiliser des algorithmes et struc-
tures communes à ces différentes procédures. Nous avons implémenté :

– le chase de [Beeri84] pour les TGD, une procédure de décision pour les TTGD,
– la première procédure de [Maher96] pour les CTGD quand le domaine de

contraintes dispose de la propriété INC,

– la seconde procédure de [Maher96] qui est strictement plus puissante que la pré-

cédente quand domaine de contraintes ne dispose pas de la propriété INC,

– la procédure en marche arrière pour les TGD de [Coulondre03].
Nous n’avons pas implémenté la procédure proposée par [Wang02] qui prend en
compte la disjonction dans la conclusion des formules logiques. Grâce à la LIBDEPEN-
DENCIES, il est aisé d’implémenter des algorithmes comme la fermeture d’un ensemble
d’attributs par des dépendances fonctionnelles, qui est une application directe de l’axio-
matisation de Armstrong pour les dépendances fonctionnelles.

6.2.2.2 Structuration de la LIBDEPENDENCIES

Les procédures de preuve en marche avant [Beeri84, Maher96] comme l’évaluation
des requêtes DATALOG se basent sur le calcul d’un point ﬁxe obtenu en itérant l’appli-
cation des formules, section 3.4.2.2.

Dans l’implémentation, nous avons utilisé une forme de base de données symbo-
lique chargée entièrement en mémoire que l’on interroge et à laquelle on ajoute des
tuples. Dans cette instance de données symbolique, on ne supprime jamais de tuples.
Ceci est dû au fait que la négation n’est autorisée dans aucun des fragments de logique
que nous avons considérés. La LIBDEPENDENCIES est composée des classes principales
encapsulant respectivement :

– les structures de données qui permettent de représenter les formules logiques.
Des classes permettent de représenter les contraintes dans les formules, les termes
et les conjonctions de termes en hypothèse et en conclusion de dépendances
(CTgd) et enﬁn des ensembles de dépendances (CBaseTgd). Toutes ces structures
sont chargées par l’analyseur (TGDParser),

– les structures de données représentant la base de données symbolique et les

tuples qui la composent (CDatabase et CTuple),

184

Chapitre 6. Aspects techniques et réalisations

– les algorithmes d’uniﬁcation, de calcul de point ﬁxe et de recherche de pièces.
Des classes d’environnements (CChaseEnvironment) permettent de regrouper
les ensembles utilisés lors des inférences. Les procédures qui les utilisent sont
invoquées à partir de l’interface principale de la bibliothèque,

– les structures pour mémoriser les valuations utilisées lors des inférences et resti-

tuer des traces (CActivation).

Cette bibliothèque a été utilisée dans le cadre de nos travaux pour la modélisation
et la vériﬁcation de modèles et de politiques de contrôle d’accès. Mais les algorithmes
étant génériques, la LIBDEPENDENCIES pourrait être utilisée dans une perspective plus
large de conception de base de données. La mise sous forme normale faisant intervenir
les dépendances multivaluées ou d’inclusion pourrait s’appuyer sur notre bibliothèque.
Nous n’avons par encore poursuivi cette direction en l’état actuel, la LIBDEPENDENCIES
n’est pas optimisée et son interface est à revoir.

6.3 Cas d’étude

Cette section propose deux cas d’étude qui illustrent la conception d’un modèle de
contrôle d’accès puis la vériﬁcation de politique avec l’exemple de la détermination des
propriétés vériﬁées par une hiérarchie de rôles existante.

6.3.1 Conception du modèle du GMSIH

Le Groupement pour la Modernisation du Système d’Information Hospitalier
(GMSIH) a proposé trois modèles de contrôle d’accès pour les établissements de
santé [GMSIH03]. L’objectif est de faciliter la mise en place de politiques de sécurité
pour la santé. En effet, dans ce domaine, les conséquences de la non-sécurité peuvent
par exemple conduire à [Deswarte04] :

– une prise de décision médicale pouvant porter préjudice au patient,
– une information médicale amoindrie ou inutilisable,
– l’impossibilité d’exhiber un dossier informatisé comme preuve,
– l’utilisation illégitime de données conﬁdentielles,
– une rupture du suivi médical.

6.3.1.1 Description du modèle

Un modèle principal est proposé, décliné en trois versions : simpliﬁé, intermédiaire et
complet. Il s’agit d’une aide pragmatique à l’élaboration de politique de sécurité pour
la santé. Les modèles proposés par le GMSIH sont des extensions du modèle RBAC3
adaptées aux contraintes spéciﬁques des milieux hospitaliers, les principaux aspects
supplémentaires introduits sont :

Section 6.3. Cas d’étude

185

FIG. 6.1 – Modèle de contrôle d’accès du GMSIH (UML) [GMSIH03]

– le concept de structure et de sa hiérarchie associée qui modélise les établissements

et leurs services,

– la relation d’affectation de rôles, qui devient une association ternaire entre utilisa-
teurs, rôles et structures, ainsi un utilisateur peut disposer de plusieurs rôles dans
des structures différentes,

– la spécialisation du concept d’utilisateur en patient et professionnel de santé, spéci-

ﬁque au domaine,

– l’ajout de concepts spéciﬁques au dossier médical qui sont les ressources contrô-

lées dans ce modèle.

La ﬁgure 6.1 illustre le modèle intermédiaire proposé par le GMSIH. Il s’agit d’un
exemple de conception de modèle de contrôle d’accès, où une organisation a demandé
une organisation des droits qui permette de représenter le plus ﬁdèlement possible
comment sont gérées les autorisations dans les établissements hospitaliers.

6.3.1.2 Application de l’architecture de contrôle d’accès

La région Rhône-Alpes a mis en place une plateforme d’information médicale,
connectant la plupart des établissements de santé de la région. Cette plateforme est
composée de trois projets principaux : le Serveur Télématique d’Identité Communau-
taire (STIC), la Plateforme d’Echange entre les Professionnels de Santé (PEPS) et le Dos-
sier Patient Partagé et Réparti (DPPR).

Le dossier patient est un projet dont l’objectif est de donner l’accès à des profession-
nels de la santé aux informations médicales relatives à un patient et localisées dans le
système d’information des établissements partenaires. Chaque système d’information
hospitalier connecté envoie à la plateforme centrale une référence des informations mé-
dicales qu’il souhaite partager. Le DPPR se base sur l’identiﬁant régional du patient.

186

Chapitre 6. Aspects techniques et réalisations

La structuration relationnelle du contrôle d’accès que nous avons proposée apporte
une réponse cohérente aux problèmes de représentation, stockage et d’interrogation des
politiques de contrôle d’accès, permettant d’évaluer les décisions de contrôle d’accès,
d’exprimer des contraintes métiers complexes et de s’assurer de l’intégrité des poli-
tiques.

Exemple 6.1 Le CHM adopte le modèle du GMSIH

Avec de nombreux autres établissements de santé, le CHM est très impliqué au sein
du GMSIH, il a été décidé que cet établissemt serait pilote pour la mise en œuvre du
modèle intermédiaire de contrôle d’accès proposé par le groupement. Il s’agit d’un
chantier qui doit être mené avec méthode dont les activités sont :

1. l’identiﬁcaton du ou des modèles de contrôle d’accès déjà utilisés,
2. la collecte et l’analyse des politiques déjà utilisées,
3. la déﬁnition de la base de données de contrôle d’accès GMSIH,
4. la déﬁnition des principes et propriétés des modèles,
5. la réalisation des mécanismes de déduction de faits en intention,
6. la déﬁnition des droits dans le nouveau modèle, à partir des droits existants.

Une fois ces étapes menées à bien on aboutit à une politique organisée selon le mo-
dèle du GMSIH. Les droits seront ensuite administrés par le service informatique une
fois l’architecture mise en production. Cela nécessite l’interface avec les utilisateurs,
ressources et accès offerts par les différentes application du CHM sur les ressources.

6.3.1.3 Réalisation spéciﬁque de moteur

L’objectif du contrôle d’accès est de pouvoir déterminer les actions des sujets autori-
sées sur les objets du système. La dérivation du triplet Acc `es a été exprimée en logique.
Cependant, pour une prise de décision efﬁcace, et non pour la vériﬁcation, il est envi-
sageable de développer sur mesure un algorithme capable de calculer I′.

Les déﬁnitions logiques et l’outillage que nous proposons permettent de concevoir
et de réaliser ce moteur. Il est possible qu’une organisation se limite à un fragment de
logique restreint aux TTGD pour formaliser le modèle du contrôle d’accès du GMSIH. On
peut même se limiter à des fragments plus restrictifs encore où les seules dépendances
récursives mises en œuvre soient celles qui expriment la transitivité et la symétrie d’une
relation.

Le modèle de contrôle d’accès du GMSIH comporte principalement deux hiérarchies
et peu de contraintes. On peut représenter ces deux hiérarchies par des graphes. Avec
l’aide d’un algorithme qui calcule la couverture transitive et réﬂexive de ces graphes,
on peut dériver le triplet fondamental d’autorisation et prendre les décisions d’accès.

Section 6.3. Cas d’étude

187

FIG. 6.2 – Exemple de hiérarchie en arbre (UML)

En représentant les graphes de domination par leurs matrices d’adjacence, la
construction de la fermeture transitive avec l’algorithme de Warshall a une complexité
en O(n3). Hiérarchies de structures et de rôles sont statiques. Il est ainsi bénéﬁque de
calculer cette couverture puis de la garder en mémoire durant l’exécution du moteur.
On peut ainsi savoir en temps constant si deux concepts sont reliés hiérarchiquement.
Les outils de preuve et de vériﬁcation que nous avons proposés ne sont pas tous
disponibles. Ils pourront éventuellement être développés a posteriori, une fois l’archi-
tecture mise en œuvre. Une bibliothèque comme la LIBDEPENDENCIES que nous avons
développée permet de réaliser ces vériﬁcations en s’interfaçant avec la base de données
du contrôle d’accès mise en place.

6.3.2 Détermination du type de hiérarchie

Nous allons illustrer le principe de la vériﬁcation de politiques avec la hiérarchie en
arbre de la ﬁgure 6.2. Le problème à résoudre est alors « Quelle structure respecte une
hiérarchie ? Un arbre, un arbre inverse, un treillis ou encore une hiérarchie générale ? ».
Le tableau 6.1 donne la hiérarchie de la ﬁgure 6.2 sous forme logique :

– la colonne de gauche est un extrait de la politique I,
– la colonne de droite est un extrait de la politique déduite I′.
Dans la hiérarchie de rôle d’exemple, chaque arête est une relation de domination
Domine entre des rôles. L’objectif est de calculer la relation H ´erite et de savoir de quel
type de hiérarchie limitée il s’agit. On remarque qu’il y a 8 arêtes dans le graphe de do-
mination et 10 concepts, l’extension de la relation Domine comporte donc 8 tuples. Cette
relation fait partie de edb. La relation H ´erite de idb comporte quant à elle 24 tuples :

– 8 en extension, par application de λH,
– 10 par réﬂexivité, par application de λR,
– 6 = 4 + 2 par transitivité, par application de λT,

188

Chapitre 6. Aspects techniques et réalisations

En section 4.3.4 nous avons déﬁni un ensemble de dépendances qui permettent
d’imposer un type de hiérarchie spéciﬁque. La satisfaction des dépendances λa, λi, ou
λt et λb permet de déterminer si cette hiérarchie est limitée en arbre (λa), arbre inverse
(λi) , treillis (λt et λb) ou si elle est au contraire générale. Pour cela il faut vériﬁer si I′ est
un modèle de l’une ou d’aucune ces dépendances. Nous notons I′|=σ pour exprimer
que I′ est un modèle de σ.

Pour cet exemple d’utilisation, les procédures de preuve comme le chase permettent
de vériﬁer la satisfaction des dépendances par I′. On exécuterait successivement l’algo-
rithme de preuve pour déterminer que :

I′6|=λi comme un spécialiste est un médecin, Domine(Sp´ecialiste, M´edecin), que le
rôle généraliste hérite aussi de médecin, Domine(G´en´eraliste, M´edecin) et que
ces deux rôles sont différents, il ne s’agit pas d’un arbre inverse : λi n’est pas
satisfaite,

I′6|=λt comme un spécialiste est un médecin, qu’un généraliste en est un aussi et qu’il
n’existe pas de rôle r⊤ qui hérite à la fois de ces deux rôles, c’est-à-dire tel que
H ´erite(r⊤, Sp´ecialiste) et H ´erite(r⊤, G´en´eraliste), la hiérarchie n’est pas un
treillis : λt n’est pas satisfaite,

I′|=λa en revanche, I′ satisfait bien la dépendance qui modélise que la hiérarchie est un

arbre : λa est satisfaite.

Supposons désormais qu’un administrateur tente d’ajouter à la hiérarchie le
tuple Domine(Sp´ecialiste, Infirmier). Alors, la dépendance qui limite la hiérar-
chie à un arbre Domine(ID, ID1)Domine(ID, ID2) → ID1 = ID2 est violée. En ef-
fet, on a Domine(Sp´ecialiste, Infirmier) et Domine(Sp´ecialiste, M´edecin) avec
Infirmier 6= M´edecin.

Dans la pratique, la transaction initiée par l’administrateur demandant l’ajout du
tuple sera avortée car elle viole la dépendance. Supposons maintenant qu’un autre ad-
ministrateur essaie d’ajouter le tuple Domine(Infirmier, M´edecin). Une telle opération
sur la politique sera refusée, car la dépendance modélisant l’antisymétrie serait violée :
H ´erite(ID1, ID2), H ´erite(ID2, ID1) → ID1 = ID2.

Relation Domine ⊆ I :

Relation H ´erite ⊆ I′ :

Domine(medecin,personnel)
Domine(directeur,personnel)
Domine(infirmier,personnel)
Domine(specialiste,medecin)
Domine(generaliste,medecin)
Domine(chirurgien,specialiste)
Domine(pneumologue,specialiste)
Domine(anesthesiste,specialiste)
Domine(cardiologue,specialiste)

Herite(medecin,personnel)
Herite(specialiste,medecin)
Herite(generaliste,medecin)
Herite(chirurgien,specialiste)
...
Herite(specialiste,personnel)
Herite(generaliste,personnel)
Herite(chirurgien,medecin)
Herite(chirurgien,personnel)

TAB. 6.1 – Expression relationnelle de la hiérarchie de la ﬁgure 6.2

Section 6.4. Réalisation de l’identiﬁcation de concepts

189

6.4 Réalisation de l’identiﬁcation de concepts

Nous avons proposé en section 5.5 une méthode d’identiﬁcation de concepts hié-
rarchisés basée sur l’algorithme PLUTON [Arévalo07]. Nous avons implémenté cet al-
gorithme avec l’environnement de développement que nous avons décrit pour la LIB-
DEPENDENCIES. Il n’est par contre pas intégré à la bibliothèque et fonctionne indépen-
damment de cette dernière.

Alors que la LIBDEPENDENCIES a une portée très large et un coût de développement
conséquent, l’implémentation de notre approche d’identiﬁcation de rôle est bien plus
ciblée et plus modeste. Par ailleurs, l’algorithme PLUTON relève plus de la fouille de
données que de la preuve logique. C’est la raison pour laquelle nous l’avons développé
comme un logiciel autonome.

6.4.1 Travaux connexes

Les approches ascendantes permettent d’identiﬁer des hiérarchies de rôles impli-
citement présents dans des permissions existantes. La hiérarchie obtenue peut être un
arbre, une forêt d’arbre ou en ordre partiel général selon la proposition. Nous décrivons
ici les principales approches d’identiﬁcation automatisées de hiérarchies de rôles.

6.4.1.1 ROLEMINER

Une première proposition nommée ROLEMINER est basée sur la suite d’outils IBM
INTELLIGENT MINER [Kuhlmann03]. La technique utilisée est celle du demographic clus-
tering, hybride entre recherche de règles d’associations et classiﬁcation non supervisée
(clustering) [Grabmeier02]. Les temps de calcul évoqués dans cette proposition sont de
l’ordre de quelques heures pour environ 18.000 utilisateurs. Malheureusement, peu de
détails sont donnés dans l’article et les algorithmes ne sont pas décrits, ce qui rend
difﬁcile la comparaison avec cette approche.

6.4.1.2 ORCA

La proposition des auteurs de [Schlegelmilch05] est l’algorithme de clustering hié-
rarchique ORCA. La technique retenue est fondée sur les forêts d’arbres comme repré-
sentation des hiérarchies de rôles. Dans le cas général cependant, la hiérarchie est un
ordre partiel sur les rôles, ce n’est pas nécessairement un arbre. Ceci conduit à une li-
mitation importante d’ORCA : une permission ne peut être associée qu’à des rôles d’un
même arbre. Un logiciel commercial getRole a suivi ces travaux. Les auteurs n’abordent
pas les performances de leur approche ni la borne maximum du nombre de rôles que
l’on peut obtenir.

190

Chapitre 6. Aspects techniques et réalisations

6.4.1.3 COMPLETEMINER et FASTMINER

Les auteurs de [Vaidya06] proposent d’utiliser l’énumération de sous-ensembles de
permissions pour identiﬁer des rôles. Les auteurs proposent deux algorithmes : une
énumération complète, COMPLETEMINER, qui calcule tous les sous-ensembles de per-
missions possibles, et une énumération partielle FASTMINER, qui se limite au calcul
d’intersections d’ensembles pris deux à deux. Les jeux d’essais proposés pour l’évalua-
tion de leur approche sont des cas favorables à FASTMINER. L’algorithme COMPLETE-
MINER n’est pas évalué.

6.4.1.4 Déﬁnition de l’ingénierie des rôles

Les auteurs cette dernière proposition ont fait évolué leur approche [Vaidya07]. Plu-
tôt que de composer un algorithme d’extraction des rôles sur mesure, comme avec
FASTMINER, ils mettent en relation le problème de l’ingénierie des rôles avec celui du
pavage d’une relation binaire [Geerts04]. La proposition ne présente pas de résultats ex-
périmentaux. Nous pensons cependant qu’il existe des liens étroits entre leur cadre et
le nôtre car ils sont fondés tout deux sur l’analyse d’une relation binaire.

6.4.2 Évaluation de la proposition

Notre implémentation semble donner des résultats pertinents et utilisables. Mal-
heureusement, nous n’avons pas eu la possibilité de faire évaluer les résultats – c’est-à-
dire des hiérarchies concepts potentiels – de notre approche par des experts. Les auteurs
de [Vaidya06] ont proposé une méthodologie pour évaluer la pertinence et l’efﬁcacité
des approches ascendantes d’ingénierie de rôles. Nous l’avons utilisée pour évaluer la
nôtre. Elle est plus performante que FASTMINER.

6.4.2.1 Méthodologie

Les auteurs de [Vaidya06] ont proposé une méthodologie pour évaluer la perti-
nence et l’efﬁcacité des approches ascendantes d’ingénierie de rôles. Nous l’avons uti-
lisée pour évaluer la nôtre. Cette méthodologie est basée sur les principes du reverse-
engineering. Elle consiste à générer aléatoirement une politique RBAC, à calculer la ma-
trice des droits d’accès à partir de cette politique, puis à vériﬁer si les rôles calculés à
partir du contexte formel sont bien ceux initialement générés :

1. générer une politique RBAC avec ou sans hiérarchie des rôles,
2. construire la matrice des droits d’accès à partir de cette politique,
3. exécuter l’algorithme de découverte des rôles sur la matrice des droits d’accès,
4. classer les concepts calculés selon une mesure de pertinence sélectionnée,

Section 6.4. Réalisation de l’identiﬁcation de concepts

191

5. parmi les n premiers concepts du classement, compter ceux qui sont effectivement
des rôles générés dans la première étape. Le nombre de rôles tirés aléatoirement
présents dans les n premiers identiﬁés donne une mesure de précision en %.

Jeu Description
a

Paramètres

Nombre d’utilisateurs par rôle constant,
MRU=3
nombre de permissions variable
NR=100, NU=2000
Nombre de permissions par rôle constant,
MRU=3, MPR=150
nombre de d’utilisateurs variable
NR=200, NP=1500
Nombre de permissions constant,
MRU=3, MPR=150
nombre d’utilisateurs par rôle variable
NP=1500
Nombre d’utilisateurs, de permissions et de rôles
NU=2500, NR=100
constants, nombre de rôles par utilisateur variable MPR=50, NP=1500

b

c

d

TAB. 6.2 – Paramètres utilisés pour les expérimentations

6.4.2.2 Résultats expérimentaux

Nous avons réalisé quatre jeux d’essai synthétiques, a, b, c et d similaires à ceux réa-
lisés dans [Vaidya06]. Pour chaque jeu, quatre courbes sont proposées. Deux concernent
la précision en % (sans hiérarchie : P(f), avec : P(h)), les deux autres le temps d’exé-
cution en secondes (sans hiérarchie : T(f), avec : T(h)).

La ﬁgure 6.3 présente les résultats obtenus par notre proposition. Les expérimenta-
tions sont décrites dans le tableau 6.2. Le générateur de politique a comme paramètres
le nombre de rôles NR, d’utilisateurs NU, de permissions NP, le nombre maximum de
rôles MRU par utilisateurs, ainsi que le nombre maximum de permissions par rôle MPR.
Le critère utilisé pour le classement des concepts est la taille de l’extension réduite. C’est
le plus proche de celui choisi pour FASTMINER appelé prioritization.

Nous obtenons des mesures de précision légèrement supérieures à FASTMINER
pour le jeu a, supérieures pour le jeu b et nettement supérieures pour le jeu c. Pour
le jeu d’essai d, la précision décroît avec l’augmentation du nombre de rôles attri-
bués à chaque utilisateur. Les rôles générés ne sont pas les premiers du classement
des concepts, mais sont cependant majoritairement présents dans la SHG : la mesure de
pertinence par taille de l’extension réduite n’est donc pas adaptée à ce jeu d’essai.

Notre approche est entre 50 et 100 fois plus rapide que les performances de FAST-
MINER présentées dans [Vaidya06]. Même si le choix du langage et la programmation
inﬂuent sur les performances, la différence est sufﬁsamment signiﬁcative. Les résultats
avec un générateur de politique hiérarchisé ou non sont assez similaires, le calcul est
sensiblement plus coûteux dans le cas des hiérarchies, car le contexte formel est plus
dense.

192

Chapitre 6. Aspects techniques et réalisations

 100

 90

 80

 70

 60

 50

T (f)
P (f)
T (h)
P (h)

 30

 100

 25

 20

 15

 10

 5

 0

 90

 80

 70

 60

 50

T (f)
P (f)
T (h)
P (h)

 0  1000  2000  3000  4000  5000

 0  2000  4000  6000  8000 10000

Nombre de permissions (a)

Nombre d’utilisateurs (c)

 100

 90

 80

 70

 60

 50

T (f)
P (f)
T (h)
P (h)

 200

 100

 150

 100

 50

 90

 80

 70

 60

 0

 50

T (f)
P (f)
T (h)
P (h)

 0

 5000  10000  15000  20000

 0

 5

 10

 15

 20

Nombre d’utilisateurs (b)

Nombre de roles (d)

FIG. 6.3 – Résultats expérimentaux, moyenne sur dix exécutions

 80

 70

 60

 50

 40

 30

 20

 10

 0

 20

 15

 10

 5

 0

Nous avons également évalué les performances sur les jeux d’essai proposés par
la FIMI (Frequent Itemset Mining Implementations), qui met à disposition plusieurs jeux
d’essai volumineux pour comparer les algorithmes de data-mining. Par exemple, pour
le jeu connect de taille 67.557 objets et 129 attributs, la sous-hiérarchie de Galois est
calculée en un peu moins de 30 minutes.

6.4.2.3

Jeux d’essais réels

Nous avons eu à notre disposition deux matrices des droits issues d’une même or-
ganisation : un établissement hospitalier. L’évaluation de la pertinence des résultats
obtenus sur ces jeux d’essais est relativement difﬁcile. En effet, nous ne disposons ni de
la hiérarchie de rôles a priori comme pour les jeux d’essais synthétiques, ni d’un expert
qui puisse évaluer nos résultats.

Contrôle d’accès à une application spéciﬁque

Ce jeu d’essai est une matrice des droits d’accès d’une des applications de l’établis-
sement. Il concerne 37 utilisateurs et les 184 permissions spéciﬁques à cette application.
La SHG calculée à partir de ce jeu d’essai comporte 33 concepts et 117 relations hié-
rarchiques. Le cas limite pour cet exemple est une politique de 8 rôles avec 2 relations
d’héritage. Le temps de calcul pour ce jeu d’essai est inférieur à 0.05 seconde.

Section 6.4. Réalisation de l’identiﬁcation de concepts

193

Contrôle d’accès à des applications

L’autre jeu d’essai est la matrice d’accès aux applications de l’établissement, qui
indique parmi les 12 applications existantes qu’elles sont celles autorisées pour cha-
cun des 1.582 utilisateurs de l’organisation. La SHG calculée à partir de ce jeu d’essai
comporte 48 concepts et 93 relations hiérarchiques. L’élagage maximum conduit à une
politique de 12 concepts sans hiérarchie : il s’agit du cas limite où chaque rôle donne
exactement une permission. Le temps de calcul pour ce jeu d’essai est inférieur à 0.1
seconde.

La SHG est difﬁcile à représenter graphiquement. Le choix d’une mesure de perti-
nence et du nombre de rôles minimum que l’on souhaite permet de calculer des po-
litiques de tailles variables, comprises entre 12 et 8 rôles. Parmi les 12 applications de
la matrice, deux d’entre elles ne sont utilisées que par exactement une seule personne
chacune. Cette attribution de droit crée ainsi deux concepts propres à ces utilisateurs,
qui ne peuvent pas être supprimés.

Pour ce jeu d’essai, un expert serait peut-être en mesure de faire une analyse croisée

des concepts de la SHG entre deux aspects des rôles :

– les services de santé qui composent l’établissement,
– les fonctions des utilisateurs au sein de l’établissement,

Catégorisation des rôles obtenus

D’après les déﬁnitions de la SHG, on peut obtenir trois grandes catégories de rôles,
selon qu’un concept introduise des objets, des attributs ou les deux. On peut interpréter
ces trois catégories comme :

– les rôles pertinents : il s’agit des concepts à la fois concepts-attributs et concepts-
objets. Ces rôles sont signiﬁcatifs : des permissions et des utilisateurs leur sont
explicitement affectés.

– les rôles abstraits : il s’agit des concepts-attributs : des rôles auxquels aucun utili-
sateur n’est affecté directement, les utilisateurs étant affectés soit à leur ancêtres, soit
à leurs descendants dans la hiérarchie. Il est intéressant d’en garder certains pour
leur pouvoir structurant,

– les rôles spéciﬁques à un groupe d’utilisateurs : il s’agit des concepts-objets, ces
rôles sont à éviter. Il vaut mieux privilégier l’affectation multiple plutôt que
d’avoir à maintenir un rôle spéciﬁque à un groupe d’utilisateur qui n’apporte au-
cune permission supplémentaire que celles de ses ancêtres.

194

Chapitre 6. Aspects techniques et réalisations

6.5 Synthèse

La thèse propose une structuration relationnelle du contrôle d’accès construite
sur les fondements des bases de données. Ce chapitre a proposé une architecture de
contrôle d’accès qui exploite la correspondance entre bases de données relationnelles et
contrôle d’accès. En utilisant les primitives existantes dans les systèmes de gestion de
base de données relationnelles, nous nous affranchissons de contraintes techniques et
nous rapprochons les politiques de contrôle d’accès des données métiers. Grâce à cette
proximité, on pourra utiliser de façon homogène les primitives de gestion des données.
Un cas d’étude orienté vers les établissements de santé a été proposé pour illustrer
le cœur de la thèse sur un cas relativement concret. Le modèle du GMSIH est une réalité,
mais les difﬁcultés de vériﬁcation et d’administration d’un tel modèle le sont aussi. Le
cadre logique pour le contrôle d’accès que la thèse propose permettra peut-être d’y
répondre.

Nous avons également décrit la principale réalisation logicielle de la thèse, une bi-
bliothèque LIBDEPENDENCIES d’outils algorithmiques pour les dépendances. C’est un
outil logiciel qui nous permet de développer les outils proposés au chapitre 5. Cette
réalisation nous a permis de valider expérimentalement notre approche. Notons que
les procédures de preuves pour les dépendances génératrices de tuples contraintes
n’avaient pas été implémentées jusqu’à présent.

Enﬁn, nous avons donné les principaux résultats de notre approche d’identiﬁcation
de concepts hiérarchisés présentée en section 5.5. À notre avis, il s’agit de l’outil le plus
rapidement industrialisable proposé dans la thèse. Non pas que la LIBDEPENDENCIES
soit une gageure, mais la réalisation efﬁcace et utilisable en production d’un tel outil
dépasse largement les moyens techniques et humains dont nous disposons.

Nous avons passé sous silence la réalisation de la représentation graphique de mo-
dèles présentée en section 5.4. Nous avons réalisé un prototype de cette approche ba-
sée sur la bibliothèque Conceptual Graphs Integrated Tools allowing Nested Typed graphs
(COGITANT10). Nous avons ainsi effectué des vériﬁcations basées sur la modélisation
en graphes conceptuels des modèles et des politiques de contrôle d’accès. Malheureu-
sement, comme la bibliothèque ne propose pas d’interface graphique, c’est une trace
écrite qui résulte des inférences. Nous avons ainsi privilégié la LIBDEPENDENCIES pour
nos réalisations.

Que ce soit sur les aspects techniques de ce chapitre, sur d’autres, plus fondamen-
taux, ou encore sur la coopération de politiques structurées avec des modèles différents,
il reste de très nombreuses activités à entreprendre. Le dernier chapitre qui suit résume
la thèse et ouvre ses principales perspectives.

10http://cogitant.sourceforge.net/

Thequestionofwhethermachinescanthink...isaboutasrelevantastheques-
tionofwhethersubmarinescanswim.

Edsger Dijkstra – “The threats to computing science”

7

Conclusion et perspectives

⊲ Ce dernier chapitre conclut la thèse. Il synthétise notre approche ainsi que nos principales contri-
butions. Nous présentons cette synthèse comme une organisation du contrôle d’accès bâtie sur deux
propositions fondamentales :

1. les modèles de contrôle d’accès sont composés d’une structure, de principes et de propriétés,
2. la structure d’un modèle est déﬁnissable en termes de concepts et de relations entre ces concepts.

Ensuite, nous discutons les principaux choix de modélisation que nous avons effectués. Cette discus-

sion conduit à des perspectives organisées selon cinq axes principaux :

– les extensions et les restrictions du cadre logique,
– l’extension du périmètre de la thèse,
– la prise en compte de problématiques propres à l’administration,
– l’application du contrôle d’accès et son industrialisation,
– l’application de la proposition aux politiques de sécurité du réseau.
Certaines de ces perspectives font déjà l’objet de nos travaux actuels. ⊳

196

Chapitre 7. Conclusion et perspectives

Plan du chapitre

. .
. .

. .
. .

. .
. .

.
.

. .
. .

. .
. .

. .
. .

. .
. .

. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .

Restrictions décidables . .

Synthèse générale .

7.1
. .
7.2 Discussion générale . .

. .
. .
Restrictions sur les fragments de logique . .
7.2.1
. .
7.2.2 Déﬁnitions du contrôle d’accès . .
. .
. .
7.2.3 Organisation des perspectives .
. .
.
. .
. .
. .
. .
. .
. .
. .
Sémantique formelle de concept
. .
.
Intégrité d’un modèle de contrôle d’accès . .
. .

. .
. .
. .
. .
. .
. .
7.3 Aspects logiques du contrôle d’accès
. .
7.3.1
.
. .
7.3.2 Dépendances disjonctives .
. .
7.3.3
. .
7.3.4
Extension du périmètre du contrôle d’accès
. .
7.4.1 Automatisation de correction et mode dégradé .
7.4.2
. .
. .
. .
.
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
7.5.1 Modèle d’administration .
Indécidabilité de la sureté du contrôle d’accès
7.5.2
. .
7.5.3 Outils pour l’administration . .
. .
7.5.4
. .
Industrialisation de la proposition .
. .
7.6.1
7.6.2 Domaines d’application de la proposition . .
. .
7.6.3
. .
. .
. .
. .

7.7 Contrôle d’accès aux réseaux .
. .
. .
Choix du cadre logique

Systèmes de gestion de base de données .
. .
. .
. .
. .

. .
Représentation graphique de modèles . .
. .
. .

. .
Bibliothèque pour les dépendances . .

7.5 Administration du contrôle d’accès . .
. .

Coopération de modèles hétérogènes
. .
. .

Problématique .
. .

7.7.1
7.7.2 Objectif .
7.7.3

. .

. .
. .
. .
. .

. .
. .
. .
. .

. .
. .
. .
. .

. .
. .
. .
.

.

. .

. .
. .
. .

. .
. .

. .

. .

7.4

7.6

. .

. .

.

.
.
.
.

. .
. .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. 197
. 199
. 199
. 200
. 201
. 201
. 201
. 202
. 202
. 203
. 204
. 204
. 205
. 205
. 206
. 206
. 207
. 209
. 210
. 210
. 211
. 212
. 213
. 213
. 213
. 214

Section 7.1. Synthèse générale

197

7.1 Synthèse générale

DEPUIS ses débuts il y a plus de trente ans, le contrôle d’accès a évolué, il s’est enrichi.

En tant que moyen à mettre en œuvre pour garantir la sécurité, le contrôle d’accès
a été, dès son plus jeune âge, analysé, formalisé, vériﬁé. Ce n’est qu’une fois adopté,
que le contrôle d’accès a tâché de représenter, le plus ﬁdèlement possible, la réalité de
l’organisation des systèmes qui l’utilisent.

Si depuis plus d’une dizaine d’années, nous avons assisté à une profusion de mo-
dèles de contrôles d’accès pratiques et théoriques, il n’en reste pas moins que les mo-
dèles de contrôle d’accès partagent des fondamentaux communs. Ce que nous avons
nommé le triplet fondamental d’autorisation en est un. L’objectif de tout contrôle d’accès
est de permettre de décider si une action demandée est légitime ou non. Cette décision
est prise au regard d’un ensemble d’assertions structurées : une politique organisée
selon un modèle.

La notion de modèle de contrôle d’accès n’est d’ailleurs apparue que tardivement,
avec la multiplication des systèmes informatisés et des enjeux de leur sécurité. Les cri-
tères désirés pour les modèles ont ainsi évolué. Loin des organisations élémentaires et
militaires, le contrôle d’accès est désormais composé de structures complexes.

Nous ne pensons, ni ne désirons, détenir une quelconque vérité sur le contrôle d’ac-
cès. En revanche, nous avons essayé de bâtir une approche cohérente, logique et utili-
sable de l’organisation des droits. Ce travail a été guidé par une vision personnelle de
ce qu’est une politique de contrôle d’accès : un ensemble de données structurées. La
thèse propose ainsi une construction du contrôle d’accès, fondée sur deux assertions :

1. les modèles de contrôle d’accès sont composés :

– d’une structure qui permet d’organiser des informations,
– de principes qui permettent de dériver de nouvelles informations à partir de

celles connues, en vue de prendre les décisions d’accès,

– de propriétés que la structure et les informations doivent respecter,

2. la structure d’un modèle de contrôle d’accès est déﬁnissable en termes de

concepts et de relations entre ces concepts.

Ces deux assertions traduisent la volonté de composer une organisation des droits
qui soit la plus générale possible, mais aussi qui permette d’assurer sa vériﬁabilité.
Nous les avons formulées avec l’objectif de s’appuyer sur un existant solide : les fon-
dements des bases de données. Ainsi, une formulation équivalente de la seconde afﬁr-
mation est qu’un schéma relationnel permet de représenter la structure d’un modèle de
contrôle d’accès. À l’aide du cadre logique des bases de données, nous avons successi-
vement déﬁni à partir des travaux existants :

– politique factuelle : une instance du schéma relationnel,
– principes : un ensemble de formules qui déﬁnit une politique déduite unique,
– propriétés : un ensemble de formules qui garantit l’intégrité des politiques.

198

Chapitre 7. Conclusion et perspectives

En faisant correspondre au long de la thèse le contrôle d’accès au modèle relation-
nel, nous avons pu transposer et résoudre les problématiques auxquelles nous nous
sommes intéressés. Nous avons ainsi mis à proﬁt les outils issus des bases de données
pour déﬁnir :

– la conception de modèle,
– la vériﬁcation de la non-intégrité de modèle,
– la simpliﬁcation de modèle,
– la représentation graphique de modèle,
– la conception et la rétroconception de politique,
– l’administration de politique,
– la catégorisation statique et dynamique dans les modèles,
– la vériﬁcation de l’intégrité de politique,
– la comparaison statique de politiques.
Ces différentes déﬁnitions ont pour but de positionner les différentes activités du
contrôle d’accès, mais aussi de permettre l’utilisation d’outils génériques. Nous avons
mis en œuvre deux notions principales pour répondre à ces problématiques : la satis-
faction et l’implication. Les deux principaux problèmes théoriques sous-jacents sont :

– le problème de la satisfaction, ou de la résolution de requêtes. Il s’agit d’un pro-
blème relatif à une instance donnée. Il s’agit de déﬁnir un algorithme qui est ca-
pable de décider si oui ou non une théorie est satisfaite par cette instance ou de
construire une nouvelle instance qui la satisfait.

– le problème de l’implication logique, ou de l’équivalence de requêtes. Il s’agit
d’un problème posé sans disposer d’une instance donnée. Il s’agit de déﬁnir un
algorithme qui est capable de décider si oui ou non toute instance modèle d’une
théorie est aussi modèle d’une formule close.

La décidabilité de ces deux problèmes a guidé le choix des fragments de la logique
du premier ordre utilisés dans notre proposition. Avec le cadre modulaire des dépen-
dances, qui propose des classes à l’expressivité et à la décidabilité contrôlée, nous pou-
vons choisir soit d’adapter le cadre logique au contrôle d’accès, ou au contraire d’adap-
ter le contrôle d’accès à l’expressivité fournie par un fragment donné. Nous pouvons
ainsi composer un contrôle d’accès sur mesure, en faisant varier les restrictions sur les
formules autorisées pour la modélisation.

Informellement, si l’on disposait d’un hypothétique curseur qui représente le choix
du fragment logique, le positionner à l’extrémité « contrôle d’accès » produirait un
modèle d’organisation des droits inﬁniment souple, mais sur lequel il serait impossible
de prendre une décision. Cet extrême pourrait être une logique d’ordre supérieur.

À l’inverse, positionner l’hypothétique curseur sur l’extrémité « propriétés théo-
riques » conduirait à un modèle de contrôle d’accès parfaitement décidable, mais d’une
rigidité telle qu’il serait impossible de représenter quelque aspect structurel des orga-
nisations. On imagine un fragment restrictif comme les dépendances fonctionnelles.

Section 7.2. Discussion générale

199

Cet hypothétique curseur caricature grossièrement les deux axes de recherches que
nous avons identiﬁés dans l’état de l’art. Un objectif ambitieux est de trouver la posi-
tion limite de ce curseur, où l’expressivité est sufﬁsante pour répondre à de nombreux
besoins de modélisation, mais où les propriétés de décidabilité sont garanties.

7.2 Discussion générale

Cette section discute le choix du cadre logique, mais aussi les fondements de notre
proposition. Nous avons essayé de donner des déﬁnitions cohérentes du contrôle d’ac-
cès avec le cadre relationnel et les dépendances. Nous avons également tâché de rendre
la proposition la plus utilisable possible. Pour ces deux critères, nous avons dû faire
des choix de modélisation. Cette discussion pose le cadre général des perspectives que
nous détaillons ensuite.

7.2.1 Restrictions sur les fragments de logique

Nous avons bâti la thèse sur deux propositions fondamentales, qui résument les
traits communs que nous avons identiﬁés dans les modèles de contrôle d’accès. Nous
avons essayé d’embrasser des notions générales avec le cadre relationnel. Nos proposi-
tions imposent cependant des restrictions sévères sur la modélisation et l’utilisation du
contrôle d’accès :

– l’impossibilité de pouvoir utiliser la négation dans l’expression des principes et
des propriétés. Comme nous souhaitons utiliser les résultats des fragments de la
logique du premier ordre des dépendances de données, nous n’avons pas mis en
œuvre des modèles DATALOG ni même des langages de requêtes non récursifs
autorisant la négation,

– nous nous sommes basés sur l’existence d’une unique interprétation calculable I′
qui soit un modèle des principes. Cependant, cette restriction n’a pas été imposée
aux fragments utilisés pour les propriétés.

Ces restrictions peuvent être relâchées, mais cela impacterait fortement la thèse. En
effet, des fragments de logique autorisant la négation dont il existe une interprétation
unique calculable ont été proposés. La stratiﬁcation des règles de déduction ou la notion
de bipolarité par exemple permettent ces garanties [Abiteboul95, Halpern03].

En introduisant la négation, on ne pourrait plus utiliser les procédures pour les
dépendances de façon générique, en considérant les règles de déduction comme des
dépendances. Il serait alors possible d’utiliser les procédures de preuves pour un frag-
ment avec négation de façon générique, mais en réduisant les classes de dépendances
utilisables à celles autorisées par ces procédures.

Plutôt que la négation, nous avons fait le choix de privilégier la possibilité de quan-
tiﬁer existentiellement des variables de la conclusion et d’exprimer des contraintes sur

200

Chapitre 7. Conclusion et perspectives

ces variables. Cela nous a permis une formulation homogène de plusieurs notions et
l’expression de contraintes d’intégrité sur les politiques. Informellement, nous pour-
rions dire que nous avons choisi de privilégier l’expressivité des propriétés des mo-
dèles, plutôt que l’expressivité des principes et la possibilité d’exprimer des politiques
hybrides.

Dans le cas général, il peut être difﬁcile de formaliser en logique du premier ordre
un modèle complet. Une sévère restriction est que le modèle soit formalisable sans
symboles de fonctions, ce qui peut rendre difﬁcile, voire impossible, l’expression de
certaines propriétés. De plus, nous n’avons pas introduit la notion de temps dans la
modélisation, sauf sous forme de contraintes sur des relations dynamiques évaluées
lors de l’exécution du moniteur.

7.2.2 Déﬁnitions du contrôle d’accès

Nous avons déﬁni une modélisation de ce qu’est le contrôle d’accès à partir des tra-
vaux initiaux de Lampson pour les déﬁnitions fondamentales et sur les modèles RBAC
pour les principaux développements relatifs aux modèles structurés. D’aucuns peuvent
remettre en question les éléments que nous avons considérés comme fondamentaux ou
comme communs aux modèles de contrôle d’accès.

Nous avons en particulier passé sous silence certaines des propositions du contrôle
d’accès. Il s’agissait principalement de travaux fondés sur des principes généraux,
comme la notion de conﬂit d’intérêts. Ce principe consiste à partitionner les états du
système de contrôle d’accès et de déﬁnir des règles qui interdisent le passage d’un état
à un autre. Considérons un exemple du domaine bancaire.

On pose les banques d’une part, et les institutions de vériﬁcation des transactions
bancaires et ﬁnancières d’autre part comme étant en conﬂit d’intérêts. Un contrôle d’ac-
cès comme le modèle « Chinese Wall Policy » permet d’imposer qu’une fois un agent
entré dans une ou l’autre de ces parties, il soit impossible d’en changer [Brewer89].

Cela permet de prévenir d’éventuelles actions délictueuses où un ancien agent des
institutions de vériﬁcations deviendrait employé d’une banque et utiliserait ses anciens
contacts, accès ou tout simplement sa connaissance du système pour outrepasser ses
privilèges. Ou éventuellement dans l’autre sens, un employé d’une banque qui de-
vienne chargé de vériﬁer son ancien employeur. Nous n’avons pas introduit la notion
de conﬂit d’intérêts, car elle relève souvent des politiques de sécurité administratives
plus que des politiques de contrôle d’accès logique.

On peut également critiquer la déﬁnition de l’administration que nous avons don-
née. Nous avons restreint l’activité des administrateurs à la manipulation d’une poli-
tique en extension. Il s’agissait pour nous de diviser les activités relevant des modèles
de celles relevant des politiques. Or on pourrait autoriser dans l’administration la pos-
sibilité de déﬁnir des principes ou des propriétés, plutôt que de ﬁger une structuration.

Section 7.3. Aspects logiques du contrôle d’accès

201

On peut imaginer, dans le cas d’une politique où il n’y a que peu d’exclusion mu-
tuelle, qu’on supprime la relation d’exclusion du modèle et qu’on ajoute, au cas par cas,
des dépendances spéciﬁques sans mettre en œuvre une relation d’exclusion munie de
propriétés. Ces dépendances utiliseraient des constantes dans les termes.

Nous avons choisi de ne pas autoriser cette possibilité et d’imposer aux adminis-
trateurs de n’agir que sur des faits sans modiﬁer la théorie logique du modèle. Nous
souhaitons clairement séparer ce qui est valable pour toute politique de ce qui est spé-
ciﬁque. Nous avons opéré cette distinction par la déﬁnition de modèle et de celle de
politique, ce qui nous a permis, ensuite, de déﬁnir l’administration.

7.2.3 Organisation des perspectives

Les discussions de cette section vont être reprises plus spéciﬁquement comme
des perspectives dont nous donnons les principales directions de recherche. Les trois
premiers axes de perspectives présentés concernent directement cette discussion et
abordent le choix d’un cadre logique, l’extension du périmètre des modèles de contrôle
d’accès et l’organisation des droits des administrateurs sur les politiques.

Nous abordons ensuite des perspectives plus techniques relatives aux domaines
d’application et à la LIBDEPENDENCIES. Enﬁn, la dernière perspective propose une
réutilisation de la structuration relationnelle proposée dans thèse aux problèmes des
pare-feux. Il s’agit de directions assez générales de recherches qui font l’objet de plu-
sieurs sous-perspectives que nous décrivons dans la section suivante.

Les travaux que nous avons présentés en section 5.4 pour la représentation de mo-
dèle et l’ingénierie de rôles en section 5.5 sont des « perspectives partiellement réali-
sées » qui servent de base pour de futurs développements.

7.3 Aspects logiques du contrôle d’accès

Les quatre perspectives suivantes concernent le choix d’un cadre logique pour
l’étude du contrôle d’accès et son application pour une redéﬁnition logique de certaines
notions qui souffrent de lacunes de caractérisation formelle.

7.3.1 Restrictions décidables

Il pourrait être intéressant du point de vue théorique, mais aussi pratique, de déﬁ-
nir des restrictions décidables de certaines classes de dépendances. L’introduction du
quantiﬁcateur existentiel dans les expressions est en particulier une source d’indéci-
dabilité. Empiriquement, nous n’avons pas rencontré de modélisations naïves qui font
boucler sans ﬁn les procédures de preuves pour les dépendances.

202

Chapitre 7. Conclusion et perspectives

Ceci peut être dû au fait que nous n’avons pas utilisé de nombreuses variables quan-
tiﬁées existentiellement, et que les dépendances qui en comportent sont généralement
assez restrictives. Cette constatation expérimentale est peut-être formalisable et pour-
rait conduire à la déﬁnition d’une classe de dépendance intermédiaire entre TTGD (sans
quantiﬁcateur existentiel) et TGD (avec quantiﬁcateur existentiel) dont la décidabilité
serait garantie.

Les liens existants entre les règles de graphes conceptuels et les dépendances pour-
raient être utiles dans ce sens. En effet, en s’intéressant aux relations récursivement
déﬁnies, il a été prouvé que l’on peut identiﬁer des ilots de décidabilité en analysant
les règles de graphes [Baget06]. Ce résultat pourrait être transposable sous forme de
restriction sur les dépendances génératrices de tuples, où l’on limiterait l’utilisation du
quantiﬁcateur existentiel à des strates, comme cela a été fait pour la négation.

7.3.2 Dépendances disjonctives

En section 3.4.1.2 nous avons présenté les principales classes de dépendances exis-
tantes. Nous avons introduit les dépendances génératrices de tuples contraintes dis-
jonctives (DCTGD). Elles ont été proposées par Junhu Wang dans sa thèse sous la di-
rection de Michael Maher [Wang02]. Plusieurs procédures relatives à cette classe de
dépendances ont été développées. Il a été montré qu’elles sont strictement plus puis-
santes que celle de [Maher96].

La thèse de Wang présente de nombreuses applications des dépendances généra-
trices de tuples contraintes avec ou sans disjonctions [Wang05]. Nous n’avons pas uti-
lisé le fragment disjonctif dans notre thèse. Il faut évaluer l’intérêt de les mettre en
œuvre pour le contrôle d’accès. Un des problèmes qui surviennent est que, si on consi-
dère un fragment disjonctif de DATALOG sans contraintes en conclusion, on peut ren-
contrer plusieurs points ﬁxes. En revanche, on pourrait seulement utiliser la disjonction
pour l’expression des propriétés et non des principes. On pourrait par exemple déﬁnir
des prérequis plus complexes que ceux présentés, comme « s’il existe un utilisateur qui
dispose du rôle r, alors il existe un utilisateur qui dispose soit du rôle r1, soit du rôle
r2 ».

7.3.3 Sémantique formelle de concept

Nous avons repris la formalisation de RBAC de [Ferraiolo03b]. Or il a été remarqué
qu’elle est ambiguë, voire erronée [Li07]. La relation d’héritage peut servir à regrouper
des utilisateurs, des permissions ou les deux.

Suggestion 5 The semantics of role inheritance should be clearly speciﬁed and dis-
cussed.

Section 7.3. Aspects logiques du contrôle d’accès

203

L’étude et la mise en perspective entre contrôle d’accès et analyse de concepts for-
mels en section 5.5 nous a conduits à identiﬁer des liens entre les utilisateurs autorisés
d’un rôle et ses permissions autorisées. Nous avons principalement considéré les rôles
comme des regroupements d’utilisateurs et de permissions. Les résultats de l’analyse
de concepts formels nous permettraient de redéﬁnir la notion de hiérarchie de rôles
comme la suivante :

Déﬁnition (Sémantique de la relation d’héritage (tentative)). r1 (cid:23) r2 si et seulement si
toutes les permissions autorisées à r2 sont autorisées à r1 et tous les utilisateurs autorisés de r1
sont autorisés de r2 :

r1 (cid:23) r2 ⇔ auth_perms(r2) ⊆ auth_perms(r1)∧

auth_users(r1) ⊆ auth_users(r2)

Une telle déﬁnition, qui exploite la correspondance de Galois entre les applications
α et ω s’inscrit dans le cadre plus large de la formalisation des modèles de contrôle
d’accès, pour déﬁnir la sémantique d’un concept d’un modèle. On pourrait également
envisager de déﬁnir formellement la notion de rôle proposée dans le langage XACML
utilisé comme véhicule de politiques de contrôle d’accès.

7.3.4 Intégrité d’un modèle de contrôle d’accès

Nous avons proposé une déﬁnition générale de la non-intégrité d’un modèle de
contrôle d’accès en section 5.2.4. Elle nous a servi de base pour des vériﬁcations élé-
mentaires, mais elle ne garantit pas qu’un modèle soit intègre pour autant.

Nous avons modélisé le contrôle d’accès par une structure relationnelle AC =
(sch, P, Σ). Mais nous avons fait une distinction entre I et I′ vis-à-vis des droits
des administrateurs et imposé que l’on puisse dériver les triplets d’autorisation
Acc `es(S, A, O), Statique(U, A, O) et Dynamique(U, A, O). Nous avons également im-
posé que les relations de sch soient bien fondées à l’aide de dépendances structurelles.
Une déﬁnition formelle de l’intégrité d’un modèle devrait donc se baser sur ces hypo-
thèses. Nous pourrions proposer la déﬁnition suivante :

Déﬁnition (Modèle intègre de contrôle d’accès (tentative)). Un modèle de contrôle d’ac-
cès AC = (edb ∪ idb, P, Σ) de théorie T = P ∪ Σ est dit intègre si et seulement si T est
satisfaisable, c’est-à-dire s’il existe une politique I′ qui est un modèlde de T. Avec de plus I′
« minimale » telle que chaque relation et chaque concept de edb contient au moins un tuple et
que chaque relation de {Acc `es, Statique, Dynamique} ⊆ idb contient aussi un tuple.

L’objectif de cette déﬁnition est d’indiquer qu’un modèle n’est pas intègre si les
concepteurs ont déﬁni des relations qui ne peuvent pas être utilisées par les adminis-
trateurs pour dériver ou contraindre des autorisations.

204

Chapitre 7. Conclusion et perspectives

Il serait intéressant de construire une expression σ qui modélise cette déﬁnition de
l’intégrité pour ensuite vériﬁer si T |= σ ou T 6|= σ. Cette construction pourrait s’expri-
mer au second ordre en quantiﬁant les relations de edb. Il faudrait par exemple déﬁnir
que l’hypothèse de σ soit la plus petite possible pour représenter un critère de « minima-
lité » de I′. Il s’agirait ainsi de déﬁnir une formule de la forme :

∀R ∈ edb . . . φ(R) → Statique(U, A, O), Dynamique(U, A, O), Acc `es(S, A, O)

Dans le cas général, une ou plusieurs expressions du premier ordre pourraient être
vériﬁées à partir de cette construction. Or une telle vériﬁcation n’est pas décidable pour
certaines classes de dépendances. De plus, il n’est pas garanti que σ soit réellement
constructible ou même exprimable au premier ordre.

Nous pourrions nous appuyer sur les dépendances du second ordre proposées
dans [Fagin06] et sur les résultats de décidabilité des théories logiques [Abiteboul95,
Dehornoy07] pour parvenir à une déﬁnition de l’intégrité d’un modèle de contrôle d’ac-
cès qui exprimerait notre intuition. Cet objectif est difﬁcile du point de vue théorique.

7.4 Extension du périmètre du contrôle d’accès

Cette section présente des perspectives d’application des résultats théoriques issus
des bases de données et plus précisément des dépendances. En effet, depuis quelques
années plusieurs résultats exploitant le chase de Beeri et Vardi [Beeri84] ont été propo-
sés, pour la correction et l’intégration de bases de données notamment.

7.4.1 Automatisation de correction et mode dégradé

Lorsqu’une politique n’est pas consistante, il faut déterminer quelles sont les don-
nées à ajouter, modiﬁer ou supprimer pour la rendre intègre. Dans le cas des dépen-
dances génératrices de tuples ou de contraintes, la correction principale est la suppres-
sion de données sources d’erreurs, c’est-à-dire qu’il faut trouver un sous-ensemble de
I′, qui soit un modèle de Σ.

Ce problème a été étudié dans le cadre général des bases de données,des résul-
tats de complexité ayant été établis [Chomicki05, Bertossi06]. Un autre problème pris
en compte est celui du Consistent Query Answering, c’est-à-dire, sachant que la base de
données ne satisfait pas un ensemble de dépendances Σ, quelles sont les résultats des
requêtes qui sont sûrs, c’est-à-dire l’ensemble des tuples de I′ qui respectent Σ et qui
font partie des réponses des requêtes. Ces résultats permettraient peut-être de complé-
ter la correction de politique non intègre présentée en section 5.3.4.

Section 7.5. Administration du contrôle d’accès

205

7.4.2 Coopération de modèles hétérogènes

Les dépendances de données ont été étudiées dans le cadre de la correspondance de
schémas [Calì04, Fagin05, Fagin06]. L’objectif de ces recherches est de déﬁnir et d’iden-
tiﬁer les propriétés de dépendances génératrices de tuples permettant de faire corres-
pondre un schéma à un autre.

Plusieurs problématiques sont relatives à cette réﬂexio, comme part l’existence et la
déﬁnition d’un schéma d’intégration. Ce schéma peut être déﬁni comme une vue glo-
bale sur des sources de données (Global-As-View). À l’inverse, on peut déﬁnir les sources
comme des vues sur le schéma global (Local-As-View) selon la stratégie d’intégration et
de coopération [Calì04, Lenzerini02].

Un problème connexe est celui de l’inversion de correspondance. Connaissant les
correspondances de deux sources vers un même schéma global, est-il possible d’iden-
tiﬁer des correspondances directes entre les sources ? Ce problème est délicat et a été
partiellement résolu à l’aide de dépendances du second ordre [Fagin06].

Cet ensemble de travaux pourrait être utilisé sur la structure relationnelle du
contrôle d’accès que nous proposons dans la thèse. En effet, la coopération de poli-
tiques hétérogènes est un problème de correspondance de schémas de contrôle d’accès.
Les travaux existants et les deux paradigmes Global-As-View et Local-As-View apporte-
raient peut-être des réponses aux problèmes de la déﬁnition d’un modèle de contrôle
d’accès commun.

Sur cette base, les travaux de Ronald Fagin permettraient alors de déﬁnir des liens
de collaborations directs entre politiques hétérogènes, pourvu que l’on connaisse un
schéma commun et des dépendances exprimant les correspondances entre ce schéma
et les sources. On pourrait imaginer que le schéma global commun soit la matrice de
Lampson exprimée comme une vue sur des modèles structurés, ou bien l’inverse. En
revanche, il faut évaluer la possibilité de déﬁnir des correspondances sur des relations
déﬁnies en intention dans chaque source et sélectionner une classe de dépendance ré-
duite sur ces schémas.

7.5 Administration du contrôle d’accès

Dans la thèse, nous avons déﬁni l’administration du contrôle d’accès vis-à-vis de
la structuration relationnelle proposée. Cette section propose des perspectives de nou-
veaux outils pour les administrateurs, mais aussi sur l’organisation de leurs droits dans
notre approche.

206

Chapitre 7. Conclusion et perspectives

7.5.1 Modèle d’administration

Selon le point de vue que nous adoptons dans la thèse, les administrateurs sont
des utilisateurs du système de contrôle d’accès : ils manipulent et interrogent les po-
litiques, qui peuvent être stockées dans un système de gestion de bases de données
relationnelles. Organiser les droits des administrateurs est un enjeu considérable en
présence d’un très grand nombre d’utilisateurs. Il faut donc structurer les droits d’uti-
lisation des primitives d’administration, c’est le rôle des modèles d’administration dont
nous proposons une déﬁnition.
Déﬁnition (Modèle d’administration). Un modèle d’administration d’un modèle de
contrôle d’accès – dit modèle de base – est une organisation des droits d’utilisation des primi-
tives d’administration du modèle de base. Le modèle d’administration et le modèle de base
peuvent être structurés différemment.

Cette déﬁnition introduit une forme de récursion dans la notion d’administration.
En effet, l’ensemble des notions, de la formalisation, des problèmes et des réponses que
nous proposons dans cette thèse se retrouve dans les modèles d’administration. . . Il ne
s’agit pas d’un écueil de notre approche, mais plutôt de sa mise en abyme. On pourrait
envisager naïvement de « réitérer » la proposition de la thèse pour les modèles d’ad-
ministration. Mais de nouveaux problèmes inédits surviennent lors de la déﬁnition des
modèles d’administration.

Dans le cas des modèles à rôles, il est recommandé de limiter les permissions des
administrateurs sur la hiérarchie de rôles à des sous-ensembles de la hiérarchie. On
déﬁnit ainsi des zones d’administratives aﬁn d’éviter que les privilèges des administra-
teurs ne se recouvrent [Crampton03a]. Pour appliquer ce principe à notre structuration,
nous pourrions créer des connexions entre les opérations administratives et une déﬁ-
nition logique de ces sous-ordres. On déﬁnirait ainsi des dépendances entre le modèle
de base et le modèle d’administration. Les travaux sur la correspondance de schémas
pourraient nous apporter des éléments de réponse.

Nous avons proposé une catégorisation des aspects des modèles de contrôle d’ac-
cès en statique et dynamique relative aux droits des administrateurs sur les relations
des modèles. Or, le principe des modèles d’administration comme SARBAC est de s’at-
tacher à la hiérarchie de rôles qui est plus stable que les affectations de rôles aux uti-
lisateurs [Crampton03a]. Pour faciliter la déﬁnition de modèles d’administration dans
notre structuration relationnelle, nous pourrions envisager d’identiﬁer plus générale-
ment ces sous-ensembles des aspects statiques.

7.5.2 Indécidabilité de la sureté du contrôle d’accès

Il faut remarquer que la déﬁnition d’un modèle d’administration d’un modèle
de contrôle d’accès fait resurgir le théorème d’indécidabilité du safety problem, sec-
tion 2.2.1.2 [Harrison76]. En effet, ce résultat a été établi dans la cadre des modèles

Section 7.5. Administration du contrôle d’accès

207

DAC où les utilisateurs peuvent déﬁnir des permissions sur les objets qu’ils détiennent.
Dans le cas des modèles structurés, on pourrait penser ce problème décidable, car les
utilisateurs ne peuvent pas déﬁnir de droits, mais les administrateurs le peuvent. C’est
donc moins la sureté du modèle de base que celle du modèle d’administration qui est
indécidable.

Nous pourrions envisager de limiter la portée de ce résultat en déﬁnissant un mo-
dèle de contrôle d’accès quelconque sur lequel les utilisateurs ne peuvent pas déﬁnir de
permissions. Ensuite, les politiques de ce modèle seraient gérées selon un modèle d’ad-
ministration qui devrait être complètement décidable, comme les modèles MAC. Il faut
évaluer la portée et les implications d’une telle approche. On imagine déjà que le pro-
blème est repoussé plus loin, hors des frontières du système d’information, au niveau
des procédures administratives qui régissent l’attribution de labels dans les modèles
MAC.

7.5.3 Outils pour l’administration

Le chapitre 5 s’est intéressé à l’utilisation de la structuration relationnelle proposée
dans la thèse. Nous avons déﬁni les problèmes de conception et d’administration du
contrôle d’accès, puis nous avons proposé des outils pour assister ces activités. L’axe de
perspectives que nous présentons ici concerne ces outils. Il s’agit de capitaliser l’existant
sur la conception de schémas relationnels et d’exploiter des liens entre les dépendances,
les graphes conceptuels et l’analyse de relations binaires.

7.5.3.1 Forme normale des noyaux

Les dépendances de jointure sont intéressantes, car elles interviennent dans la dé-
composition des relations : elles permettent de garantir qu’une décomposition est sans
perte. Prenons comme exemple une relation Statique(U, R, A, O), qui stocke les autori-
sations statiques des utilisateurs et le rôle qui donne la permission. La dépendance de
jointure ⋊⋉ [{U, R}, {R, A, O}] indique que la relation Statique(U, R, A, O) est décom-
posable en deux sous relations Habilite(U, R) et A f f ecte(R, A, O), et que ces relations
permettent de reconstruire Statique(U, R, A, O) sans pertes.

Une des applications principales des dépendances de données est la conception de
base de données. Cette discipline consiste à concevoir de « bons » schémas. À partir
de la sémantique des données qu’il organise, le concepteur doit structurer un ensemble
d’attributs en relations de telle façon :

– qu’aucune donnée ne soit perdue, ou que de « fausses » données soit générées,
– que le schéma dispose de bonnes propriétés, comme la non-redondance de l’in-

formation,

– que le schéma préserve bien la sémantique des données, en particulier les dépen-

dances connues.

208

Chapitre 7. Conclusion et perspectives

Les « bonnes propriétés » désirées pour un schéma sont regroupées en formes nor-
males. Des algorithmes de mise sous forme normale existent [Abiteboul95]. Il pourrait
être bénéﬁque de les utiliser pour vériﬁer le fondement des structurations des droits.
Nous n’avons pas posé de conditions particulières sur les noyaux des modèles. On peut
imaginer d’indiquer au concepteur du modèle dans quelle forme se trouve le schéma,
et même de l’aider à le mettre sous une meilleure forme.

De tels outils existent dans les ateliers de conception de bases de données. Les com-
posants logiciels que nous avons développés dans la LIBDEPENDENCIES pourraient
être utilisés pour de tels moteurs, pour mettre des schémas sous forme normale com-
plexe, autorisant la jointure sur des relations déﬁnies récursivement par exemple. Cette
application pourrait être conduite pour le contrôle d’accès mais aussi pour des pro-
blèmes de conception de base de données plus généralement.

Les travaux de Henning Christiansen permettraient même d’étendre la notion de
validation d’un modèle [Christiansen06]. Ils recoupent la notion de simpliﬁcation de
modèle présentée en section 5.2.5. L’objectif de ces travaux est de simpliﬁer un en-
semble de contraintes d’intégrité. Leur utilisation permettrait peut-être de simpliﬁer
les propriétés d’un modèle de contrôle d’accès.

7.5.3.2 Analyse relationnelle de concepts

Nous avons présenté une méthode d’ingénierie des rôles hiérarchisés en section 5.5.
Nous l’avons construite à partir d’une structure nommée sous-hiérarchie de Galois qui
nous sert de base de rôles potentiels pour la création d’une hiérarchie pertinente.

La structure de la sous-hiérarchie de Galois a été reprise pour la déﬁnition de l’ana-
lyse relationnelle de concepts. Il ne s’agit non plus de trouver un concept intermédiaire
hiérarchisé, mais plusieurs [Hacene07, Huchard07]. Ceci nous permettrait d’identiﬁer
avec un seul algorithme plusieurs concepts entre rôles et permissions, comme ceux dé-
ﬁnis par Epstein dans sa thèse, section 5.5.1 [Epstein02].

De plus, la notion d’élagage que nous utilisons pourrait être intégrée à un algo-
rithme comme PLUTON, pour aboutir à la déﬁnition d’un algorithme de construction
de la sous-hiérarchie de Galois sous contraintes, comme il en existe pour la construc-
tion du treillis des concepts [Besson06]. Cette approche permettrait de mieux déﬁnir
le processus d’élagage que nous avons proposé comme un post-traitement de la sous-
hiérarchie de Galois.

7.5.3.3 Pavage d’une relation binaire

La recherche de rectangles dans une relation binaire est un socle commun sur le-
quel ont été déﬁnis plusieurs problèmes différents de fouille de données [Geerts04].
Les auteurs de [Vaidya07] ont déﬁni le problème de l’ingénierie des rôles comme celui

Section 7.5. Administration du contrôle d’accès

209

du pavage d’une relation binaire. Leur méthode d’analyse et d’interprétation consiste
à identiﬁer un ensemble de rôles le plus petit possible, puis d’éventuellement modiﬁer
itérativement cet ensemble pour obtenir une hiérarchie satisfaisante.

Notre déﬁnition de l’ingénierie des rôles est différente. Elle est exprimable comme
la recherche d’un ensemble partiellement ordonné dans une relation binaire, qui com-
porte toutes les intersections non vides d’utilisateurs et de permissions autorisés. Nous
nous basons sur la sous-hiérarchie de Galois pour itérer le processus de rafﬁnement.

Comme notre approche et celle de [Vaidya07] partent toutes deux d’une relation
binaire, des ponts peuvent exister entre les deux déﬁnitions. Le pavage pourrait être
une caractérisation d’un élagage maximal de la sous-hiérarchie de Galois. Le rôle de
l’expert serait alors de trouver la hiérarchie la plus satisfaisante entre ces deux extrêmes.

7.5.4 Représentation graphique de modèles

Nous décrivons ici les perspectives relatives aux représentations graphiques des
modèles et des politiques, et plus généralement l’interaction entre le concepteur ou
l’administrateur et une organisation du contrôle d’accès.

7.5.4.1 Aspects contextuels

Comme nous avons développé un cadre logique pour le contrôle d’accès sur les dé-
pendances de données, nous pouvons choisir de nous limiter à un fragment de logique
en choisissant de n’utiliser qu’une classe donnée de dépendances. Malheureusement,
les graphes conceptuels sont une forme d’équivalent graphique des dépendances géné-
ratrices de tuples totales sans contraintes. Hormis la relation d’égalité qui bénéﬁcie d’un
statut particulier, les contraintes ne sont pas exprimables dans les graphes conceptuels.
On pourrait envisager d’étendre le formalisme des graphes conceptuels avec des
pictogrammes ou de nouveaux symboles graphiques qui permettraient de représenter
des aspects qui nécessitent l’utilisation de contraintes, notamment les aspects contex-
tuels comme l’espace ou le temps. Cette solution ad hoc n’aurait cependant pas le pou-
voir d’expression des dépendances avec contraintes. On pourrait également envisager
d’ajouter les contraintes aux graphes sous forme d’annotations formelles, comme Object
Constraint Language, OCL, qui enrichit UML avec des formules logiques.

Cette solution paraît envisageable, mais il faudrait alors redéﬁnir de nouvelles pro-
cédures de chaînage capables de manipuler ces annotations formelles. De plus, les pro-
positions attenantes aux graphes conceptuels s’attachent à déﬁnir toute opération lo-
gique graphiquement. On sortirait ainsi du cadre strict des graphes conceptuels pour
se rapprocher d’une représentation plus spéciﬁque comme DTAC [Tidswell01], dotée
d’une sémantique logique correspondant à la structuration relationnelle que nous pro-
posons.

210

Chapitre 7. Conclusion et perspectives

7.5.4.2 Labélisation

Parmi les concepts présents dans le treillis des concepts formels, certains sont sup
irréductibles ou inf irréductibles [Ganter97] : ils ne peuvent pas être exprimés comme
l’union ou l’intersection d’autres concepts. Nous pensons qu’il serait intéressant d’in-
troduire cette notion dans notre proposition : à partir d’une caractérisation formelle,
nous apposerions des labels sur les concepts de la sous-hiérarchie de Galois. On pour-
rait faire intervenir ces labels accompagnés d’autres indicateurs sur les notes que nous
avons faites ﬁgurer sur les hiérarchies de la ﬁgure 5.5. L’objectif serait de faciliter la sé-
lection des concepts pertinents et l’interprétation de la hiérarchie de rôles obtenue par
l’expert. On pourrait également comparer les irréductibles aux rôles identiﬁés avec la
méthode de [Vaidya07].

7.5.4.3

Intégration des outils

Les graphes conceptuels et l’analyse de concepts formels sont liés [Wille97]. La mise
à proﬁt des résultats entre ces deux disciplines permettrait d’homogénéiser encore plus
notre proposition. Comme les graphes conceptuels sont liés au fragment des dépen-
dances et que l’analyse de concepts se fonde sur des relations binaires, un pont supplé-
mentaire entre ces deux domaines permettrait d’enrichir encore les deux aspects de la
conception de modèle et celui de la conception de hiérarchie que nous avons présentés
relativement indépendamment.

7.6 Industrialisation de la proposition

Cette section propose des directions pour améliorer notre proposition en vue d’une

éventuelle industrialisation. Il s’agit de verrous techniques, mais aussi scientiﬁques.

7.6.1 Bibliothèque pour les dépendances

La version sur laquelle nous travaillons actuellement vise à rendre la LIBDEPEN-
DENCIES plus générique, plus efﬁcace et plus utilisable. Ces objectifs passent par l’in-
dépendance des algorithmes vis-à-vis des structures de données, la mise à disposition
de meilleures interfaces mieux encapsulées et isolées. Les principaux chantiers logiciels
concernant la bibliothèque sont :

– une meilleure organisation des classes d’algorithmes, en particulier la classe outil

utilisée par les procédures CEnvironnement et ses spécialisations,

– une meilleure utilisation de la STL et des algorithmes génériques qu’elle propose,
– l’intégration de certains patrons de conception pour la structuration de la biblio-
thèque. Notamment Facade pour le solver, Patron de Méthode pour articuler les

Section 7.6. Industrialisation de la proposition

211

différentes procédures à partir d’une même base, Composite et Visitor pour les
structures de données récursives,

– l’utilisation de plus de composants logiciels offerts par BOOST et les projets pé-
riphériques, comme la gestion de l’interface ligne de commande, l’utilisation de
l’analyseur syntaxique Spirit et l’interfaçage avec les systèmes de gestion de bases
de données

– la déﬁnition générique, à l’aide de templates, des outils de manipulation de type
et de métaprogrammation. Il s’agit là d’une révision majeure qui impacterait
profondément le code avec l’adoption du paradigme Modern C++ [Abrahams04,
Alexandrescu01].

Il faut de plus s’assurer de la sécurité de la LIBDEPENDENCIES. En effet, si l’on
imagine qu’elle soit utilisée dans un logiciel déployé et mise en production, la LIB-
DEPENDENCIES serait utilisée pour les outils de raisonnement et de vériﬁcation sur le
contrôle d’accès, mais également dans le moniteur. Or le moniteur doit être incontour-
nable, inviolable et vériﬁé. Il faut donc s’assurer de la correction de l’implémentation.
La mise en place de tests fonctionnels rigoureux, de bonnes pratiques et l’intégration
de cryptographie seraient des directions envisageables.

7.6.2 Domaines d’application de la proposition

Le contrôle d’accès est un des mécanismes les plus transparents des systèmes d’in-
formation : on le retrouve dans tout type de logiciel et d’architecture. Notre proposition
pourrait donc s’appliquer pour contrôler les accès à un système d’exploitation.

Les modèles RBAC ont été mis en œuvre dans les systèmes Microsoft, Sun et ré-
cemment dans Linux, avec le projet de sécurisation orienté noyau grsecurity1. Le
cadre relationnel que nous avons construit permettrait de rétroconcevoir ces modèles
et les formaliser logiquement. On pourrait ainsi utiliser les différents outils présentés
au chapitre 5. L’expressivité du cadre des dépendances permettrait de modéliser les
spéciﬁcités des implémentations de RBAC par exemple.

Comme nous avons proposé une structuration relationnelle du contrôle d’accès,
mais aussi des outils pour le concevoir et l’administrer, une perspective d’application
qui permettrait de réutiliser le plus grand nombre de composants que nous avons déﬁ-
nis est un « centre de sécurité » pour les systèmes d’information.

Ces applications sont le centre nerveux des architectures de contrôle d’accès et de
sécurité plus généralement. Elles intègrent dans une interface et avec un cadre logiciel
commun l’ensemble des applications nécessaires à la conception et à l’administration
de sécurité. L’objectif serait d’utiliser la structure relationnelle de la thèse comme base
pour le moteur d’un tel centre de sécurité. Ainsi, nous proposerions un cadre sur lequel
construire les fonctionnalités attendues d’un tel environnement d’administration. Le

1http://www.grsecurity.net/

212

Chapitre 7. Conclusion et perspectives

centre de sécurité serait comparable à un atelier de « génie du contrôle d’accès » avec
la possibilité de vériﬁer et de simpliﬁer des modèles et des politiques.

Un langage graphique visuel inspiré des graphes conceptuels permettrait au
concepteur de sélectionner les notions qu’il veut intégrer à partir d’une bibliothèque
de concepts, relations, principes et propriétés des modèles de contrôle d’accès exis-
tants. On pourrait ainsi déﬁnir sous forme d’options à activer les propriétés que les
relations respectent : choisir que c’est une exclusion, une hiérarchie en arbre, générale,
etc. Tout serait déclaratif : la manipulation d’objet graphique serait traduite en terme
de dépendances et de relations logiques.

Un autre outil serait un atelier d’administration des politiques de contrôle d’accès.
L’atelier de conception de politique utiliserait l’outil d’ingénierie des rôles en proposant
plusieurs stratégies de sélection des concepts pertinents. Ensuite, une fois la politique
développée, on utiliserait les outils de vériﬁcation de politique pour l’administration.

7.6.3 Systèmes de gestion de base de données

Notre proposition a structuré le contrôle d’accès du point de vue des données re-
lationnelles. Dans l’architecture que nous proposons, les politiques de contrôle d’accès
sont stockées dans une base de données dédiée. Cette base de données peut être gérée
par le même système que celui qui gère déjà les données de production existante de
l’organisation. On rapproche ainsi les données métiers des données de contrôle d’accès
qui gouvernent les droits que les utilisateurs ﬁnaux ont sur les données de production.
Si les dépendances peuvent être utilisées pour les applications à la sécurité que nous
avons proposée dans la thèse, elles peuvent également être utilisées pour garantir l’in-
tégrité des données métiers stockées dans le système de gestion de bases de données.
Lorsqu’on envisage l’application de notre proposition pour contrôler l’accès à des don-
nées on doit séparer :

– d’une part, les données métiers, ou données de production, c’est-à-dire l’ensemble
des informations relatives aux activités de l’organisation et dont nous souhaitons
contrôle d’accès. Ces données sont stockées dans des bases et des tables « clas-
siques » du système,

– d’autre part, les données de sécurité, c’est-à-dire l’ensemble des informations re-
latives aux droits des usagers du système, stockées dans une base de données
spéciﬁque, typiquement dans le catalogue, apellée quelquefois métabase ou base de
données système.

La prise en compte conjointe de la modélisation des données de production et de
celle du contrôle d’accès permettrait d’exprimer des politiques bien plus complexes
et plus proches des organisations. L’objectif serait d’organiser le contrôle d’accès aux
bases de données avec les outils de bases de données.

Section 7.7. Contrôle d’accès aux réseaux

213

7.7 Contrôle d’accès aux réseaux

Cette perspective envisage de réutiliser le cadre relationnel proposé dans la thèse
pour une autre application que le contrôle d’accès logique au système d’information :
le contrôle d’accès aux réseaux. Il est même envisageable de combiner les deux ap-
plications dans une perspective d’intégration globale de la sécurité des accès : sur les
couches basses du réseau, mais aussi au niveau des applications.

7.7.1 Problématique

Les pare-feux sont désormais des outils incontournables pour garantir la sécurité
des réseaux [CERT/CC05]. La fonction d’un pare-feu est d’inspecter les trames réseau
qui le traversent pour déterminer si elles peuvent passer ou non. La prise de décision
est basée sur un ensemble de règles, sa politique, qui déﬁnit à quelles conditions une
trame doit être rejetée ou autorisée à passer. On redéﬁnit ainsi la problématique centrale
du contrôle d’accès.

Avec l’apparition d’utilisations de plus en plus sophistiquées et d’augmentation de
la taille des réseaux, les pare-feux ont évolué du simple routeur ﬁltrant à des technolo-
gies élaborées telles que l’inspection stateful ou le ﬁltrage applicatif, capables de gérer
de très gros débits de données. Ceci rend les politiques de plus en plus complexes et
nombreuses, à tel point que la politique d’un pare-feu de taille réelle peut devenir inin-
telligible pour un humain.

L’administration des pare-feux devient ainsi de plus en plus pénible et nécessite
l’utilisation rigoureuse de bonnes pratiques [CERT/CC02] sans quoi le nombre d’er-
reurs de conﬁguration rendrait le dispositif de ﬁltrage tout à fait inutile. La tâche de-
vient encore plus complexe lorsque plusieurs ﬁrewalls sont déployés dans un réseau et
que différents administrateurs interviennent.

Aﬁn de réduire au minimum le nombre d’erreurs de conﬁguration des règles de
pare-feux, qui sont une source majeure de failles, il faut proposer aux administrateurs
des outils d’interrogation et de vériﬁcation automatique des pare-feux. La structuration
et les outils proposés dans la thèse permettent peut-être d’apporter des éléments de
réponse à ce problème.

7.7.2 Objectif

La principale approche utilisée en pratique est celle du test de pénétration (pen-
testing) où l’on teste effectivement le pare-feu en envoyant des paquets et en vériﬁant
si les trames sont passées ou non, comme le ferait un éventuel pirate. Cette approche
n’est pas satisfaisante, car elle est lente, elle encombre les réseaux et elle n’est pas ﬁable.
Comment savoir si un paquet s’est perdu ou s’il a été bloqué ?

214

Chapitre 7. Conclusion et perspectives

La transposition des travaux de la thèse serait donc une approche formelle, basée
sur une modélisation de ce que sont les politiques des pare-feux, les principes qui les
gouvernent, les paquets et enﬁn la topologie du réseau. En utilisant un cadre relationnel
pour cette modélisation on disposerait d’éléments

– de représentation des principes complexes introduits dans les ﬁrewall. Par
exemple, des modules sont intégrés dans les produits existants comme iptables
pour mémoriser les connexions ou gérer l’ouverture dynamique de ports,

– d’expression d’ensemble de propriétés à vériﬁer sur les jeux de règles et permet-
tant de savoir si ces propriétés sont satisfaites ou pas, comme nous avons vériﬁé
et simpliﬁé des politiques,

– d’interrogation des pare-feux prenant en compte la topologie du réseau. On pour-
rait par exemple déterminer si un ensemble de trames peut atteindre une desti-
nation ou pas, ou identiﬁer quel ensemble de trames peut atteindre une cible
donnée.

7.7.3 Choix du cadre logique

Les problématiques des pare-feux sont pour certains aspects semblables à celles du
contrôle d’accès, mais l’utilisation faite et les contraintes de ces deux mécanismes de
protection sont différentes. Le domaine sur lequel exprimer les politiques est différent.
Alors que pour le contrôle d’accès la modélisation est composée de formules logiques
avec peu de contraintes et beaucoup de symboles de prédicats, pour les pare-feux il
s’agit plutôt d’intervalles sur des valeurs et de peu de symboles de prédicats. De plus,
les règles permettent d’exprimer soit l’autorisation soit l’interdiction de transiter. On
est dans un cas de politiques hybrides.

De plus, les ensembles principaux concernés par ces deux mécanismes sont dif-
férents : pour le contrôle d’accès, on peut manipuler des milliers d’utilisateurs, de
rôles ou de permissions, pour les pare-feux, il s’agit d’ensemble de paquets, déﬁnis
par les protocoles standards qui représentent des nombres de paquets potentiels bien
plus grands2. Certaines techniques algorithmiques coûteuses ne sont donc pas envisa-
geables.

On pourrait privilégier les travaux issus des bases de contraintes dont l’objectif est
de représenter de manière ﬁnie de très grands ensembles exprimés par des contraintes
arithmétiques [Revesz95]. Dans le paradigme des bases de contraintes, les données,
c’est-à-dire les politiques de pare-feux sont représentées en intention. On ne spéciﬁe
pas que tel ou tel paquet va être rejeté ou va passer, mais qu’un ensemble de paquets
satisfaisants à des contraintes va être rejeté ou va passer. Les règles des politiques pour-
raient être représentées par des polyèdres déﬁnis sur un espace à n-dimensions, cha-
cune représentant un champ des protocoles réseau.

2En considérant seulement quatre champs des paquets IPv4 comme l’adresse source (32 bits), de desti-
nation (32 bits), le port source (16 bits) et de destination (16 bits) on obtient déjà 296 paquets potentiels. . .

Section 7.7. Contrôle d’accès aux réseaux

215

Les propositions existantes sur l’interrogation de telles données (sélection, pro-
jection, opérations ensemblistes) permettent de donner des opérations primitives
sur lesquelles s’appuyer. Les dépendances permettraient par exemple d’imposer des
contraintes sur les dates et sur le fonctionnement des protocoles. On pourrait mo-
déliser des règles de la forme « si un ping3 est autorisé à sortir, alors le ping entrant
correspondant sera autorisé à rentrer ».

Plusieurs travaux se sont attachés à la formalisation des règles de pare-feux ou à leur
vériﬁcation, mais aucun à notre connaissance n’est capable de représenter les règles de
pare-feux dynamiques. Plusieurs éléments bibliographiques donnent des pistes pour
cette perspective :

– [Al-Shaer04, Bartal04] proposent des outils de vériﬁcations des ﬁrewalls à partir

de cinq anomalies types,

– [Adi03] propose un état de l’art sur le sujet,
– [Eronen01] propose un approche à base de programmation par contraintes qui est

à rapprocher des bases de contraintes,

– [Wool04] donne une liste des erreurs courantes à vériﬁer dans les pare-feux qui

permettrait de créer un liste de propriétés types à vériﬁer,

– [Liu04] propose un langage d’interrogation de ﬁrewall type SQL mais adapté aux

domaines de contraintes sans prédicats,

– [Gouda04] propose une structure de données efﬁcace pour la décorrélation et le
stockage des règles, c’est une première étape qui permet de supprimer la négation
des politiques,

– [Frantzen03] propose un état de l’art des théories mathématiques utilisables pour

la vériﬁcation de pare-feux,

– [Vigna03] propose une modélisation mathématique de la topologie du réseau,
utile pour la vériﬁcation de politiques impliquant plusieurs pare-feux dans un
même réseau.

Avec la reprise de la LIBDEPENDENCIES et les investigations sur les techniques de
fouille dans les relations binaires, l’application aux pare-feux est une perspective que
nous comptons réaliser à court terme et dans laquelle nous nous sommes engagés.

3Un ping est une requête d’écho attendant une réponse telle que déﬁnie dans le protocole de contrôle

Internet Control Message Protocol (ICMP) [Postel81].

Thegrandaimofallscienceistocoverthegreatestnumberofempiricalfacts
bylogicaldeductionfromthesmallestnumberofhypothesesoraxioms.

Albert Einstein

A

Préliminaires au cadre logique

⊲ La thèse s’appuie sur les dépendances de données comme outils de modélisation logique des
modèles de contrôle d’accès. Nous avons utilisé et fait référence à la logique du premier ordre dans toute
la thèse pour déﬁnir une structure relationnelle du contrôle d’accès. Cette annexe reprend des déﬁnitions
mathématiques existantes qui n’ont pas été présentées sur ce fondement. Dans ce chapitre nous décrivons :

– la logique du premier ordre,
– le modèle relationnel,
– la logique comme fondement des bases de données relationnelles.
La notation utilisée et les résultats cités sont principalement issus de Foundations of Databases
pour le modèle relationnel et sa formalisation logique (sections A.3 et A.2) [Abiteboul95]. Nous reprenons
des éléments des chapitres deux (Theoretical Background), trois (The Relational Model) et quatre
(Conjunctive Queries) dans cette annexe.

Nous nous sommes appuyés sur le chapitre sept (Logique du premier ordre) du cours de logique

et de théorie des ensembles de Patrick Dehornoy1 pour la logique du premier ordre [Dehornoy07]. ⊳

1http://www.math.unicaen.fr/~dehornoy/surveys.html

218

Annexe A. Préliminaires au cadre logique

Plan du chapitre

. .

. .

. .

.

. .

. .

A.1 Logique du premier ordre .

A.1.1
A.1.2
A.1.3
. .
A.1.4 Déduction .
. .
A.2 Modèle relationnel .
A.3 Base de données et logique . .
. .

. .
. .
Syntaxe de la logique du premier ordre .
. .
Sémantique de la logique du premier ordre .
. .
Interprétation de Herbrand . .
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .

.
.
.
.
.

. .
. .

. .
. .

. .
. .
. .
A.3.1
. .
A.3.2 Requêtes conjonctives . .

Syntaxe .

. .

. .

. .

. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .
. .

.
.
.
.
.
.
.
.
.

. .
. .
. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .
. .
. .

. 219
. 219
. 221
. 223
. 225
. 228
. 229
. 229
. 230

Section A.1. Logique du premier ordre

219

A.1 Logique du premier ordre

L’ objectif de la logique mathématique est d’étudier le raisonnement et en particulier

la vérité des propositions exprimées dans le langage des mathématiques. C’est un
langage formel qui permet la représentation de relations entre objets et la déduction
de nouvelles relations à partir de relations connues comme vraies. La logique est utile,
car c’est un cadre commun pour exprimer et déﬁnir formellement les fondements des
bases de données.

A.1.1 Syntaxe de la logique du premier ordre

Déﬁnition (Langage). Un vocabulaire, ou signature, V d’un langage L du premier ordre
est composé :

– de variables, appartenant à l’ensemble des variables Var,
– de symboles de constantes, appartenant à l’ensemble des constantes Const,
– de symboles de prédicats avec leur arité associée, appartenant à l’ensemble Pred2,
– de symboles de fonctions avec leur arité associée, appartenant à l’ensemble Fonc3,
– des connecteurs standards de la logique appartenant à l’ensemble {¬, ∧, ∨, ↔, →},
– des quantiﬁcateurs ∀ signiﬁant « pour tout » et ∃ signiﬁant « il existe »,
– ainsi que des caractères de ponctuation virgule « , » et parenthèses « ( » et « ) ».
Les ensembles Fonc, Const, Var et Pred sont disjoints.

Maintenant que nous disposons du vocabulaire de base : le lexique d’un langage
du premier ordre, nous allons déﬁnir comment construire des phrases : les règles de
syntaxes qui déﬁnissent si une phrase est bien formée.

Déﬁnition (Terme). L’ensemble Terme des termes d’un langage L sur un vocabulaire V est
déﬁni récursivement comme :

– une variable est un terme,
– une constante est un terme,
– si f ∈ Fonc est un symbole de fonction d’arité n, et t1, . . . , tn des termes alors une

expression de la forme f (t1, . . . , tn), appelée forme fonctionnelle, est un terme,

– rien d’autre n’est un terme

Une forme prédicative, ou proposition atomique, ou simplement atome, est une expres-
sion de la forme R(t1, . . . , tn), où R est un symbole de prédicat d’arité n appartenant à
Pred et t1, . . . , tn une liste de termes d’arité correspondante.

Déﬁnition (Formule). Une formule F d’un langage L est déﬁnie récursivement au moyen des
règles suivantes :

2On peut ajouter le symbole de relation binaire particulier « = ».
3Les constantes peuvent être considérées comme des fonction d’arité nulle.

220

Annexe A. Préliminaires au cadre logique

– un atome est une formule,
– si φ est une formule, alors ¬φ est une formule,
– si φ et ψ sont des formules, alors φ ∧ ψ, φ ∨ ψ, φ ↔ ψ et φ → ψ sont des formules,
– si φ est une formule et x une variable, alors ∃xφ et ∀xφ sont des formules,
– rien d’autre n’est une formule.

Un atome ou la négation d’un atome est appelé un littéral. L’ensemble des connec-
teurs est celui de la logique des propositions. Notons que l’ensemble proposé : néga-
tion (¬), conjonction (∧), disjonction (∨), équivalence (↔) et implication (→) n’est pas
minimal, mais que nous l’utilisons pour rendre plus lisible la notation. L’implication
φ → ψ en particulier, est un raccourci syntaxique pour ψ ∨ ¬φ de même que φ ↔ ψ est
équivalent à (φ → ψ) ∧ (ψ → φ). De plus, nous notons ∀x1, . . . , xn et ∃y1, . . . , yn pour
respectivement ∀x1, . . . , ∀xn et ∃y1, . . . , ∃yn

Lorsqu’une variable x appartient à une formule précédée d’un quantiﬁcateur, ∀x ou
∃x , elle est dite liée par ce quantiﬁcateur. Si une variable n’est liée par aucun quanti-
ﬁcateur, elle est libre. La distinction entre variable libre et variable liée est importante.
Une variable liée ne possède pas d’identité propre et peut être remplacée par n’importe
quel autre nom de variable qui n’apparaît pas dans la formule. Ainsi, ∃x a(x, y) est
identique à ∃z a(z, y) mais pas à ∃x a(x, z) et encore moins à ∃y a(y, y). Une formule
dont toutes les variables sont liées est appelée une formule close, ou fermée (sentence en
anglais), nous verrons que ces formules sont du plus grand intérêt. Une théorie est un
ensemble de formules closes.

Déﬁnition (Clause). Une clause est une formule fermée de la forme :

∀x1, . . . , xs(A1 ∨ . . . ∨ Ak ∨ ¬B1 ∨ . . . ∨ ¬Bn)

ou de façon équivalente

∀x1, . . . , xs(B1 ∧ . . . ∧ Bn → A1 ∨ . . . ∨ Ak)

où chaque Ai et Bi est un atome et x1, . . . , xs sont des variables apparaissant dans ces atomes.
Une clause telle que k ≤ 1 est appelée clause de Horn. Une clause telle que k = 1 et n = 0 est
appelée un fait.

Les clauses de Horn constituent une base de la programmation logique (PROLOG) et
des bases de données logiques (DATALOG). Plusieurs propositions de cadres logiques
pour le contrôle d’accès se limitent à des clauses. Cependant, leur pouvoir d’expression
est grand, mais il ne permet pas toujours d’exprimer certaines propriétés attendues des
modèles de contrôle d’accès, du moins sans passer par des réécritures (par exemple la
Skolémisation).

Section A.1. Logique du premier ordre

221

Exemple A.1 Socrate est (toujours) mortel

Prenons comme illustration de l’expression des formules de la logique un syllogisme
célèbre. Considérons le raisonnement suivant :

1. Tout homme est mortel ;
2. Socrate est un homme ;
3. donc Socrate est mortel

Ces expressions exprimées en langue naturelle peuvent s’écrire en logique dans le
vocabulaire Const = {socrate}, Var = {H}, Pred = {Homme, Mortel} et Fonc = ∅.

1. ∀H (Homme(H) → Mortel(H))
2. Homme(socrate)
3. Mortel(socrate)

Nous verrons que l’étude du raisonnement « si les propositions (1) et (2) sont vraies
alors la proposition (3) est vraie aussi » est l’objet de l’étude de la sémantique.

A.1.2 Sémantique de la logique du premier ordre

Jusqu’ici, nous n’avons pas donné de sens aux formules de la logique, nous n’avons
fait que spéciﬁer leur syntaxe. Une formule peut être interprétée comme une phrase
sur un ensemble d’objets : il est possible de lui donner une signiﬁcation vis-à-vis de cet
ensemble d’objets.

L’ensemble des objets considéré est appelé l’univers du discours, ou domaine du dis-
cours, il est noté U. Un prédicat représente une relation particulière entre les objets de U,
qui peut être vraie ou fausse. Déﬁnir cette relation revient à déﬁnir les n-uplets d’objets
qui satisfont le prédicat. L’univers du discours est donc un ensemble d’objets mathé-
matiques sur lequel une formule logique prend une valeur par interprétation :

– des constantes comme des objets particuliers,
– des variables comme des objets quelconques,
– des fonctions comme des fonctions particulières entre objets
– des prédicats comme des relations entre les objets.

Déﬁnition (Interprétation). Une interprétation4 d’un langage L de vocabulaire V est un
quadruplet I = (U, C, F, P ) où

– U est un ensemble dénombrable appelé univers du discours ou domaine d’interpréta-

tion,

– C est une fonction Const → U qui à chaque constante faire correspondre un objet de U,
– F est une fonction Un → U qui a chaque symbole de fonction n-aire f fait correspondre

son interprétation f I, un objet de U,

4En mathématique l’usage serait plutôt de traiter de structure de type V ou de réalisation de L.

222

Annexe A. Préliminaires au cadre logique

– P une fonction Un dans {vrai, f aux}, qui à chaque symbole de prédicat n-aire p fait
correspondre son interprétation pI. pI est une relation n-aire entre des objets de U, c’est-
à-dire un sous-ensemble de Un.

Une interprétation I est ﬁnie si son univers du discours est ﬁni.

Donnons un exemple de ce que peut être une interprétation. Soit le langage LN

composé à partir du vocabulaire :
– du symbole de constante 0,
– des symboles de prédicat binaires ≤, =,
– des symboles de fonction unaire S, et binaires +, ×.
Une interprétation de LN est IN = (N, 0, S, +, ×, ≤, =), où l’univers du discours
est N, 0 est associé à l’entier naturel 0, S est associée à la fonction successeur, + et ×
sont associés à l’addition et la multiplication, enﬁn, ≤ et = sont associés aux relations
inférieur ou égal et égal.

Par exemple, les formules suivantes sont bien formées dans le langage LN :
– ∀x(¬(= (S(x), 0))),
– ∀x∃y(¬(= (x, 0)) →= (S(y), x)),
– ∀x(0 ≤ x),
– ¬∃x(∀y(≤ (y, x))).
L’interprétation du terme S(S(0) + 0) est l’entier naturel 2 et les formules closes
précédentes sont évaluées à vrai dans IN. On peut par exemple associer à la dernière
formule la phrase de la langue naturelle « il n’existe pas d’entier naturel plus grand que
tous les autres ».

Déﬁnition (Valuation). Une valuation µ (de variables) est une fonction µ : Vars → U. Pour
un terme t, tI,µ est la sémantique conférée à t par I en utilisant la valuation µ pour interpréter
les variables. La valuation est récursivement étendue aux termes dans une interprétation I =
(U, C, F, P ) de la façon suivante :

– xI,µ = µ(x) si x ∈ Var
– cI,µ = d où c est un symbole de constante de Const et C fait correspondre d ∈ U à c,
– ( f (t1, . . . , tn))I,µ = f I,µ(tI,µ
1

, . . . , tI,µ

n, F fait correspondre f I,µ ∈ U à f et que les tI,µ
récursivement aux termes ti.

n ) où f est un symbole de fonction de Fonc d’arité
i ∈ U sont les éléments de U assignés

La valeur de vérité d’un atome p(t1, . . . , tn) dans une interprétation I et une valuation µ
est la valeur booléenne obtenue en appliquant la fonction pI : Un → {vrai, f aux} assignée à p
par P. Les tI,µ
, . . . , tI,µ
sont assignés aux termes t1, . . . , tn par I et µ. pI fait correspondre aux
n
1
éléments tI,µ
, . . . , tI,µ
de U une valeur booléenne. De façon équivalente, un atome est évalué à
n
1
vrai si tI,µ
, . . . , tI,µ
n ∈ pI. On écrit I |= p(t1, . . . , tn)[µ] pour indiquer que p(t1, . . . , tn) est
1
évalué à vrai dans I pour une valuation µ.

Section A.1. Logique du premier ordre

223

Dans le cas où le symbole de prédicat binaire « = » est ajouté à l’ensemble des sym-

et faux sinon.

boles de prédicats, l’interprétation de = (t1, t2) est vrai si tI,µ
Déﬁnition (Satisfaction de formule). On note µ[x/u] la valuation identique à µ, sauf pour
la variable x auquel elle fait correspondre u. Une formule φ est dite satisfaite dans une inter-
prétation I et une valuation µ, noté I |= φ[µ] ssi sa valeur de vérité est vrai.

1 = tI,µ
2

La valeur de vérité d’une formule du premier ordre φ dans une interprétation I et une
valuation µ est déterminée en fonction des valeurs de vérité des atomes en appliquant les tables
de vérité usuelles aux connecteurs logiques booléens {¬, ∧, ∨, →, ↔} et les règles suivantes
aux quantiﬁcateurs :

– ∃xφ est vraie dans I s’il existe u ∈ U tel que I |= φ[µ[x/u]]
– ∀xφ est vraie dans I si pour tout u ∈ U, I |= φ[µ[x/u]]

Toute formule close φ a donc une unique valeur de vérité pour une interprétation
donnée sur un univers du discours U, et donc quelque soit µ. On note alors I |= φ pour
indiquer que φ est satisfaite dans I, ou que I satisfait φ, ou encore que I est un modèle
de φ. Une formule φ est dite valide, noté |= φ si toute interprétation la satisfait.

Une formule close φ implique logiquement une autre formule close ψ, noté φ |= ψ, si
tout modèle de φ est aussi un modèle de ψ. On peut dire que ψ est une conséquence
logique de φ.

Une interprétation I est un modèle d’un ensemble Φ de formules closes si I satis-
fait chaque formule de Φ. Un ensemble Φ est satisfaisable s’il admet un modèle. Un
ensemble de formules Φ est valide si toute interprétation est un modèle de Φ.

La logique que nous venons de décrire dispose d’un très grand pouvoir d’expres-
sion, qui est utilisé pour exprimer formellement et raisonner dans les bases de don-
nées. Les requêtes, les vues, les règles DATALOG ainsi que les dépendances de données
peuvent être exprimées à l’aide de formules logiques, chapitre 3, dont le sens est déﬁni
grâce à la sémantique logique.

Théorème. Soient φ et ψ des formules closes de la logique du premier ordre. φ |= ψ si et
seulement si |= φ → ψ

A.1.3 Interprétation de Herbrand

Les formules de la logique du premier ordre s’interprètent dans des structures quel-
conques formées d’un domaine (l’univers du discours), d’opérateurs (les interpréta-
tions des fonctions) et de relations entre les éléments du domaine (les interprétations
des prédicats). Une formule est valide si elle est vraie dans toutes les interprétations sur
toutes les structures imaginables. . .

Nous allons maintenant nous intéresser à des interprétations particulières, qui sont
utiles dans le cadre des bases de données : les interprétations de Herbrand. Toutes ces

224

Annexe A. Préliminaires au cadre logique

Exemple A.2 Satisfaction d’une formule de l’arithmétique

La satisfaction d’une formule dépend de l’interprétation qu’on en fait, c’est-à-dire au
sens que l’on donne aux symboles du langage.
Considérons la formule close φ : ∀x1, ∃x2(x1 = x2 + 1) du langage de l’arithmétique
du premier ordre, utilisant la notation inﬁxe.
On peut déﬁnir deux interprétations IN = (N, 1, +, =) et IZ = (Z, 1, +, =) pour ce
langage, pour lesquelles φ sera évaluée différemment.
En effet, la formule φ est satisfaite dans IZ : tout nombre relatif a un prédécesseur,
mais pas dans IN, où 0 n’en a pas. φ est donc une formule satisfaisable (dans IZ)
mais pas valide (elle n’est pas satisfaite dans IN).

interprétations partagent le même univers du discours et les mêmes interprétations des
constantes et des symboles de fonctions, appelées préinterprétation de Herbrand.

Déﬁnition (Univers de Herbrand). L’univers de Herbrand d’un langage L du premier
ordre est l’ensemble des termes clos (sans variables) formés sur les symboles de fonctions et les
constantes du langage. On peut déﬁnir l’univers de Herbrand récursivement par strates :

– soit H0 l’ensemble des constantes Const de L. Si Const est vide, alors on pose H0 = {a}

où a est une constante arbitraire,

– soit Hi+1 l’union de Hi et de l’ensemble des termes de la forme f (t1, . . . , tn), pour tout

symbole de fonction f d’arité n de L et où les ti sont des éléments de Hi,

Alors limi→∞Hi = H∞ est l’univers de Herbrand du langage L.

Par exemple, pour un langage comportant comme symboles de constante a et b et

une fonction unaire f , l’univers de Herbrand est ainsi construit :

H0 = {a, b}
H1 = {a, b, f (a), f (b)}
H2 = {a, b, f (a), f (b), f ( f (a)), f ( f (b))}
. . .
H∞ = {a, b, f (a), f (b), f ( f (a)), f ( f (b)), f ( f ( f (a))), f ( f ( f (b))), f ( f ( f ( f (a)))), . . .}

Déﬁnition (Base et interprétation de Herbrand). Une préinterprétation de Herbrand
d’un langage L est un triplet H = (H∞, C, F ) où

– H∞ est l’univers du discours,
– C est la fonction identité qui à chaque constante de L fait correspondre elle même,
– F interprète chaque fonction f d’arité n comme une fonction Hn

∞ → H∞ qui fait corres-

pondre aux termes t1, . . . , tn le terme f (t1, . . . , tn) de H∞.

Une base de Herbrand BH est l’ensemble des atomes clos (positifs) formés sur les termes

de l’univers de Herbrand à l’aide des symboles de prédicats de L.

Section A.1. Logique du premier ordre

225

Une interprétation de Herbrand I = (H∞, C, F, P ) étend une préinterprétation de Her-
brand en associant à tout élément de BH une valeur de vérité, où de façon équivalente, en déﬁ-
nissant un sous-ensemble de BH qui représente les formes prédicatives vraies.

Ainsi, dans les interprétations de Herbrand, qui ne diffèrent que par P, les termes
ont un double rôles : la construction syntaxique abordée jusqu’à présent et des élé-
ments de l’univers du discours. La préinterprétation fait correspondre au symbole de
constante a, l’élément du discours a et à la construction syntaxique f (a) l’élément du
discours f (a).

Théorème (Théorème de Herbrand). Soit S un ensemble de clauses. S est insatisfaisable si
et seulement si S n’a pas de modèle de Herbrand, c’est-à-dire d’interprétation de Herbrand qui
le satisfasse.

L’étude de la satisfaction de formules peut donc être restreinte aux seules interpré-
tations « syntaxiques » que sont les interprétations de Herbrand. Cette propriété n’est
cependant pas vraie pour les formules logiques plus générales que les clauses, mais
nous savons qu’il est possible de réécrire toute formule φ en un ensemble de clauses φs
selon le processus suivant :

1. élimination des symboles d’implication → et d’équivalence ↔ par utilisation des

équivalences φ → ψ ≡ ψ ∨ ¬φ et φ ↔ ψ ≡ (ψ ∧ φ) ∨ (¬ψ ∧ ¬φ),

2. mise sous forme prénexe, c’est-à-dire sous forme d’une formule où les quantiﬁca-

teurs apparaissent au début et dont la portée s’étend sur tous les atomes,

3. élimination des quantiﬁcateurs existentiels par Skolémisation,
4. mise sous forme conjonctive (conjonction de disjonctions de littéraux), par utili-
sation des lois de De Morgan : ¬(φ ∨ ψ) ≡ (¬φ ∧ ¬ψ) et ¬(φ ∧ ψ) ≡ (¬φ ∨ ¬ψ),

5. chaque disjonction de littéraux de cette formule est alors une clause.

L’élimination des variables quantiﬁées existentiellement se fait par Skolémisation, en
remplaçant chaque variable par un terme de la forme f (x1, . . . , xn) où f est un nou-
veau symbole de fonction et où les x1, . . . , xn sont les variables quantiﬁées existen-
tiellement qui la précédent. Par exemple, la forme normale de Skolem de la formule
∀x∃y∀z p(x, y, z) est la formule ∀x∀z p(x, f (x), z). Notons que φs n’est pas équivalent
à φ mais que φs est satisfaisable si et seulement si φ est satisfaisable. Ce principe est à la
base de la programmation logique.

A.1.4 Déduction

La logique des propositions, couramment utilisée en électronique, peut être vue
comme une restriction de la logique des prédicats où seuls sont autorisés des symboles
de prédicats d’arité nulle. Dans le cas propositionnel, on peut toujours évaluer trivia-
lement la validité (ou la satisfaisabilité) d’une formule en testant toutes les affectations

226

Annexe A. Préliminaires au cadre logique

possibles de valeurs de vérité aux variables, c’est-à-dire en utilisant la méthode des
tables de vérité. Pour la logique du premier ordre, ce n’est malheureusement pas le cas.
La sémantique donnée aux formules n’a pas de caractère constructif et ne conduit
pas, par sa déﬁnition, à un algorithme. Un des résultats fondamentaux de la logique
mathématique est le développement de d’algorithmes pour déterminer l’implication
logique : c’est la notion de preuve, ou déduction, qui permet de bâtir des démonstrations
de formules logiques.

Déﬁnition (Déduction). La déduction, ou preuve, d’une formule φ d’un langage L du pre-
mier ordre à partir d’un ensemble de formules Φ appartenant également à L, noté Φ ⊢ φ est une
suite de formules ψ1, . . . , ψn telle que d’une part ψn = φ et d’autre part, ∀i ∈ [1..n − 1], ψi est
soit :

– une formule appartenant à Φ,
– soit un axiome du calcul de la logique des prédicats,
– soit la formule obtenue par application des règles de déduction à partir de formules ψj,

j < i

Les axiomes de la logique sont obtenus à partir des axiomes du calcul proposition-
nel, c’est-à-dire que ce sont des formules obtenues en substituant dans toute tautologie
de la logique des propositions des formules de L aux variables propositionnelles. Soit
A, B, C des formules, x une variable, D une formule n’ayant pas x pour variable libre et
t un terme, les formules suivantes sont axiomes de la logique du premier ordre :

1. ¬A ∨ A,
2. (A → (B → A)),
3. ((A → (B → C)) → (A → B) → (A → C)),
4. (¬B → ¬A) → (A → B),

De plus, on ajoute les axiomes spéciﬁques aux quantiﬁcateurs, (∀xA(x) → A(t))
qui est appelé l’axiome de substitution, ((D → B) → (D → ∀xB)) ainsi que ∃x¬F ↔
¬∀xF. Les deux règles de déductions étant la coupure, ou modus ponens, et la généralisa-
tion :

modus ponens

généralisation

⊢ A, ⊢ A → B

⊢ B

⊢ A,
⊢ ∀xA

Théorème (Théorème d’adéquation, de cohérence, ou de validité). Soit Φ un ensemble
de formules closes d’un langage L, et φ une formule.

Si Φ ⊢ φ alors toute interprétation qui satisfait Φ satisfait aussi φ : Φ ⊢ φ implique
Φ |= φ. En particulier, si Φ est valide, il en est de même pour φ. ⊢ Φ implique |= φ : toute
formule prouvable est valide.

Section A.1. Logique du premier ordre

227

Théorème (Théorème de déduction). Soient Φ un ensemble de formules closes d’un langage
L, et φ et ψ deux formules, on suppose φ close. Φ ⊢ φ → ψ est équivalent à Φ ∪ {φ} ⊢ ψ.

On appelle consistant tout ensemble de formules closes (une théorie) qui une prouve

jamais à la fois une formule et sa négation.

Théorème (Théorème de déduction, corollaire). Soient Φ un ensemble de formules closes
d’un langage L, et φ une formule.

– Φ prouve ψ si et seulement si l’extension Φ ∪ {φ} est inconsistante.
– si Φ est consistante, l’une a moins des extensions Φ ∪ {φ}, Φ ∪ {¬φ} est consistante.

Théorème (Théorème de complétude, Gödel). Soit Φ un ensemble de formules closes d’un
langage L, et φ une formule.

Si Φ |= φ alors il existe une preuve φ utilisant Φ comme hypothèses : Φ |= φ implique

Φ ⊢ φ.

Pour des raisons techniques (la description d’algorithmes de preuve), nous allons

également introduire la déﬁnition d’une substitution.

Déﬁnition (Substitution). Une substitution σ est un ensemble ﬁni de substitutions élémen-
taires (xi/ti) notée σ = {(x1/t1), . . . , (xn/tn)} où les xi sont des variables deux à deux
distinctes et où les ti sont des termes.

Soit F une formule, l’application de la substitution σ à la formule F notée σ(F) est le résultat
de la substitution simultanée dans F de chaque occurrence de xi par le terme ti et telle que chaque
occurrence de xi qui était libre dans F ne devienne pas liée.

Une substitution σ telle que pour deux atomes t1 et t2, σ(t1) = σ(t2) est appelée un uniﬁ-

cateur de t1 et t2.

228

Annexe A. Préliminaires au cadre logique

A.2 Modèle relationnel

Le concept mathématique sous-jacent au modèle relationnel est celui de relation
dans la théorie des ensembles, c’est-à-dire un sous-ensemble du produit cartésien de
domaines.

Déﬁnition (Attribut). Un attribut est un symbole d’un ensemble ﬁni U = {A1, . . . , An}
appelé univers. Tous les ensembles d’attributs sont des sous-ensembles de U pour lesquels nous
omettons les accolades, ainsi ABC désigne {A, B, C}.

Soit dom un ensemble dénombrable de constantes. À chaque attribut A est associé un en-

semble dénombrable de valeurs atomiques appelé domaine noté Dom(A) ⊆ dom.

Déﬁnition (Produit cartésien). Le produit cartésien des domaines D1, . . . , Dk noté D1 ×
. . . × Dk est l’ensemble P des k-uplets (v1, . . . , vn) tels que ∀vi ∈ Di : (v1, . . . , vk) ∈ P.

Déﬁnition (Relation). Soit relname un ensemble dénombrable de noms de relations. Un
schéma de relation R ∈ relname est un ensemble ﬁni d’attributs A1 . . . An. L’arité d’un
schéma de relation est la cardinalité de son ensemble d’attributs.

Une instance de relation de schéma R = A1 . . . An de domaines respectifs Di = Dom(Ai)
est un sous-ensemble du produit cartésien D1 × . . . × Dn. Une instance de relation est donc un
ensemble de n-uplets appelés tuples (v1, . . . , vn) avec ∀i vi ∈ Di.

Pour un tuple t sur un schéma R et un ensemble X ⊆ R, la notation t[X] est la restriction
de t à X. Un tuple t sur un schéma de relation R peut, de façon équivalente, être déﬁni comme
une application R :→ ∪A∈RDom(A) telle que ∀A ∈ R, t[A] ∈ Dom(A).

Déﬁnition (Base de donnée). Un schéma de base de donnée, ou simplement schéma, R
est un ensemble ﬁni non vide de schémas de relations {R1, . . . , Rn}.

Une instance de base de données, ou simplement une base de données, I est un ensemble
d’instances de relations sur le schéma de base de données. Pour distinguer les schémas et ins-
tances de base de données des schémas et instances de relation, nous utilisons une police
différente. Par exemple : R est un schéma de base de données, R un schéma de relation, I une
instance de base de données, I une instance de relation.

La représentation habituelle des bases de données relationnelles est celle de tables.
À chaque table est associé un nom de relation, les colonnes de la tables sont les attri-
buts. Chaque ligne de la table est un tuple ou enregistrement. Les valeurs des tuples sont
prises dans un ensemble de constantes, le domaine, qui en général contient les entiers,
les chaînes de caractères, les booléens, mais aussi les dates ou des structures plus com-
plexes comme les images dans les systèmes de gestion de base de données contempo-
rains. Le schéma spéciﬁe la structure de la base de données, l’instance donne sa valeur
actuelle.

Section A.3. Base de données et logique

229

A.3 Base de données et logique

Dans le cadre de la logique, la fonction de correspondance C d’une interprétation
peut, à deux symboles de constantes différents faire correspondre un seul et même
élément de l’univers du discours U. Cependant, nous nous intéressons à la logique
pour son application aux bases de données, ce qui conduit aux spécialisations sui-
vantes [Abiteboul95] :

– les symboles de fonctions ne sont pas autorisés dans la construction des formules,
– les bases de données étant par essence ﬁnies, les interprétations le sont aussi,
– les constantes ont un statut particulier, elles sont toutes distinctes.

A.3.1 Syntaxe

Le fait que les fonctions ne soient pas autorisées dans la construction des formules
est une restriction importante, mais qui permet de simpliﬁer et de garantir la ﬁnitude
des ensembles manipulés. Pour mettre en parallèle les déﬁnitions proposées en sec-
tion 3.2.1 et le cadre de la logique, nous nous donnons le langage LR associé au schéma
d’une base de données R. Le vocabulaire du langage LR se compose :

– d’un ensemble de variables,
– d’un ensemble ﬁni de constantes : les valeurs possibles dom,
– d’aucun symbole de fonction,
– d’un ensemble ﬁni de symboles de prédicats n-aires, auxquels correspondent les

symboles de relation n-aires de relname,

– à chaque forme prédicative de LR correspond un schéma de relation de R.
Le procédé de formation des formules est le même que celui décrit pour la logique
du premier ordre. On note que l’univers de Herbrand est d’une part ﬁni, et d’autre part
limité à sa première strate H∞ = H0. Ainsi, lorsqu’on interprète les formules de LR :

– un prédicat représente une relation particulière entres les objets du discours : dé-
ﬁnir cette relation revient à déﬁnir les tuples qui satisfont le prédicat : l’instance
de relation,

– à chaque place de terme dans un atome, correspond un ensemble de constantes,

le domaine,

– la notion d’attribut du modèle relationnel disparait et est remplacée par la position

des termes dans les atomes,

– une interprétation consistant à déﬁnir les relations vraies entre les éléments du
domaine, une base de données peut être déﬁnie comme l’interprétation (ﬁnie)
de LR. En particulier, une instance de base de données peut être assimilée à une
interprétation de Herbrand ﬁnie, ce qui permet de confondre les notations I |= φ
et I |= φ où I est une interprétation et I une instance de base de données.

230

Annexe A. Préliminaires au cadre logique

Une autre hypothèse faite dans les bases de données est l’hypothèse du monde clos, qui
signiﬁe que seuls sont considérés comme vrais les faits stockés dans la base de données.
Les faits non enregistrés dans une extension de prédicats (c’est-à-dire une relation) sont
supposés faux, à la différence de l’hypothèse du monde ouvert où un fait non enregistré est
considéré comme inconnu. L’hypothèse du monde clos suppose donc une connaissance
complète du monde réel que la base de données décrit, mais dont on n’enregistre que
les faits positifs, pour minimiser la taille des informations stockées.

Enﬁn, pour permettre l’expression de requêtes incluant des comparaisons sur les
éléments du domaine d’un attribut, le langage logique est étendu pour inclure le prédi-
cat binaire « = » d’égalité entre termes. On peut étendre les comparaisons avec d’autres
prédicats particuliers, dont la valeur de vérité est calculable par la machine et indépen-
damment des instances, appelés prédicats built-in, comme les relations de comparai-
sons usuelles sur les entiers (≤, <, ≥, >, =, 6=).

Selon que l’on restreigne l’expression des formules de LR, la logique du premier
ordre permet de représenter et de déﬁnir la sémantique de différents composants des
bases de données relationnelles :

– des requêtes sur la base de données,
– des vues sur la base de données,
– des règles de déductions de nouvelles données à partir des connues,
– des dépendances entre les données.

A.3.2 Requêtes conjonctives

La syntaxe et la sémantique des requêtes conjonctives peuvent être déﬁnies sans uti-
liser la logique, avec l’algèbre relationnelle par exemple. Il s’agit d’ailleurs du point de
vue adopté au départ de l’étude du modèle relationnel. Ce n’est que plus tard que le
pont entre logique et modèle relationnel a été fait. Il s’avère que les requêtes exprimées
en algèbre relationnelle et en logique sont équivalentes : elles ont le même pouvoir
d’expression [Abiteboul95].

Déﬁnition (Requête conjonctive). Une formule du calcul conjonctif sur un schéma de base
de données de R est une expression de la forme :

– un atome est une formule de requête conjonctive,
– si φ et ψ sont des formules alors φ ∧ ψ sont des formules,
– si φ est une formule et x une variable, alors ∃xφ est une formule,
Une requête conjonctive sur un schéma de base de données de R est une expression :

{e1, . . . , em | φ}

où φ est une formule du calcul conjonctif, e1, . . . , em un tuple libre et l’ensemble des variables

apparaissant dans e1, . . . , em est exactement l’ensemble des variables libres de φ.

Section A.3. Base de données et logique

231

Une instance de base de données I sur le schéma R satisfait une formule φ du calcul conjonc-

tif pour une valuation ν, noté I |= φ[ν], si

– soit φ = R(u) est un atome et ν(u) ∈ I(R),
– soit φ = (ψ ∧ ξ) est une conjonction de formules et I |= ψ[ν] et I |= ξ[ν],
– soit φ = ∃xψ et pour une constante c ∈ dom, I |= ψ[ν[x/c]]
Enﬁn, q = {e1, . . . , em | φ} une requête conjonctive sur un schéma R. Pour une instance I,

l’image de I par q est :

q(I) = {ν(< e1, . . . , em >) | I |= φ[ν]et ν est une valuation sur les variables libres de φ}

Le langage des formules du calcul conjonctif est donc un sous-ensemble de LR. Les
réponses d’une requête forment une relation en intention, c’est-à-dire une relation dont
on n’a pas déﬁni explicitement l’instance, mais dont on a déﬁni la propriété φ qu’elle
doit respecter.

Ceci conduit au concept de vue utilisé dans les systèmes de gestion de base de don-
nées et évoqué en section 2.2.3. Une vue est simplement une requête conjonctive à la-
quelle on fait correspondre un nom de relation, ne faisant pas partie de R, en d’autre
termes un nouveau symbole de prédicat.

IfIhadeighthourstochopdownatree,Iwouldspendsixhourssharpening
anaxe.

Anonymous

B

Théories logiques

⊲ Cette annexe propose des compléments techniques : des listes des symboles et deux exemples de

théories logiques pour représenter des modèles de contrôle d’accès.

En premier lieu, nous synthétisons les principaux symboles utilisés dans la thèse. Ils sont classés
selon qu’ils sont utilisés pour les déﬁnitions ensemblistes, pour la déﬁnition du cadre relationnel ou pour
la représentation logique de modèles de contrôle d’accès.

Ensuite, nous présentons une théorie logique pour les modèles MAC et nous rassemblons les expres-
sions logiques déﬁnies pour les modèles RBAC au long des différents chapitres. Cette théorie sert de base
pour les traces proposées dans l’annexe suivante. ⊳

234

Annexe B. Théories logiques

Plan du chapitre

. .

. .

. .

. .

. .

. .
. .
. .
. .
. .
. .
. .

.
.
.
.
.
.
.

. .
. .
. .
. .
. .
. .
. .

. .
. .
. .
. .
. .
. .
. .

. 235
. 235
. 236
. 237
. 238
. 238
. 239

B.1

. .

. .

. .

.

. .

Symboles utilisés . .
. .
B.1.1 Déﬁnitions ensemblistes du contrôle d’accès . .
B.1.2
. .
. .
B.1.3
. .
. .
. .

. .
Structuration relationnelle .
Prédicats du contrôle d’accès .
. .
. .
. .

. .
. .
. .
. .
. .

. .
. .
. .
. .
. .

. .
. .
. .
. .
. .

B.2 Modèles de contrôle d’accès
. .
. .

B.2.1 MAC . .
B.2.2
RBAC . .

. .
. .

. .
. .

. .
. .
. .
. .
. .

.
. .
. .

. .
. .
. .

.
.
.

Section B.1. Symboles utilisés

235

B.1 Symboles utilisés

LA thèse a repris et déﬁni plusieurs symboles, nous les rassemblons dans cette sec-

tion. Les symboles sont classés en trois catégories selon qu’ils sont utilisés pour :
– la déﬁnition ensembliste du contrôle d’accès,
– la déﬁnition de la structuration relationnelle proposée,
– la représentation des modèles avec la structuration relationnelle.

B.1.1 Déﬁnitions ensemblistes du contrôle d’accès

Les symboles que nous regroupons dans le tableau B.1 sont ceux issus des propo-
sitions existantes étudiées dans l’état de l’art du chapitre 2 que nous reprennons par la
suite. Le tableau B.1 synthétise les symboles pour lesquels nous avons utilisé une police
calligraphiée (S, A, O . . . ). Ces symboles concernent principalement les modèles RBAC.

Symbole

U
S
O
A

R

P ⊆ O × A

U RA ⊆ U × R
PRA ⊆ R × P

SU ⊆ S × U
SR ⊆ S × R
RH ⊆ R × R

auth_users : R → 2U
auth_perms : R → 2P

assigned_users : R → 2U
assigned_perms : R → 2P

ME R ⊆ R × R

ACCE SS ⊆ S × A × O

F : S × A × O → {vrai, f aux}

2.1.3

2.3.1

×

×
×

×
×
×
×

×

×
×
×
×

×
×
×
×
×
×

Description Fact.1 Stat.2 Réf.
utilisateurs
sujets (ou session)
objets
actions
rôles
permission
affectation
affectation
association
association
hiérarchie ((cid:23), (cid:22))
utilisateurs autorisés
permissions autorisés
utilisateurs assignés
permissions assignées
exclusion entre rôles
triplet d’autorisation
moniteur

2.5.1
4.1.1
4.1.2

×
×
×
×

×

2.3.2

TAB. B.1 – Symboles ensemblistes du contrôle d’accès

236

Annexe B. Théories logiques

B.1.2 Structuration relationnelle

Nous synthétisons ici les différents symboles utilisés pour la déﬁnition de la stru-
ture relationnelle sur laquelle nous développons la thèse. Les symboles sont pré-
sentés en section 4.1.3. Pour un symbole donné, nous proposons son inteprétation
comme composant d’un modèle de contrôle d’accès (en italique) et son nom consacré
dans [Abiteboul95].

Symbole

AC = (sch, P, Σ)

sch = edb ∪ idb

edb
idb

P

Σ = Σedb ∪ Σidb

Σedb
Σidb

I = Is ∪ Id

Is
Id

I′ = I′

s ∪ I′
d

I′
s
I′
d

Description
modèle de contrôle d’accès
base de données déductive
schéma
schéma en extension (noyau)
schéma en intention
principes du modèle
règles de déduction
propriétés du modèle
dépendances de données
propriétés de edb
propriétés de idb
politique factuelle (en extension)
instance de edb
politique factuelle statique
politique factuelle dynamique
politique déduite (en intention)
instance de sch
plus petit point ﬁxe unique de P
politique déduite statique
politique déduite dynamique

TAB. B.2 – Structuration relationnelle

Section B.1. Symboles utilisés

237

B.1.3 Prédicats du contrôle d’accès

Une fois la structuration relationnelle déﬁnie, nous avons modélisé le contrôle d’ac-
cès sous forme logique dans le chapitre 4. Nous rassemblons ici les principaux sym-
boles de prédicats utilisés dans les schémas. Nous notons Nom/n pour indiquer que le
symbole de prédicat Nom est d’arité n.

Symbole
User/1
Sujet/1
Action/1
Objet/1
Role/1
Label/1

Habilite/2
A f f ecte/3
Repr ´esente/2

Endosse/2
Accred/2
Classi f /2
Perm/3

AuthUsers/2

AssignedUsers/2

AuthPerms/2

AssignedPerms/2

Acc `es/3
Statique/3

Dynamique/3

DomineC
H ´eriteC

S ´eparationC
ExclusionC

Description Fact. Stat.

utilisateur (U)
sujet ou session (S)
action (A)
objet (O)
rôle RBAC (R)
label MAC
rôles-utilisateurs (U RA)
rôles-permissions (PRA)
sessions-utilisateur (SU)
sessions-rôles (SR)
label-utilisateur
label-objet
permission, actions-objets
rôles-utilisateurs
rôles-utilisateurs
rôles-permissions
rôles-permissions
triplet fondamental (ACCE SS)
orienté utilisateurs statique
orienté utilisateurs dynamique
héritage en extension sur C
héritage en intention sur C (RH)
exclusion en extension sur C
exclusion en intention sur C (ME R)

TAB. B.3 – Symboles de prédicats

×
×
×
×
×
×

×
×
×
×
×
×

×

×

×

×
×
×
×

×
×

×
×
×

×
×
×
×

×

×
×
×
×

238

Annexe B. Théories logiques

B.2 Modèles de contrôle d’accès

B.2.1 MAC

Les modèles MAC sont des modèles structurés simples et efﬁcaces basés sur deux
règles de déduction permettant de dériver le triplet Acc `es, section 2.2.2. Les modèles
MAC sont fondés sur des labels hiérarchisés en ordre total ou en treillis. Le tableau B.4
présente les expressions logiques représentant successivement :

– utilisateurs et sujets sont mis en bijection (ρ),
– les labels MACsont hiérarchisés (α),
– la hiérarchie des labels est un treillis (β),
– chaque sujet et objet est associé à un unique label (γ),
– on dérive les actions autorisées à partir de la hiérarchie. On note le statut particu-

lier des deux actions read et write dans ces dépendances (δ),

– on ne peut pas obtenir de permissions sans label (λ).

Type
TTGD
TTGD

TTGD
TTGD
TTGD
EGD

TGD
TGD

EGD
EGD

TTGD
TTGD

TGD
TGD

ρ1
ρ2

α1
α2
α3
α4

β1
β1

γ1
γ2

δ1
δ2

λ1
λ2

Expression logique
User(U) → Sujet(S)
Sujet(S) → User(U)

Label(ID) → DomineL(ID, ID)

DomineL(ID1, ID2) → H ´eriteL(ID1, ID2)

DomineL(ID1, ID2), H ´eriteL(ID2, ID3) → H ´eriteL(ID1, ID3)

H ´eriteL(ID1, ID2), H ´eriteL(ID2, ID1) → ID1 = ID2

Label(ID1), Label(ID2) → ∃ID⊥H ´eriteL(ID1, ID⊥), H ´eriteL(ID2, ID⊥)
Label(ID1), Label(ID2) → ∃ID⊤ H ´eriteL(ID⊤, ID1), H ´eriteL(ID⊤, ID2)

Accred(S, L1), Accred(S, L2) → L1 = L2
Classi f (O, L1), Classi f (O, L2) → L1 = L2

Accred(S, L1), H ´eriteL(L1, L2), Classi f (O, L2) → Acc `es(S, read, O)
Accred(S, L1), H ´eriteL(L2, L1), Classi f (O, L2) → Acc `es(S, write, O)
Acc `es(S, read, O) → Accred(S, L1), H ´eriteL(L1, L2), Classi f (O, L2)
Acc `es(S, write, O) → Accred(S, L1), H ´eriteL(L2, L1), Classi f (O, L2)

TAB. B.4 – Théorie logique des modèles MAC en treillis

Soit T la théorie logique du tableau B.4. À l’aide d’un chase, on peut dériver le théo-
rème T |= Acc `es(S, read, O), Acc `es(S, write, O) → ∃L Accred(S, L), Classi f (O, L). Les
étapes d’une telle dérivation sont :

1. supposons un sujet s et un objet o tels que Acc `es(s, read, o), Acc `es(s, write, o),
2. par application de λ1 on dérive Accred(s, l1), H ´eriteL(l1, l2) et Classi f (o, l2),
3. par application de λ2 on dérive Accred(s, l′
2),

1) et Classi f (o, l′

1), H ´eriteL(l′

2, l′

Section B.2. Modèles de contrôle d’accès

239

4. par application de γ1 on dérive l1 = l′
5. par application de γ2 on dérive l2 = l′
6. ∃L Accred(S, L), Classi f (O, L) est vériﬁée avec Accred(s, l1) et Classi f (o, l2).

1 (on identiﬁe les symboles),
2 (on identiﬁe les symboles),

B.2.2 RBAC

La famille des modèles RBAC a reçu une attention particulière, c’est en effet une
des principales sources qui a conduit à l’élaboration des multiples modèles que nous
pouvons désormais rencontrer. De plus, de nombreuses extensions et formalisations
indépendantes de ces modèles ont été proposées, chapitre 2.

Au long de la thèse, nous avons très souvent fait référence aux modèles « ofﬁ-
ciels » du standard RBAC, c’est-à-dire les modèles de référence RBAC0, RBAC1, RBAC2
et RBAC3 [Ferraiolo03b]. Les tableaux B.5 et B.6 synthétisent les expressions logiques
que nous avons développées dans la thèse. Ces formules sont regroupées selon les sec-
tions où elles apparaissent.

Une légende verticale indique à quel modèle le plus bas dans la famille ces formules
s’appliquent. Une formule d’un modèle est valide pour les modèles qui s’appuient
dessus, ﬁgure2.3. Le premier tableau s’applique aux modèles RBAC0 (noyau, principes
fondamentaux) et RBAC1 (hiérarchie). Le second tableau concerne les modèles RBAC2
(contraintes) et RBAC3 (contraintes, hiérarchie et contraintes sur hiérarchie).

240

Annexe B. Théories logiques

Type

Expression logique

section 3.4.4 et section 4.2.3

0 σ0
C
A
σ1
B
R
σ2

TGD
FD

TTGD

Endosse(S, R) → ∃U Repr ´esente(S, U)

Repr ´esente(S, U1), Repr ´esente(S, U2) → U1 = U2
Repr ´esente(S, U), Endosse(S, R) → Habilite(U, R)

section 3.4.4 et section 4.3.3

0 σ3
C
A
σ4
B
R
σ5

Statique(U, A, O) → ∃R Habilite(U, R), A f f ecte(R, A, O)

TGD
TGD
TGD Dynamique(U, A, O) → ∃S Repr ´esente(S, U), Statique(U, A, O)

Acc `es(S, A, O) → ∃R Endosse(S, R), A f f ecte(R, A, O)

section 3.3.3 et section 4.3

0 τ1
C
A
τ2
B
R
τ3

TTGD
TTGD
TTGD

Endosse(S, R), A f f ecte(R, A, O) → Acc `es(S, A, O)

Habilite(U, R), A f f ecte(R, A, O) → Statique(U, A, O)

Repr ´esente(S, U), Acc `es(S, A, O) → Dynamique(U, A, O)

section 3.3.3.2 et section 4.3.4

1 ρ0
C
ρ1
A
B
ρ2
R
ρ′

TTGD
TTGD
TTGD
EGD

1
C
A
B
R

1
C
A
B
R

α1
α2
α3
α4
α5

β1
β2
β3
β4
β5

TTGD
TTGD
TTGD
TTGD
TTGD

TGD
TGD
TGD
TGD
TGD

Domine(R1, R2) → H ´erite(R1, R2)

Domine(R1, R2), H ´erite(R2, R3) → H ´erite(R1, R3)

Role(R) → Domine(R, R)

H ´erite(R1, R2), H ´erite(R2, R1) → R2 = R1
section 4.3, section 4.3.4 et section 5.5.4.3

Habilite(U, R1), Domine(R1, R2) → AuthUsers(R2, U)

A f f ecte(R2, A, O), Domine(R1, R2) → AuthPerms(R1, A, O)

Endosse(S, R), AuthPerms(R, A, O) → Acc `es(S, A, O)

Habilite(U, R), AuthPerms(R, A, O) → Statique(U, A, O)
Repr ´esente(S, U), Acc `es(S, A, O) → Dynamique(U, A, O)

section 4.3.3

AuthUsers(R2, U) → Habilite(U, R1), Domine(R1, R2)

AuthPerms(R1, A, O) → A f f ecte(R2, A, O), Domine(R1, R2)

Acc `es(S, A, O) → Endosse(S, R), AuthPerms(R, A, O)

Statique(U, A, O) → Habilite(U, R), AuthPerms(R, A, O)

Dynamique(U, A, O) → Repr ´esente(S, U),

Endosse(S, R), AuthPerms(R, A, O)

TAB. B.5 – Théorie logique des modèles RBAC1 et RBAC2

Section B.2. Modèles de contrôle d’accès

241

Type

2 γ0
C
A
γs
B
R
γr

TTGD
TTGD
NGD

γ1
γ2
γ3
γ4
γ5

NGD
NGD
NGD
NGD
NGD

2
C
A
B
R

3 λ0
C
λt
A
B
λs
R

TTGD
TTGD
TGD

3 λ1
C
A
λ2
B
R
λd

NGD
NGD
TTGD

Expression logique

section 3.4.6 et section 4.5.2

S ´eparation(R1, R2) → Exclusion(R1, R2)
Exclusion(R1, R2) → Exclusion(R2, R1)

Exclusion(R, R) → ⊥

section 3.4.6 et section 4.5.2, choisir une des cinq sémantiques

Exclusion(R1, R2), Habilite(U, R1), Habilite(U, R2) → ⊥
Exclusion(R1, R2), Endosse(S, R1), Endosse(S, R2) → ⊥

Exclusion(R1, R2), A f f ecte(R1, A, O), A f f ecte(R2, A, O) → ⊥
Exclusion(R1, R2), A f f ecte(R1, A1, O), A f f ecte(R2, A2, O) → ⊥

Exclusion(R1, R2), Endosse(S, R1), Endosse(S, R2),

Repr ´esente(S, U), Repr ´esente(S, U) → ⊥

section 4.5.3 et section 4.5.5

Exclusion(R1, R2), H ´erite(R, R1) → Exclusion(R, R2)
D ´epend(R1, R2), N ´ecessite(R2, R3) → N ´ecessite(R1, R3)

N ´ecessite(Sub, Sup), Domine(Sup, Sub),
Habilite(U, Sub) → ∃U′Habilite(U′, Sub)

formules redondantes, section 5.2.5

Exclusion(R1, R2), H ´erite(R, R1), H ´erite(R, R2) → ⊥

H ´erite(R1, R2), Exclusion(R1, R2) → ⊥

Dynamique(U, A, O) → Statique(U, A, O)

TAB. B.6 – Théorie logique des modèles RBAC2 et RBAC3

Letuschangeourtraditionalattitudetotheconstructionofprograms.
Insteadofimaginingthatourmaintaskistoinstructacomputerwhattodo,let
usconcentrateratheronexplainingtohumanbeingswhatwewantacomputer
todo.

Donald Knuth

C

Traces d’inférence

⊲ Cette annexe propose deux traces d’inférence commentées obtenues avec la LIBDEPENDENCIES.
Il s’agit d’illustrer la preuve syntaxique de propriétés des modèles de contrôle d’accès. Nous décrivons
les résultats obtenus avec notre prototype à l’aide de la théorie logique des modèles RBAC présentée dans
l’annexe précédente. ⊳

244

Annexe C. Traces d’inférence

Plan du chapitre

C.1
C.2

Inclusion des triplets d’autorisation . .
. .
Simpliﬁcation des propriétés de l’exclusion mutuelle . .

. .

. .

. .

. .

. .
. .

.
.

. .
. .

. .
. .

. 245
. 247

Section C.1. Inclusion des triplets d’autorisation

245

AFIN d’illustrer l’intérêt de l’utilisaiton des procédures de preuves pour la vériﬁca-

tion de modèles de contrôle d’accès, nous proposons deux traces, qui reprennent
deux exemples de preuve présentés dans la thèse. Les dépendances auxquelles nous
faisont référence dans les traces sont celles du tableau B.6. L’algorithme utilisé est l’ex-
tension par Maher du chase de Beeri et Vardi, section 3.4.2.2, [Beeri84, Maher96]. Cet
algorithme est décrit par la ﬁgure 3.2.

C.1 Inclusion des triplets d’autorisation

Cette première trace correspond à la preuve fournie par la LIBDEPENDENCIES dé-
crite en section 3.6 : l’inclusion des autorisations dynamiques dans les statiques pour
le modèle RBAC1. Cette propriété est modélisée par la dépendance σ de la forme
Dynamique(U, A, O) → Statique(U, A, O). Par rapport à l’exemple déjà présenté, cette
trace prend en compte la hiérarchie de rôle.

--------------------------------Tgds in base : 19--------------------------------
[0] (for all)[R,S] endosse(S,R)->(exist)[U] represente(S,U).
[1] (for all)[S,U1,U2] represente(S,U1),represente(S,U2)-> {(U1=U2)}.
[2] (for all)[R,S,U] represente(S,U),endosse(S,R)->habilite(U,R).
[3] (for all)[R1,R2] domine(R1,R2)->herite(R1,R2).
[4] (for all)[R1,R2,R3] domine(R1,R2),herite(R2,R3)->herite(R1,R3).
[5] (for all)[R] role(R)->domine(R,R).
[6] (for all)[R1,R2] herite(R1,R2),herite(R2,R1)-> {(R2=R1)}.
[7] (for all)[R1,R2,U] habilite(U,R1),herite(R1,R2)->authUsers(R2,U).
[8] (for all)[A,O,R,U] authPerms(R,A,O),habilite(U,R)->statique(U,A,O).
[9] (for all)[A,O,U] statique(U,A,O)->(exist)[R] authPerms(R,A,O),habilite(U,R).
[10] (for all)[A,O,R,S] authPerms(R,A,O),endosse(S,R)->acces(S,A,O).
[11] (for all)[A,O,S] acces(S,A,O)->(exist)[R] authPerms(R,A,O),endosse(S,R).
[12] (for all)[A,O,R,S,U] represente(S,U),endosse(S,R),authPerms(R,A,O)

->dynamique(U,A,O).

[13] (for all)[A,O,U] dynamique(U,A,O)->(exist)[R,S] represente(S,U),

endosse(S,R),authPerms(R,A,O).

[14] (for all)[R1,R2] separation(R1,R2)->exclusion(R1,R2).
[15] (for all)[R1,R2] exclusion(R1,R2)->exclusion(R2,R1).
[16] (for all)[R] exclusion(R,R)->error(reflex) {(1=\=1)}.
[17] (for all)[R1,R2,U] exclusion(R1,R2),habilite(U,R1),habilite(U,R2)

->error(ssd) {(1=\=1)}.

[18] (for all)[R,R1,R2] exclusion(R1,R2),herite(R,R1)->exclusion(R,R2).
--------------------------------------------------------------------------------

Tuples :
[0] dynamique(_u_0,_a_0,_o_0); -1;

tgdGoal : (for all)[A,O,U] dynamique(U,A,O)->statique(U,A,O).

Supposons l’existence d’un tuple Dynamique(u0, a0, o0). Soit en langage naturel,

supposons qu’un utilisateur dispose d’une autorisation dynamique.

stepNumber : 1
++++++++++++++++++++++++++++++++++++++++

246

Annexe C. Traces d’inférence

Treating [13]... ’(for all)[A,O,U] dynamique(U,A,O)->(exist)[R,S]

represente(S,U),endosse(S,R),authPerms(R,A,O).’
Added to tuples: represente(_s_0,_u_0); 13;
Added to tuples: endosse(_s_0,_r_0); 13;
Added to tuples: authPerms(_r_0,_a_0,_o_0); 13;
Added to activations: {A:_a_0,O:_o_0,U:_u_0}; 0;

...[13] treated

Par application de β5 (dépendance [13]), il existe également un rôle r0 et une ses-
sion s0 tels que Endosse(s0, r0), Repr ´esente(s0, u0) et AuthPerms(r0, a0, o0). Soit en lan-
gage naturel, on ne peut pas disposer d’une permission sans passer par un rôle.

stepNumber : 2
++++++++++++++++++++++++++++++++++++++++
Treating [8]... ’(for all)[A,O,R,U] authPerms(R,A,O),habilite(U,R)->statique(U,A,O).’

Added to tuples: statique(_u_0,_a_0,_o_0); 8;
Added to activations: {A:_a_0,O:_o_0,R:_r_0,U:_u_0}; 3,4;

...[8] treated

Treating [10]... ’(for all)[A,O,R,S] authPerms(R,A,O),endosse(S,R)->acces(S,A,O).’

Added to tuples: acces(_s_0,_a_0,_o_0); 10;
Added to activations: {A:_a_0,O:_o_0,R:_r_0,S:_s_0}; 3,2;

...[10] treated

Comme il existe AuthPerms(r0, a0, o0) et Habilite(u0, r0), alors par application de
α4 (dépendance [8]), il existe Statique(u0, a0, o0). Soit en langage naturel, on dispose
d’une autorisation statique par l’intermédiaire des rôles qu’on endosse. Notons que par ap-
plication de α5 (dépendance [10]) on a également dérivé un théorème plus général :
Dynamique(U, A, O) → ∃S Statique(U, A, O), Acc `es(S, A, O).

++++++++++++++++++++++++++++++++++++++++
No more tuples can be produced (FIX POINT), testing termination case:

Possible mappings :

{A:_a_0,O:_o_0,U:_u_0}; 5;
statique(_u_0,_a_0,_o_0); 8;

Termination case : the chase is finished and prove F|=g (PROOF)
--------------------------------------------------------------------------------------
the chase is finished and prove F|=g (PROOF)
number of rules applied for closure F(l):4
this chase was :0.096241 seconds long
number of tuples generated:7

goal goalTgd: (for all)[A,O,U] dynamique(U,A,O)->statique(U,A,O).
number of answers: 1
final mapping:
[1] {A:_a_0,O:_o_0,U:_u_0}; 5;

Ainsi, si un tuple Dynamique(u0, a0, o0), quel qu’il soit, existe dans la politique alors

le tuple Statique(u0, a0, o0) existe aussi, on a prouvé que {β5, α4} |= σ.

Section C.2. Simpliﬁcation des propriétés de l’exclusion mutuelle

247

Chaque valuation intermédiaire et la dépendance qui a été utilisée pour générer
un tuple est enregistré par une CActivation. La trace pourrait être simpliﬁée en ne
présentant que ses activations, c’est-à-dire l’arbre d’inférence partant de l’hypothèse de
σ et aboutissant à sa conclusion.

C.2 Simpliﬁcation des propriétés de l’exclusion mutuelle

En section 5.2.5 nous avons montré comment une procédure de preuve peut per-
mettre de démontrer automatiquement certains résultats pour la simpliﬁcation d’une
théorie logique. La trace d’exécution du chase que nous proposons dans cette section est
une preuve de {γr, γs, λ0} |= λ1. Ces expressions logiques sont la représentation des
propriétés de l’exclusion mutuelle et de l’interaction de l’exclusion avec une hiérarchie
déﬁnie sur le même concept. La preuve automtisée que nous proposons est inspirée
d’un résultat de [Gavrila98].

--------------------------------Tgds in base : 4--------------------------------
[0] (for all)[R1,R2] separation(R1,R2)->exclusion(R1,R2).
[1] (for all)[R1,R2] exclusion(R1,R2)->exclusion(R2,R1).
[2] (for all)[R] exclusion(R,R)->error(reflex) {(1=\=1)}.
[3] (for all)[R,R1,R2] exclusion(R1,R2),herite(R,R1)->exclusion(R,R2).
--------------------------------------------------------------------------------
Tuples :
[0] exclusion(_r1_0,_r2_0); -1;
[1] herite(_r_0,_r1_0); -1;
[2] herite(_r_0,_r2_0); -1;

seed : exclusion(_r1_0,_r2_0),herite(_r_0,_r1_0),herite(_r_0,_r2_0)
goal : {(1=\=1) }
tgdGoal : (for all)[R,R1,R2] exclusion(R1,R2),herite(R,R1),herite(R,R2)-> {(1=\=1)}.

Supposons l’existence des tuples Exclusion(r1, r2), H ´erite(r0, r1) et H ´erite(r0, r2).

stepNumber : 1
++++++++++++++++++++++++++++++++++++++++
Treating [1]... ’(for all)[R1,R2] exclusion(R1,R2)->exclusion(R2,R1).’

Added to tuples: exclusion(_r2_0,_r1_0); 1;
Added to activations: {R1:_r1_0,R2:_r2_0}; 0;

...[1] treated

Treating [3]... ’(for all)[R,R1,R2] exclusion(R1,R2),herite(R,R1)->exclusion(R,R2).’

Added to tuples: exclusion(_r_0,_r2_0); 3;
Added to activations: {R:_r_0,R1:_r1_0,R2:_r2_0}; 0,1;

Added to tuples: exclusion(_r_0,_r1_0); 3;
Added to activations: {R:_r_0,R1:_r2_0,R2:_r1_0}; 3,2;

...[3] treated

Par application de γs (dépendance [1]), on déduit Exclusion(r2, r1). Soit en lan-
gage naturel, l’exclusion est symétrique. Ensuite, par deux applications de λ0 (dépen-

248

Annexe C. Traces d’inférence

dance [3]), on déduit que Exclusion(r0, r2) et Exclusion(r0, r1). Soit en langage natu-
rel, l’exclusion se transmet par la relation d’héritage.

stepNumber : 2
++++++++++++++++++++++++++++++++++++++++
Treating [1]... ’(for all)[R1,R2] exclusion(R1,R2)->exclusion(R2,R1).’

Added to tuples: exclusion(_r2_0,_r_0); 1;
Added to activations: {R1:_r_0,R2:_r2_0}; 4;

Added to tuples: exclusion(_r1_0,_r_0); 1;
Added to activations: {R1:_r_0,R2:_r1_0}; 5;

...[1] treated

Treating [3]... ’(for all)[R,R1,R2] exclusion(R1,R2),herite(R,R1)->exclusion(R,R2).’

Added to tuples: exclusion(_r_0,_r_0); 3;
Added to activations: {R:_r_0,R1:_r2_0,R2:_r_0}; 6,2;

...[3] treated

Par application de γs (dépendance [1]), on déduit Exclusion(r2, r0) et que
Exclusion(r1, r0). Ensuite, par application de λ0 (dépendance [3]), on déduit que
Exclusion(r0, r0).

stepNumber : 3
++++++++++++++++++++++++++++++++++++++++
Treating [2]... ’(for all)[R] exclusion(R,R)->error(reflex) {(1=\=1)}.’

Added to tuples: error(reflex); 2;
Added to store: (1=\=1)
Added to activations: {R:_r_0}; 8;

...[2] treated

Par application de γr (dépendance [2]), soit en langage naturel, l’exclusion est ir-
réﬂexive , on déduit ⊥ représenté ici par l’antilogie 1 6= 1 stockée dans le magasin de
contraintes.

--------------------------------------------------------------------------------------
there is an inconsistency in the constraint store F|=g vacuously (VACUOUSLY)
number of rules applied for closure F(l):7
this chase was :0.088197 seconds long
number of tuples generated:10

Le chase pour les dépendances génératrices de tuples contraintes se termine en ayant
dérivé la conclusion à prouver : une antilogie. On a prouvé {γr, γs, λ0} |= λ1. Techni-
quement pour cette preuve, il s’agit du cas de terminaison numéro deux, provoqué par
des contraintes incohérentes [Maher96]. Notons que nous avons également utilisé un
prédicat Error/1. Il pourrait remplacer le syntatic sugar utilisé pour représenter ⊥.

Bibliographie

[Abadi07]

[Abiteboul95]

Martín Abadi. Access Control in a Core Calculus of Dependency. Elec-
tronic Notes in Theoretical Computer Science, vol. 172, pages 5–31,
Elsevier, Amsterdam, Avril 2007. 46, 47, 50, 62, 63
Serge Abiteboul, Richard Hull & Victor Vianu. Foundations of da-
tabases. Addison-Wesley, Boston, 1995. iii, xv, 22, 46, 48, 65, 72, 73,
74, 81, 82, 85, 86, 90, 96, 139, 199, 204, 208, 217, 229, 230, 236

[Abrahams04]

[Abou El Kalam03] Anas Abou El Kalam. Politiques et modèles de sécurité pour les do-
maines de la santéet des affaires sociales. Doctorat, Institut National
Polytechnique de Toulouse, Toulouse, 2003. 13, 30, 32, 52, 63, 130
David Abrahams & Aleksey Gurtovoy. C++ template meta-
programming : Concepts, tools, and techniques from boost and
beyond. Addison-Wesley Professional, Boston, 2004. 211
Kamel Adi, Amy Felty, Luigi Logrippo & Bernard Stepien. Evalua-
tion of Current Research in Firewall Analysis. Rapport technique, The
UofO LOTOS Research Group, 2003. 215
Gail-Joon Ahn & Ravi S. Sandhu. Role-based authorization constraints
speciﬁcation. ACM Transactions on Information & System Security,
vol. 3, no. 4, pages 207–226, ACM Press, New York, 2000. 39
Mohammad A. Al-Kahtani & Ravi S. Sandhu. Rule-Based RBAC
with Negative Authorization. In ACSAC’04 : 20th Annual Compu-
ter Security Applications Conference, pages 405–415, Washington,
2004. IEEE Computer Society. 46, 47
Ehab S. Al-Shaer & Hazem H. Hamed. Discovery of Policy Ano-
malies in Distributed Firewalls. In INFOCOM’04 : 23rd AnnualJoint
Conference of the IEEE Computer and Communications Societies,
volume 4, pages 2605–2616, Washington, 2004. IEEE Computer So-
ciety. 47, 215

[Al-Kahtani04]

[Adi03]

[Ahn00]

[Al-Shaer04]

[Alexandrescu01] Andrei Alexandrescu. Modern C++ Design : Generic Program-
ming and Design Patterns Applied. Addison-Wesley, Boston, 2001.
181, 211

250

[Allen83]

[Appel99]

[Arends05]

[Arévalo07]

[Atluri02]

[Baget06]

[Barker02]

[Barker03]

[Bartal04]

[Baudinet95]

BIBLIOGRAPHIE

James F. Allen. Maintaining Knowledge about Temporal Intervals.
Communications of the ACM, vol. 26, no. 11, pages 832–843, ACM
Press, New York, 1983. 42
Andrew W. Appel & Edward W. Felten. Proof-Carrying Authenti-
cation. In CCS’99 : ACM Conference on Computer and Commu-
nications Security, Singapore, pages 52–62, New York, 1999. ACM
Press. 48
R. Arends, R. Austein, M. Larson, D. Massey & S. Rose. Protocol
Modiﬁcations for the DNS Security Extensions. RFC 4035, mar 2005.
50
Gabriela Arévalo, Anne Berry, Marianne Huchard, Guillaume Per-
rot & Alain Sigayret. Performances of Galois Subhierarchy-building
Algorithms.
In ICFCA’07 : 5th International Conference on For-
mal Concept Analysis, Clermont-Ferrand, volume 4390 of LNCS.
Springer-Verlag, 2007. iv, 162, 189
Vijayalakshmi Atluri & Avigdor Gal. An authorization model for tem-
poral and derived data : securing information portals. ACM Transac-
tions on Information & System Security, vol. 5, no. 1, pages 62–94,
ACM Press, New York, 2002. 43, 45
Jean-François Baget & Eric Salvat. Rules Dependencies in Backward
Chaining of Conceptual Graphs Rules.
In Henrik Schärfe, Pascal
Hitzler & Peter Øhrstrøm, editeurs, ICCS’06 : 14th International-
Conference on Conceptual Structures, Aalborg, Denmark, volume
4068 of Lecture Notes in Computer Science, pages 102–116. Springer-
Verlag, 2006. 202
Steve Barker. Access Control for Deductive Databases by Logic Pro-
In Peter J. Stuckey, editeur, ICLP’02 : 18th Interna-
gramming.
tional Conference on Logic Programming, Copenhagen,Denmark,
volume 2401 of Lecture Notes in Computer Science, pages 54–69.
Springer-Verlag, 2002. 97
Steve Barker & Peter J. Stuckey. Flexible access control policy spe-
ciﬁcation with constraint logic programming. ACM Transactions on
Information & System Security, vol. 6, no. 4, pages 501–546, ACM
Press, New York, 2003. 27, 29, 34, 45, 51, 52, 63, 79, 97, 117, 139
Yair Bartal, Alain J. Mayer, Kobbi Nissim & Avishai Wool. Firmato :
A novel ﬁrewall management toolkit. ACM Transactions on Compu-
ting Systems, vol. 22, no. 4, pages 381–420, ACM Press, New York,
2004. 215
Marianne Baudinet, Jan Chomicki & Pierre Wolper. Constraint-
Generating Dependencies. In Georg Gottlob & Moshe Y. Vardi, edi-
teurs, ICDT’95 : 5th International Conference on Database Theory,

BIBLIOGRAPHIE

251

[Beeri84]

[Bell75]

[Benantar06]

[Berry05]

[Bertino99]

[Bertino01]

[Bertino03]

[Bertino05]

[Bertossi06]

[Besson06]

[Bhatti05]

Prague, Czech Republic, volume 893 of Lecture Notes in Computer
Science, pages 322–337. Springer-Verlag, 1995. 81, 83
Catriel Beeri & Moshe Y. Vardi. A Proof Procedure for Data Dependen-
cies. Journal of the ACM, vol. 31, no. 4, pages 718–741, ACM Press,
New York, 1984. iii, 80, 81, 87, 88, 92, 183, 204, 245
D. Bell & L. LaPadula. Secure Computer Systems : Uniﬁed Exposition
and Multics Interpretation. Rapport technique, 1975. xiii, 21, 22
Messaoud Benantar, editeur. Access control systems - security,
identity management and trust models. Springer-Verlag, 2006. 39,
40, 130, 134, 180
Anne Berry, Marianne Huchard, Ross M. McConnell, Alain Sigay-
ret & Jeremy Spinrad. Efﬁciently Computing a Linear Extension of the
Sub-hierarchy of a Concept Lattice. In ICFCA’05 : 3rd International
Conference on Formal Concept Analysis, volume 3403 of LNCS,
pages 208–222, 2005. 162
Elisa Bertino, Elena Ferrari & Vijay Atluri. The speciﬁcation and en-
forcement of authorization constraints in workﬂow management systems.
ACM Transactions on Information & System Security, vol. 2, no. 1,
pages 65–104, ACM Press, New York, 1999. 32
Elisa Bertino, Piero A. Bonatti & Elena Ferrari. TRBAC : A temporal
role-based access control model. ACM Transactions on Information
& System Security, vol. 4, no. 3, pages 191–233, ACM Press, New
York, 2001. 43, 45, 76
Elisa Bertino, Barbara Catania, Elena Ferrari & Paolo Perlasca. A
logical framework for reasoning about access control models. ACM Tran-
sactions on Information & System Security, vol. 6, no. 1, pages 71–
127, ACM Press, New York, 2003. 46, 47, 52, 63, 146
Elisa Bertino & Ravi S. Sandhu. Database Security-Concepts, Ap-
proaches, and Challenges. IEEE Transactions on Dependable & Se-
cure Computing, vol. 2, no. 1, pages 2–19, IEEE Computer Society,
Washington, 2005. 176
Leopoldo E. Bertossi. Consistent query answering in databases. SIG-
MOD Record, vol. 35, no. 2, pages 68–76, ACM Press, New York,
2006. iv, 87, 204
Jérémy Besson, Céline Robardet & Jean-François Boulicaut. Mining
a New Fault-Tolerant Pattern Type as an Alternative to Formal Concept
Discovery. In ICCS’06 : 14th International Conference on Concep-
tual Structures, volume 4068 of LNCS, pages 144–157, 2006. 208
Rafae Bhatti, Basit Shaﬁq, Elisa Bertino, Arif Ghafoor & James Jo-
shi. X-GTRBAC Admin : A decentralized administration model for

252

BIBLIOGRAPHIE

[Blaze99]

[Brewer89]

[Calì04]

[Calvanese94]

[CERT/CC02]

[CERT/CC05]

[Chein92]

[Cholvy97]

[Chomicki05]

[Chomicki07]

[Christian95]

[Christiansen06]

enterprise-wide access control. ACM Transactions on Information
& System Security, vol. 8, no. 4, pages 388–423, ACM Press, New
York, 2005. 36, 43
M. Blaze, J. Feigenbaum, J. Ioannidis & A. Keromytis. The KeyNote
Trust-Management System Version 2. RFC 2704, Internet Engineering
Task Force, September 1999. 49
David F.C. Brewer & Michael J. Nash. The chinese wall security policy.
In IEEE Symposium on Security and Privacy, pages 206–214. IEEE
Computer Society, 1989. 200
Andrea Calì. Reasoning in Data Integration Systems : why LAV and
GAV are Siblings. In Maristella Agosti, Nicoletta Dessì & Fabio A.
Schreiber, editeurs, SEBD’04 : 12th Italian Symposium on Advan-
ced DatabaseSystems, Cagliari, Italy, pages 282–289, 2004. 169, 205
Diego Calvanese & Maurizio Lenzerini. On the Interaction Between
ISA and Cardinality Constraints. In 10th International Conference on
Data Engineering, Houston, Texas, pages 204–213. IEEE Computer
Society, 1994. 122
CERT/CC. Test the ﬁrewall system. Security improvement module,
2002. 213
CERT/CC, US Secret Service & CSO magazine. E-CrimeWatch Sur-
vey. Rapport technique, 2005. 213
Michel Chein & Marie-Laure Mugnier. Conceptual Graphs : Funda-
mental Notions. Revue d’Intelligence Artiﬁcielle, vol. 6, no. 4, pages
365–406, Hermes, Cachan, 1992. 143, 145
Laurence Cholvy & Frédéric Cuppens. Analyzing consistency of se-
curity policies. In SP’97 : IEEE Symposium on Security and Privacy,
page 103, Washington, DC, USA, 1997. IEEE Computer Society. 52
Jan Chomicki & Jerzy Marcinkowski. Minimal-change integrity
maintenance using tuple deletions.
Information & Computation,
vol. 197, no. 1-2, pages 90–121, Academic Press, Duluth, Minne-
sota, 2005. iv, 87, 204
Jan Chomicki. Consistent Query Answering : Five Easy Pieces. In Tho-
mas Schwentick & Dan Suciu, editeurs, ICDT’07 : 11th Internatio-
nal Conference on Database Theory, Barcelona, Spain, volume 4353
of Lecture Notes in Computer Science, pages 1–17. Springer-Verlag,
2007. 87
Holzbaur Christian. clp(q,r) Manual Rev. 1.3.2. OEFAI, Austrian
Research Institute for Artiﬁcial Intelligence, Vienna, 1995. 182
Henning Christiansen & Davide Martinenghi. On Simpliﬁcation of
Database Integrity Constraints. Fundamenta Informaticae, vol. 71,

BIBLIOGRAPHIE

253

[Clark87]

[Clarke01]

[Codd70]

[Coulondre98]

[Coulondre03]

[Covington01]

[Coyne96]

[Crampton03a]

[Crampton03b]

[Crampton05]

no. 4, pages 371–417, Polish Mathematical Society, Warszawa, 2006.
iv, 87, 208
D. D. Clark & D. R. Wilson. A Comparison of Commercial and Military
Computer Security Policies.
In IEEE Symposium on Security and
Privacy, pages 184–195, 1987. 32, 39
Dwaine E. Clarke, Jean-Emile Elien, Carl M. Ellison, Matt Fredette,
Alexander Morcos & Ronald L. Rivest. Certiﬁcate Chain Discovery
in SPKI/SDSI.
Journal of Computer Security, vol. 9, no. 4, pages
285–322, IOS Press, Amsterdam, 2001. 49
E. F. Codd. A relational model of data for large shared data banks. Com-
munications of the ACM, vol. 13, no. 6, pages 377–387, ACM Press,
New York, 1970. 80
Stéphane Coulondre & Eric Salvat. Piece Resolution : Towards Lar-
ger Perspectives.
In Marie-Laure Mugnier & Michel Chein, edi-
teurs, ICCS’98 : 6th International Conference on Conceptual Struc-
tures, Montpellier, France, volume 1453 of Lecture Notes in Computer
Science, pages 179–193. Springer-Verlag, 1998. 144
Stéphane Coulondre. A top-down proof procedure for generalized data
dependencies. Acta Informatica, vol. 39, no. 1, pages 1–29, Springer-
Verlag, Berlin, 2003. 92, 144, 183
Michael J. Covington, Wende Long, Srividhya Srinivasan, Anind K.
Dey, Mustaque Ahamad & Gregory D. Abowd. Securing context-
aware applications using environment roles. In SACMAT’01 : 6th ACM
Symposium on Access Control Models and Technologies, pages
10–20, 2001. 29, 34, 44
Edward J. Coyne. Role engineering. In RBAC’95 : 1st ACM Work-
shop on Role-based access control, page 4, New York, 1996. ACM
Press. 36, 153
Jason Crampton. Specifying and enforcing constraints in role-based
access control.
In SACMAT’03 : 8th ACM Symposium on Access
Control Models and Technologies, pages 43–50. ACM Press, 2003.
40, 95, 153, 161, 206
Jason Crampton & George Loizou. Administrative scope : A founda-
tion for role-based administrative models. ACM Transactions on Infor-
mation & System Security, vol. 6, no. 2, pages 201–231, ACM Press,
New York, 2003. 36
Jason Crampton. Understanding and developing role-based adminis-
trative models. In Vijay Atluri, Catherine Meadows & Ari Juels, edi-
teurs, CCS’05 : 12th ACM Conference on Computer and Commu-
nicationsSecurity, Alexandria, Virginia, pages 158–167. ACM Press,
2005. 36

254

[Crook03]

[Cuppens99]

[Cuppens00]

[Cuppens03]

[Cuppens04a]

[Cuppens04b]

[Damiani07]

[Dehornoy07]

[Denning76]

[Deswarte03]

[Deswarte04]

[DeTreville02]

[Dey01]

BIBLIOGRAPHIE

Robert Crook, Darrel C. Ince & Bashar Nuseibeh. Modelling access
policies using roles in requirements engineering. Information & Soft-
ware Technology, vol. 45, no. 14, pages 979–991, Elsevier, Amster-
dam, 2003. 118
Frédéric Cuppens & Alban Gabillon. Logical Foundations of Multile-
vel Databases. Data & Knowledge Engineering, vol. 29, no. 3, pages
259–291, Elsevier, Amsterdam, 1999. 22
Frédéric Cuppens. Modélisation formelle de la sécurité des systèmes
d’informations, Habilitation à Diriger les Recherches. Doctorat, Uni-
versité Paul Sabatier, Toulouse, 2000. 22
Frédéric Cuppens & Alexandre Miège. Modelling Contexts in the
In ACSAC’03 : 19th Annual Computer Security
Or-BAC Model.
Applications Conference, Las Vegas, Nevada, pages 416–427. IEEE
Computer Society, 2003. 30, 44
Frédéric Cuppens, Nora Cuppens-Boulahia & Alexandre Miège.
Inheritance hierachies in the Or-BAC Model and Application in a net-
work environnement.
In 2nd Foundation of Computer Security
Workshop, July 2004. 30
Frédéric Cuppens & Alexandre Miège. AdOrBAC : an administration
model for Or-BAC. Computer Systems : Science and Engineering,
vol. 19, no. 3, CRL Publishing, Leicester, 2004. 30, 35, 36
Maria Luisa Damiani, Elisa Bertino, Barbara Catania & Paolo Per-
lasca. GEO-RBAC : A spatially aware RBAC. ACM Transactions
on Information & System Security, vol. 10, no. 1, ACM Press, New
York, 2007. 27, 29, 34, 44, 45, 74, 76
Patrick Dehornoy. Logique et théorie des ensembles. Notes de
cours FIMFA ENS, 2007. 204, 217
Dorothy E. Denning. A lattice model of secure information ﬂow. Com-
munications of the ACM, vol. 19, no. 5, pages 236–243, ACM Press,
New York, 1976. 21
Yves Deswarte & Ludovic Mé, editeurs. Sécurité des réseaux et
systèmes répartis. Hermes, Cachan, Oct 2003. 13, 130
Yves Deswarte & Anas Abou El Kalam. Modèle de sécurité pour le
secteur de la santé. Technique et Science Informatiques, vol. 23, no. 3,
pages 291–321, Hermes, Cachan, 2004. 18, 184
John DeTreville. Binder, a Logic-Based Security Language. In SP’02 :
IEEE Symposium on Security and Privacy, page 105, Washington,
2002. IEEE Computer Society. 46, 47, 50, 63
Anind K. Dey. Understanding and Using Context. Personal Ubiqui-
tous Comput., vol. 5, no. 1, pages 4–7, Springer-Verlag, London,
2001. 41

BIBLIOGRAPHIE

[Egenhofer91]

[Epstein02]

[Eronen01]

[Fagin86]

[Fagin03]

[Fagin05]

[Fagin06]

[Ferraiolo01]

[Ferraiolo03a]

[Ferraiolo03b]

255

Max J. Egenhofer. Reasoning about Binary Topological Relations. In
Oliver Günther & Hans-Jörg Schek, editeurs, SSD’91 : 2nd Interna-
tional Symposium Advances in Spatial Databases, Zürich, Switzer-
land, volume 525 of Lecture Notes in Computer Science, pages 143–
160. Springer-Verlag, 1991. 42
Pete E. Epstein. Engineering of Role/Permissions assignments. Docto-
rat, Fairfax University, VA, USA, 2002. xi, 153, 154, 208
Pasi Eronen & Jukka Zitting. An expert system for analyzing ﬁre-
wall rules. In NordSec’01 : 6th Nordic Workshop on Secure IT Sys-
tems, pages 100–107, Copenhagen, 2001. Technical University of
Denmark. Technical Report IMM-TR-2001-14. 215
Ronald Fagin & Moshe Y. Vardi. The theory of data dependencies :
a survey. In American Mathematical Society, editeur, Symposia in
Applied Mathematics, volume 34 of Mathematics of Information Pro-
cessing, pages 19–72, 1986. 57, 81
Ronald Fagin, Phokion G. Kolaitis & Lucian Popa. Data exchange :
In PODS’03 : 22nd ACM SIGACT-SIGMOD-
getting to the core.
SIGART Symposiumon Principles of Database Systems, San Diego,
California, pages 90–101. ACM Press, 2003. 169
Ronald Fagin, Phokion G. Kolaitis & Lucian Popa. Data exchange :
getting to the core. ACM Transaction on Database Systems, vol. 30,
no. 1, pages 174–210, ACM Press, New York, 2005. 205
Ronald Fagin. Inverting schema mappings. In Stijn Vansummeren,
editeur, PODS’06 : 25th ACM SIGACT-SIGMOD-SIGART Sympo-
siumon Principles of Database Systems, Chicago, Illinois, pages
50–59. ACM Press, 2006. iv, 85, 87, 169, 204, 205
David F. Ferraiolo, Ravi S. Sandhu, Serban I. Gavrila, Richard D.
Kuhn & Ramaswamy Chandramouli. Proposed NIST standard for
Role-Based Access Control. ACM Transactions on Information & Sys-
tem Security, vol. 4, no. 3, pages 224–274, ACM Press, New York,
2001. 25, 34, 139
David F. Ferraiolo, R. Chandramouli, Gail-Joon Ahn & Serban I.
Gavrila. The role control center : features and case studies.
In SAC-
MAT’03 : 8th ACM Symposium on Access Control Models and
Technologies, pages 12–20, New York, NY, USA, 2003. ACM Press.
37, 46, 143
David F. Ferraiolo, Richard D. Kuhn & Ramaswamy Chandra-
mouli. Role-based access control. Artech House Publishers, 2003.
ii, xiii, xv, 24, 25, 27, 28, 29, 34, 35, 39, 40, 51, 56, 70, 71, 77, 105, 117,
130, 137, 138, 139, 153, 161, 202, 239

256

[Ferraiolo07]

[Frantzen03]

[Gallaher02]

[Ganter97]

[Gavrila98]

[Geerts04]

[Georgiadis01]

[Gligor98]

[GMSIH03]

[Godfrey98]

BIBLIOGRAPHIE

David F. Ferraiolo, Richard D. Kuhn & Ravi S. Sandhu. RBAC
Standard Rationale : Comments on "A Critique of the ANSI Standard
on Role-Based Access Control".
IEEE Security and Privacy, vol. 5,
no. 6, pages 51–53, IEEE Computer Society, Los Alamitos, Califor-
nia, 2007. 28
Lars Frantzen. Approaches for analysing and comparing packet
ﬁltering in ﬁrewalls. Master, Technical University of Berlin, 2003.
215
Michael P. Gallaher, Alan C. O’Connor & Brian Kropp. The Eco-
nomic Impact of Role-Based Access Control. Rapport technique, Plan-
ning report 02-1, National Institute of Standards and Technology,
2002. 153
Bernhard Ganter & Rudolf Wille. Formal concept analysis : Mathe-
matical foundations. Springer-Verlag, Secaucus, New-Jersey, 1997.
Translator-C. Franzke. 210
Serban I. Gavrila & John F. Barkley. Formal Speciﬁcation for Role Ba-
sed Access Control User/Role and Role/Role Relationship Management.
In ACM Workshop on RBAC, pages 81–90, 1998. 27, 35, 39, 40, 117,
134, 135, 136, 180, 247
Floris Geerts, Bart Goethals & Taneli Mielikäinen. Tiling Databases.
In Einoshin Suzuki & Setsuo Arikawa, editeurs, DS’04 : 7th Inter-
national Conference on Discovery Science, Padova, Italy, volume
3245 of Lecture Notes in Computer Science, pages 278–289. Springer-
Verlag, 2004. 190, 208
Christos K. Georgiadis, Ioannis Mavridis, George Pangalos & Ro-
shan K. Thomas. Flexible team-based access control using contexts. In
SACMAT ’01 : Proceedings of the sixth ACM symposium on Ac-
cess control models and technologies, pages 21–27, New York, NY,
USA, 2001. ACM Press. 44
Virgil D. Gligor, Serban I. Gavrila & David F. Ferraiolo. On the For-
mal Deﬁnition of Separation-of-Duty Policies and their Composition. In
1998 Symposium on Security and Privacy, pages 172–183, Oakland,
CA, 1998. IEEE Computer Society Press. 40, 95, 117
GMSIH. Politique de Sécurité des Systèmes d’Information des Etablis-
sements de Santé - Politique d’autorisation. Rapport technique, Grou-
pement pour la Modernisation du Systèmes d’Information Hospi-
talier, Mars 2003. xi, 34, 55, 184, 185
Parke Godfrey, John Grant, Jarek Gryz & Jack Minker.
Integrity
constraints : Semantics and applications., chapitre 9, pages 265–
306. Kluwer, 1998. 81, 85

BIBLIOGRAPHIE

257

[Godin95]

[Gouda04]

[Grabmeier02]

[Graham86]

[Greco92]

[Gupta95]

[Hacene07]

[Halpern03]

[Hansen05]

[Harrison76]

Robert Godin, Guy Mineau, Rokia Missaoui & Hafedh Mili. Mé-
thodes de Classiﬁcation Conceptuelle Basées sur les Treillis de Galois et
Applications. Revue d’Intelligence Artiﬁcielle, vol. 9, no. 2, pages
105–137, Hermes, Cachan, 1995. 160
Mohamed G. Gouda & Alex X. Liu. Firewall design : consistency, com-
pleteness and compactness. In ICDCS’04 : 24th International Confe-
rence On Distributed Computing Systems, pages 320–327, 2004. 46,
215
Johannes Grabmeier & Andreas Rudolph. Techniques of Cluster Al-
gorithms in Data Mining. Data Mining & Knowledge Discovery,
vol. 6, no. 4, pages 303–360, Kluwer, Hingham, Massachusetts,
2002. 189
Marc H. Graham, Alberto O. Mendelzon & Moshe Y. Vardi. Notions
of dependency satisfaction. Journal of the ACM, vol. 33, no. 1, pages
105–129, ACM Press, New York, 1986. 87, 140
Sergio Greco, Nicola Leone & Pasquale Rullo. COMPLEX : An
IEEE Transactions on
Object-Oriented Logic Programming System.
Knowledge & Data Engineering, vol. 4, no. 4, pages 344–359, IEEE
Computer Society, Los Alamitos, California, 1992. 52
Ashish Gupta & Inderpal Singh Mumick. Maintenance of Materia-
lized Views : Problems, Techniques and Applications. IEEE Quarterly
Bulletin on Data Engineering ; Special Issue on Materialized Views
and Data Warehousing, vol. 18, no. 2, pages 3–18, IEEE Computer
Society, Los Alamitos, California, 1995. 85
Mohamed Rouane Hacene, Michel Dao, Marianne Huchard &
Petko Valtchev. Analyse formelle de données relationnelles pour la ré-
ingénierie des modèles UML.
In Isabelle Borne, Xavier Crégut, So-
phie Ebersold & Frédéric Migeon, editeurs, LMO’07 : Journées Lan-
gages et Modèles à Objets, Toulouse, pages 151–166. Hermès La-
voisier, 2007. 208
Joseph Y. Halpern & Vicky Weissman. Using First-Order Logic to
Reason about Policies. In CSFW’03 : 16th IEEE Computer Security
Foundations Workshop, Paciﬁc Grove, California, pages 187–201.
IEEE Computer Society, 2003. 46, 47, 51, 63, 114, 128, 146, 199
Frode Hansen & Vladimir Oleshchuk. Conformance Checking of
RBAC Policy and its Implementation.
In ISPEC’05 : 1st Informa-
tion Security Practice and Experience Conference, volume 3439 of
LNCS, pages 144–155. Springer-Verlag, 2005. 53, 63, 117
Michael A. Harrison, Walter L. Ruzzo & Jeffrey D. Ullman. Pro-
tection in operating systems. Communications of the ACM, vol. 19,
no. 8, pages 461–471, ACM Press, New York, 1976. 19, 206

258

[Holzmann97]

[Huchard07]

[ISO91]

[ISO99]

[Jackson00]

[Jaffar94]

[Jajodia01]

[Jansen98]

[Jim01a]

[Jim01b]

[Jones93]

[Joshi02]

BIBLIOGRAPHIE

Gerard J. Holzmann. The Model Checker SPIN. IEEE Transactions
on Software Engineering, vol. 23, no. 5, pages 279–295, IEEE Com-
puter Society, Los Alamitos, California, 1997. 53
Marianne Huchard, Mohamed Rouane Hacene, Cyril Roume &
Petko Valtchev. Relational concept discovery in structured datasets.
Annals of Mathematics and Artiﬁcial Intelligence, vol. 49, no. 1-4,
pages 39–76, Springer-Verlag, Berlin, 2007. 208
ISO.
Information Technology - Software Product evaluation - Quality
Characteristics and Guidelines for their use. Rapport technique, 1991.
Int. Standard ISO/IEC 9126. 13
ISO. International Standardization Organization (ISO) and Inter-
national Electrotechnical Commission (IEC) ISO/IEC 9075 :1999,
database languages – SQL. 1999. 23, 175
Daniel Jackson, Ian Schechter & Ilya Shlyakhter. Alcoa : the Alloy
Constraint Analyzer. In International Conference on Software Engi-
neering. IEEE CS Press, Los Alamitos, 2000. 53
Joxan Jaffar & Michael J. Maher. Constraint Logic Programming : A
Survey. Journal of Logic Programming, vol. 19/20, pages 503–581,
Elsevier, Amsterdam, 1994. 51, 83
Sushil Jajodia, Pierangela Samarati, Maria Luisa Sapino & V. S. Su-
brahmanian. Flexible support for multiple access control policies. ACM
Transaction on Database Systems, vol. 26, no. 2, pages 214–260,
ACM Press, New York, 2001. 46, 47, 52, 62, 63
W. A. Jansen. Inheritance Properties of Role Hierarchies. In 21st NIST-
NCSC National Information Systems Security Conference, pages
476–485, 1998. 28
Trevor Jim. SD3 : A Trust Management System with Certiﬁed Evalua-
tion. In IEEE Symposium on Security and Privacy, pages 106–115,
2001. 49, 50, 63
Trevor Jim & Dan Suciu. Dynamically distributed query evaluation. In
PODS’01 : 20th ACM SIGMOD-SIGACT-SIGART symposium on
Principles of database systems, pages 28–39, New York, NY, USA,
2001. ACM Press. 49, 50
A. J. I. Jones & M. Sergot. On the Characterization of Law and Compu-
ter Systems : The Normative Systems Perspective.
In J.-J. C. Meyer
& R. J. Wieringa, editeurs, Deontic Logic in Computer Science :
Normative System Speciﬁcation, pages 275–307. Wiley, New York,
1993. 52
James Joshi, Elisa Bertino & Arif Ghafoor. Temporal hierarchies and
inheritance semantics for GTRBAC. In SACMAT’02 : 7th ACM sym-

BIBLIOGRAPHIE

259

[Joshi03]

[Joshi05]

posium on Access control models and technologies, pages 74–83,
New York, NY, USA, 2002. ACM Press. 43, 118
James Joshi, Basit Shaﬁq, Arif Ghafoor & Elisa Bertino. Dependen-
cies and separation of duty constraints in GTRBAC. In SACMAT’03 :
8th ACM Symposium on Access Control Models and Technologies,
pages 51–64. ACM Press, 2003. 76
James Joshi, Elisa Bertino, Usman Latif & Arif Ghafoor. A Gene-
ralized Temporal Role-Based Access Control Model. IEEE Transactions
on Knowledge & Data Engineering, vol. 17, no. 1, pages 4–23, IEEE
Computer Society, Los Alamitos, California, 2005. 43, 45, 74

[Journal Ofﬁciel98] Journal Ofﬁciel. Décret no 98-608 du 17 juillet 1998, 1998. Décret

[Koch03]

[Kuhlmann03]

[Kuhn97]

[Kumar02]

[Lampson74]

[Landwehr81]

[Lassez89]

relatif à la protection des secrets de la défense nationale. xiii, 21
Manuel Koch & Francesco Parisi-Presicce. Visual Speciﬁcations of
In Michel Wermelinger & Tiziana
Policies and Their Veriﬁcation.
Margaria, editeurs, FASE’04 : 7th International Conference on Fun-
damental Approaches to Software Engineering, Barcelona, Spain,
volume 2621 of LNCS, pages 278–293. Springer-Verlag, 2003. 37,
46, 53, 54, 63
Martin Kuhlmann, Dalia Shohat & Gerhard Schimpf. Role mi-
ning - revealing business roles for security administration using data
mining technology. In SACMAT’03 : 8th ACM Symposium on Ac-
cess Control Models and Technologies, pages 179–186. ACM Press,
2003. 154, 189
Richard D. Kuhn. Mutual exclusion of roles as a means of implemen-
ting separation of duty in role-based access control systems. In RBAC
’97 : 2ndACM workshop on Role-based access control, pages 23–
30, New York, NY, USA, 1997. ACM Press. 28, 39, 40
Arun Kumar, Neeran M. Karnik & Girish Chaﬂe. Context sensiti-
vity in role-based access control. ACM SIGOPS Operating Systems
Review, vol. 36, no. 3, pages 53–66, ACM Press, New York, 2002. 44
Butler W. Lampson. Protection. ACM SIGOPS Operating Systems
Review, vol. 8, no. 1, pages 18–24, ACM Press, New York, 1974. iii,
xv, 3, 15, 17, 102
Carl E. Landwehr. Formal Models for Computer Security. ACM Com-
puting Surveys, vol. 13, no. 3, pages 247–278, ACM Press, New
York, 1981. 17
Jean-Louis Lassez & Ken McAloon.
Independence of Negative
In Josep Díaz & Fernando Orejas, editeurs, TAP-
Constraints.
SOFT’89 : Proceedings of the International Joint Conference on
Theory and Practice of Software Development, Barcelona, Spain,

260

BIBLIOGRAPHIE

[Lenzerini02]

[Li00a]

[Li00b]

[Li03a]

[Li03b]

[Li04a]

[Li04b]

[Li07]

[Liu04]

volume 351 of Lecture Notes in Computer Science, pages 19–27.
Springer-Verlag, 1989. xv, 83, 90
Maurizio Lenzerini. Data Integration : A Theoretical Perspective.
In Lucian Popa, editeur, PODS’02 : 21st ACM SIGACT-SIGMOD-
SIGART Symposium on Principles of Database Systems, Madison,
Wisconsin, pages 233–246. ACM Press, 2002. 169, 205
Ninghui Li. Delegation Logic : A Logic-based Approach to Distributed
Authorization. Doctorat, New York University, 2000. 49
Ninghui Li, Benjamin N. Grosof & Joan Feigenbaum. A Practically
Implementable and Tractable Delegation Logic. In IEEE Symposium on
Security and Privacy, pages 27–42, 2000. 46, 49
Ninghui Li, Benjamin N. Grosof & Joan Feigenbaum. Delegation
logic : A logic-based approach to distributed authorization. ACM Tran-
sactions on Information & System Security, vol. 6, no. 1, pages 128–
171, ACM Press, New York, 2003. 49, 63
Ninghui Li & John C. Mitchell. DATALOG with Constraints : A Foun-
dation for Trust Management Languages. In Verónica Dahl & Philip
Wadler, editeurs, Practical Aspects of Declarative Languages, 5th
International Symposium, PADL 2003, New Orleans, LA, USA, Ja-
nuary 13-14, 2003, Proceedings, volume 2562 of Lecture Notes in
Computer Science, pages 58–73. Springer-Verlag, 2003. xv, 49, 63,
72, 74, 76, 97
Ninghui Li, Ziad Bizri & Mahesh V. Tripunitara. On mutually-
exclusive roles and separation of duty. In CCS ’04 : 11th ACM confe-
rence on Computer and communications security, pages 42–51,
New York, NY, USA, 2004. ACM Press. 38, 39
Ninghui Li & Mahesh V. Tripunitara. Security analysis in role-
based access control. In Trent Jaeger & Elena Ferrari, editeurs, SAC-
MAT’04 : 9th ACM Symposium on Access Control Models and
Technologies, New York, pages 126–135, New York, NY, USA, 2004.
ACM Press. 63
Ninghui Li, Ji-Won Byun & Elisa Bertino. A Critique of the ANSI
Standard on Role-Based Access Control. IEEE Security and Privacy,
vol. 5, no. 6, pages 41–49, IEEE Computer Society, Los Alamitos,
California, 2007. 28, 34, 35, 55, 107, 113, 114, 120, 128, 202
Alex X. Liu, Mohamed G. Gouda, Huibo H. Ma & Anne H. H.
Ngu. Firewall Queries. In Teruo Higashino, editeur, OPODIS’04 :
8th International Conference on Principles of Distributed Systems,
Grenoble, France, volume 3544 of Lecture Notes in Computer Science,
pages 197–212. Springer-Verlag, 2004. 47, 215

BIBLIOGRAPHIE

[Liu05]

[Maher96]

[Maher97]

[Maher00]

[Mayer06]

[Meyers05]

[Miège05]

[Mossakowski03]

[Nash90]

[Neumann02]

261

Peng Liu, Jian bin Hu & Zhong Chen. A Formal Language for
Access Control Policies in Distributed Environment.
In WI’05 :
IEEE/WIC/ACM International Conference on Web Intelligence,
pages 766–769, Washington, DC, USA, 2005. IEEE Computer So-
ciety. 63
Michael J. Maher & Divesh Srivastava. Chasing Constrained Tuple-
In Richard Hull, editeur, 15th ACM
Generating Dependencies.
SIGACT-SIGMOD-SIGART Symposium on Principles of Database
Systems, Montreal, Canada, pages 128–138. ACM Press, 1996. iii,
81, 87, 88, 90, 91, 92, 127, 180, 183, 202, 245, 248
Michael J. Maher. Constrained dependencies. Theoretical Computer
Science, vol. 173, no. 1, pages 113–149, Elsevier, Essex, 1997. 83
Michael J. Maher & Junhu Wang. Optimizing Queries in Extended Re-
lational Databases. In Mohamed T. Ibrahim, Josef Küng & Norman
Revell, editeurs, DEXA’00 : 11th International Conference on Da-
tabase and Expert Systems Applications, London, volume 1873 of
Lecture Notes in Computer Science, pages 386–396. Springer-Verlag,
2000. 83, 85
Alain J. Mayer, Avishai Wool & Elisha Ziskind. Ofﬂine ﬁrewall ana-
International Journal of Information Security, vol. 5, no. 3,
lysis.
pages 125–144, Springer-Verlag, Berlin, 2006. 47
Scott Meyers. Effective C++, third edition. Addison-Wesley, 2005.
113
Alexandre Miège. Dénition d’un environnement formel d’expression
de politiques de sécurité. Modèle Or-BAC et extensions. Doctorat, Ecole
Nationale Supérieure des Télécommunications,Paris, 2005. 29, 30,
45, 46, 63, 76, 108, 117
Till Mossakowski, Michael Drouineaud & Karsten Sohr. A temporal-
logic extension of role-based access control covering dynamic separation
of duties. In 10th international symposium on temporal representa-
tion and reasoning, 4th international conference on temporal logic,
volume 00, page 83, Los Alamitos, California, 2003. IEEE Compu-
ter Society. 43, 53
M. J. Nash & K. R. Poland. Some Conundrums Concerning Separation
of Duty. In IEEE Symposium on Security and Privacy, pages 201–
209, 1990. xv, 32, 33, 38, 39, 45
Gustaf Neumann & Mark Strembeck. A scenario-driven role engi-
