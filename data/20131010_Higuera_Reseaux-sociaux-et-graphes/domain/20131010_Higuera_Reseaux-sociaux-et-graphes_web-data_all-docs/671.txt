https://www.math.univ-toulouse.fr/~msablik/Cours/MathDiscretes/MathDiscretes.pdf

MATHÉMATIQUES DISCRÈTES

Mathieu SABLIK

Table des matières

I

I.2

Principales règles de fonctionnement
Représentation .
.
.

Introduction à la théorie des ensembles
I.1 Notions sur les ensembles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
I.1.1 Construction par extension et compréhension . . . . . . . . . . . . . . . . . .
I.1.2
. . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
I.1.3
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Sous-ensembles .
Inclusion .
I.2.1
. .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
I.2.2
Ensemble des parties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
I.3 Opérations sur les ensembles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
I.3.1 Union et Intersection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
I.3.2 Différence et complémentaire . . . . . . . . . . . . . . . . . . . . . . . . . . . .
I.3.3
Produit cartésien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.
.

.
.

.
.

II Notions sur les langages

II.1 Exemples de problèmes
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
II.2 Mots sur un alphabet ﬁni . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
II.2.1 Un peu de vocabulaire . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
II.2.2 Propriété d’équidivisibilité . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
II.3.1 Déﬁnition et exemples de langages . . . . . . . . . . . . . . . . . . . . . . . . .
II.3.2 Opérations sur les langages . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
II.3.3 Equations sur les langages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

II.3 Langage .

.

.

.

.

.

.

.

.

.

.
.

.
.

.
.

III Fonctions et applications
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
III.1 Premières notions .
III.1.1 Déﬁnition .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
III.1.2 Modes de représentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
III.1.3 Composition de fonction et d’applications
. . . . . . . . . . . . . . . . . . . .
III.1.4 Applications singulières . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
III.2.1 Injection et surjection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
III.2.2 Bijection et application réciproque . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . .
III.3.1 Fonction caractéristique d’un ensemble . . . . . . . . . . . . . . . . . . . . . .
III.3.2 Suites .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

III.3 Quelques classes importantes de fonctions

III.2 Propriétés sur les fonctions

.

.

.

.

.

.

.

IV Cardinalité

IV.1 Cardinalité des ensembles ﬁnis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
IV.1.1 Ensembles de même cardinalité . . . . . . . . . . . . . . . . . . . . . . . . . . .
IV.1.2 Cardinal d’un ensemble ﬁni . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5
5
5
5
6
6
6
6
7
7
7
8

9
9
9
9
10
11
11
11
11

13
13
13
14
15
16
16
16
17
18
18
18

19
19
19
19

TABLE DES MATIÈRES

IV.2 Dénombrement

IV.3 Cas des ensembles inﬁnis

.

.

.

.

.

.

.
.

IV.1.3 Principe des tiroirs .
.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
IV.2.1 Dénombrement et opération sur les ensembles . . . . . . . . . . . . . . . . . .
IV.2.2 Arrangements et combinaisons . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
IV.3.1 Déﬁnition et premiers exemples d’ensembles dénombrables . . . . . . . . . .
IV.3.2 Critères de dénombrabilité . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
IV.3.3 Ensembles non dénombrables . . . . . . . . . . . . . . . . . . . . . . . . . . . .
IV.3.4 Théorème de Cantor-Schröder-Bernstein . . . . . . . . . . . . . . . . . . . . .

.

.

V Relations sur les ensembles

.

.

.

.

.
.

.
.

V.1 Vocabulaire des relations .
.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
V.1.1 Déﬁnition .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
V.1.2 Modes de représentations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
V.1.3 Quelques notions proches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
V.3.1 Déﬁnition et exemples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
V.3.2 Classes d’équivalence et partition . . . . . . . . . . . . . . . . . . . . . . . . .
V.3.3 Ensemble quotient
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

V.2 Propriétés sur les relations .
.
V.3 Relations d’équivalence .

.
.

.

.

VI Relations d’ordre

.

.
.

.
.

.
.

.
.

.
.

.
.

VI.1 Premières notions .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VI.1.1 Déﬁnition .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VI.1.2 Exemples de relations d’ordre classiques . . . . . . . . . . . . . . . . . . . . .
VI.1.3 Mode de représentation .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VI.1.4 Fonctions croissantes et décroissantes . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
VI.3.1 Ordre bien fondé .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VI.3.2 Application à l’étude de la terminaison d’algorithme . . . . . . . . . . . . . .
VI.3.3 N et le principe de récurrence . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VI.3.4 Principe d’induction .
VI.3.5 Déﬁnition inductive .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

VI.2 Bornes d’un ensemble .
.
VI.3 Induction .

.
.
.

.
.
.

.

.

.

.

.

.

.

.

VIIQuelques problèmes sur les graphes

.

.

.

.

.

.

.

.

.

.

.

.

.

.

.

VII.3.1 Graphes isolés .
.
VII.3.2 Graphes cycliques
VII.3.3 Graphes complets .
VII.3.4 Graphe biparti
.
.
VII.3.5 Graphes planaires
VII.3.6 Arbres .
.

VII.1 Différents problèmes à modéliser . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VII.2 Premières propriétés .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VII.2.1 Graphe orienté ou non . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VII.2.2 Isomorphisme de graphe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VII.2.3 Degré .
VII.3 Quelques classes de graphe importantes . . . . . . . . . . . . . . . . . . . . . . . . . .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
VII.4.1 Position du problème
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VII.4.2 Exemples d’applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VII.4.3 Nombre chromatique de graphes classiques
. . . . . . . . . . . . . . . . . . .
VII.4.4 Comment calculer un nombre chromatique ? . . . . . . . . . . . . . . . . . . .
VII.4.5 Résolution algorithmique . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VII.4.6 Cas des graphes planaires . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.
VII.4 Problèmes de coloriages .

.
.
.
.
.
.
.

.
.

.

.

.

.

.

2

20
21
21
24
25
25
26
27
28

29
29
29
29
30
31
32
32
33
34

35
35
35
35
36
36
37
38
38
38
39
41
41

45
45
46
46
47
47
48
48
48
48
49
49
49
50
50
50
51
51
51
53

3

Table des Matières

VII.5 Problèmes de chemins dans un graphe . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VII.5.1 Déﬁnitions .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VII.5.2 Connexité .
VII.5.3 Chemin Eulérien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
VII.5.4 Chemins hamiltonien . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

.
.

.
.

.
.

54
54
54
55
57

TABLE DES MATIÈRES

4

Introduction à la théorie des ensembles

ChapitreI

I.1 Notions sur les ensembles
I.1.1 Construction par extension et compréhension

Intuitivement, un ensemble est une collection d’objets deux à deux distincts appelés éléments.

On peut déﬁnir un ensemble de deux manières :

— en extension : on donne la liste exhaustive des éléments qui y ﬁgurent ;
— en compréhension : on donne les propriétés que doivent posséder les éléments de l’ensemble.

Exemple I.1. Voilà quelques exemples d’ensembles d’élèves :

— {Pierre ; Paul ; Marie}, on donne les trois éléments qui déﬁnissent l’ensemble ;
— {élèves de la classe qui ont les yeux bleus} ;
— {élèves qui viennent en cours en pyjama}, mais cet ensemble est certainement vide !

Exemple I.2. Dans votre scolarité vous avez rencontré certains ensembles classiques de nombres :

— N = {0, 1, 2, 3, . . .} est l’ensemble des nombres naturels ;
— N∗ = {1, 2, 3, . . .} est l’ensemble des nombres naturels non nul ;
— Z = {. . . ,−3,−2,−1, 0, 1, 2, 3, . . .} est l’ensemble des nombres entiers ;
— Q = {p/q : p ∈ Z et q ∈ N avec q (cid:54)= 0} ;
— R l’ensemble des nombres réels ;
— C l’ensemble des nombres complexes.

Exemple I.3. Les langages de programmation actuels exigent que certaines variables soient décla-
rées avec un certain type de données. Un type de données est un ensemble d’objets associés à une
liste d’opérations standards effectuées sur ces objets. Déﬁnir le type d’une variable équivaut à
déclarer l’ensemble des valeurs possibles et autorisées pour cette variable.

Dans la sémantique de Python vous avez dû rencontrer :

— le type bool s’interprète comme l’ensemble {Vrai, Faux},
— le type int s’interprète comme l’ensemble des entiers
— le type float s’interprète comme l’ensemble des nombres à virgule ﬂottante
— le type str s’interprète comme l’ensemble des chaînes de caractères
— le type list s’interprète comme l’ensemble des listes de longueur variable.

I.1.2 Principales règles de fonctionnement

On admettra l’existence d’ensembles. Sans rentrer dans l’axiomatique, la notion d’ensemble
satisfait un certain nombre de règles de fonctionnement, en voici les principales :
Relation d’appartenance Il faut pouvoir dire si un objet est dans l’ensemble. On note x ∈ A l’élé-

ment x est dans l’ensemble A.

Chapitre I. INTRODUCTION À LA THÉORIE DES ENSEMBLES

6

Objets distincts On peut distinguer deux éléments entre eux et un ensemble ne peut pas contenir

deux fois le même objet.

Ensemble vide Il existe un ensemble qui ne contient aucun élément, c’est l’ensemble vide et on le

note ∅ ou {}.

Paradoxe de Russell Un ensemble peut être élément d’un autre ensemble mais pas de lui même.
Remarque I.1. Cette dernière règle peut ne pas sembler naturelle. A la naissance de la théorie des
ensembles, les mathématiciens ne voyaient pas d’objection à envisager un ensemble dont les élé-
ments seraient tous les ensembles : l’ensemble des ensembles. Russell leur opposa le paradoxe
suivant :
Supposons que l’ensemble de tous les ensembles existe, et notons-le E. On considère l’ensemble
A = {x ∈ E : x /∈ x} . Comme E contient tous les ensembles, A appartient à E. Est-ce que A
appartient à A ?

— si A ∈ A alors par déﬁnition de A, on a A /∈ A,
— si A /∈ A alors par déﬁnition de A, on a A ∈ A.

I.1.3 Représentation

On peut représenter les ensembles à l’aide d’un diagramme de Venn, ce sont les fameux dia-

grammes “patates”.
Exemple I.4. L’ensembe {Pierre ; Paul ; Marie ; Julie ; Karim} se représente par :

×Julie

×Marie

×Pierre

×Karim

×Paul

I.2 Sous-ensembles
I.2.1 Inclusion

Déﬁnition I.1 (Sous-ensembles). L’ensemble A est un sous-ensemble de B si tous les éléments de A
sont des éléments de B (autrement dit x ∈ A =⇒ x ∈ B). On dit aussi que A est inclus dans B, on
le note A ⊂ B.
Remarque I.2. Pour tout ensemble A on a ∅ ⊂ A et A ⊂ A.
Exemple I.5. On a {1, 2} ⊂ {1, 2, 3}.

Bien sûr on a N ⊂ Z ⊂ Q ⊂ R ⊂ C.

Déﬁnition I.2 (Egalité d’ensembles). Deux ensembles sont égaux si et seulement si ils ont les
mêmes éléments, autrement dit si A ⊂ B et B ⊂ A.

I.2.2 Ensemble des parties

Déﬁnition I.3 (Ensemble des parties). Soit A un ensemble, l’ensemble des parties de A, noté P (A),
est l’ensemble des sous-ensembles de A.

On remarque que l’on a toujours ∅ ∈ P (A) car ∅ ⊂ A et A ∈ P (A) car A ⊂ A.

Exemple I.6. Si A = {1, 2, 3} alors P (A) = {∅,{1},{2},{3},{1, 2},{1, 3},{2, 3},{1, 2, 3}}.

7

I.3. Opérations sur les ensembles

Remarque I.3. On a P (∅) = {∅} et P (P (∅)) = {∅,{∅}}. La notation ∅ décrit un ensemble qui ne
contient rien alors que {∅} décrit un ensemble contenant un élément, l’ensemble vide. Un tiroir
contenant un sac vide ({∅}) n’est pas vide et contient bien un objet.

I.3 Opérations sur les ensembles

On présente ici des opérations sur les ensembles qui permettent de construire de nouveaux

ensembles.

I.3.1 Union et Intersection

Déﬁnition I.4 (Union). L’union des ensembles A et B est l’ensemble des éléments qui sont éléments
de A ou de B. On le note A ∪ B.
Proposition I.1 Propriétés de la réunion

La réunion admet certaines propriétés :

Idempotence : A ∪ A = A
Commutativité : A ∪ B = B ∪ A
Associativité : A ∪ (B ∪ C) = (A ∪ B) ∪ C
Elément neutre : A ∪ ∅ = A

Déﬁnition I.5 (Intersection). L’intersection des ensembles A et B est l’ensemble des éléments com-
muns à A et à B. On le note A ∩ B.

On dit que deux ensembles sont disjoints (ou incompatibles) si A ∩ B = ∅.

Proposition I.2 Propriétés de l’intersection

L’intersection admet certaines propriétés :

Idempotence : A ∩ A = A
Commutativité : A ∩ B = B ∩ A
Associativité : A ∩ (B ∩ C) = (A ∩ B) ∩ C
Elément neutre : si l’on se place dans un ensemble Ω appelé univers et que A est un sous-

ensemble de Ω alors A ∩ Ω = A

Proposition I.3 Propriétés de distributivité

On a les distributivités suivantes entre l’union et l’intersection :

de ∪ sur ∩ : A ∪ (B ∩ C) = (A ∪ B) ∩ (A ∪ C)
de ∩ sur ∪ : A ∩ (B ∪ C) = (A ∩ B) ∪ (A ∩ C)

I.3.2 Différence et complémentaire

Déﬁnition I.6 (Différence). La différence de l’ensemble A par l’ensemble B est l’ensemble des élé-
ments qui sont dans A mais pas dans B, on le note A (cid:114) B.
Déﬁnition I.7 (Différence symétrique). La différence symétrique entre les ensembles A et B est l’en-
semble des éléments qui sont dans A ou B mais pas dans les deux, on le note

A∆B = (A ∪ B) (cid:114) (A ∩ B).

Déﬁnition I.8 (Complémentaire). On se ﬁxe un ensemble Ω appelé univers. Pour A ⊂ Ω, on
déﬁnit le complémentaire de A par rapport à Ω comme l’ensemble des éléments de Ω qui ne sont
pas éléments de A, on le note A = Ω (cid:114) A lorsqu’il n’y a pas d’ambiguïtés.

Chapitre I. INTRODUCTION À LA THÉORIE DES ENSEMBLES

8

Remarque I.4. Il faut obligatoirement se placer dans un ensemble de référence pour déﬁnir la com-
plémentation.
Proposition I.4 Propriétés de la complémentation
La complémentation a plusieurs propriétés :

Involution : A = A
Loi de Morgan : A ∩ B = A ∪ B et A ∪ B = A ∩ B

A

B

Ω

n

U n i o

Intersection D

iffére

Différencesymétrique

c

n

e

A ∪ B

A ∩ B

A (cid:114) B

A∆B

Passage au complémentaire

A ∪ B

A ∩ B

A (cid:114) B

A∆B

FIGURE I.1 – Exemples de constructions d’ensembles à partir des ensembles A et B contenus dans
l’univers Ω

I.3.3 Produit cartésien

Déﬁnition I.9 (Produit cartésien). Le produit cartésien des ensembles A et B (dans cet ordre) est
l’ensemble des couples (a, b) où a ∈ A et b ∈ B, on le note A × B.
(a1, . . . , ak) où ai ∈ Ai pour tout i ∈ {1, . . . , k}, on le note A1 × · · · × Ak.

Le produit cartésien des ensembles A1, A2, . . . , Ak (dans cet ordre) est l’ensemble des k-uplets
Si A1 = · · · = Ak on note Ak l’ensemble des k-uplets formés par les éléments de A.

Remarque I.5. Le couple (a, b) n’est pas un ensemble.

Si a (cid:54)= b alors (a, b) est distinct de (b, a).

Exemple I.7. Le système de codage informatique des couleurs RGB, (de l’anglais ”Red, Green,
Blue”) reconstitue une couleur par synthèse additive à partir de trois couleurs primaires (rouge,
vert et bleu), formant sur l’écran une mosaïque trop petite pour être aperçue. Ainsi pour chacune
des trois couleurs primaires, on donne une valeur s’exprimant dans un intervalle entre 0 et 255.
D’un point de vue informatique, une couleur est donc un élément de [0; 255] × [0; 255] × [0; 255] =
[0; 255]3.

ChapitreII

Notions sur les langages

II.1 Exemples de problèmes

La notion de langage est utilisée pour modéliser différents problèmes où l’information est sto-

ckée sous une forme de chaîne de caractères. Voici quelques exemples :

— Langage naturel : chaque mot est formé par un ensemble de lettres concaténées. L’ensemble
des mots forme un dictionnaire. Puis ces mots sont organisés pour former des phrases. Dans
ce cas, une structure apparaît qui est régie par la grammaire de la langue utilisé.

— Stocker de l’information sur un disque dur : toute information stockée sur un disque dur
est codée par une succession de bits (0 ou 1), que ce soit du texte, image, musique... On
peut se demander s’il est possible de compresser cette information, c’est-à-dire trouver une
fonction qui a un chaîne de {0, 1} renvoie de manière bijective une chaîne plus courte.

— Recherche de chaîne de caractères dans un texte.
— Compilation : un programme est une suite de caractères. Un compilateur s’intéresse essen-

tiellement aux deux choses suivantes :
— Analyse lexicale : on cherche les éléments de bases qui structurent le programme (If, For,
— Analyse syntaxique : on vériﬁe que les expressions sont correctes (ex : var + var ∗ var va

While, affectation...).
être interprété comme var + (var ∗ var)).

— Bio-informatique : l’ADN code l’information génétique à l’aide de 4 bases azotées : adénine

(A), cytosine (C), guanine (G) ou thymine (T).

II.2 Mots sur un alphabet ﬁni
II.2.1 Un peu de vocabulaire

Alphabet Un alphabet A est un ensemble ﬁni dont les éléments sont appelés des lettres.
Exemple II.1. B = {0, 1} est l’alphabet binaire, A = {a, b, c} est un alphabet à trois lettres, B =
{a, . . . , z} un alphabet à 26 lettres . On peut considérer n’importe quel ensemble ﬁni, par exemple
C = {hello, word} est un alphabet à deux lettres.
Mots sur un alphabet ﬁni Un mot est une suite ﬁnie d’éléments de A on le note u = u1u2 . . . un
et n est la longueur du mot u, notée |u|. Le mot vide est noté ε.

On note A∗ l’ensemble des mots sur A et A+ l’ensemble des mots sans le mot vide.

Opérations sur les mots Soient u et v deux mots de A∗, on déﬁnit la concaténation w = u.v
comme le mot de longueur |u| + |v| tel que w = u1u2 . . . u|u|v1v2 . . . v|v|.

Chapitre II. NOTIONS SUR LES LANGAGES

10

Pour n ∈ N on déﬁnit par récurrence la puissance d’un mot par u0 = ε et un+1 = u.un pour

n ∈ N.

On dit que v est un préﬁxe de u s’il existe un mot w tel que u = v.w et v est un sufﬁxe de u s’il

existe un mot w tel que u = w.v.

Distance sur les mots On peut déﬁnir différentes distances sur les mots. On s’intéressera ici à
la distance édition déﬁnie comme étant le plus petit nombre d’opérations d’édition élémentaires
nécessaires pour transformer le mot u en le mot v. Les opérations d’édition élémentaires sont la
suppression ou l’insertion d’un symbole.

De multiples variantes de cette notion de distance ont été proposées, qui utilisent des en-
sembles d’opérations différents et/ou considèrent des poids variables pour les différentes opé-
rations. Pour prendre un exemple réel, si l’on souhaite réaliser une application qui « corrige » les
fautes de frappe au clavier, il est utile de considérer des poids qui rendent d’autant plus proches
des séquences qu’elles ne diffèrent que par des touches voisines sur le clavier, permettant d’inté-
grer une modélisation des confusions de touches les plus probables.

L’utilitaire Unix diff implante une forme de calcul de distances. Cet utilitaire permet de com-
parer deux ﬁchiers et d’imprimer sur la sortie standard toutes les différences entre leurs contenus
respectifs.

II.2.2 Propriété d’équidivisibilité

Lemme II.1 Lemme de Levi

qu’un des deux cas suivant est vériﬁé :

Soient u, v, z, t des mots sur l’alphabet A tels que uv = zt. Alors il existe un mot w ∈ A∗ tel
— ou bien u = zw et t = wy si |u| ≥ |z|,
— ou bien z = uw et v = wt si |u| ≤ |z|.

Démonstration : On considère que uv = zt = a1a2 . . . an où les ak sont des lettres de A. Soit i l’entier tel

que u = a1a2 . . . ai et v = ai+1 . . . an. De même soit j l’entier tel que z = a1a2 . . . aj et t = aj+1 . . . an.

Si |u| ≥ |z|, alors i ≥ j et on a u = zw et t = wv avec w = aj+1 . . . ai.
Si au contraire |u| ≤ |z|, alors i ≤ j et on a z = uw et v = wt avec w = ai+1 . . . aj.

Graphiquement cela signiﬁe que l’on a une des deux décompositions suivantes :

u

z

v

w

t

ou bien

u

z

v

w

t

Exemple II.2. Soient u = anti, v = constitutionnellement, z = anticonstitutionnel, t = lement quatre
mots. Comme anti.constitutionnellement = anticonstitutionnel.lement, et que de plus |anti| ≤
|anticonstitutionnel| alors il existe le mot w = constitutionnel tel que anticonstitutionnel = anti.constitutionnel
et constitutionnellement = constitutionnel.lement.

Une conséquence importante : si on applique le Lemme de Levi avec u = z, on a w =  et donc
v = t. On en déduit que si uv = ut alors v = t, autrement dit, on peut simpliﬁer à gauche. De
même, on peut simpliﬁer à droite une équation sur les mots.

Proposition II.2

Soient u, v, z et t ∈ A∗. Si uv = ut alors v = t.
De même si uv = zv alors u = z.

11

II.3. Langage

II.3 Langage
II.3.1 Déﬁnition et exemples de langages

Un langage L sur un alphabet ﬁni A est un ensemble de mots déﬁnis sur A autrement dit

L ⊂ A∗.
Exemple II.3. Exemples de langages sur B = {0, 1} :

— ∅ (cid:54)= {ε} ;
— B∗ = {ε, 0, 1, 00, 01, 10, 11, 000, 001, . . .} ;
— B+ = {0, 1, 00, 01, 10, 11, 000, 001, . . .} ;
— tout ensemble ﬁni de mots ;
— {0n : n ∈ N} ;
— {0n1m : n, m ∈ N} ;
— {0n1n : n ∈ N} ;
— {0p : p ∈ N nombre premier} ;
— {u ∈ B∗ : u est le codage en binaire d’un nombre premier} ;
— {u ∈ B∗ : u est un palindrome} ;
— {u ∈ B∗ : u est un code html certiﬁé} (cid:54)= {u ∈ A∗ : u est un code html bien interprété par Firefox} ;
— {u ∈ B∗ : u est le codage en MP3 de votre chanson préférée} ;
— {u ∈ B∗ : u est le codage en assembleur d’un programme qui s’arrête sur l’entrée vide} ;
— . . .

II.3.2 Opérations sur les langages

sur les langages :

Soient L, L1 et L2 des langages sur un alphabet ﬁni A. On peut déﬁnir différentes opérations
— Union : L1 ∪ L2 langage comportant des mots de L1 ou de L2 ;
— Intersection : L1 ∩ L2 langage comportant des mots de L1 et de L2 ;
— Compémentaire : L langage comportant des mots de A∗ qui ne sont pas dans L ;
— Concaténation : L1.L2 langage comportant les mots formés en concaténant un mot L1 à un

mot de L2

— Puissance : On déﬁnit par récurrence la puissance nème de L, notée Ln par

L1.L2 = {u1.u2 : u1 ∈ L1 et u2 ∈ L2};

L0 = {ε} et Ln+1 = L.Ln.

Attention, il ne faut pas confondre, on a Ln = {u ∈ A∗ : il existe u1, u2, . . . , un ∈ L tel que u =
u1.u2.· · · .un} qui en général est différent de {un : n ∈ N}.
(cid:91)

— Fermeture de Kleene : On déﬁnit
L∗ =

L+ =

Ln

Ln.

et

(cid:91)

n≥0

n>0

II.3.3 Equations sur les langages

Proposition II.3 Le lemme d’Arden

Soient M et N deux langages sur A tels que ε /∈ M. L’équation sur les langages X =

M.X ∪ N où X est le langage inconnu, admet pour unique solution M∗.N .

Chapitre II. NOTIONS SUR LES LANGAGES

12

ChapitreIII

Fonctions et applications

La notion d’application permet d’associer à chaque élément d’un ensemble un élément d’un
autre ensemble. En informatique, on a souvent de cette notion pour passer d’un objet à sa représen-
tation, pour traduire une représentation vers une autre, comme support de preuves de propriétés
de programmes, etc...

III.1 Premières notions
III.1.1 Déﬁnition

Déﬁnition III.1 (Fonction). Soient E et F deux ensembles. Une fonction f : E → F (de E dans F) est
déﬁnie par un sous-ensemble de G f ⊂ E × F tel que pour tout x ∈ E, il existe au plus un y ∈ F tel
que (x, y) ∈ G f . Quand il existe, on note cet élément par f (x). L’élément x est alors l’antécedent de
y et y est l’image de x. On note aussi f : x (cid:55)−→ y le fait que f associe l’élément y comme image de
x.

Etant donné A ⊂ E et B ⊂ F, on déﬁnit

— l’image de A par f :

f (A) = {y ∈ F : il existe x ∈ E tel que f (x) = y};

— la préimage de B par f :

f −1(B) = {x ∈ E : il existe y ∈ F tel que f (x) = y}.

Déﬁnition III.2 (Domaine de déﬁnition, Image). Le domaine de déﬁnition d’une fonction f : E → F,
noté Dom( f ) est l’ensemble des éléments de x ∈ E qui ont une image par f . Autrement dit :

Dom( f ) = f −1(F) = {x ∈ E : il existe y ∈ F tel que f (x) = y}

L’ensemble image d’une fonction f : E → F, noté Im( f ) est l’ensemble des éléments de y ∈ E qui

ont un antécédent par f . Autrement dit :

Im( f ) = f (E) = {y ∈ F : il existe x ∈ E tel que f (x) = y}

Déﬁnition III.3 (Egalité). Deux fonctions f : E → F et g : E → F sont égales si Dom( f ) = Dom(g)
et f (x) = g(x) pour tout x ∈ Dom( f ).
Déﬁnition III.4 (Application). Une application de E dans F est une fonction de E dans F telle que
Dom( f ) = E . On note FE l’ensemble des applications de E dans F.

Chapitre III. FONCTIONS ET APPLICATIONS

14

III.1.2 Modes de représentation

On donne ici différents moyens pour représenter une fonction f : E → F.

Table de valeur Pour chaque élément de E on donne l’élément de F associé. Si E est ﬁni on peut
représenter cela sous forme de tableau.

x
f(x)

0
aa

1
nj

2
zj

3
nk

4
za

5
az

6
aa

7
aa

8
zz

9
ju

Un autre exemple est le code ASCII qui permet d’associer à chaque entier entre 0 et 127 un

caractère :

Diagramme de Venn Parfois il est plus visuel de montrer les différents liens sur un diagramme
de Venn.

×
e
×
d

×
b

×
a

×
c

E

×
1

×
4

×
2

F

×
3

15

III.1. Premières notions

Formule algébrique Lorsque l’ensemble E est inﬁni, on ne peut pas stocker toutes les valeurs,
on peut déﬁnir la fonction par une formule :

f : R −→

x

R

(cid:55)−→ 3x2 + 2x − 5

Courbe On peut aussi représenter la fonction sous forme de courbe qui à chaque point de l’abs-
cisse fait correspondre un élément de l’ordonnée.

8

6

4

2

0

5

10

15

20

: E → F par un algorithme qui prend en
Algorithme On peut aussi déﬁnir une fonction f
argument un élément de E et lorsqu’il s’arrête, il renvoie un élément de F. Le domaine de déﬁnition
est l’ensemble des valeurs pour lesquelles l’algorithme s’arrête.

III.1.3 Composition de fonction et d’applications

Déﬁnition III.5 (Composition). On considère les fonctions f : E → F et g : F → G. On déﬁnit la
fonction composée de f par g, notée g ◦ f : E → G, déﬁnie par g ◦ f (x) = g( f (x)). On applique f à
l’argument x, puis on applique g au résultat s’il existe.
Le domaine de déﬁnition de g ◦ f est donné par :

Dom(g ◦ f ) = {x ∈ Dom( f ) : f (x) ∈ Dom(g)}

Attention, en général, on considère la composée d’applications pour s’abstraire des contraintes

de domaines de déﬁnition.
Exemple III.1. Soient E = {α, β, γ}, F = {a, b, c, d, e} et G = {1, 2, 3, 4}, on déﬁnit f
g : F → G par :

: E → F et

f : E −→ F
(cid:55)−→ b
α
β (cid:55)−→ a
γ (cid:55)−→ d

g : F −→ G
(cid:55)−→ 2
(cid:55)−→ 1
(cid:55)−→ 4
(cid:55)−→ 3
(cid:55)−→ 1

a
b
c
d
e

La représentation avec le diagramme de Venn donne :

Chapitre III. FONCTIONS ET APPLICATIONS

16

β
×

×
α

×
γ

E

e
×
d
×

b
×

a
×

c
×

f

F
g ◦ f

g

×
1

×
4

×
3

×
2

G

Ainsi la fonction f ◦ g : E −→ G donne les associations suivantes :
γ (cid:55)−→ 3

β (cid:55)−→ 2

α (cid:55)−→ 1

Remarque III.1. Au milieu du XXème siècle, quelques mathématiciens trouvèrent que la notation
g ◦ f portait à confusion et décidèrent d’utiliser une notation post-ﬁxée : x f pour f (x) et x f g pour
g ◦ f (x).
Remarque III.2. Attention en général f ◦ g (cid:54)= g ◦ f .
Proposition III.1 Associativité de la composée

Soient f

: E → F, g : F → G et h : G → H trois applications. Alors on a h ◦ (g ◦ f ) =

(h ◦ g) ◦ f et cette application se note h ◦ g ◦ f .

Démonstration : Par déﬁnition de la composition d’applications, il vient h ◦ (g ◦ f )(x) = h(g ◦ f (x)) =

h(g( f (x))) et (h ◦ g) ◦ f (x) = h ◦ g( f (x)) = h(g( f (x))) pour tout x ∈ E d’où l’égalité recherchée.

III.1.4 Applications singulières

Déﬁnition III.6 (Identité). Etant donné un ensemble A, la fonction identité est l’application déﬁnie
par

IdA : A −→ A
(cid:55)−→ x

x

Déﬁnition III.7 (Injection canonique). Soit A ⊂ B, l’injection canonique est l’application déﬁnie par

f : A −→ B
(cid:55)−→ x

x

Déﬁnition III.8 (Projection canonique). Soit A1 × · · · × Ak le produit cartésien de k ensemble, la
projection canonique suivant la ième coordonnée pour i ∈ {1, . . . , k} est l’application déﬁnie par

πi : A1 × · · · × Ak −→ Ai
(cid:55)−→ ai

(a1, . . . , ak)

III.2 Propriétés sur les fonctions
III.2.1

Injection et surjection

Déﬁnition III.9 (Fonction injective). Une fonction est injective si tout élément de l’espace d’arrivée
admet au plus un antécédent.
Déﬁnition III.10 (Fonction surjective). Une fonction est surjective si chaque élément de l’espace
d’arrivée admet au moins un antécédent.

Autrement dit, si f : E → F est une fonction alors Im( f ) = f (E) = F.

17

III.2. Propriétés sur les fonctions

III.2.2 Bijection et application réciproque

Déﬁnition III.11 (Application bijective). Une application qui est à la fois injective et surjective est
bijective.

Attention, en général, la notion de bijection est utilisé pour les applications.

Proposition III.2

telle que f ◦ g = IdF et g ◦ f = IdE.
notée f −1.

L’application f : E → F est bijective si et seulement si il existe une application g : F → E

Si f est bijective, l’application g est unique, c’est l’application réciproque de l’application f ,

Démonstration : Si f : E → F est bijective alors à chaque élément x ∈ E correspond un et un seul élément
y ∈ F, c’est la déﬁnition de l’application. De même, à chaque élément y ∈ F correspond un élément
x ∈ E (c’est la surjectivité), et cet élément est unique (c’est l’injectivité). Cela permet de déﬁnir une
fonction g : F → E qui vériﬁe

x = g(y) si et seulement si f (x) = y.

On en déduit que f ◦ g = IdF et g ◦ f = IdE.
Montrons qu’une telle application est unique. Soit h : F → E telle que f ◦ h = IdF et h ◦ f = IdE.
On a f ◦ h(y) = f ◦ g(y) = IdF(y) pour tout y ∈ F, par injectivité de f , on en déduit que h(y) = g(y).
Les fonctions g et h sont donc égales.
Supposons maintenant qu’il existe une fonction g : F → E telle que f ◦ g = IdF et g ◦ f = IdE et
montrons que f est bijective :
— Soient x1, x2 ∈ E tels que f (x1) = f (x2), on a donc g( f (x1)) = g( f (x2)) et comme g ◦ f = IdE on
— Soient y ∈ F, on a y = IdF(y) = f (g(y)). Ainsi, g(y) est une préimage de y par f , on en déduit

en déduit que x1 = x2 et donc que f est injective.

que f est surjective.

f est injective et surjective, on en déduit que f est bijective.

Exemple III.2. L’application de R dans R déﬁnie par f : x (cid:55)−→ 2x est :

2 ) = y ;

— surjective car pour tout y ∈ R on a y
— injective car si x, y ∈ R vériﬁent f (x) = f (y) alors 2x = 2y autrement dit x = y.

2 ∈ R et f ( y

La fonction f est donc bijective et son application réciproque est f −1 : x (cid:55)−→ x
2 .

Proposition III.3

Soient f : E → F et g : F → G deux bijections. La composée g ◦ f est bijective et

(g ◦ f )−1 = f −1 ◦ g−1.

Démonstration : On a :

(g ◦ f ) ◦ ( f −1 ◦ g−1) = g ◦ f ◦ f −1 ◦ g−1 = g ◦ IdF ◦ g−1 = g ◦ g−1 = IdG.

De même, on a :

( f −1 ◦ g−1) ◦ (g ◦ f ) = f −1 ◦ g−1 ◦ g ◦ f = f −1 ◦ IdF ◦ f = f −1 ◦ f = IdE.

On en déduit que g ◦ f est bijective et par unicité de l’application réciproque, on a (g ◦ f )−1 =

f −1 ◦ g−1.

Chapitre III. FONCTIONS ET APPLICATIONS

18

III.3 Quelques classes importantes de fonctions
III.3.1 Fonction caractéristique d’un ensemble

Déﬁnition III.12. Soit Ω un ensemble pour tout A ⊂ Ω on déﬁnit la fonction caractéristique de
l’ensemble A par

®

1A : Ω −→ {0, 1}

(cid:55)−→

x

si x ∈ A
si x /∈ A

1
0

La fonction caractéristique d’un ensemble permet de déﬁnir un ensemble de manière fonction-

nelle. Ainsi, on a :

A = {x ∈ Ω : 1A(x) = 1}

Proposition III.4 Propriétés des fonctions caractéristiques

Soient A, B ∈ P (Ω), pour tout x ∈ Ω, on a :
1. 1A∩B(x) = 1A(x) × 1B(x)
2. 1A∪B(x) = 1A(x) + 1B(x) − 1A∩B(x)
3. 1A(x) = 1 − 1A(x)

Exemple III.3. A l’aide des fonctions caractéristiques on peut retrouver les formules classiques, par
exemple pour tout x ∈ Ω, on a :

1A∪B(x) = 1 − (1A(x) + 1B(x) − 1A∩B(x))
= 1 − 1A(x) − 1B(x) + 1A(x)1B(x)
= (1 − 1A(x))(1 − 1B(x))
= 1A(x)1B(x)
= 1A∩B(x)

Comme l’égalité est vraie pour tout x ∈ Ω, on en déduit que A ∪ B = A ∩ B.

III.3.2 Suites

Soit K un ensemble, une suite à valeurs dans K est une application de N dans K. On note KN
l’ensemble des suite à valeurs dans K. Etant donnée une suite u ∈ KN, on note souvent un le nème
élément de la suite et u = (un)n∈N.

ChapitreIV

Cardinalité

En informatique, la résolution algorithmique de nombreux problèmes consiste en l’énuméra-
tion exhaustive de ses possibilités pour ensuite décider pour chacune si elle est solution ou non au
problème. Il est parfois bon d’évaluer le nombre de possibilités aﬁn d’évaluer le temps d’exécution
de l’algorithme.

IV.1 Cardinalité des ensembles ﬁnis
IV.1.1 Ensembles de même cardinalité

Considérons les ensembles E = {a, b, c, d} et F = {1, 2, 3}. Il est possible de déﬁnir une applica-
tion surjective de E sur F, mais pas d’application injective. Il est possible de déﬁnir une application
injective de F sur E, mais pas d’application surjective. En fait, il n’y a pas assez d’éléments dans F
(ou trop peu dans E). Le cardinal d’un ensemble précise la notion de nombre d’éléments.
Déﬁnition IV.1 (Ensemble de même cardinal). Deux ensembles (ﬁni ou non) sont équipotents ou
de même cardinal s’il existe une bijection entre eux.
Remarque IV.1. Par abus de langage on dit qu’il existe une surjection (respectivement une injection,
une bijection) s’il existe une application surjective (respectivement une application injective, une
application bijective).

IV.1.2 Cardinal d’un ensemble ﬁni

Lemme IV.1

Soient n et k deux entiers naturels.
— S’il existe une application injective de {1, . . . , n} dans {1, . . . , k} alors n ≤ k.
— S’il existe une application surjective de {1, . . . , n} dans {1, . . . , k} alors n ≥ k.
— S’il existe une application bijection de {1, . . . , n} dans {1, . . . , k} alors n = k.

Démonstration : Montrons par récurrence sur n ∈ N∗ la propriété Pn : pour tout k ∈ N, s’il existe une

application injective de {1, . . . , n} dans {1, . . . , k} alors n ≤ k.

Clairement cette propriété est vraie pour P1 car il n’y a pas d’application d’un ensemble non vide
dans un ensemble vide.
Supposons que Pn est vériﬁée et montrons que Pn+1 est aussi vériﬁée. Soit f : {1, . . . , n + 1} →
{1, . . . , k} une injection. Pour tout x ∈ {1, . . . , n}, on a f (x) (cid:54)= f (n + 1) car f est une injection. On a
deux cas possibles :
— Si f (x) < f (n + 1) pour tout x ∈ {1, . . . , n} alors f (x) ∈ {1, . . . , k − 1} car f (x) ≤ f (n + 1) − 1 ≤

k − 1. En utilisant l’hypothèse de récurrence, on en déduit que n ≤ k − 1 et donc n + 1 ≤ k.

Chapitre IV. CARDINALITÉ

20

— Sinon, on considère x0 ∈ {1, . . . , n} tel que f (x0) > f (x) pour tout x ∈ {1, . . . , n + 1} (cid:114) {x0}. On
déﬁnit la fonction g : {1, . . . , n + 1} → {1, . . . , k} telle que g(x) = f (x) pour tout x ∈ {1, . . . , n +
1} (cid:114){x0, n + 1}, g(x0) = f (n + 1) et g(n + 1) = f (x0). Comme f est une injection, les éléments de
{1, . . . , n + 1} n’ont pas deux images identiques par g donc g est injective. De plus g(x) < g(n + 1)
pour tout x ∈ {1, . . . , n}, en réalisant le même raisonnement que le point précédent, on en déduit
que n + 1 ≤ k.
Par récurrence la propriété Pn est vériﬁée pour tout n ∈ N ce qui montre le premier point du

lemme.

Le deuxième point se montre de la même manière.
Si f : {1, . . . , n} → {1, . . . , k} est bijective, elle est injective d’où n ≤ k, et elle est surjective d’où

n ≥ k. On en déduit que n = k.
Si on a une bijection f : E → {1, . . . , n} et une bijection g : E → {1, . . . , m} alors g ◦ f −1 réalise
une bijection de {1, . . . , n} dans {1, . . . , m}. On en déduit que n = m ce qui nous permet de déﬁnir
le cardinal d’un ensemble ﬁni.

Déﬁnition IV.2 (Cardinal d’un ensemble ﬁni). Un ensemble E est ﬁni s’il est vide ou s’il existe
n ∈ N∗ tel que E est en bijection avec {1, . . . , n}. Cet entier est unique, il est appelé le cardinal de
E. On le note Card (E). Si E est vide, on pose Card (E) = 0.

Remarque IV.2. Le cardinal d’un ensemble ﬁni correspond à l’idée naturelle du nombre d’éléments
d’un ensemble.
Proposition IV.2

Soient E et F deux ensembles ﬁnis. On a :
— Il existe une application injective de E dans F si et seulement si Card (E) ≤ Card (F).
— Il existe une application surjective de E dans F si et seulement si Card (E) ≥ Card (F).
— Il existe une application bijective de E dans F si et seulement si Card (E) = Card (F).
Démonstration : Soient g : E → {1, . . . , Card (E)} et h : F → {1, . . . , Card (F)} deux bijections déﬁnis-

Montrons le deuxième point. Soit f

Montrons le premier point. Soit f : E → F une injection, h◦ f ◦ g−1 est une injection de {1, . . . , Card (E)}

sant le cardinal de E et F.
dans {1, . . . , Card (F)}, donc Card (E) ≤ Card (F). Réciproquement, supposons que Card (E) ≤
Card (F). On déﬁnit ϕ = h−1 ◦ i ◦ f où i : x (cid:55)→ x est l’injection canonique de {1, . . . , Card (E)} dans
{1, . . . , Card (F)}. L’application ϕ est une injection de E dans F.
: E → F une surjection, h ◦ f ◦ g−1 est une surjection de
{1, . . . , Card (E)} dans {1, . . . , Card (F)}, donc Card (E) ≥ Card (F). Réciproquement, supposons que
Card (E) ≥ Card (F). On déﬁnit ϕ = h−1 ◦ s ◦ f où s : {1, . . . , Card (E)} → {1, . . . , Card (F)} est déﬁ-
nie par s(x) = x si x ∈ {1, . . . , Card (F)} et s(x) = 1 si x ∈ {Card (F) + 1, . . . , Card (E)}. L’application
s est surjective et donc ϕ est une surjection de E dans F.
: E → F. Alors h ◦ f ◦ g−1 est une bijection
Pour le dernier point, on considère une bijection f
de {1, . . . , Card (E)} dans {1, . . . , Card (F)}, on en déduit que Card (E) = Card (F). Réciproquement,
supposons que Card (E) = Card (F) = n et considérons deux bijections g : E → {1, . . . , n} et h : F →
{1, . . . , n}. On en déduit que h−1 ◦ g est une bijection de E dans F.

IV.1.3 Principe des tiroirs

La contraposée du premier point de la proposition IV.2 établit un principe naturel très utilisé
en combinatoire appelé "principe des tiroirs" : si on doit ranger plus de paires de chaussettes qu’on
a de tiroirs, alors forcément un tiroir recevra au moins deux paires. Formellement cela se traduit
par la proposition suivante.
Proposition IV.3 Principe des tiroirs

Soient E et F deux ensembles ﬁnis non vides et f : E → F une application. Si Card (E) >

Card (F) alors il existe x1, x2 ∈ E tels que f (x1) = f (x2).

21

IV.2. Dénombrement

Démonstration : On peut faire une preuve directe de ce résultat. Comme E est ﬁni on note E = {x1, . . . , xCard(E)}.

Soit f : E → F et supposons que f (xi) (cid:54)= f (xj) si i (cid:54)= j. On en déduit que f (x1), . . . , f (xCard(E)) sont
tous distincts et sont des éléments de F ainsi Card (E) ≤ Card (F). On en déduit que si Card (E) >
Card (F) alors au moins deux éléments de E ont la même image.

Exemple IV.1. Il y a au moins deux personnes à Paris qui ont exactement le même nombre de
cheveux. Le nombre moyen de cheveux chez un humain est de 150000 donc raisonnablement,
personne n’en a plus d’un million. Or il y a plus d’un million d’habitants à Paris, donc au moins
deux habitants ont le même nombre de cheveux.
Il est possible d’étendre le principe des tiroirs.

Proposition IV.4

Soient E et F deux ensembles ﬁnis non vides et f : E → F une application. Si Card (E) >

k Card (F) avec k ∈ N∗ alors il existe une valeur de f qui est répétée au moins k + 1 fois.

Démonstration : Si chaque valeur de f est répétée au plus k fois alors E contient au plus k Card (F)

éléments. Ainsi si Card (E) > k Card (F), une valeur de f est répétée au moins k + 1 fois.

Exemple IV.2. Voyons combien de noms différents doivent apparaître dans l’annuaire pour qu’au
moins cinq noms commencent et terminent par la même lettre. Soient E l’ensemble des noms et
F l’ensemble des paires de lettres qu’il est possible de constituer avec un alphabet de 26 lettres.
Clairement Card (F) = 26 × 26 = 676. On considère la fonction f
: E → F qui renvoie pour
chaque nom la paire de lettre correspondant aux premières et dernières lettre du nom (par exemple
f (maurice) = (m, e)). Pour avoir cinq noms qui commence par la même lettre et termine par la
même lettre il faut que Card (E) > 4 Card (F) = 4 × 676 = 2704. Ainsi il faut que l’annuaire
contienne au moins 2705 noms.
Exemple IV.3. Montrons que dans tout groupe de six personnes, trois se connaissent mutuellement
ou trois ne se sont jamais vues. Considérons x une personne, E l’ensemble des cinq autres per-
sonnes et B = {0, 1}. Prenons la fonction f : E → B tel que f (a) = 1 si a ∈ E connaît x et 0 sinon.
Comme Card (E) > 2 Card (B), soit trois personnes connaissent x, soit il ne connaissent pas x.

Supposons que a, b et c connaissent x. Si deux d’entre eux se connaissent, avec x on a trouvé

trois personnes qui se connaissent mutuellement. Sinon a, b et c ne se connaissent pas.

Le même type de raisonnement fonctionne si a, b et c ne connaissent pas x.

IV.2 Dénombrement

On cherche le cardinal d’un ensemble ﬁni, c’est à dire à dénombrer le nombre d’éléments de
cet ensemble. Dans votre scolarité en informatique vous utiliserez la notion de dénombrement au
moins dans les deux cas de ﬁgures suivants :

— dénombrer le nombre de cas à analyser par un algorithme en vu d’étudier sa complexité ;
— lorsqu’on tire au hasard un élément dans un univers ﬁnis Ω de manière équiprobable (c’est
à dire que chaque élément à la même probabilité d’être tiré), la probabilité que cet élément
soit dans l’ensemble A ⊂ Ω est

P(A) =

Card (A)
Card (Ω)

.

IV.2.1 Dénombrement et opération sur les ensembles

On répertorie ici les principes de bases pour dénombrer un ensemble. Cela revient à décompo-

ser l’ensemble considéré en ensembles plus simples à l’aide des opérations sur les ensembles.

Union et intersection

Si A et B sont deux ensembles disjoints, c’est à dire A ∩ B = ∅, on a :

Card (A ∪ B) = Card (A) + Card (B) .

Chapitre IV. CARDINALITÉ

22

Si (Ai)i∈I est une famille d’ensembles disjoints indexée par I, on a :

(cid:33)

(cid:32)(cid:91)

i∈I

(cid:88)

i∈I

Card

Ai

=

Card (Ai) .

Lorsque A et B sont deux ensembles quelconques, on cherche à écrire l’union comme une union

disjointe d’ensembles. Ainsi A ∪ B = (A (cid:114) B) ∪ (B (cid:114) A) ∪ (A ∩ B) et l’union est disjointe ainsi

Card (A ∪ B) = Card (A (cid:114) B) + Card (B (cid:114) A) + Card (A ∩ B)

On a aussi A = (A (cid:114) B) ∪ (A ∩ B) et B = (B (cid:114) A) ∪ (A ∩ B) et les deux unions sont disjointes.
On en déduit que Card (A) = Card (A (cid:114) B) + Card (A ∩ B) et Card (A ∪ B) = Card (B (cid:114) A) +
Card (A ∩ B). On en déduit que

Card (A ∪ B) = Card (A) + Card (B) − Card (A ∩ B)

Sur le diagramme de Venn cela donne :

×
h

×
c

A

×
b

×

f

×
e

×
d

B

×
g

×
a

×
h

×
c

A

×
b

×
i

×
l

×
j

×

f

×
e

C
×
m

×
d

B

×
g

×
a

×
k

Lorsqu’on fait l’opération Card (A) +
Card (B), les éléments e et f sont comp-
tés deux fois.
Pour compter le nombre d’éléments
dans A ∪ B, on doit donc retrancher
Card (A ∩ B) à Card (A) + Card (B).

l’opération Card (A) +
Lorsqu’on fait
Card (B) + Card (C), les éléments a, f , i et
l sont comptés deux fois et l’élément e est
compté trois fois.
Lorsqu’on fait l’opération Card (A ∩ B) +
Card (B ∩ C) + Card (C ∩ A), les éléments
a, f , i et l sont comptés une fois et l’élé-
ment e est compté trois fois.
Ainsi dans l’expression

(cid:0)Card (A) + Card (B) + Card (C)(cid:1)
−(cid:0)Card (A ∩ B) + Card (B ∩ C) + Card (C ∩ A)(cid:1)

l’élément e n’est pas comptabilisé,
il
faut donc rajouter à cet
somme la
quantité Card (A ∩ B ∩ C) pour obtenir
Card (A ∪ B ∪ C).

On a donc la proposition suivante.

Proposition IV.5

Card (A ∪ B) = Card (A) + Card (B) − Card (A ∩ B)

Card (A ∪ B ∪ C) = Card (A) + Card (B) + Card (C) − Card (A ∩ B) − Card (A ∩ C)

−Card (B ∩ C) + Card (A ∩ B ∩ C)

23

IV.2. Dénombrement

Remarque IV.3. Cela correspond au principe de l’addition : si on cherche à dénombrer un événe-
ment où l’on s’est ramené à considérer un cas ou bien un autre ou bien un autre, etc..., cela revient
à dénombrer une union de sous-ensembles, ce qui revient à effectuer la somme des cardinaux de
chaque sous-ensemble éventuellement en réajustant les intersections.
Remarque IV.4. Il existe une formule générale (non exigible) pour une union ﬁnie d’ensembles
(Ai)i∈{1,...,n} :

(cid:88)

(cid:33)

(cid:32)(cid:92)

i∈I

Card

Ai

(cid:32) n(cid:91)

(cid:33)

n(cid:88)

Card

Ai

=

i=1

i=1

(−1)i+1

I⊂{1,...,n} avec Card(I)=i

Exemple IV.4 (Nombre de carrés). On cherche à compter le nombre de carrés dans la ﬁgure ci
dessous :

On note A1, A2, A3 et A4 les ensembles de carrés dont les côtés sont respectivement 1, 2, 3 et
4. L’ensemble des carrés peut donc s’écrire comme une union disjointe : A = A1 ∪ A2 ∪ A3 ∪ A4.
Donc Card (A) = 16 + 9 + 4 + 1 = 30.

Produit cartésien

Soient A et B deux ensembles ﬁnis. L’ensemble A × B correspond aux couples d’éléments (a, b)
où a ∈ A et b ∈ B. Ainsi on a Card (A) possibilités pour choisir le premier éléments et une fois
que l’on a choisi un élément de A, il y a Card (B) possibilités pour choisir b ∈ B. On en déduit
que A × B contient Card (A) × Card (B) éléments. On peut représenter les différents choix à l’aide
d’un arbre comme sur la ﬁgure IV.1.

a1

a2

a3

a4

A = {a1, a2, a3, a4}
B = {b1, b2, b3}
Card (A × B) = 4 × 3 = 12

(a1, b1 )

(a1, b2 )

(a1, b3 )

(a2, b1 )

(a2, b2 )

(a2, b3 )

(a3, b1 )

(a3, b2 )

(a3, b3 )

(a4, b1 )

(a4, b2 )

(a4, b3 )

FIGURE IV.1 – Représentation sous forme d’arbre du produit cartésien de deux ensembles ﬁnis.

Ce raisonnement se généralise facilement au cas où on fait un produit cartésien d’une famille

ﬁnie d’ensembles ﬁnis.
Proposition IV.6

Soient A et B deux ensembles ﬁnis, on a :

Card (A × B) = Card (A) × Card (B)

Et plus généralement, si (Ai)i∈{1,...,n} est une famille ﬁnie d’ensembles ﬁnis alors :

Card (A1 × · · · × An) = Card (A1) × · · · × Card (An)

Remarque IV.5. Cela correspond au principe de la multiplication : si on cherche à dénombrer un
événement où l’on s’est ramené à considérer un cas pris dans un ensemble, puis un autre dans un
autre ensemble, puis un autre, etc..., on effectue le produit des cardinaux de chaque ensemble.

Chapitre IV. CARDINALITÉ

24

Exemple IV.5 (Nombre de mots). On considère un alphabet A de cardinal Card (A) = m, on sou-
haite compter le nombre de mots de longueur n noté An (par exemple pour connaitre le nombre
de mots de passe possibles).
Si A = {a, b} et n = 4, le nombre de mots de longueur 4 qui peuvent être composés à partir

des lettres a et b est 24 = 16, on peut les énumérer :

aaaa, aaab, aaba, aabb, abaa, abab, abba, abbb, baaa, baab, baba, babb, bbaa, bbab, bbba, bbbb

Exemple IV.6 (Nombre de noms de variables BASIC). Les noms des variables du langage BASIC se
déﬁnissent ainsi :

<Lettre>::= A|B|... |Z
<Digit> ::= 0|1|... |9
<Var> ::= <Lettre> | <Lettre><Digit>
Ainsi une variable est une lettre ou bien une lettre composée d’un digit. Le nombre de variables

est donc :
Card (<Var>) = Card (<Lettre>|) + Card (<Lettre>) .Card (<Digit>) = 26 + (26∗ 10) = 286

Passage au complémentaire

Parfois il est plus facile de dénombrer le complémentaire d’un ensemble. Par exemple, si A ⊂ Ω
, alors Ω est une union disjointe de A et A, on en déduit

et que l’on connaît Card (Ω) et Card
que Card (Ω) = Card (A) + Card
A

A
. Ainsi on a

ä

Ä
ä

Ä

Ä

ä

A

Card (A) = Card (Ω) − Card

IV.2.2 Arrangements et combinaisons

On peut aussi utiliser les formules classiques d’arrangements et de combinaisons. Avant d’uti-

liser les différentes formules, il est commode de se poser les questions suivantes :
— Quel est le nombre n d’objets de référence ?
— Quel est le nombre p d’objets concernés (p ≤ n) par la situation considérée ?
— Les p objets sont-ils considérés en “vrac” (sans ordre, tirage simultané), ou sont ils classés

d’une certaine façon (avec ordre, tirage successif) ?

Arrangement

Permutation de n éléments : c’est le nombre de façon de ranger n objets dans l’ordre.

n! = n × (n − 1) × (n − 2) × · · · × 2 × 1

Arrangements de p éléments parmi n sans répétition : c’est le nombre de listes de p éléments

parmi n, les éléments sont donc ordonnés dans la liste.

n = n × (n − 1) × (n − 2) × · · · × (n − p + 1) =
Ap

n!

(n − p)!

Arrangement de p éléments parmi n avec répétition : c’est le nombre de listes de p éléments
parmi n, mais on s’autorise des répétitions éventuelles des éléments. Les éléments sont ordonnés
dans la liste.

Proposition IV.7

noté FE, est :

Soient E et F deux ensembles ﬁnis, le cardinal de l’ensemble des applications de E dans F,

np

Ä

ä

Card

FE

= Card (F)Card(E)

25

Combinaison

IV.3. Cas des ensembles inﬁnis

Combinaisons de p éléments parmi n sans répétition : c’est le nombre de sous-ensembles de

p éléments dans un ensemble contenant n éléments, les éléments ne sont donc pas ordonnés.

Proposition IV.8

Quelques formules :

Cp
n =

n!

p!(n − p)!

Cn−p
n = Cp
n

Cp+1
n+1 = Cp

n + Cp+1

n

n(cid:88)

i=0

(a + b)n =

nakbn−k (formule du binôme)
Ck

Combinaisons de p éléments parmi n avec répétition : c’est le nombre de listes non ordonnées,
avec répétition éventuelle, de p éléments dans un ensemble contenant n éléments, les éléments ne
sont donc pas ordonnés.

Kp
n = Cp

n+p−1 =

(n + p − 1)!
p!(n − 1)!

IV.3 Cas des ensembles inﬁnis
IV.3.1 Déﬁnition et premiers exemples d’ensembles dénombrables

Déﬁnition IV.3 (Ensemble dénombrable). Un ensemble est dénombrable s’il est ﬁni ou s’il est en
bijection N.

Exemple IV.7. Voilà quelques exemples d’ensembles dénombrables :

— N (cid:114) {0} est dénombrable par la bijection

f : N −→ N (cid:114) {0}
(cid:55)−→ n + 1

n

.

— l’ensemble des nombres pairs, noté 2N, est dénombrable par la bijection

f : N −→ 2N
(cid:55)−→ 2n .

n

— l’ensemble des nombres impairs, noté 2N + 1, est dénombrable par la bijection

f : N −→ 2N + 1
(cid:55)−→ 2n + 1 .

n

— l’ensemble des entiers relatifs Z est dénombrable par la bijection

f :

N
2n

2n + 1

−→ Z
(cid:55)−→ −n
(cid:55)−→ n + 1

.

— l’ensemble N2 est dénombrable par la bijection
f : N2 −→ N

(p, q)

(cid:55)−→ 2p(2q + 1) − 1

.

Chapitre IV. CARDINALITÉ

26

On peut aussi considérer la bijection dite fonction de couplage de Cantor :

q

4

3

2

1

0

10

6

3

1

0

16

11

7

4

2

23

17

12

8

5

31

24

18

13

9

40

32

25

19

14

f : N2 −→ N

(cid:55)−→ p +(cid:80)p+q−1

i=0

(p, q)

(i + 1) = p + (p+q)(p+q+1)

2

0

1

2

3

4

p

— Par récurrence sur l’entier k ∈ N∗, on montre que Nk est dénombrable.

Proposition IV.9

Tout sous-ensemble X ⊂ N est dénombrable.

Démonstration : Si X est ﬁni, c’est terminé. Supposons que X est inﬁni. On déﬁnit par récurrence une

application ϕ : N → X de la manière suivante :

ϕ(0) = min{x ∈ X} et ϕ(n + 1) = min{x ∈ X : x > ϕ(n)} pour n ≥ 1.

On vériﬁe que ϕ est une bijection de N sur X

IV.3.2 Critères de dénombrabilité

Proposition IV.10

Il existe une application f : X → N qui est injective si et seulement si X est dénombrable.

Démonstration : Supposons que X est inﬁni, autrement c’est terminé.

Si f : X → N est injective alors X est en bijection avec f (X), qui est un sous-ensemble inﬁni de
N. D’après la proposition IV.9, f (X) est dénombrable, comme f (X) est inﬁni, il existe une bijection
h : f (X) → N. Dans ce cas, h ◦ f réalise une bijection de X sur N.
La réciproque découle de la déﬁnition de la dénombrabilité.

Exemple IV.8 (Applications). Cette proposition est très commode pour montrer qu’un ensemble est
dénombrable :

— Un sous-ensemble d’un ensemble dénombrable est dénombrable.
— N2 est dénombrable car l’application suivante est injective :

f : N2 −→ N

(p, q)

(cid:55)−→ 2p3q .

— Nk est dénombrable, on considère k nombres premiers distincts p1, . . . , pk et on vériﬁe
que l’application suivante est injective :

f :

Nk

(a1, . . . , ak)

−→ N
(cid:55)−→ pa1

1 pa2

2 . . . pak
k

.

Proposition IV.11

Un produit ﬁni d’ensembles dénombrables est dénombrable.

Démonstration : Soient X1, . . . , Xk des ensembles dénombrables et pour tout i ∈ {1, . . . , k} on considère

une application injective fi : Xi → N.

Comme Nk est inﬁni et dénombrable, il existe donc une bijection h : Nk → N. On déﬁnit :

ϕ : X1 × · · · × Xk −→ N

(x1, . . . , xk)

(cid:55)−→ h( f1(x1), . . . , fk(xk))

27

IV.3. Cas des ensembles inﬁnis

Si h( f1(x1), . . . , fk(xk)) = h( f1(x(cid:48)
1, . . . , x(cid:48)
( f1(x1), . . . , fk(xk)) = ( f1(x(cid:48)
vité de chaque fi. On en déduit que ϕ est injective donc X1 × · · · × Xk est dénombrable.

k)) par injectivité de h et (x1, . . . , xk) = (x(cid:48)

k)) pour (x1, . . . , xk), (x(cid:48)

k) ∈ X1 × · · · × Xk alors
k) par injecti-

1), . . . , fk(x(cid:48)

1), . . . , fk(x(cid:48)

1, . . . , x(cid:48)

Proposition IV.12

Il existe une application f : N → X qui est surjective si et seulement si X est dénombrable.

Démonstration : Supposons X inﬁni autrement c’est terminé. Par hypothèse, il existe une application
f : N → X qui est surjective. Pour tout x ∈ X , déﬁnissons g(x) = min{y ∈ N : f (y) = x}. On vériﬁe
que g : X → N est injective et on en déduit que X est dénombrable.

Exemple IV.9 (Dénombrabilité de Q). L’ensemble Q est dénombrable. On considère l’application :

f : Z × N −→ Q
(cid:55)−→ p
q+1

(p, q)

.

Cette application est surjective et en composant avec une bijection de N sur Z × N on obtient une
surjection de N sur Q.
Proposition IV.13

Une réunion dénombrable d’ensembles dénombrables est dénombrable.

Démonstration : Soit I un ensemble dénombrable et (Xi)i∈I une famille d’ensembles dénombrables in-
dexées par I. Pour chaque i ∈ I, il existe une application injective fi : Xi → N. On déﬁnit l’ensemble

(cid:91)

i∈I

Y =

{(i, fi(x)) : x ∈ Xi} ⊂ I × N

L’ensemble I × N est dénombrable, donc Y est dénombrable. Pour tout (i, y) ∈ Y, on déﬁnit ϕ(i, y)

la préimage de y par fi qui est déﬁni de manière unique par injectivité de fi.

L’application ϕ : Y →(cid:83)

i∈I Xi est surjective et Y est dénombrable, donc(cid:83)

i∈I Xi est dénombrable.

IV.3.3 Ensembles non dénombrables

Il existe des ensembles qui ne sont pas dénombrables. L’exemple le plus simple est l’ensemble
des parties de N noté P (N). En fait, on peut démontrer le théorème suivant qui est un peu plus
général :
Théorème IV.14 (Cantor 1981)

Soient E un ensemble. Il n’existe pas d’application bijective de E dans P (E).

Démonstration : Supposons qu’il existe une bijection f : E −→ P (E) et posons

A = {x ∈ E : x /∈ f (x)}

Puisque A ⊂ E, il existe x0 tel que f (x0) = A, on a donc deux cas possible :

— si x0 ∈ A, par déﬁnition x0 /∈ f (x0) = A ce qui est impossible ;
— si x0 /∈ A, par déﬁnition x0 ∈ f (x0) = A, on aboutit aussi à une contradiction.

L’hypothèse de départ était absurde, il n’existe donc pas de telle bijection.

Un autre argument utilisé en informatique théorique permet de montrer que [0, 1[ n’est pas

dénombrable. C’est l’argument diagonal de Cantor.
Théorème IV.15 (Argument diagonal de Cantor)

L’ensemble [0, 1[ n’est pas dénombrable.

Chapitre IV. CARDINALITÉ

28

:

i ∈ N}. Chaque réel xi admet une écriture décimale xi = 0, x0
i x1

Démonstration : Supposons que [0, 1[ soit dénombrable alors il existe une suite de réels (xi)i∈N telle
que [0, 1[= {xi
i . . . avec
i ∈ {0, 1, . . . , 9} pour j ∈ N.
xj
i pour tout i ∈ N. Alors le réel
y = 0, y1y2y3 · · · ∈ [0, 1[ est différent du réel xi pour tout i ∈ N car il diffère pour la ième décimal. On
en déduit une contradiction.

Considérons une suite d’entiers yi ∈ {0, 1, . . . , 8} telle que yi

i x2

i x3

(cid:54)= xi

On en déduit que R n’est pas dénombrable. De plus l’ensemble des nombres réels irrationnels,
c’est à dire R (cid:114) Q, n’est pas dénombrable. En effet, si tel n’était pas le cas, R = (R (cid:114) Q) ∪ Q serait
dénombrable.

IV.3.4 Théorème de Cantor-Schröder-Bernstein

Pour deux ensembles ﬁnis E et F, s’il existe une application injective de E dans F et une applica-
tion injective de F dans E alors on a respectivement Card (E) ≤ Card (F) et Card (F) ≤ Card (E).
On a donc Card (F) = Card (E), c’est à dire que E et F sont en bijection. En fait ce phénomène se
généralise à des ensembles inﬁnis, c’est le théorème de Cantor-Schröder-Bernstein et on verra la
démonstration plus tard.
Théorème IV.16 (Théorème de Cantor-Schröder-Bernstein)

S’il existe une application injective de A vers B et une application injective de B vers A,

alors il existe une application bijection de A vers B.

Exemple IV.10. Ce théorème est très utile pour montrer que deux ensembles sont équipotent. On
peut montrer que [0, 1], ]0, 1[, ]0, 1[2, R et P (N) sont équipotents deux à deux. Par exemple pour
montrer que P (N) et [0, 1] sont en bijection, on montre que les deux fonctions suivantes sont des
injections :

g :

[0, 1]

x = 0, x0x1x2x3x4 . . .

−→ P (N)
(cid:55)−→ {i ∈ N si xi = 1}

f : P (N) −→ [0, 1]

(cid:55)−→ (cid:80)

A

n∈A 2−n

ChapitreV

Relations sur les ensembles

V.1 Vocabulaire des relations
V.1.1 Déﬁnition

Déﬁnition V.1 (Relation binaire). Une relation binaire R d’un ensemble E vers un ensemble F est
déﬁnie par une partie GR ⊂ E × F. Si (x, y) ∈ GR, on dit que x est en relation avec y et l’on note
xRy (notation inﬁxe) ou R(x, y) ou R x y (notations préﬁxes). L’ensemble E est appelé ensemble de
départ, l’ensemble F est l’ensemble d’arrivée et la partie GR de E × F est appelé le graphe de la relation.
Quand une relation binaire est déﬁnie d’un ensemble E vers lui-même (autrement dit E = F
dans la déﬁnition précédente, donc déﬁnie par une partie GR de E2), on dit que c’est une relation
interne sur E, ou simplement relation sur E.
Exemple V.1. Soient A = {a, b, c, d, e} l’ensemble des élèves et B = {Math, In f o, Ang, Phys} l’en-
semble des cours. L’ensemble A × B correspond aux couples possibles d’étudiants et cours. On
peut déﬁnir les relations suivantes :

— la relation R qui décrit si un étudiant suit le cours régulièrement déﬁni par

GR = {(a, Math), (a, Phys), (b, In f o), (c, Ang), (d, Ang), (e, Math), (e, Ang)}

— la relation S déﬁnit par GS = {(a, Math), (c, Math), (d, Ang)} qui décrit si un étudiant
présent à un intérêt personnel pour la matière (éventuellement il peut présenter un intérêt
pour la matière mais ne va pas souvent en cours).

V.1.2 Modes de représentations

Il existe différentes manières de représenter une relation d’un ensemble E vers un ensemble F.

Diagramme cartésien et matrice de relation Un diagramme cartésien est un tableau où les lignes
désignent les éléments de E et les colonnes les éléments de F. Les couples en relations sont marqués
par le symbole V. On peut aussi représenter la relation par une matrice en remplaçant les espaces
vides par 0 et les espaces marqués par 1.
R Math Phys Ang
a
b
c
d
e

S Math Phys Ang
a
b
c
d
e

V
V
V

In f o

V

V

V

V

V

V

In f o

V

Chapitre V. RELATIONS SUR LES ENSEMBLES

30

Diagramme sagittal Par un graphique où les éléments de E sont situés à gauche, les éléments de
F sont situé à droite et les éléments en relation sont reliés par une arête. On appelle cela un graphe
biparti.

a

b

c

d

e

In f o

Ang

Phys

Math

Graphe orienté Lorsque on a une relation interne sur un ensemble ﬁni, on dessine un graphe
orienté où les sommets sont les éléments et on a un arc allant d’un sommet a à un sommet b si a est
en relation avec b.
Par exemple la relation interne sur {1, 2, 3, 4} déﬁnit par {(2; 1); (2; 2); (3; 1); (1; 4); (4; 3)} est

représentée par :

1

2

3

4

Remarques sur ces représentations Lorsqu’on représente une relation entre l’ensemble E et l’en-
semble F, tous les liens entre les éléments de E et F sont représentés et peuvent être reconstitués.
Cependant, dans les représentations précédentes les choix sont arbitraires :

— Diagramme sagittal : où placer les sommets et quelle forme donner aux ﬂèches ?
— Diagramme cartésien et matrice : quel ordre de parcours faut il donner aux éléments ?

De manière générale établir l’égalité entre deux relations est un problème difﬁcile et il n’y a pas
d’algorithme performant pour décider ce problème.

V.1.3 Quelques notions proches

Relation fonctionnelle Une fonction f : E → F associe a chaque élément de E au plus un élément
de F. On peut alors déﬁnir la relation R f déﬁnie par le graphe

GR f = {(x, f (x)) : x ∈ E} ⊂ E × F.

Réciproquement, pour une relation R telle que pour tout x ∈ E il y a au plus un y ∈ F vériﬁant
xRy alors on peut lui associer une fonction f telle que f (x) = y si et seulement si xRy. On dit que
R est une relation fonctionnelle.
Relation n-aire Etant donné n ensembles E1, E2, . . . , En, une relation n-aire R est déﬁnie par un
sous ensemble GR ⊂ E1 × E2 × · · · × En.

Si n = 2, on retrouve la notion de relation binaire, si n = 3 on dit que l’on a une relation
ternaire... La notion de relation n-aire est au centre des bases de données qui cherchent à mettre en
relation différentes données.

31

V.2. Propriétés sur les relations

V.2 Propriétés sur les relations

On s’intéresse principalement aux relations internes, c’est à dire déﬁnies sur un seul ensemble.
On représentera donc cette relation soit avec une matrice carrée, soit avec un graphe orienté. Dans
cette section on déﬁnit des propriétés sur les relations.
Reﬂexivité Une relation R est réﬂexive si pour tout x ∈ E on a

xRx.

Il est possible de repérer la réﬂexivité sur les modes de représentations :
— Diagramme cartésien : la diagonale doit être notée.
— Diagramme sagittal : chaque sommet admet une boucle.

3

2

1

1

2

3
1 V V V
V V
2
V
3

Exemple V.2. Quel que soit l’ensemble, la relation d’égalité = est réﬂexive. Sur N, la relation ≤ est
réﬂexive, mais < n’est pas réﬂexive.
Exemple V.3. Sur l’ensemble des mots A∗, on considère la relation

l≡ déﬁnit par

u l≡ v si et seulement si u et v ont même longueur.
l≡ petit et grand

l≡ grand mais grand (cid:54) l≡ grande.

Par exemple grand
La relation

l≡ est réﬂexive.

Symétrie Une relation R est symétrique si pour tout x, y ∈ E on a

xRy si et seulement si yRx.

Il est possible de repérer la réﬂexivité sur les modes de représentations :
— Diagramme cartésien : symétrie par rapport à la diagonale.
— Diagramme sagittal : quand une ﬂèche va de a vers b, il y a aussi une ﬂèche de b vers a.

3

2

1

3
V

2

V

1
1 V
2
3 V

Exemple V.4. Quel que soit l’ensemble, la relation d’égalité = est symétrique. Sur N, la relation ≤
est n’est pas symétrique.

La relation

l≡ sur A∗ est symétrique.

Transitivité Une relation R est transitive si pour tout x, y, z ∈ E on a

xRy et yRz implique que xRz.

Il est possible de repérer la réﬂexivité sur les modes de représentations :
— Diagramme sagittal : tout chemin qui part d’un sommet s et va à un sommet s(cid:48) en suivant

la direction des ﬂèches admet un raccourci, c’est à dire un chemin de longueur un.

Chapitre V. RELATIONS SUR LES ENSEMBLES

32

1

4

3

2

1

2

4

3
V

1
2 V V V V
3
4

V

Example : Quel que soit l’ensemble, la relation d’égalité = est transitive.

Sur N, la relation ≤ est transitive.
l≡ sur A∗ est transitive.
La relation
La relation "est le père de" n’est pas transitive : on ne peut pas à la fois être grand père et père.

Antisymétie Une relation R est antisymétrique si pour tout x, y ∈ E on a

xRy et yRx implique que x = y.

1

4

3

2

1

2

1
2 V
3
4 V

V

3
V

4

V
V
V

Example : Sur N, la relation ≤ est antisymétrique.
l≡ sur A∗ n’est pas antisymétrique.

La relation

V.3 Relations d’équivalence

L’égalité est réﬂexive, symétrique et transitive. Dans ce chapitre, on veut généraliser la notion
d’égalité en considérant que deux éléments sont identiques s’ils vériﬁent une propriété donnée :
c’est la notion d’équivalence.

V.3.1 Déﬁnition et exemples

La relation d’équivalence est une abstraction de la notion d’égalité, elle permet de lier entre

eux des éléments qui partagent un ou plusieurs attributs communs.

Déﬁnition V.2. Une relation binaire déﬁnie sur un unique ensemble E est une relation d’équivalence
si elle est réﬂexive, symétrique et transitive.
Exemple V.5. Par déﬁnition, pour x, y ∈ Z, on note x ≡ y[mod n], lire x est congru à y modulo n, si
et seulement s’il existe k ∈ Z tel que x − y = kn. On a déﬁni une relation d’équivalence sur Z car
on peut vériﬁer :

— Réﬂexivité : x ≡ x[mod n] car x − x = 0.n et 0 ∈ Z.
— Symétrie : si x ≡ y[mod n] alors il existe k ∈ Z tel que x − y = k.n, on a donc y− x = −k.n
et −k ∈ Z d’où y ≡ x[mod n].
— Transitivité : si x ≡ y[mod n] et y ≡ z[mod n] alors il existe k, k(cid:48) ∈ Z tels que x − y = k.n
et y − z = k(cid:48).n. Ainsi x − z = x − y + y − z = (k + k(cid:48)).n. On en déduit que x ≡ z[mod n]

Exemple V.6. Voici quelques exemples de relations d’équivalence :

— Sur l’ensemble des personnes, la relation "a le même âge que" est une relation d’équiva-
lence. Des personnes liées appartiennent à la même tranche d’âge.
— Sur l’ensemble des triangles, la relation "a les mêmes angles que" est une relation d’équi-
valence. Des triangles liés par cette relation sont dits semblables.

33

V.3. Relations d’équivalence

— La relation R déﬁnie sur R (cid:114) {0} par xRy si et seulement si xy > 0 est une relation
d’équivalence. Deux réels liés par cette relation ont le même signe.

On pourra vériﬁer que ce sont bien des relations d’équivalence.
Remarque V.1. Si R est une relation d’équivalence, on dit que x est équivalent à y si aRb. La relation
étant symétrique, on a aussi b est équivalent à a. On dit que a et b sont équivalents.

V.3.2 Classes d’équivalence et partition

Déﬁnition V.3. Soit R une relation d’équivalence sur un ensemble E. La classe d’équivalence d’un
élément x, noté Cl(x), est l’ensemble des éléments de E qui sont en relation avec x. Autrement dit

Cl(x) = {y ∈ E : xRy}.

Parfois la classe d’équivalence de x est aussi notée ˙x.

Proposition V.1

Une classe d’équivalence n’est jamais vide.

Démonstration : La classe d’un élément contient toujours au moins cet élément par réﬂexivité de la rela-

tion d’équivalence.

Proposition V.2

L’intersection de deux classes d’équivalence distinctes est vide.

E et leurs classes d’équivalence Cl(x) et Cl(y).
xRz et zRy par transitivité on en déduit que xRy et par réﬂexivité yRx.

Démonstration : Soit R une relation d’équivalence sur un ensemble E, on considère deux éléments x, y ∈
Supposons qu’il existe z ∈ Cl(x) ∩ Cl(y), on a donc xRz et yRz. Par symétrie, on a zRy. Ainsi
Pour tout t ∈ Cl(y), on a yRt donc par transitivité xRt d’ou t ∈ Cl(x). Autrement dit Cl(y) ⊂
De même, pour tout t ∈ Cl(x), on a xRt donc par transitivité yRt d’ou t ∈ Cl(y). Autrement dit

Cl(x).
Cl(x) ⊂ Cl(y).

On en déduit que Cl(x) = Cl(y). Ainsi si deux classes sont distinctes alors l’intersection est vide.

Déﬁnition V.4. Soit E un ensemble, la famille d’ensembles (Ai)i∈I indexée par I est une partition
si :

— l’union des (Ai)i∈I est égale à E, c’est à dire E = ∪i∈I Ai,
— deux éléments de (Ai)i∈I distincts sont disjoints, c’est à dire que si i (cid:54)= j alors Ai ∩ Aj = ∅.

Théorème V.3

Etant donné une relation d’équivalence sur un ensemble, les classes d’équivalences forment

une partition.

Démonstration : Les classes sont des parties de E. De plus la classe d’un élément contient cet élément.
Si l’on choisi deux classes distinctes (i.e. Cl(x) (cid:54)= Cl(y)) alors leur intersection est vide d’après la

L’union des classes d’équivalence est donc E.

proposition précédente.

Exemple V.7. Considérons la relation d’équivalence correspondant à la congruence modulo 3. On
a trois classes d’équivalence :

— Cl(0) = {. . . ,−6,−3, 0, 3, 6, 9, 12, . . .} ;
— Cl(1) = {. . . ,−5,−2, 1, 4, 7, 10, 13, . . .} ;
— Cl(2) = {. . . ,−4,−1, 2, 5, 8, 11, 14, . . .}.

Chapitre V. RELATIONS SUR LES ENSEMBLES

34

V.3.3 Ensemble quotient

Déﬁnition V.5. Soit E un ensemble munit d’une relation d’équivalence R. L’ensemble quotient est
l’ensemble des classes d’équivalence de tous les éléments de E. On le note E/R.
Proposition V.4

Etant donné une relation d’équivalence R sur E, la fonction suivante est surjective :

f : E −→ E/R
(cid:55)−→ Cl(x)

x

Parfois, pour parler aisément d’une classe, on choisit un de ses éléments qui représente cette

classe. Cet élément, surmonté d’un point, sert à représenter la classe en question.
Exemple V.8 (Congruence modulo 4). On considère Z muni de la relation d’équivalence x ≡
y[mod 4]. On choisit pour représentants les entiers 0, 1, 2 et 3. L’ensemble-quotient est Z/4Z =
{ ˙0, ˙1, ˙2, ˙3}.

ChapitreVI

Relations d’ordre

Dans ce chapitre on va déﬁnir la notion de relation d’ordre sur un ensemble qui permet de
mettre en place une hiérarchie sur E par une relation de précédence : l’élément a est en relation
avec b si a précède b dans la hiérarchie.

VI.1 Premières notions
VI.1.1 Déﬁnition

Déﬁnition VI.1. Une relation binaire (cid:22) sur un ensemble E est une relation d’ordre si elle est ré-
ﬂexive, transitive et antisymétrique. Autrement dit :
(cid:22) réﬂexive : Pour tout x ∈ E on a x (cid:22) x .
(cid:22) transitive : Pour tout x, y, z ∈ E, si x (cid:22) y et y (cid:22) z alors x (cid:22) z.
(cid:22) antisymétrique : Pour tout x, y ∈ E, si x (cid:22) y et y (cid:22) x alors x = y.
Déﬁnition VI.2. Un ordre est total si pour tous éléments x, y ∈ E on a x (cid:22) y ou y (cid:22) x. Un ordre
est dit partiel pour souligner qu’on n’a pas forcément cette propriété.

Si x (cid:22) y, on dit que x est un minorant de y et que y est un majorant de x.

VI.1.2 Exemples de relations d’ordre classiques

Ordres sur les nombres

— Les relations ≤ et ≥ sont des relations d’ordre total sur N qui s’étendent à Z, Q ou R.
— Les relations < et > ne sont pas des relations d’ordre sur N (respectivement Z, Q ou R), ce
— Sur N∗ la relation a divise b, notée a|b, est une relation d’ordre mais n’est pas total. On

sont des relations d’ordre strictes.
rappelle que a divise b s’il existe k ∈ N∗ tel que b = a k, par exemple 3|57.

Ordres sur les parties d’un ensemble Soit E un ensemble l’inclusion, notée ⊂, est une relation
d’ordre sur l’ensemble des parties P (E) qui n’est pas totale.

Ordres sur les mots Soit A un alphabet. Il existe différentes notions pour ordonner l’ensemble
des mots A∗ :
— La relation u est préﬁxe de v, notée u <perd v et déﬁnit par il existe un mot w ∈ A∗ tel que

v = u.w, est une relation d’ordre qui n’est pas total

Chapitre VI. RELATIONS D’ORDRE

36

— Soit (cid:22) un ordre total sur A, on déﬁnit l’ordre lexicographique sur A∗ par

u ≤lex v ⇐⇒ (u préﬁxe de v) ou (∃m ∈ N tel que u1 . . . um = v1 . . . vm et um+1 ≤ vm+1)
C’est une relation d’ordre total sur A∗. On a par exemple a ≤lex fa, poule ≤lex poulet,
avion ≤lex train, livraison ≤lex livre, foot ≤lex fort.

VI.1.3 Mode de représentation

Voilà le diagramme sagittal d’un ordre sur un ensemble à trois éléments :

3

2

1

1

2

3
1 V V V
V V
2
V
3

Pour simpliﬁer la lecture du diagramme, on supprime les boucles dues à la réﬂexivité et les

ﬂèches déductibles par transitivité :

1

2

3

L’idée est de représenter les sommets du diagramme et tracer seulement les ﬂèches correspon-
dant aux successeurs immédiats. On dit que y est un successeur immédiat de x si x (cid:22) y, x (cid:54)= y et
il n’existe pas de z tel que x (cid:22) z (cid:22) y.
L’élément x minore y, (x (cid:22) y) si et seulement si on peut passer du point qui représente x au
point qui représente y en suivant les ﬂèches du diagramme de Hasse. Le diagramme de Hasse
d’un ordre total est une chaîne.
Example : Le diagramme de Hasse pour l’ordre ⊂ sur E = {1, 2, 3} est :

{1, 2, 3}

{1, 2}

{1, 3}

{2, 3}

{1}

{2}

∅

{3}

VI.1.4 Fonctions croissantes et décroissantes

Déﬁnition VI.3. Soient A et B deux ensembles munis respectivement des relations d’ordre (cid:22)A et
(cid:22)B et f : A −→ B une application. On dit que

— f est croissante si x (cid:22)A y alors f (x) (cid:22)B f (y).
— f est décroissante si x (cid:22)A y alors f (y) (cid:22)B f (x).
— f est strictement croissante si x (cid:22)A y et x (cid:54)= y alors f (x) (cid:22)B f (y) et f (x) (cid:54)= f (y).
— f est strictement décroissante si x (cid:22)A y et x (cid:54)= y alors f (y) (cid:22)B f (x) et f (x) (cid:54)= f (y).

Proposition VI.1

Soit A et B deux ensembles munis respectivement des relations d’ordre (cid:22)A et (cid:22)B tel que
(cid:22)A est total. Une application f : A → B strictement croissante ou strictement décroissante est
injective.

37

VI.2. Bornes d’un ensemble

VI.2 Bornes d’un ensemble

Soit A une partie d’un ensemble ordonné E par la relation d’ordre (cid:22).

Déﬁnition VI.4. Un élément minimal de A est un élément de A qui n’admet pas d’élément plus
petit dans A.

On appelle minorant de A tout élément de E qui est plus petit que n’importe lequel des éléments

de A. Autrement dit :

x minorant de A ⇐⇒ pour tout y ∈ A on a x (cid:22) y

Par la propriété d’antisymétrie, A admet au plus un seul minorant dans A, c’est le plus petit

élément de A, s’il existe on le note min(A).

On appelle borne inférieure le plus grand des minorants, on le note inf(A). Autrement dit

x borne inférieure de A ⇐⇒

pour tout y ∈ A on a x (cid:22) y

et
pour tout z minorant A on a z (cid:22) x

(x est un minorant)

(x est le plus grand des minorants)

Déﬁnition VI.5. Un élément maximal de A est un élément de A qui n’admet pas d’élément plus
grand dans A.

On appelle majorant de A tout élément de E qui est plus grand que n’importe lequel des élé-

ments de A. Autrement dit :

x majorant de A ⇐⇒ pour tout y ∈ A on a y (cid:22) x

Par la propriété d’antisymétrie, A admet au plus un seul majorant dans A, c’est le plus grand

élément de A.

On appelle borne supérieur le plus petit des majorant, on le note sup(A). Autrement dit

x borne supérieur de A ⇐⇒

pour tout y ∈ A on a y (cid:22) x

et
pour tout z majorant de A on a x (cid:22) y

(x est un majorant)

(x est le plus petit des majorants)

Exemple VI.1. Le diagramme de Hasse pour l’ordre ⊂ sur E = {1, 2, 3} est :

{1, 2, 3}

{1, 2}

{1, 3}

{2, 3}

{1}

{2}

∅

{3}

Considérons les ensembles suivants :

A = {{1},{1, 2},{1, 3}}
B = {{2},{3},{2, 3}}

C = A ∪ B = {{1},{2},{3},{1, 2},{1, 3},{2, 3}}

Chapitre VI. RELATIONS D’ORDRE

38

On a

Eléments minimaux
Eléments maximaux
Plus petit élément
Plus grand élément

Borne inférieure
Borne supérieure

A
{1}

{1, 2},{1, 3}

non existant

{1}
{1}
{1, 2, 3}

B
{2},{3}
{2, 3}
{2, 3}
∅

non existant

non existant

C

{1},{2},{3}

{1, 2},{1, 3},{2, 3}

non existant
non existant

∅

{1, 2, 3}

Exemple VI.2. L’intervalle I = [0, 1[ sous ensemble de R muni de la relation d’ordre classique ≤
n’admet pas d’élément maximaux, admet un plus petit élément min(I) = 0, admet une borne
supérieur sup(I) = 1 et admet une borne inférieure inf(I) = 0.

Induction

VI.3
VI.3.1 Ordre bien fondé

Déﬁnition VI.6. Un ensemble ordonné (E,(cid:22)) est bien fondé s’il n’existe pas de suite inﬁnie stricte-
ment décroissante d’éléments de E.

De manière équivalente, un ensemble bien fondé peut se déﬁnir de la manière suivante :

Théorème VI.2

au moins un élément minimal.

Un ensemble ordonné (E,(cid:22)) est bien fondé si et seulement si toute partie non vide admet

Exemple VI.3. L’ordre usuel ≤ sur N est bien fondé mais il ne l’est pas sur Z, R, [0, 1].

L’ordre | sur N \ {0, 1} déﬁni par "a|b ⇐⇒ a divise b" est bien fondé.
L’ordre lexicographique sur N2 est bien fondé. Il est déﬁni par

(a, b) (cid:22) (c, d) ⇐⇒; (a < c ou (a = c et b ≤ d))

Soit A un alphabet contenant au moins deux lettres, <perd est bien fondé mais pas ≤lex.

VI.3.2 Application à l’étude de la terminaison d’algorithme

On dit qu’un programme P termine sur l’entrée x si le calcul de P(x) nécessite un nombre ﬁni
d’étapes. Il est indécidable de savoir si un programme termine sur une entrée donnée, c’est à dire il
n’existe pas de programme qui prend en entrée le code d’un programme P et le code d’une entrée
x et répond oui si P(x) s’arrête. Autrement dit il n’existe pas de méthodes qui fonctionne à tout les
coup pour prouver la terminaison d’un algorithme. La notion d’ordre bien fondé fonctionne assez
souvent.

Cas des algorithmes itératifs : les variants de boucles
Déﬁnition VI.7. Etant donné (E,(cid:22)) un ordre bien fondé, un variant de boucle est une fonction
de l’ensemble des états du programme dans E strictement décroissant à chaque passage dans la
boucle.
Proposition VI.3

Si une boucle admet un variant alors elle termine.

Exemple VI.4. Considérons l’algorithme d’Euclide (algorithme 1), la fonction (a, b) → b est un
variant de boucle donc l’algorithme termine.

39

VI.3. Induction

Algorithm 1: Algorithme d’euclide
Data: (x, y) ∈ N2
Result: le pgcd de x et y

a ← x;
b ← y;
while b (cid:54)= 0 do

tmp ← a;
a ← b;
b ← tmp[mod b];

Cas des algorithmes récursifs

On considère une fonction f déﬁnit de manière récursive. Si les appels successifs de f ne s’ar-

rête pas, on pourrait construire une suite inﬁnie strictement décroissante.
Proposition VI.4

Soit f une fonction récursive déﬁnit sur un ensemble ordonné (E,(cid:22)) bien fondé. Si f est
déﬁni sur les éléments minimaux et si pour tout x ∈ E non minimal, le déﬁnition de f (x) ne
fait appel à des valeurs f (y) pour y (cid:22) x avec x (cid:54)= y alors f est bien déﬁnit.

Exemple VI.5. On considère la fonction fact déﬁnie par :

— fact(0) = 1 ;
— fact(n + 1) = (n + 1) ∗ fact(n).

Elle est bien déﬁnie car (N,≤) est bien fondé, fact est déﬁnie sur l’élément minimal 0 et l’appel
de fact sur un élément non minimal fait appel à des éléments plus petit.
Exemple VI.6. On considère la fonction f déﬁnie sur N \ {0, 1} par :

— f (p) = 1 si p premier ;
— f (n) = f (a) + f (b) si n = ab et a (cid:54)= 1 et b (cid:54)= 1.

Elle est bien déﬁnie car (N \ {0, 1},|) est bien fondé, f est déﬁnie sur les éléments minimaux (les
nombres premiers) et l’appel de fact sur un élément non minimal fait appel à des éléments plus
petit.

VI.3.3 N et le principe de récurrence
L’ensemble (N,≤) est bien fondé.
Théorème VI.5 Principe de récurrence

Soit P une propriété dépendant d’un élément n de N. Si les deux hypothèses suivantes sont

vériﬁées
Initialisation : P(0) est vraie,
Héridité : si pour tout n ∈ N on a la propriété suivante :

alors pour tout n ∈ N, la propriété P(n) est vraie.

"P(n) est vraie =⇒ P(n + 1) est vraie"

que la conclusion est fausse.

Démonstration : On raisonne par l’absurde : supposons que les hypothèses du théorème sont vraies mais
Soit X = {n ∈ N, P(n) est fausse}. L’ensemble X est une partie non vide de N, comme (N,≤) est
bien fondé, X admet un plus petit élément noté n0.
Comme P(0) est vraie, on a n0 > 0 donc n0 − 1 est un entier positif ou nul, autrement dit n0 − 1 ∈
N. P(n0 − 1) est vraie car n0 − 1 /∈ X. Par hypothèse P(n0 − 1) =⇒ P(n0) donc P(n0) est vraie ce qui
est contradictoire avec le fait que n0 ∈ X.

Chapitre VI. RELATIONS D’ORDRE

40

Exemple VI.7. On cherche à démontrer par récurrence la propriété P(n) déﬁnie par :

Initialisation : Pour n = 0, on a(cid:80)0
Héridité : On suppose que pour n ∈ N la propriété P(n) est vraie, c’est à dire(cid:80)n

i=0(2i + 1) = 1 = (0 + 1)2 donc P(0) est vériﬁée.

i=0

(2i + 1) = (n + 1)2

(n + 1)2. Montrons que P(n + 1) est vériﬁée :

i=0(2i + 1) =

n(cid:88)

n(cid:88)

n+1(cid:88)

i=0

n+1(cid:88)

(2i + 1) = 2(n + 1) + 1 +

(2i + 1)

i=0

= 2(n + 1) + 1 + (n + 1)2
= (n + 1)2 + 2(n + 1) + 12
= ((n + 1) + 1)2

(par hypothèse de récurrence)

(2i + 1) = (n + 2)2

Par le principe de récurrence on en déduit que pour tout n ∈ N on a(cid:80)n

i=0

i=0(2i + 1) = (n + 1)2.

Le principe de récurrence peut être généralisé en considérant que dans la deuxième hypothèse

la propriété est vraie pour tout k ≤ n.
Corollaire VI.6 Principe de récurrence généralisée

Soit P une propriété dépendant d’un élément n de N. Si les deux hypothèses suivantes sont

vériﬁées
Initialisation : P(0) est vraie.
Héridité : si pour tout n ∈ N on a la propriété suivante :

"P(k) est vraie pour tout k ≤ n =⇒ P(n + 1) est vraie"

Alors pour tout n ∈ N, la propriété P(n) est vraie.

Démonstration : On applique le principe de récurrence du théorème VI.5 à la propriété Q tel que pour

n ∈ N, Q(n) est vraie si P(k) est vraie pour tout k ≤ n.

Exemple VI.8. Démontrons que pour deux mots u, v ∈ A∗ tels que uv = vu alors u et v sont des
puissances d’un même mot w. On note P(n) la propriété suivante :

(|uv| = n et uv = vu) ⇐⇒ ∃w ∈ A∗,∃p, q ∈ N tels que u = wp et v = wq)

On va montrer que P(n) est vraie par récurrence généralisée :

Initialisation : Pour n = 0, on a u = v = ε donc P(0) est vraie.
Héridité : On suppose que P(k) est vraie pour tout k ≤ n, c’est à dire que si |uv| = k ≤ n et
uv = vu alors il existe w ∈ A∗ et p, q ∈ N tels que u = wp et v = wq.
Prenons u et v dans A∗ tels que |uv| = n + 1 et uv = vu. Sans perte de généralité, on
suppose que |u| ≥ |v|. Le mot v est un préﬁxe de u donc il existe un mot t ∈ A∗ tel que
u = vt. L’égalité u.v = v.u s’écrit vt.v = v.vt donc en simpliﬁant par v on a tv = vt. On a
deux cas :
— Si |v| = 0 alors v = ε = u0 et u = u1.
— Si |v| ≥ 1 alors |vt| = |u| < |uv| = n + 1, par l’hypothèse de récurrence il existe w ∈ A∗
Par le principe de récurrence généralisée, la propriété P(n) est vraie pour tout n ∈ N donc pour

et p, q ∈ N tels que v = wp et t = wq. On a alors v = wp et u = vt = wpwq = wp+q.

deux mots u, v ∈ A∗ tels que uv = vu alors u et v sont des puissances d’un même mot w.

41

VI.3. Induction

VI.3.4 Principe d’induction

On souhaite généraliser le principe de récurrence à des ensembles ordonnés bien fondés.

Théorème VI.7

Soit (cid:22) un ordre bien fondé sur un ensemble E. Soit P une propriété dépendante d’un élé-

ment x de E. Si les deux hypothèses suivantes sont vériﬁées
Initialisation : P(x) est vraie pour tout élément minimal x de E.
Héridité : Si pour tout x ∈ E qui n’est pas minimal on a la propriété suivante :

"P(y) est vraie pour tout y (cid:22) x avec y (cid:54)= x =⇒ P(x) est vraie"

Alors pour tout x ∈ E, la propriété P(x) est vraie.

Démonstration : On raisonne par l’absurde : supposons que les hypothèse du théorème sont vraies mais
Soit X = {x ∈ E, P(x) est fausse}. L’ensemble X est une partie non vide de E, comme (E,(cid:22)) est

que la conclusion est fausse.

bien fondé, X admet un plus petit élément noté x0.
Comme P est vraie pour tout élément minimal de E, l’élément x0 n’est pas minimal. Pour tout
y ∈ E tel que y (cid:22) x0 et y (cid:54)= x0, la propriété P(y) est vraie car x0 minimal dans X et donc y /∈ X . Par
hypothèse d’hérédité P(x0) est vraie ce qui est contradictoire avec le fait que x0 ∈ X.

Exemple VI.9. Montrons par induction que tout entier n ∈ N \ {0, 1} la propriété P(n) suivante est
vériﬁée : "n s’écrit comme un produit de nombre premier".
L’ensemble E = N \ {0, 1} muni de l’ordre divise, noté |, est bien fondé et les éléments mini-

maux sont les nombres premiers.
Initialisation : Pour tout nombre premier x ∈ E la propriété P(x) est vraie.
Héridité : Soit x ∈ E qui n’est pas minimal on suppose que pour tout y ∈ E tel que tel que y divise
x et y (cid:54)= x la propriété P(y) est vraie. Montrons que P(x) est vraie.
Comme x n’est pas minimal, x n’est pas premier donc il existe x1, x2 ∈ E tel que x =
x1 × x2. On a x (cid:54)= x1 et x (cid:54)= x2, et x1 divise x et x2 divise x. Par hypothèse d’hérédité x1
et x2 s’écrivent comme produit de nombre premiers donc x = x1 × x2 s’écrit aussi comme
produit de nombres premiers.

VI.3.5 Déﬁnition inductive

Déﬁnition inductive d’un ensemble

Déﬁnition VI.8. Soit E un ensemble. Une déﬁnition inductive d’un sous-ensemble X de E consiste
à la donnée :

— d’un sous-ensemble B de E appelé base,
— d’un ensemble K d’opérations ϕ : Erϕ −→ E où rϕ est l’arité de ϕ.

L’ensemble X est alors déﬁni comme le plus petit (pour l’inclusion) ensemble vériﬁant les as-

sertions suivantes :
Base : B ⊂ X,
Induction : pour tout ϕ ∈ K et pour tous x1, x2, . . . , xrϕ ∈ X on a ϕ(x1, x2, . . . , xrϕ ) ∈ X.

On dit que X est la fermeture inductive de B par K.

Exemple VI.10. Quelques ensembles déﬁnis inductivement :

— L’ensemble des entiers naturels est déﬁni par :
Base : B = {0},
Induction :
— L’ensemble des entiers pairs est déﬁni par :
Base : B = {0},

succ : N −→ N

(cid:55)−→ n + 1 .

n

Chapitre VI. RELATIONS D’ORDRE

42

n

n

(cid:55)−→ n + 2 .

(cid:55)−→ n + 2 .

Induction : ϕ : N −→ N
— L’ensemble des entiers impairs est déﬁni par :
Base : B = {1},
Induction : ϕ : N −→ N
— L’ensemble des mots binaires est déﬁni par :
Base : B = {ε},
Induction : ϕ0 : A∗ −→ A∗
— L’ensemble des mots de {0, 1}∗ qui contiennent autant de 0 que de 1 est déﬁni par :
Base : B = {ε},
Induction : ψ1 : A∗ × A∗ −→ A∗
— L’ensemble des mots de Dyck ∆ ⊂ {0, 1}∗ est déﬁni par :
Base : B = {ε},
Induction : ψ : A∗ × A∗ −→ A∗

(cid:55)−→ 0u1v et ψ2 : A∗ × A∗ −→ A∗

(cid:55)−→ 0u et ϕ1 : A∗ −→ A∗

(cid:55)−→ 1u0v .

u

(cid:55)−→ 1u .

(u, v)

(u, v)

(cid:55)−→ 0u1v .

u

(u, v)

Preuve par induction

Le principe d’induction permet de démontrer des propriétés sur des ensembles déﬁnis induc-

tivement.
Théorème VI.8

Soit X ⊂ E la fermeture inductive de B par K. Soit P une propriété déﬁnie sur X. Pour

montrer que pour tout x ∈ X la propriété P(x) est vraie, il sufﬁt de montrer que :
Base : Pour tout x ∈ B, on a P(x) vraie.
Induction Pour tout ϕ ∈ K d’arité rϕ et tous x1, x2, . . . , xrϕ alors on a

P(x1), P(x2), . . . , P(xrϕ ) vraies =⇒ P(ϕ(x1, x2, . . . , xrϕ )) vraie

Exemple VI.11. On considère l’ensemble des mots de Dyck ∆ ⊂ {0, 1}∗ déﬁni par :

Base : B = {ε},
Induction : ψ : A∗ × A∗ −→ A∗
On veut montrer par induction que tout mot w ∈ ∆ vériﬁe la propriété P(w) : "w a autant de 0

(cid:55)−→ 0u1v .

(u, v)

que de 1 et tout préﬁxe de w a plus de 0 que de 1".

Base : ε vériﬁe la propriété demandée,
Induction : Soient u, v ∈ ∆ tels que P(u) et P(v) soient vériﬁées. On note w = ψ(u, v) =
0u1v. Comme u et v ont autant de 0 et de 1, il en est de même pour w. Soit t un préﬁxe de
w. Il y a deux cas :
— Si |t| ≤ 1 + |u| alors t est un préﬁxe de 0u. Il s’écrit t = 0t(cid:48) où t(cid:48) est un préﬁxe de u.
Comme les préﬁxes de u ont plus de 0 que de 1, on en déduit que t a plus de 0 que de 1.
— Si |t| > 1 + |u| alors t s’écrit t = 0u1t(cid:48) où t(cid:48) est un préﬁxe de v. Comme les préﬁxes de v

ont plus de 0 que de 1, on en déduit que t a plus de 0 que de 1.

Déﬁnition inductive d’une fonction

Lorsqu’un ensemble X est déﬁni inductivement de telle sorte que chaque élément se décom-
pose de manière unique, il est possible de déﬁnir une fonction sur cette ensemble. Cela est très
utile pour programmer récursivement des fonctions.
Déﬁnition VI.9. Soit X ⊂ E la fermeture inductive de B par K. On dit que X est librement engendré
si pour tout x ∈ X on a x ∈ B ou bien il existe une unique règle ϕ ∈ K d’arisé rϕ et un unique
k-uplet (x1, . . . , xrϕ ) tels que x = ϕ(x1, . . . , xrϕ ).

43

VI.3. Induction

Déﬁnition VI.10. Soient Y un ensemble et X un sous-ensemble de E déﬁni par :

— une base B ⊂ E,
— un ensemble K d’opérations ϕ : Erϕ −→ E où rϕ est l’arité de ϕ.
Une fonction f : X → Y est déﬁnie inductivement par la donnée de :
f (b) pour tout b ∈ B,

Base :
Induction : Pour tout ϕ ∈ K et pour tous x1, x2, . . . , xrϕ ∈ X la valeur de f (ϕ(x1, x2, . . . , xrϕ )) se

déﬁnit à partir de f (x1), f (x2), . . . , f (xrϕ ).

Exemple VI.12. Quelques fonctions déﬁnies inductivement :

— La factorielle d’un entier n ∈ N se déﬁnit par :
Base : 0! = 1,
Induction : (n + 1)! = (n + 1) × n!.
— L’exposant d’un réel an se déﬁnit pour n ∈ N par :
Base : a0 = 1,
Induction : an+1 = a × an.
— La longueur l : A∗ → N d’un mot binaire u ∈ A∗ est déﬁni inductivement par
Base : l(ε) = 0 ;
Induction : Pour u ∈ A∗, on a l(ϕ0(u)) = l(0u) = 1 + l(u) et l(ϕ1(u)) = l(1u) = 1 + l(u).

Langage rationnel
Déﬁnition VI.11. On déﬁnit inductivement les langages rationnels Rat ⊂ P (A∗) par :

Base : ∅ ∈ Rat, {ε} ∈ Rat et {a} ∈ Rat pour tout a ∈ A ;
Induction : Si L et L(cid:48) sont des langages rationnels alors :
— L ∪ L(cid:48) ∈ Rat,
— L.L(cid:48) ∈ Rat,
— L∗ ∈ Rat.

Exemple VI.13. Voilà quelques exemples de langages rationnels :
— tous les langages ﬁnis sont rationnels et en particulier A ;
— A∗ est rationnel ;
— A+ = A.A∗ ;
— le langage des mots sur A = {0, 1} qui contient au moins une fois le mot 111 est rationnel
car il s’écrit A∗.{111}.A∗ ;
— le langage des mots sur A = {0, 1} qui contient un nombre pair de fois la lettre 1 est
rationnel car il s’écrit ({b}∗.{a}.{b}∗.{a}.{b}∗)∗ ;

Les langages rationnels constituent un outil pour décrire des langages simples (rationnels). Ces
formules sont par exemple utilisées pour effectuer des recherche des occurrences d’un motif. On
notera deux applications concrètes notables :

— Sous UNIX, il existe par exemple un utilitaire grep qui permet de rechercher les occur-
rences d’un motif dans un ﬁchier texte. La commande suivante imprime sur la sortie stan-
dard toutes les lignes du ﬁchier ‘cours.pdf’ contenant au moins une occurrence du mot
graphe :
> grep ’graphe’ cours.pdf
Il est possible de faire des recherches de répétition (e+) ...

— L’analyse lexicale se trouve tout au début de la chaîne de compilation. C’est la tâche consis-
tant à décomposer une chaîne de caractères en lexèmes, qui vont ensuite être analysés par
l’analyseur syntaxique qui va ensuite les interpréter.

Chapitre VI. RELATIONS D’ORDRE

44

ChapitreVII

Quelques problèmes sur les graphes

VII.1 Différents problèmes à modéliser

On peut considérer que l’article fondateur de la théorie des graphe fut publié par le mathé-
maticien suisse Leonhard Euler en 1741. Il traitait du problème des sept ponts de Königsberg :
est il possible de réaliser une promenade dans la ville de Königsberg partant d’un point donné et
revenant à ce point en passant une et une seule fois par chacun des sept ponts de la ville ?

Cette théorie va connaitre un essor au cours du XIXème par l’intermédiaire du problème sui-
vant : quel est le nombre minimal de couleurs nécessaires pour colorier une carte géographique de
telle sorte que deux régions limitrophe n’ont pas la même couleur ? Le théorème des quatre cou-
leurs afﬁrme que seulement quatre sont nécessaires. Le résultat fut conjecturé en 1852 par Francis
Guthrie, intéressé par la coloration de la carte des régions d’Angleterre, mais ne fût démontré
qu’en 1976 par deux Américains Kenneth Appel et Wolfgang Haken. Ce fut la première fois que
l’utilisation d’un ordinateur a permis de conclure leur démonstration en étudiant les 1478 cas par-
ticulier auxquels ils ont ramené le problème.

Au XXème siècle, la théorie des graphes va connaître un essor croissant avec le développement
des réseaux dont il faut optimiser l’utilisation. On peut citer quelques exemples de manière non
exhaustive :

— réseaux de transports routier, d’eau, d’électricité : les sommets représentent les carrefours

— réseaux informatiques : les sommets représentent les ordinateurs et les arêtes les connexions

et les arêtes les rues ;

physiques ;

— réseaux sociaux : les sommets représentent les membres du groupe, deux personnes sont
reliées par une arête si elles se connaissent (Facebook : graphe non orienté, twiter : graphe
orienté, combien de poignées de main on est du président ?. . . ) ;

— graphe du web : les sommets représentent les pages web et chaque arc correspond a un

hyperliens d’une page vers une autre ;

— réseau de transports de données (téléphonie, wiﬁ, réseaux informatique. . . ) ;
— représentation d’un algorithme, du déroulement d’un jeu ;
— réseaux de régulation génétique ;
— organisation logistique : les sommets représentent des évènements, deux évènements sont

reliées par une arête s’ils ne peuvent pas avoir lieu en même temps ;

— ordonnancement de projet : les sommets représentent les différentes tâches composant un
projet, deux tâches sont reliés par une ﬂèche si la deuxième ne peut pas commencer avant
que la première soit terminée ;
— et beaucoup d’autres encore. . .
L’étude des graphes se réalise sous deux point de vues complémentaire. L’étude de propriétés
structurelles de graphes ou de familles de graphes et l’étude algorithmique de certaines propriétés.

Chapitre VII. QUELQUES PROBLÈMES SUR LES GRAPHES

46

VII.2 Premières propriétés
VII.2.1 Graphe orienté ou non

Dans les exemples que l’on a vus, un graphe est un ensemble ﬁni de sommets reliés par des
arêtes. Ces arêtes peuvent être orientées ou non, de plus une valeur peut être associée à chaque
arête ou aux sommets.

Déﬁnition VII.1. Un graphe orienté G = (S, A) est la donnée :

— d’un ensemble S dont les éléments sont des sommets ;
— d’un ensemble A ⊂ S × S dont les éléments sont les arcs.

Un arc a = (s, s(cid:48)) est aussi noté s → s(cid:48), s est l’origine de a et s(cid:48) l’extrémité. On dit aussi que s(cid:48) est

le successeur de s et s le prédécesseur de s(cid:48).

On peut souhaiter qu’il y ait plusieurs arcs entre deux mêmes sommets. On parle alors de

graphe orienté multi-arcs. Formellement, G = (S, A, i, f) c’est la donnée :

— d’un ensemble S dont les éléments sont des sommets ;
— d’un ensemble A dont les éléments sont les arcs ;
— de deux fonctions i : A → S et f : A → S qui à chaque arcs a ∈ A associe son prédécesseur
i(a) et son successeur f(a).

Exemple VII.1. Exemple de graphe orienté :

1

4

2

3

Exemple de graphe orienté multi-arcs :

G = (S, A) où

— S = {1, 2, 3, 4},
— A = {(1, 2), (2, 1), (2, 4), (3, 4), (3, 3)}.

1

4

c

a

b

e

d

2

f

3

G = (S, A, i, f) où

— S = {1, 2, 3, 4},
— A = {a, b, c, d, e, f , g, h},

a
b
c
d
e
f
g

(cid:55)→ 1
(cid:55)→ 2
(cid:55)→ 2
(cid:55)→ 2
(cid:55)→ 3
(cid:55)→ 3
(cid:55)→ 3

a
b
c
d
e
f
g

(cid:55)→ 2
(cid:55)→ 1
(cid:55)→ 4
(cid:55)→ 4
(cid:55)→ 4
(cid:55)→ 3
(cid:55)→ 3

.

g

— i :

et f :

Déﬁnition VII.2. Un graphe non orienté G = (S, A) est la donnée :

— d’un ensemble S dont les éléments sont les sommets du graphe,
— d’un ensemble A dont les éléments, les arêtes du graphe, sont des parties à un ou deux
éléments de S.

Le ou les sommets d’une arête sont appelés extrémités de l’arête. Les arêtes n’ayant qu’une seule
extrémité sont des boucles.

On peut de la même façon un graphe non-orienté multi-arêtes. Formellement, G = (S, A, α) est

la donnée :

— d’un ensemble S dont les éléments sont des sommets ;
— d’un ensemble A dont les éléments sont les arêtes ;
— d’une fonction α de A dans les parties à un ou deux éléments de S.

Exemple VII.2. Exemple de graphe non-orienté :

47

VII.2. Premières propriétés

1

4

2

3

G = (S, A) où

— S = {1, 2, 3, 4},
— A = {{1, 2},{2, 4},{3, 4},{3}}.

Exemple de graphe non orienté multi-arêtes :

1

4

c

a

b

e

d

2

f

3

g

G = (S, A, α) où

— S = {1, 2, 3, 4},
— A = {a, b, c, d, e, f , g, h},
(cid:55)→ {1, 2}
(cid:55)→ {1, 2}
(cid:55)→ {2, 4}
(cid:55)→ {2, 4}
(cid:55)→ {3, 4}
(cid:55)→ {3}
(cid:55)→ {3}

— α :

a
b
c
d
e
f
g

.

Si un arc ou une arête à ses deux extrémités constituées du même sommet, on dit que c’est une

boucle.

ou d’arcs.

pas de boucle.

Un graphe est simple s’il est non-orienté, s’il a au plus une arête entre deux sommets et s’il n’a
L’ordre d’un graphe est le nombre de sommets |S| et la taille d’un graphe est le nombre d’arêtes

VII.2.2

Isomorphisme de graphe
Deux graphes orientés G = (S, A) et G(cid:48) = (S(cid:48), A(cid:48)) sont isomorphes s’il existe une application
bijective ϕ : S → S(cid:48) telle que pour tout s, s(cid:48) ∈ S on (s, s(cid:48)) ∈ A ⇐⇒ (ϕ(s), ϕ(s(cid:48))) ∈ A(cid:48). L’application
ϕ est alors un isomorphisme de graphes orientés.
Exemple VII.3. Les deux graphes suivants sont isomorphes par l’isomorphisme ϕ : 1 (cid:55)→ A, 2 (cid:55)→
B, 3 (cid:55)→ C, 4 (cid:55)→ D, 5 (cid:55)→ E.

3

4

2

5

1

B

E

D

C

A

De même, deux graphes non-orientés G = (S, A) et G(cid:48) = (S(cid:48), A(cid:48)) sont isomorphes s’il existe une
application bijective ϕ : S → S(cid:48) telle que pour tout s, s(cid:48) ∈ S on {s, s(cid:48)} ∈ A ⇐⇒ {ϕ(s), ϕ(s(cid:48))} ∈ A.
L’application ϕ est alors un isomorphisme de graphes non-orientés.

VII.2.3 Degré

Pour un graphe orienté, on appèle degré entrant d’un sommet s, noté d−(s) (resp. degré sortant
d’un sommet s, noté d+(s)) le nombre d’arcs dont le sommet est prédécesseur (resp. successeur).
Pour un graphe non-orienté, on appelle degré d’un sommet s, noté d(s) le nombre d’arêtes dont

le sommet est une extrémité.
Théorème VII.1 Lemme de la poignée de main

Soit G = (S, A) un graphe orienté. On alors les égalités suivantes :

(cid:88)

s∈S

(cid:88)

s∈S

d+(s) =

d−(s) = |A|.

Chapitre VII. QUELQUES PROBLÈMES SUR LES GRAPHES

48

Soit G = (S, A) un graphe non-orienté. On a alors l’égalité suivante :

d(s) = 2|A|.

(cid:88)

s∈S

Démonstration : Pour un graphe orienté G = (S, A), chaque arc a un successeur et un prédécesseur d’ou

la première égalité.

Pour obtenir la deuxième égalité, il sufﬁt d’orienté le graphe non-orienté et remarquer que pour

chaque sommet d(s) = d+(s) + d−(s).

Une conséquence directe de ce théorème est que dans un graphe, le nombre de sommets dont

le degré est impair est toujours pair.

Corollaire VII.2

Dans un graphe, le nombre de sommets dont le degré est impair est toujours pair.

VII.3 Quelques classes de graphe importantes

On s’intéresse ici à déﬁnir quelques classes de graphes non-orientés dont la plupart sont simple

(non multi-arête et sans boucle).

VII.3.1 Graphes isolés

Le graphe isolé d’ordre n est un graphe à n sommets sans arête, on le note In.

I3

I4

I5

I6

I7

VII.3.2 Graphes cycliques

Le graphe cyclique d’ordre n est le graphe à n sommets S = {s1, . . . , sn} tels que les arêtes sont

A = {{si, si+1} : i ∈ [1, n]} ∪ {{sn, s1}}, on le note Cn.

C3

C4

C5

C6

C7

VII.3.3 Graphes complets

Le graphe complet d’ordre n est le graphe simple à n sommets dont tous les sommets sont reliés

deux à deux, on le note Kn.

49

VII.3. Quelques classes de graphe importantes

K3

K4

K5

K6

K7

VII.3.4 Graphe biparti

Un graphe est biparti s’il existe une partition de son ensemble de sommets en deux sous-

ensembles X et Y telle que chaque arête ait une extrémité dans X et l’autre dans Y.

On déﬁnit le graphe biparti complet entre un ensemble de n sommets et un ensemble à m sommets
comme le graphe simple tel que chaque sommet du premier ensemble est relié à chaque sommet
su deuxième ensemble. On le note Kn,m.

A

1

B

2
K3,3

C

3

VII.3.5 Graphes planaires

Un graphe non-orienté (pas forcément simple) est planaire s’il admet une représentation sagit-

tale dans un plan sans que les arêtes se croisent.
Exemple VII.4. K4 est planaire puisque on peut le représenter de la façon suivante :

K4

Est ce que K5 et K3,3 sont planaires ?

VII.3.6 Arbres

Déﬁnition VII.3. Un arbre se déﬁnit de manière inductive par :

— le graphe formé par un sommet est un arbre ;
— si G = (S, A) est un arbre, alors pour s ∈ S et x un élément quelconque n’appartenant
pas à S, le graphe G(cid:48) = (S ∪ {x}, A ∪ {{x, s}}) est un arbre.

Un exemple d’arbre :

Chapitre VII. QUELQUES PROBLÈMES SUR LES GRAPHES

50

VII.4 Problèmes de coloriages

VII.4.1 Position du problème

Déﬁnition VII.4. Soit G = (S, A) un graphe non orienté simple (sans boucle et pas multi-arêtes).
Un coloriage de G consiste à assigner une couleur (ou un nombre) à chaque sommet de telle sorte
que deux sommets adjacents soient de couleurs différentes. Un graphe G est k-coloriable s’il existe
un coloriage avec k couleurs.

Le nombre chromatique du graphe G, noté χ(G) est le nombre minimal de couleurs nécessaire

pour colorier un graphe.

VII.4.2 Exemples d’applications

Problème de compatibilité Dans un groupe de 14 étudiants, on doit former des groupes de telle
sorte que les étudiants d’un même groupe ne s’entendent pas trop mal. On connaît les
incompatibilités suivantes :

l’étudiant

A

B

ne s’entend pas avec

B,E,F,H A,C,E,G

C
B,D

D

E

F

G

H

C,E,G A,D,F,H A,E,H B,D,H A,E,F,G

Le nombre minimal de groupes nécessaire correspond au nombre chromatique du graphe
des incompatibilités.

E

D

F

C

G

B

H

A

Problème d’emploi du temps Pendant un festival, on veut organiser des tournois de scrable (S),
échecs (E), go (G), dames (D), tarot (T) et master-mind (M). Plusieurs personnes se sont
inscrites à la fois pour les tournois E, S, G, d’autres personnes pour les tournois G, D, M,
et enﬁn d’autres personnes pour les tournois M, T, S. Il est entendu qu’une participation
simultanée à plusieurs tournois est impossible et que les organisateurs veulent satisfaire
tout le monde.
Quel est le nombre maximum de tournois qui pourraient se dérouler en même temps ?

G

E

D

S

T

M

Coloriage de carte On cherche à colorier une carte de telle sorte que deux pays frontaliers soient
de couleurs différentes. Pour résoudre ce problème, plus historique qu’autre chose, on peut
se ramener au coloriage d’un graphe planaire construit de la façon suivante : les sommet
correspondent aux pays et il y a une arête entre deux sommets si les pays correspondant
sont frontaliers.

51

VII.4. Problèmes de coloriages

VII.4.3 Nombre chromatique de graphes classiques

Il est facile de déterminer le nombre chromatique de certains graphes classiques :
— graphe isolé d’ordre n : χ(In) = 1 ;
— graphe cyclique d’ordre n : χ(Cn) = 2 si n pair et 3 si n impair ;
— graphe complet d’ordre n : χ(Kn) = n ;
— G graphe biparti avec au moins une arête : χ(G) = 2 (en fait un graphe est 2-coloriable si et

seulement s’il est biparti) ;

— G arbre avec au moins une arête : χ(G) = 2.

VII.4.4 Comment calculer un nombre chromatique ?

Il est intéressant d’avoir des outils pour encadrer le nombre chromatique. On note qu’obtenir
un coloriage à k couleurs d’un graphe G permet d’afﬁrmer que χ(G) ≤ k. La difﬁculté réside pour
trouver une minoration.
Proposition VII.3

Soit G un graphe et G(cid:48) un sous graphe, on a χ(G(cid:48)) ≤ χ(G).

On va introduire deux nouvelles notions.

Déﬁnition VII.5. Soit G un graphe non orienté.
Une clique est un sous-graphe complet de G.
Une stable est un sous-graphe induit de G sans arcs (ou arêtes).

Ces notions donnes des informations sur le nombre chromatique :
— les sommets d’une même clique doivent être coloriés d’une couleur différente, ainsi trouver

une clique à k sommets permet d’afﬁrmer que χ(G) ≥ k ;

— les sommets d’une même stable peuvent être coloriés de la même couleur.

VII.4.5 Résolution algorithmique

Dans cette section on s’intéresse aux algorithmes qui permettent de trouver un coloriage ou le

nombre chromatique.

Algorithme glouton

On considère ici un coloriage comme une fonction des sommets dans les entiers. L’algorithme
glouton nous donne facilement un coloriage du graphe, le principe consiste à prendre les sommets
les uns après les autres et pour chaque sommet s d’affecter la couleur minimale qui n’apparait pas
dans les voisins coloriés de s.

Algorithm 2: Algorithme glouton de coloriage d’un graphe
Data: Un graphe G = (S, A)
Result: Une coloration ϕ : S → N∗ de G

for s ∈ S do

ϕ(s) ← plus petite couleur non utilisé par les voisins de s;

Terminaison L’algorithme termine une fois que l’on a visité tous les sommets.

Correction A chaque fois que l’on attribue une couleur à un sommet, elle est différentes des
couleurs des sommets voisins pour lesquels on a attribué une couleur. Ainsi le coloriage obtenu
est valide.

Chapitre VII. QUELQUES PROBLÈMES SUR LES GRAPHES

52

Complexité On passe |S| fois dans la boucle, chaque fois que l’on passe dans la boucle on regarde
tous les voisins du sommet considéré, on a au plus ∆(G) voisin à regarder où ∆(G) est le degré
maximal du graphe. Dans le pire des cas, on une complexité O(∆(G)|S|).

A t’on un coloriage optimal avec cet algorithme ? Le résultat dépend généralement de l’ordre
dans lequel on choisit les sommets et il est facile de trouver des exemples ou l’ordre donné ne
donne pas un coloriage optimal. On peut jouer sur l’ordre des sommets choisis, par exemple les
prendre dans l’ordre des degrés décroissants.

Algorithme de Welsh-Powell

Il est possible d’améliorer cet algorithme en coloriant d’abord les sommets qui imposent le
plus de contraintes (sommet de plus haut degré) et en utilisant la couleur que l’on vient d’utiliser
là ou cela est possible. On appèle ce principe l’algorithme de Welsh-Powell. Pour certaine classe
de graphe cet algorithme donne même systématiquement le coloriage optimal.

Algorithm 3: Algorithme de Welsh-Powell pour colorier un graphe
Data: Un graphe G = (S, A)
Result: Une coloration ϕ : S → N de G

L ← liste des sommets ordonnés par degré décroissant ;
couleur-courante ← 0;
while L (cid:54)= ∅ do

couleur-courante ← couleur-courante +1;
Colorier s le premier sommet de L avec couleur-courante;
Eliminer s de L;
V ← voisins de s;
for x ∈ L do
if x /∈ V then

Colorier x avec la couleur-courante;
Eliminer x de L;
Ajouter les voisins de x à V;

Terminaison Il est clair que, puisque le nombre de sommets dans L (et donc non coloriés) dimi-
nue d’au moins une unité à chaque fois que l’on exécute la boucle.

Correction Cette algorithme fournit bien un coloriage de G, en effet chaque fois que l’on colorie
un sommet, on place dans V les sommets voisins à ce sommet de telle sorte que l’on ne colorie
plus de cette couleur les sommets de V. Ainsi deux sommets voisins sont de couleurs différentes.
Complexité De manière grossière, on passe |S| fois dans la boucle while puis |S| fois dans la
boucle for, on a donc une complexité grossière en O(|S|2). Cependant, on peut être plus précis.
Dans la preuve de la proposition VII.4, on voit que l’on passe au maximum ∆(G) + 1 fois dans la
boucle while. On a donc une complexité en O(∆(G)|S|).
Proposition VII.4

Soit ∆(G) le degré maximal d’un graphe G, on a χ(G) ≤ ∆(G) + 1.

Démonstration : Soit s le dernier sommet colorié par l’algorithme 2. Si s n’a pas été colorié avant, c’est
que pour chacune des couleurs précédentes, un sommet adjacent à s a été colorié de cette couleur.
Par suite, le nombre de couleurs utilisées avant de colorier s ne peut dépasser d(s). Ainsi, en tenant
compte de la couleur de s, on déduit que le nombre total de couleurs utilisées par l’algorithme ne
dépasse pas d(s) + 1.

53

VII.4. Problèmes de coloriages

A t’on un coloriage optimal avec cet algorithme ? Là encore il existe des exemples ou cet algo-
rithme n’est pas optimal même si dans la majorité des cas il donne un coloriage optimal.

Existe t’il un algorithme pour trouver le nombre chromatique d’un graphe ?

On cherche un algorithme qui prend en argument un graphe G = (S, A) et renvoie le nombre
chromatique de ce graphe. Pour cela on teste tous les 2-coloriages, il y en a 2|S| s’il y a en a un
valide, on a χ(G) = 2, sinon on teste tous les 3-coloriages et ainsi de suite. L’algorithme termine
car il y a un coloriage à ∆(G) + 1 couleurs et il nous donne un coloriage optimal car on a essayer
toutes les possibilités avec moins de couleurs.
Cependant cet algorithme a une complexité en O((∆(G) + 1)|S|) dans le pire des cas, cette
complexité est par exemple atteinte pour le graphe complet. Cette complexité est exponentielle
en la taille du graphe et en pratique, pour des graphes un peu grand, il faut attendre des temps
extrêmement long pour le voir terminer. On estime que les complexités qui permettent d’avoir un
algorithme utilisable sont les complexité en O(nd) pour une valeur d donnée. Pour le problème du
nombre chromatique on ne sait pas s’il existe un algorithme polynomial qui permet de le résoudre.
Toutefois, il existe des classes de graphes pour lesquelles l’algorithme glouton (et donc de
complexité polynomiale) donne même systématiquement le coloriage optimal. En TD on verra
qu’un algorithme glouton avec un bon ordre sur les sommets donne un coloriage optimal pour les
graphes d’intervalles.
Remarque VII.1. En général on s’intéresse aux problèmes de décisions, par exemple :

Problème 1 : Etant donné a, b, c ∈ Z, est ce que ax2 + bx + c = 0 admet une solution rélle ?
Problème 2 : Etant donné un graphe G est ce que G admet un 3-coloriage ?

suivant :

On s’intéresse aux complexités qui résolvent ces problèmes, on déﬁnit les classes de problèmes
— Classe P : classe de problèmes que l’on peut résoudre en temps polynomial (par exemple
Problème 1) ;
— Classe NP : classe de problèmes tel que si on donne une solution on peut vériﬁer que
c’est bien une solution du problème (par exemple Problème 2) ;
— Classe E xp : classe de problèmes que l’on peut résoudre en temps exponentiel.

On a P ⊂ NP ⊂ E xp. On sait que P (cid:54)= E xp mais on ne sait pas si P = NP, c’est le problème
ouvert de l’informatique théorique.
Il existe une autre classe, la classe des problèmes NP-complet, ce sont les problèmes tels que
si on les résout en temps polynomial, on résout tous les problèmes NP en temps polynomial. En
particulier le problème de 3-coloriage est NP-complet.

VII.4.6 Cas des graphes planaires

Les graphes planaires sont une classe graphe avec des propriétés intéressantes du point de vu

du coloriage.

Déﬁnition VII.6 (Graphe planaire). Un graphe G = (S, A) est planaire s’il existe une représentation
dans le plan où les arêtes ne s’intersectent pas.

Exemple VII.5. Le graphe suivant est planaire si on déplace les sommets

G3

En fait, le nombre de couleur maximal pour colorié un graphe planaire est 4. Ce théorème est
connu comme l’un des premiers ou la preuve nécessite un ordinateur pour explorer l’explosion
combinatoire des différents cas de base.

Chapitre VII. QUELQUES PROBLÈMES SUR LES GRAPHES

54

Théorème VII.5

Tout graphe planaire est coloriable avec 4 couleurs, son nombre chromatique est donc infé-

rieur ou égal à 4.

VII.5 Problèmes de chemins dans un graphe
VII.5.1 Déﬁnitions

Déﬁnition VII.7. Soit G = (S, A) un graphe orienté (resp. non-orienté). Un chemin (resp. une
chaîne) dans G est une suite de sommets C = (s0, s1, s2, . . . , sk) telle qu’il existe un arc (resp. une
arête) entre chaque couple de sommets successifs de C. Ce qui s’écrit :

— si G = (S, A) est orienté alors pour tout i ∈ [0, k − 1] on a (si, si+1) ∈ A,
— si G = (S, A) est non-orienté alors pour tout i ∈ [0, k − 1] on a {si, si+1} ∈ A,
On appellera :

Chemin (resp. chaîne) simple : un chemin (resp. chaîne) dont tous les arcs (resp. arêtes) sont diffé-

rents.

Chemin (resp. chaîne) élémentaire : un chemin (resp. chaîne) dont tous les sommets sont différents

sauf peut être le départ et l’arrivée (pour autoriser les circuits ou cycles).

Circuit dans un graphe orienté : un chemin simple ﬁnissant à son point de départ.
Cycle dans un graphe non-orienté : une chaîne simple ﬁnissant à son point de départ.

VII.5.2 Connexité

Un graphe orienté est connexe si le graphe non orienté associé est connexe. Un graphe orienté

Déﬁnition VII.8 (Connexité et forte connexité). Un graphe non-orienté est connexe si pour tout
couple de sommets s et s(cid:48), il existe une chaîne reliant s à s(cid:48).
est fortement connexe si pour tout couple de sommets s et s(cid:48), il existe une chemin reliant s à s(cid:48).
Exemple VII.6 (Graphe connexe et fortement connexe). G1 est fortement connexe tandis que G2 est
connexe mais non fortement connexe.

B

A

C

B

A

C

G1

G1

Déﬁnition VII.9 (Composantes connexes et fortement connexes). Une composante connexe (resp.
fortement connexe) C d’un graphe G = (S, A) est un sous-ensemble maximal de sommets tels
que deux quelconques d’entre eux soient reliés par une chaîne (resp. un chemin). Formellement,
si s ∈ C alors on a :

— pour tout s(cid:48) ∈ C il existe une chaîne (resp. un chemin) reliant s à s(cid:48),
— pour tout s(cid:48) ∈ S \ C, il n’existe pas de chaîne (resp. chemin) reliant s à s(cid:48).

Quelques propriétés :
— Les composantes connexes (resp. fortement connexe) d’un graphe G = (S, A) forment une

partition de S.

— Un graphe est connexe (resp. fortement connexe) si et seulement s’il a une seule composante

— Le sous-graphe induit par une composante connexe (resp. fortement connexe) est connexe

connexe (resp. fortement connexe).

(resp. fortement connexe).

55

VII.5. Problèmes de chemins dans un graphe

— La composante connexe C qui contient un sommet s ∈ S est

C = {s(cid:48) ∈ S tel qu’il existe une chaîne reliant s à s(cid:48)}
— La composante fortement connexe C qui contient un sommet s ∈ S est

C = {s(cid:48) ∈ S tel qu’il existe un chemin reliant s à s(cid:48) et un chemin reliant s(cid:48) à s}

Exemple VII.7 (Composantes connexes). Les composantes connexes de G1 sont {A, C, E} et {B, D, F}
tandis que celles de G4 sont {1}, {2, 6}, {3, 5, 7} et {4}.

B

F

A

D

C

E

G1

4

5

2

7

1

3

6

G2

Exemple VII.8 (Composantes fortement connexes). Les composantes fortement connexes de G1
sont {A, B} et {C} tandis que celles de G2 sont {1, 7}, {2, 3, 5, 6} et {4}.

B

A

C

G1

4

5

2

7

1

3

6

G2

VII.5.3 Chemin Eulérien

Problématique

Au XVIIIème siècle un casse-tête est populaire chez les habitants de Königsberg : est-il pos-
sible de se promener dans la ville en ne passant qu’une seule fois par chacun des sept ponts de
Königsberg ? C’est le célèbre mathématicien Euler qui montre le premier que ce problème n’a pas
de solution, en utilisant pour la première fois la notion de graphe. Le problème se reformule ainsi
en terme de graphes : existe-t-il un cycle qui passe exactement une fois par toutes les arêtes dans
le graphe (multi-arête) ci-dessous ?

Ville de Königsberg

G

Déﬁnition VII.10. Soit G un graphe non orienté. Une chaîne (resp. un cycle) eulérienne est une
chaîne (resp. un cycle) qui passe une et une seule fois par toutes les arêtes de G.

On déﬁnit les mêmes notions pour un graphe orienté G : un chemin (resp. un circuit eulérien)

est un chemin (resp. un circuit) passant une et une seule fois par tous les arcs de G.

Chapitre VII. QUELQUES PROBLÈMES SUR LES GRAPHES

56

Exemple VII.9. Le graphe G1 admet un cycle eulérien. Le graphe G2 admet un chemin eulérien
mais pas un circuit.

G1

G2

Caractérisation des chemins eulériens

Avant de prouver la caractérisation des chemin eulériens, on a besoin du résultat suivant.

Proposition VII.6

Un graphe dont tous les sommets sont de degré supérieur ou égal à 2 possède au moins un

cycle.

Démonstration : La preuve utilise un algorithme de marquage. Initialement tous les sommets sont non
marqués. Un sommet s1 est marqué arbitrairement. L’algorithme construit alors une séquence s1, . . . , sk
de sommets marqués en choisissant arbitrairement pour si+1 un sommet non marqué adjacent à si.
L’algorithme s’arrête lorsque sk ne possède plus de voisin non marqué. Puisque ce sommet est de
(cid:54)= sk−1 dans la séquence, j < k − 1. On en déduit que
degré au moins 2, il possède un voisin sj
(sk, sj, sj+1, . . . , sk−1, sk) est un cycle.

Théorème VII.7

Soit G = (S, A) un graphe non orienté connexe. Il admet un cycle eulérien si et seulement

si d(s) est pair pour tout s ∈ S.

chaîne Eulériene.

Si seulement deux sommets ne vériﬁent pas les conditions précédentes alors G admet une

Démonstration : Soit G = (S, A) un graphe connexe. Pour qu’il admette un cycle Eulérien il faut qu’en
chaque sommet lorsqu’on arrive par une arête on puisse repartir par un autre arête. On obtient donc
que d(s) est pair si le graphe est orienté pour chaque sommet s ∈ S.
G, si chaque sommet s ∈ S est de degré pair alors G admet un cycle eulérien.

Réciproquement, on démontre par récurrence sur le nombre d’arcs que pour un graphe connexe
Initialisation : Si |A| = 0, on a un graphe connexe sans arêtes, c’est à dire un seul sommet isolé qui

admet un cycle eulérien.

Induction : On suppose que le théorème est vrai pour tout graphe ayant un nombre d’arêtes in-
férieur ou égal à n (hypothèse de récurrence forte). Soit G = (S, A) un graphe connexe tel que
|A| = n + 1 et pour chaque sommet s ∈ S est de degré pair. Comme le graphe est connexe et que le de-
gré de chaque sommet est pair, on en déduit que G admet un cycle élémentaire C = (s1, s2, . . . , sk, s1).
Soit G(cid:48) le sous-graphe de G auquel on a supprimé les arêtes de C. Le graphe G(cid:48) n’est pas for-
cément connexe mais vériﬁe d(s) pairs pour chacun de ses sommet s. On applique l’hypothèse de
récurrence sur chacune de ses composantes qui admettent donc des cycles eulériens. On combine
alors ces différents cycles eulériens avec le cycle C, pour former un cycle eulérien sur G de la façon
suivante : on parcourt C depuis un sommet initial arbitraire et, à chaque fois que l’on rencontre une
des composantes connexes de G(cid:48) pour la première fois, on insère le cycle eulérien considéré sur cette
composante. S’agissant d’un cycle, on est assuré de pouvoir poursuivre le parcours de C après ce
détour. Il est facile de vériﬁer qu’on a ainsi bien construit un cycle eulérien sur G.

Si G admet une chaîne Eulérienne et admet un sommet de degré impair, soit c’est le point de
départ de la chaîne, soit il arrive un moment où l’on ne pourra plus repartir ce qui constitue le sommet
terminal de la chaîne. Ainsi, si seulement deux sommets sont de degré impair il peuvent servir de
point de départ et d’arrivé d’un chemin passant par tous les arêtes du graphe, le graphe peut donc
admettre une chaîne Eulérienne.

Dans le cas orienté on montre de manière similaire le résultat suivant.

57

VII.5. Problèmes de chemins dans un graphe

Théorème VII.8

seulement si d+(s) = d−(s) pour tout s ∈ S.

Soit G = (S, A) un graphe orienté fortement connexe. Il admet un circuit eulérien si et
Si seulement deux sommets vériﬁent |d+(s) − d−(s)| = 1 alors G admet un chemin Eulé-

rien.

VII.5.4 Chemins hamiltonien

Déﬁnition VII.11. Soit G un graphe non orienté. Un cycle (respectivement une chaîne) hamiltonien
est un cycle (resp. une chaîne) qui passe une et une seule fois par tous les sommets de G.

On déﬁnit les mêmes notions pour un graphe orienté G : un circuit ou un chemin hamiltonien est

un circuit ou un chemin passant une et une seule fois par tous les sommets de G
Exemple VII.10. G1 admet un circuit hamiltonien, G2 n’admet ni chaîne ni cycle hamiltoniens, G3
admet une chaîne hamiltonienne mais pas de cycles hamiltoniens et G4 admet un cycle hamilto-
nien.

G1

G2

G3

G4

On ne connaît pas de condition nécessaire et sufﬁsante exploitable dans la pratique pour déci-
der si un graphe est hamiltonien ou non. De manière générale, la recherche de cycle, chaîne, circuit
ou chemin Hamiltonien est un problème algorithmiquement difﬁcile. En fait, on peut montrer que
c’est un problème NP-complet.

