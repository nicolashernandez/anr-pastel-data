https://www.theses.fr/2017NORMC203.pdf

ThÃ¨se de doctorat

THESE

Pour obtenir le diplÃ´me de doctorat 

SpÃ©cialitÃ© : Informatique et applications

PrÃ©parÃ©e au sein de l'UniversitÃ© de Caen Normandie

CaractÃ©riser et dÃ©tecter les communautÃ©s

Titre de la thÃ¨se

dans les rÃ©seaux sociaux
PrÃ©sentÃ©e et soutenue par

Jean CREUSEFOND

Mme. Anne BOYER

Mr. Christoph DÃœRR

Mr. Thomas LARGILLIER

Mr. Matthieu LATAPY

Mr. Sylvain PEYRONNET

Mr. Marc SPANIOL

Mr. Emmanuel VIENNET

ThÃ¨se soutenue publiquement le 17/01/2016

devant le jury composÃ© de

Professeur des UniversitÃ©s
UniversitÃ© de Nancy 2, LORIA
Directeur de recherche CNRS
UniversitÃ© de Pierre et Marie Curie, LIP6
MaÃ®tre de confÃ©rences
UniversitÃ© de Caen Normandie, GREYC
Directeur de recherche CNRS
UniversitÃ© de Pierre et Marie Curie, LIP6
Professeur des UniversitÃ©s
UniversitÃ© de Caen Normandie, GREYC
Professeur des UniversitÃ©s
UniversitÃ© de Caen Normandie, GREYC
Professeur des UniversitÃ©s
UniversitÃ© Paris 13, L2TI

Rapporteuse

Examinateur

Examinateur

Rapporteur

Directeur

Examinateur

Examinateur

ThÃ¨se dirigÃ©e par Sylvain Peyronnet, laboratoire GREYC

Remerciements

Tout d'abord, j'aimerais remercier Sylvain Peyronnet et Thomas Largillier
pour leur encadrement tout au long de cette thÃ¨se. Sans leur patience, leur
sincÃ©ritÃ© et leur implication, cette thÃ¨se n'aurait jamais vu le jour. Sylvain,
Thomas, je vous dois beaucoup.

Je remercie aussi Christoph DÃ¼rr et Emmanuel Viennet d'avoir acceptÃ©
de faire partie de mon jury, et Marc Spaniol de le prÃ©sider. En plus d'Ãªtre
membres de mon jury, Anne Boyer et Matthieu Latapy m'ont fait l'honneur
de rapporter ma thÃ¨se, et je les en remercie profondÃ©ment.

Je souhaite aussi mentionner les interlocuteurs avec lesquels j'ai eu des
discussions qui ont Ã©tÃ©s des points clef lors de ce doctorat. Gaetan Richard,
merci pour ta curiositÃ© insatiable et ton entrain Ã  toute Ã©preuve. LoÃ¯c Lhote,
merci pour ton humour noir et ton enthousiasme. Michel Habib, merci pour
tes idÃ©es ingÃ©nieuses et tes projets innovants. Nicolas Bacquey, merci pour
ton regard critique et ton point de vue formel. Marc Spaniol, merci pour tes
propositions pertinentes et ton intÃ©rÃªt qui m'a beaucoup encouragÃ©.

J'ai aussi reÃ§u beaucoup d'aide pour louvoyer dans l'administration. Merci
Ã  Julien ClÃ©ment pour son soutien au niveau de l'Ã©quipe AMACC, Marie
Meleux pour sa patience envers mon cas atypique pour l'Ã©cole doctorale et
Arielle Perette pour sa gestion du labo.

Certaines personnes furent un soutien indispensable dans mon quotidien.
Sans ordre particulier, je souhaiterais remercier Nicolas et Yohann Bacquey,
Alexandre Letois, LÃ©na Coms, Axel Huet, Laureen Collette, Yohann Troude,
Emily Abbott et Thibaut VallÃ©e. Je remercie enn toute ma famille pour son
soutien inconditionnel et total.

Je remercie ensuite tous ceux que j'ai oubliÃ© de remercier : toutes ces
discussions rapides dans les couloirs, ou enammÃ©es lors de colloques, toutes
ces rencontres Ã©phÃ©mÃ¨res et tous ces amis lointains. Vous avez apportÃ©, Ã 
votre maniÃ¨re, une pierre Ã  mon modeste Ã©dice.

Enn, merci Ã  toi lecteur de cette thÃ¨se, de t'intÃ©resser Ã  mon travail de

recherche. Ton regard critique lui donne un sens et une raison d'exister.

J. Creusefond

i

ii

J. Creusefond

Table des matiÃ¨res

1 Introduction

1

2 Rappels

7
7
2.1 Ã‰lÃ©ments de thÃ©orie des graphes . . . . . . . . . . . . . . . . .
9
2.1.1 Chemins . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1.2 Partitions et couvertures . . . . . . . . . . . . . . . . .
9
2.1.3 Parcours et marches alÃ©atoires . . . . . . . . . . . . . . 10
2.2 RÃ©seaux sociaux . . . . . . . . . . . . . . . . . . . . . . . . . . 14
2.3 Fonctions de qualitÃ©
. . . . . . . . . . . . . . . . . . . . . . . 15
2.4 Algorithmes de dÃ©tection de communautÃ© . . . . . . . . . . . . 19
. . . . . . . . . . . . . . 19
2.4.1
2.4.2 Algorithmes . . . . . . . . . . . . . . . . . . . . . . . . 20
2.5 MÃ©thodes de comparaison . . . . . . . . . . . . . . . . . . . . 22

StratÃ©gies de partitionnement

3 Ã‰tude de la structure communautaire de rÃ©seaux de commu-

25
nication par les motifs temporels
3.1 Adaptation des motifs aux pÃ©riodes d'activitÃ©
. . . . . . . . . 29
3.2 Experiences . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
3.2.1 Analyse des propriÃ©tÃ©s des a-motifs . . . . . . . . . . . 34
3.2.2 Etude de la relation entre a-motifs et communautÃ©s . . 37

4 Une nouvelle fonction de qualitÃ© : la compacitÃ©

41

4.1 ModÃ©lisation et dÃ©nition d'une structure communautaire com-

pacte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
4.2 Respect des axiomes de Van Laarhoven et Marchiori . . . . . . 45

5 Une mÃ©thode de dÃ©tection de communautÃ©s basÃ©e sur lâ€™algo-

rithme du LexDFS
55
5.1 Un algorithme de partitionnement basÃ© sur le LexDFS . . . . 56
5.2 Ã‰valuation expÃ©rimentale du Lex-Clusering . . . . . . . . . . . 60
5.2.1 Vitesse de convergence du Lex-Clustering . . . . . . . . 61

J. Creusefond

iii

5.2.2 Ã‰tude des  clusters  individuels . . . . . . . . . . . . 62
5.2.3 Ã‰tude des partitions
. . . . . . . . . . . . . . . . . . . 68
5.2.4 Comparaison avec des vÃ©ritÃ©s de terrain . . . . . . . . . 71

6 Lâ€™Ã©valuation de structures communautaires

73
6.1 MÃ©thodologie expÃ©rimentale . . . . . . . . . . . . . . . . . . . 75
6.2 ParamÃ¨tres expÃ©rimentaux . . . . . . . . . . . . . . . . . . . . 76
6.3 Optimisations . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
6.4 RÃ©sultats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80

7 CoDACom : une boÃ®te Ã  outils pour la dÃ©tection de commu-

nautÃ©s
87
7.1 Utilisation et fonctionnalitÃ©s . . . . . . . . . . . . . . . . . . . 88
7.2 Travaux connexes . . . . . . . . . . . . . . . . . . . . . . . . . 97

8 Conclusion

99
8.1 A-motifs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
8.2 Lex-Clustering et compacitÃ© . . . . . . . . . . . . . . . . . . . 100
8.3 Fonctions de qualitÃ© et vÃ©ritÃ©s de terrain . . . . . . . . . . . . 101

A DÃ©marches et description du rÃ©seau dâ€™e-mails de lâ€™universitÃ©

de Caen

103

iv

J. Creusefond

Chapitre 1

Introduction

En 2016, il y a plus de 1,71 milliards de comptes actifs sur un rÃ©seau
social comme Facebook 1. Le nombre d'inscrits sur les rÃ©seaux sociaux sur le
web augmente de deux cent millions par an depuis 2010 2. L'augmentation du
nombre de comptes entraine mÃ©caniquement une augmentation du volume
de donnÃ©es produit. La problÃ©matique de la volumÃ©trie des donnÃ©es est au
coeur des challenges algorithmiques liÃ©s aux rÃ©seaux sociaux.

La taille des rÃ©seaux sociaux complique leur analyse. Pour pallier ce pro-
blÃ¨me, plusieurs mÃ©thodes sont envisageables, l'une d'elles est de partitionner
les rÃ©seaux sociaux en Ã©lÃ©ments plus petits. Ce partitionnement permet alors,
dans l'idÃ©al, de comprendre le comportement global du systÃ¨me en analysant
localement les Ã©lÃ©ments qui le composent et leurs comportements. Dans cette
thÃ¨se, je m'intÃ©resse au partitionnement de rÃ©seaux sociaux en sous-groupes
d'individus le composant.

J'ai choisi de travailler avec une reprÃ©sentation usuelle des rÃ©seaux so-
ciaux : le graphe. Un graphe est un ensemble d'entitÃ©s et d'interactions (on
parle traditionnellement de noeuds et d'arÃªtes). Dans les rÃ©seaux sociaux
web, ces interactions sont reprÃ©sentÃ©es explicitement. Par exemple, sur Face-
book on se dÃ©clare ami d'une personne tandis que sur Twitter on suit son l
d'actualitÃ©. La Fig. 1.1 illustre un extrait du rÃ©seau de Facebook [65] reprÃ©-
sentÃ© sous forme de graphe. Les objets d'Ã©tude principaux de ma thÃ¨se sont
les structures formÃ©es par ces interactions. Elles permettent de caractÃ©riser
des groupes d'individus.

Seule une fraction de l'activitÃ© des individus dans les rÃ©seaux sociaux est
reprÃ©sentÃ©e par ce modÃ¨le. En eet, dans ce modÃ¨le, on ne fait pas apparaÃ®tre

1. https://investor.fb.com/investor-news/press-release-details/2016/

Facebook-Reports-Second-Quarter-2016-Results/default.aspx

2. https://www.statista.com/statistics/278414/number-of-worldwide-

social-network-users/

J. Creusefond

1

Chapitre 1. Introduction

Figure 1.1  Un extrait de Facebook [65] sous forme de graphe : 4 039
utilisateurs et leurs 88 234 relations d'amitiÃ©.

le contenu des messages, le temps en ligne, ou mÃªme la nature multiple des
relations (travail, amis, famille, etc.). Cependant, rÃ©duire le rÃ©seau de cette
maniÃ¨re permet d'observer et d'interprÃ©ter des caractÃ©ristiques de la struc-
ture. Voici par exemple quelques observations que l'on peut rÃ©aliser Ã  partir
de la gure Fig. 1.1 :

1. Certains individus sont Ã  la jonction de diÃ©rentes parties du rÃ©seau.
C'est par exemple le cas du noeud entourÃ© en rouge. Cette position
centrale permet d'agrÃ©ger l'information de plusieurs groupes distincts
et donne la possibilitÃ© de contacter indirectement beaucoup d'indivi-
dus [41].

2. On peut aussi remarquer que, mÃªme s'il y a plus de quatre mille indivi-
dus dans le rÃ©seau, le nombre d'intermÃ©diaires pour aller de n'importe
quel individu Ã  un autre est faible, moins d'une dizaine. Une informa-
tion peut ainsi emprunter un chemin court pour aller d'un point Ã  un
autre du rÃ©seau et donc se propager rapidement [24].

3. On observe que les individus forment des groupes, comme ceux en-
tourÃ©es en bleu. Il s'agit de parties du rÃ©seau constituÃ©es d'ensembles
d'individus ayant beaucoup de contacts entre eux. Il y a souvent une
raison sociale Ã  l'existence de ces groupes dans notre modÃ¨le [39].

De nombreux domaines applicatifs sont basÃ©s sur les caractÃ©ristiques sous-
jacentes associÃ©es Ã  ces trois observations [6, 7]. Les travaux de cette thÃ¨se

2

J. Creusefond

portent tous sur la notion de groupe, esquissÃ©e dans la troisiÃ¨me observation
ci-dessus.

L'objectif de la dÃ©tection de communautÃ©s est la dÃ©tection de ces groupes.
Il n'y a pas de consensus sur la dÃ©nition de ce qu'est une communautÃ©. Il
est cependant communÃ©ment admis qu'il s'agit d'une partie dense du graphe
reprÃ©sentant le rÃ©seau social [36].

Un grand nombre d'application rÃ©elles utilise des algorithmes de dÃ©tection
de communautÃ©s : recherche d'organisations criminelles [33], dÃ©tection de
 spam  [12], systÃ¨mes de recommandation [84], etc. D'autres disciplines
scientiques utilisent la dÃ©tection de communautÃ©s pour mieux comprendre
la structure des objets Ã©tudiÃ©s. C'est le cas de la sociologie [93] et de la
biologie [32] par exemple.

Du fait de la variÃ©tÃ© des communautÃ©s recherchÃ©es, les dÃ©nitions de la
communautÃ© sont multiples. Par exemple, une entreprise cherchant Ã  diu-
ser un message publicitaire dans certaines communautÃ©s sera intÃ©ressÃ©e par
les facteurs facilitant la transmission. Dans un autre contexte, la dÃ©tection
des communautÃ©s de  spammers  utiliserait des critÃ¨res de cohÃ©sion in-
terne, oÃ¹ les membres d'une communautÃ© doivent avoir des caractÃ©ristiques
proches [60].

Girvan et Newman [39] dÃ©nissent une communautÃ© comme un ensemble
d'entitÃ©s au sein duquel il y a plus de relations internes qu'externes. Ra-
dicchi et al. [81] ajoutent Ã  cette dÃ©nition la contrainte que les individus
d'une communautÃ© ont plus de voisins Ã  l'intÃ©rieur de leur communautÃ© qu'Ã 
l'extÃ©rieur. Ils appellent ces structures les communautÃ©s fortes.

Ces dÃ©nitions sont binaires : elles n'apportent pas de gradation quant au
respect des propriÃ©tÃ©s recherchÃ©es. An de permettre plus de souplesse, on
peut concevoir des fonctions attribuant un score aux groupes. On appelle ces
fonctions des fonctions de qualitÃ©. Elles quantient les propriÃ©tÃ©s considÃ©rÃ©es
comme importantes pour l'application. Les fonctions de qualitÃ© peuvent Ãªtre
vues comme une extension des dÃ©nitions. Newman et Girvan ont revisitÃ©
leur dÃ©nition pour crÃ©er une fonction de qualitÃ© [75], la modularitÃ©.

Les fonctions de qualitÃ© sont plus exibles que les dÃ©nitions binaires.
En eet, elles permettent d'obtenir une prÃ©fÃ©rence entre des communautÃ©s
ainsi qu'entre des partitions du graphe. De nombreux algorithmes [20, 78]
crÃ©ent initialement une partition triviale (une communautÃ© par individu, par
exemple) et amÃ©liorent cet Ã©tat par des opÃ©rations locales qui augmentent
la valeur de la fonction de qualitÃ©. Les fonctions de qualitÃ© servent aussi Ã 
l'Ã©valuation des partitions [43]. Pour Ã©valuer un algorithme de dÃ©tection de
communautÃ©s, on procÃ©dera Ã  l'Ã©valuation des partitions qu'il calcule.

En plus des fonctions de qualitÃ©, les chercheurs utilisent frÃ©quemment des
jeux de donnÃ©es extraits de la rÃ©alitÃ© pour Ã©valuer les structures communau-

J. Creusefond

3

Chapitre 1. Introduction

taires (par exemple [52, 79]). Ces jeux de donnÃ©es dÃ©crivent des structures
assimilÃ©es Ã  des communautÃ©s, par exemple des domaines de recherche dans
des rÃ©seaux de chercheurs [16]. L'Ã©valuation consiste alors Ã  Ã©valuer la proxi-
mitÃ© entre partitions et donnÃ©es.

Les problÃ©matiques au coeur de cette thÃ¨se sont les suivantes :

 La diusion de l'information sur les rÃ©seaux sociaux est trÃ¨s proche
de modÃ¨les infectieux. Est-il possible de s'inspirer de ces modÃ¨les pour
dÃ©tecter les communautÃ©s ?

 Les fonctions de qualitÃ© et les jeux de donnÃ©es sont utilisÃ©s pour Ã©valuer
les partitions de deux maniÃ¨res diÃ©rentes. Quel est le lien entre les deux
mÃ©thodes Ã©valuatives ?

 Les communautÃ©s ont Ã©tÃ© assez peu caractÃ©risÃ©es dans le cas oÃ¹ le rÃ©-
seau correspond Ã  un ensemble de messages. Dans ces rÃ©seaux, je m'in-
tÃ©resse aux messages liÃ©s causalement, comme dans une conversation.
La structure communautaire a-t-elle une inuence sur la faÃ§on dont les
messages s'enchainent ?

Les contributions de cette thÃ¨se sont les rÃ©ponses Ã  ces problÃ©matiques.

Le chapitre 2 contient les notions nÃ©cessaires Ã  la lecture de cette thÃ¨se.
J'y prÃ©sente d'abord les notions fondamentales de la thÃ©orie des graphes puis
les propriÃ©tÃ©s classiques des rÃ©seaux sociaux. Enn, j'y dÃ©cris l'ensemble des
algorithmes de dÃ©tection de communautÃ©s, fonctions de qualitÃ© et mÃ©thodes
de comparaison que j'utilise dans ce manuscrit.

Le chapitre 3 prÃ©sente une Ã©tude expÃ©rimentale des rÃ©seaux formÃ©s par
des messages. Les expÃ©riences qui y sont menÃ©es ont pour but de dÃ©terminer
le lien entre la structure communautaire et les messages liÃ©s causalement.

Le chapitre 4 introduit une nouvelle fonction de qualitÃ© : la compacitÃ©. Elle
est basÃ©e sur les propriÃ©tÃ©s d'un modÃ¨le simple de diusion de l'information.
Cette fonction mesure dans ce modÃ¨le le taux de propagation d'un message
dans une communautÃ©. Une forte compacitÃ© implique que l'information se
propage rapidement dans la communautÃ©.

Le chapitre 5 contient un nouvel algorithme de dÃ©tection de communautÃ©s.
Celui-ci repose sur un algorithme de parcours de graphes visitant les zones
denses les unes aprÃ¨s les autres. Cet algorithme crÃ©e des  clusters  compacts.
Le chapitre 6 prÃ©sente une Ã©tude sur la correspondance entre l'Ã©valuation
par les fonctions de qualitÃ© et la comparaison aux jeux de donnÃ©es. J'y dÃ©-
nis la notion de contexte, c'est-Ã -dire d'ensemble de jeux de donnÃ©es qui se
comportent de maniÃ¨re similaire au regard des fonctions de qualitÃ©.

4

J. Creusefond

Le chapitre 7 prÃ©sente un outil dÃ©veloppÃ© dans le cadre de cette thÃ¨se :
CoDACom 3 ( Community Detection Algorithme Comparator ). Cet ou-
til permet d'analyser des algorithmes de dÃ©tection de communautÃ©s et des
fonctions de qualitÃ©. CoDACom a plusieurs objectifs : analyser de nouveaux
algorithmes, tester un algorithme connu dans un cas d'Ã©tude nouveau, et
Ã©valuer les mÃ©thodes d'analyse.

Enn, le chapitre 8 conclut la thÃ¨se et ouvre quelques perspectives.

3. http://codacom.greyc.fr

J. Creusefond

5

Chapitre 1. Introduction

6

J. Creusefond

Chapitre 2

Rappels

Dans ce chapitre, je rappelle les notions essentielles Ã  la lecture de cette
thÃ¨se. J'introduis d'abord les concepts fondamentaux de la thÃ©orie des graphes,
utilisÃ©s ici pour reprÃ©senter et manipuler les rÃ©seaux sociaux. Je prÃ©sente en-
suite les propriÃ©tÃ©s structurelles connues des rÃ©seaux sociaux. Enn je prÃ©-
sente l'Ã©tat de l'art des algorithmes de dÃ©tection de communautÃ©s, fonctions
de qualitÃ© et mÃ©thodes de comparaison.

2.1 Ã‰lÃ©ments de thÃ©orie des graphes

Dans cette section, je prÃ©sente les dÃ©nitions de quelques Ã©lÃ©ments de

thÃ©orie des graphes. Les notations utilisÃ©es sont listÃ©es Tab. 2.1 page 13.

DÃ©finition 2.1 (Graphe). Un graphe ğº = (ğ‘‰, ğ¸) est un ensemble ğ‘‰ de
noeuds et un ensemble ğ¸ âŠ† ğ‘‰ Ã— ğ‘‰ dâ€™arÃªtes entre ces noeuds.

Sauf mention contraire, je considÃ¨re des graphes non orientÃ©es, c'est-Ã -
dire que pour tout ğ‘¢, ğ‘£ âˆˆ ğ‘‰ , (ğ‘¢, ğ‘£) est indistinguable de (ğ‘£, ğ‘¢). Les graphes
utilisÃ©s sont sans boucle, c'est-Ã -dire : âˆ€ğ‘¢ âˆˆ ğ‘‰ , (ğ‘¢, ğ‘¢) /âˆˆ ğ¸. Par convention,
je note ğ‘› = |ğ‘‰ | le nombre de noeuds et ğ‘š = |ğ¸| le nombre d'arÃªtes.
DÃ©finition 2.2 (Incidence). Une arÃªte (ğ‘¢, ğ‘£) âˆˆ ğ¸ est dite incidente Ã  ğ‘¢ et Ã 
ğ‘£, et ces noeuds sont dit voisins.

DÃ©finition 2.3 (DegrÃ©). Le degrÃ© dâ€™un noeud ğ‘£ est le nombre dâ€™arÃªtes inci-
dentes Ã  ce noeud, ğ‘˜ğ‘£ = |{ğ‘’ | ğ‘’ âˆˆ ğ¸, ğ‘£ âˆˆ ğ‘’}|.

Notons que dans la dÃ©nition 2.3, le degrÃ© devrait Ãªtre formellement notÃ©
ğ‘˜ğ‘£(ğº). Cependant, pour simplier la lecture, le graphe ne sera pas mentionnÃ©
quand il n'y a pas d'ambiguÃ¯tÃ©. Dans le cas contraire, le graphe sera prÃ©cisÃ©
en indice. Par exemple, je noterai ğ‘˜ğ‘£,ğº le degrÃ© du noeud ğ‘£ dans ğº.

J. Creusefond

7

Chapitre 2. Rappels

DÃ©finition 2.4 (DensitÃ©). La densitÃ© dâ€™un graphe est la probabilitÃ© que deux
noeuds pris au hasard soient voisins.

Un exemple de graphe est prÃ©sentÃ© Fig. 2.1.

Figure 2.1  Exemple de graphe, reprÃ©sentÃ© de maniÃ¨re ensembliste et gra-
phique. Le degrÃ© de chaque noeud est indiquÃ©. La densitÃ© de ce graphe est
de 0,5.

DÃ©finition 2.5 (Clique). Une clique est un graphe de densitÃ© 1. Une k-clique
est une clique ayant ğ‘˜ noeuds.

J'utilise parfois des extensions du graphe, comme le graphe orientÃ© ou le

graphe pondÃ©rÃ©.

DÃ©finition 2.6 (Graphe orientÃ©). Un graphe orientÃ© ğº = (ğ‘‰, ğ¸) est un
graphe pour lequel âˆ€ğ‘¢,ğ‘£ âˆˆ ğ‘‰ , (ğ‘¢, ğ‘£) est distinguable de (ğ‘£, ğ‘¢)

Dans un graphe orientÃ©, on parle d'arc et non d'arÃªte. Dans la suite de ce
manuscrit, je dirai qu'un arc (ğ‘¢, ğ‘£) est Ã©mis par ğ‘¢ âˆˆ ğ‘‰ et est reÃ§u par ğ‘£ âˆˆ ğ‘‰ .
DÃ©finition 2.7 (Graphe pondÃ©rÃ©). Un graphe pondÃ©rÃ© ğº = (ğ‘‰, ğ‘¤) est un
ensemble de noeuds ğ‘‰ et une fonction de poids ğ‘¤ : ğ‘‰ Ã— ğ‘‰ â†’ R qui associe
une valeur rÃ©elle Ã  chaque couple de noeuds.

8

J. Creusefond

v1v5v2v3v4G = (V, E)V = {v1,v2,v3,v4,v5}E = {(v1,v2),(v2,v3),(v2,v5),(v3,v4),(v4,v5)}kv1=1kv5=2kv4=2kv3=2kv2=22.1. Ã‰lÃ©ments de thÃ©orie des graphes

2.1.1 Chemins

Dans cette thÃ¨se, j'utilise des algorithmes visitant des noeuds de voisins

en voisins. Ces visites successives forment des chemins.
DÃ©finition 2.8 (Chemin). Un chemin de longueur ğ‘˜ âˆˆ N+ dans un graphe
est une suite de noeuds ğœ‹ = (ğ‘£0, . . . , ğ‘£ğ‘˜) âˆˆ ğ‘‰ ğ‘˜+1 respectant âˆ€ğ‘– âˆˆ [0..ğ‘˜ âˆ’
1], (ğ‘£ğ‘–, ğ‘£ğ‘–+1) âˆˆ ğ¸.

Je note Î (ğ‘¢,ğ‘£) l'ensemble des chemins possibles entre ğ‘¢ et ğ‘£ et je note

ğ‘™ğ‘’ğ‘›(ğœ‹) la longueur du chemin ğœ‹.

DÃ©finition 2.9 (Composante connexe). Une composante connexe dâ€™un graphe
est un ensemble maximal (au sens du cardinal) de noeuds ğ‘‰ â€² âŠ† ğ‘‰ tel que
âˆ€ğ‘¢, ğ‘£ âˆˆ ğ‘‰ â€², Î (ğ‘¢, ğ‘£) Ì¸= âˆ….

Je traite principalement de graphes connexes, qui ne comportent qu'une

composante connexe.

DÃ©finition 2.10 (Distance). La distance entre deux noeuds dans la mÃªme
composante connexe est ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘¢, ğ‘£) = min

ğ‘™ğ‘’ğ‘›(ğœ‹).

ğœ‹âˆˆÎ (ğ‘¢,ğ‘£)

DÃ©finition 2.11 (ExcentricitÃ©). Lâ€™excentricitÃ© dâ€™un noeud dans un graphe
connexe est la distance maximale entre ce noeud et les autres noeuds du
graphe, ğ‘’ğ‘¥ğ‘(ğ‘£) = max
ğ‘¢âˆˆğ‘‰

ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘¢, ğ‘£).

DÃ©finition 2.12 (DiamÃ¨tre). Le diamÃ¨tre dâ€™un graphe connexe est le maxi-
mum des distances entre les noeuds, ğ‘‘ğ‘–ğ‘ğ‘š(ğº) = max
ğ‘¢,ğ‘£âˆˆğ‘‰

ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘¢, ğ‘£).

2.1.2 Partitions et couvertures

L'objectif de la dÃ©tection de communautÃ©s est de dÃ©couvrir des groupes
d'individus dans un rÃ©seau social. Ces groupes sont associÃ©s Ã  des  clusters 
dans le graphe.

DÃ©finition 2.13 (Cluster). Un Â« cluster Â» est un ensemble de noeuds non
vide.

Un  cluster  est dit trivial s'il ne contient qu'un noeud.

DÃ©finition 2.14 (InternalitÃ©). Une arÃªte (ğ‘¢, ğ‘£) âˆˆ ğ¸ est dite interne Ã  un
Â« cluster Â» ğ‘ si ğ‘¢ âˆˆ ğ‘ et ğ‘£ âˆˆ ğ‘. Elle est dite externe si ğ‘¢ âˆˆ ğ‘ ou ğ‘£ âˆˆ ğ‘.
DÃ©finition 2.15 (Couverture). Une couverture ğ¶ est un ensemble de Â« clus-

ters Â» recouvrants â‹ƒï¸€

ğ‘âˆˆğ¶

ğ‘ = ğ‘‰ .

J. Creusefond

9

Chapitre 2. Rappels

Deux  clusters  ayant un noeud en commun sont dit chevauchants.

DÃ©finition 2.16 (Partition). Une partition ğ¶ dâ€™un graphe est une couverture
dont les Â« clusters Â» sont disjoints : âˆ€ğ‘1, ğ‘2 âˆˆ ğ¶, ğ‘1 Ì¸= ğ‘2 â‡’ ğ‘1 âˆ© ğ‘2 = âˆ…

Dans cette thÃ¨se, je m'intÃ©resse aux algorithmes de dÃ©tections de com-
munautÃ© produisant des partitions [36]. Je note toutefois qu'il existe des
algorithmes de dÃ©tection de communautÃ©s produisant des couvertures [102].

DÃ©finition 2.17 (Sous-graphe induit). Le sous-graphe induit par un Â« clus-
ter Â» ğ‘, est un graphe ğºâ€² = (ğ‘, ğ¸â€²) oÃ¹ ğ¸â€² = ğ‘2 âˆ© ğ¸.

J'Ã©tends aux  clusters  les dÃ©nitions propres aux graphes, comme la
connexitÃ© ou le diamÃ¨tre. Ces fonctions sont alors Ã  appliquer au sous-graphe
induit par le  cluster .

J'Ã©tudie systÃ©matiquement des  clusters  connexes.

DÃ©finition 2.18 (Graphe quotient). Le graphe quotient associÃ© Ã  la partition
ğ¶ dâ€™un graphe ğº = (ğ‘‰, ğ¸) est un graphe pondÃ©rÃ© ğºâ€² = (ğ¶, ğ‘¤) tel que âˆ€ğ‘1, ğ‘2 âˆˆ
ğ¶, ğ‘¤(ğ‘1, ğ‘2) = |{(ğ‘, ğ‘) | (ğ‘, ğ‘) âˆˆ ğ¸, ğ‘ âˆˆ ğ‘1, ğ‘ âˆˆ ğ‘2}|.

2.1.3 Parcours et marches alÃ©atoires

Un parcours de graphe est un chemin visitant chaque noeud du graphe.
Un algorithme de parcours de graphe visite donc sÃ©quentiellement tous les
noeuds du graphe.

Dans cette thÃ¨se, j'utilise le DFS ( Depth-First Search , parcours en
profondeur) ainsi que le BFS ( Breadth-First Search , parcours en largeur).
Le DFS visite un noeud ğ‘£ puis choisit comme noeud Ã  visiter par la suite
l'un des voisins non visitÃ©s de ğ‘£. Si tous les voisins de ğ‘£ ont dÃ©jÃ  Ã©tÃ©s visitÃ©s,
le DFS choisit l'un des voisins du noeud prÃ©cÃ©dent, et ainsi de suite. Le DFS
est prÃ©sentÃ© Alg. 1.

Algorithme 1 : DFS(G,s)

DonnÃ©es : Un graphe ğº et un noeud de dÃ©part ğ‘ 

1 dÃ©but

2

3

4

5

10

Marque ğ‘  comme visitÃ©
pour ğ‘£ âˆˆ ğ‘£ğ‘œğ‘–ğ‘ ğ‘–ğ‘›ğ‘ (ğ‘ ) faire

si ğ‘£ nâ€™est pas marquÃ© comme visitÃ© alors

DFS(ğº, ğ‘£)

J. Creusefond

2.1. Ã‰lÃ©ments de thÃ©orie des graphes

Le BFS place d'abord le noeud d'origine dans une le. Ã€ chaque itÃ©ration,
le BFS va visiter le premier Ã©lÃ©ment de la le puis placer tous ses voisins dans
la le, s'ils n'y sont pas dÃ©jÃ . Le BFS est prÃ©sentÃ© Alg. 2.

Algorithme 2 : BFS(G,s)

DonnÃ©es : Un graphe ğº et un noeud de dÃ©part ğ‘ 

1 dÃ©but

2

3

4

5

6

7

8

ğ‘“ ğ‘–ğ‘™ğ‘’ â† (ğ‘ )
tant que ğ‘“ ğ‘–ğ‘™ğ‘’ Ì¸= () faire

ğ‘£ â† ğ‘‘Â´ğ‘’ğ‘“ ğ‘–ğ‘™ğ‘’(ğ‘“ ğ‘–ğ‘™ğ‘’)
pour ğ‘¢ âˆˆ ğ‘£ğ‘œğ‘–ğ‘ ğ‘–ğ‘›ğ‘ (ğ‘£) faire

si ğ‘¢ nâ€™est pas marquÃ© comme enfilÃ© alors

marque ğ‘¢ comme enlÃ©
ğ‘’ğ‘›ğ‘“ ğ‘–ğ‘™ğ‘’(ğ‘“ ğ‘–ğ‘™ğ‘’, ğ‘¢)

Le BFS visite les noeuds par ordre de distance par rapport au noeud
initial. Le DFS commence par crÃ©er un long chemin, puis revient sur ses
pas quand il ne peut plus continuer. Un exemple de l'exÃ©cution de ces deux
algorithmes est prÃ©sentÃ© Fig. 2.2

Plusieurs algorithmes de dÃ©tection de communautÃ©s utilisent des marches
alÃ©atoires uniformes, un processus discret sur le graphe. Ã€ chaque instant, un
marcheur est situÃ© sur un noeud du graphe. Il se dÃ©place Ã  l'instant suivant
uniformÃ©ment alÃ©atoirement vers l'un des voisins du noeud sur lequel il est
situÃ©. Le chemin formÃ© est appelÃ© une marche alÃ©atoire. Les probabilitÃ©s de
transition du marcheur alÃ©atoire sur un graphe sont illustrÃ©es Fig. 2.3.

J. Creusefond

11

Chapitre 2. Rappels

Figure 2.2  Ã‰tat d'un graphe lors d'une exÃ©cution du DFS et du BFS.
Les noeuds bleus reprÃ©sentent les noeuds visitÃ©s et les noeuds rouges sont
les derniers noeuds visitÃ©s. L'itÃ©ration correspondant Ã  la visite est indiquÃ©e
dans le noeud. Les Ã©tats successifs du graphe sont reprÃ©sentÃ©s de gauche Ã 
droite.

Figure 2.3  Un graphe et les probabilitÃ©s de transition d'un marcheur
alÃ©atoire sur ce graphe.

12

J. Creusefond

123412234DFSBFS11111122233Visite 1Visite 2Visite 3Visite 4â‡¨1/31/21/21/21/31/211/32.1. Ã‰lÃ©ments de thÃ©orie des graphes

Notation

ğº = (ğ‘‰,ğ¸ âˆˆ {ğ‘¢,ğ‘£ | ğ‘¢ âˆˆ ğ‘‰, ğ‘£ âˆˆ ğ‘‰ })

ğ‘› = |ğ‘‰ |
ğ‘š = |ğ¸|

ğ‘˜ğ‘£ = |{ğ‘’ | ğ‘’ âˆˆ ğ¸, ğ‘£ âˆˆ ğ‘’}|

ğ‘™ğ‘’ğ‘›(ğœ‹) = |ğœ‹| âˆ’ 1

Î (ğ‘¢,ğ‘£)

ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘¢,ğ‘£) = min

ğœ‹âˆˆÎ (ğ‘¢,ğ‘£)

ğ‘™ğ‘’ğ‘›(ğœ‹)

ğ‘’ğ‘¥ğ‘(ğ‘£) = max
ğ‘¢âˆˆğ‘‰
ğ‘‘ğ‘–ğ‘ğ‘š(ğº) = max
ğ‘¢,ğ‘£âˆˆğ‘‰

ğ‘‰ ğ‘œğ‘™(ğ‘) =âˆ‘ï¸€

ğ‘£âˆˆğ‘ ğ‘˜ğ‘£

ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘¢,ğ‘£)

ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘¢,ğ‘£)

ğ‘š(ğ‘) = |{ğ‘¢, ğ‘£ | ğ‘¢, ğ‘£ âˆˆ ğ‘,{ğ‘¢, ğ‘£} âˆˆ ğ¸}|

ğ‘š(ğ‘, ğ‘â€²) = |{ğ‘–, ğ‘— | (ğ‘–, ğ‘—) âˆˆ ğ¸, ğ‘– âˆˆ ğ‘, ğ‘— âˆˆ ğ‘â€²}|

ğ‘(ğ¶, ğ‘£) = {ğ‘ | ğ‘ âˆˆ ğ¶, ğ‘£ âˆˆ ğ‘}

ğ’(ğ‘‰ )

DÃ©nition

Un graphe, un ensemble ğ‘‰ de

noeuds et un ensemble ğ¸ d'arÃªtes

Le nombre de noeuds
Le nombre d'arÃªtes
DegrÃ© d'un noeud ğ‘£

Longueur d'un chemin ğœ‹

L'ensemble des chemins allant de

ğ‘¢ Ã  ğ‘£

Distance entre deux noeuds ğ‘¢ et ğ‘£

ExcentricitÃ© du noeud ğ‘£
DiamÃ¨tre d'un graphe ğº
La somme des degrÃ©s d'un

 cluster 

Le nombre d'arÃªtes internes d'un

 cluster 

Le nombre d'arÃªtes entre les

 clusters  ğ‘ et ğ‘â€²

Le  cluster  dans lequel apparaÃ®t

le noeud ğ‘£ dans la partition ğ¶
Ensemble des partitions d'un

ensemble ğ‘‰

Table 2.1  Notations

J. Creusefond

13

Chapitre 2. Rappels

2.2 RÃ©seaux sociaux

Un  rÃ©seau social  est un rÃ©seau ayant Ã©tÃ© crÃ©Ã© par des interactions so-
ciales [31]. Il existe diÃ©rentes catÃ©gories de rÃ©seaux sociaux. Dans les graphes
reprÃ©sentant ces rÃ©seaux, les individus correspondent aux noeuds et leurs in-
teractions correspondent aux arÃªtes. Je distingue les interactions bilatÃ©rales,
nÃ©cessitant l'accord des deux individus pour Ãªtre Ã©tablie, des interactions
unilatÃ©rales.
Les rÃ©seaux sociaux web permettent d'Ã©tablir explicitement des relations
entre les utilisateurs. Les relations dans certains de ces sites web sont
bilatÃ©rales. C'est par exemple le cas de Facebook. Dans d'autres rÃ©-
seaux comme Twitter ou Youtube, la relation sociale est Ã©tablie de
maniÃ¨re unilatÃ©rale par le  follow  (le fait de suivre les publications
de quelqu'un). Deux individus sont voisins dans le graphe associÃ© si une
relation existe entre les deux.

Les rÃ©seaux de communication sont formÃ©s par des transmissions d'in-
formation entre individus. On retrouve la mÃªme distinction entre uni-
latÃ©ralitÃ© (comme pour les e-mails et les SMS) et bilatÃ©ralitÃ© (appels
tÃ©lÃ©phoniques et vidÃ©oconfÃ©rences). Deux individus sont voisins dans le
graphe associÃ© s'ils ont communiquÃ© en utilisant ce rÃ©seau.

Les rÃ©seaux de collaboration correspondent Ã  des individus ayant tra-
vaillÃ© ensemble sur un sujet. On y trouve par exemple des rÃ©seaux
d'acteurs ayant tournÃ© des lms ensemble ou des scientiques ayant co-
Ã©crit des articles. Les relations dans ce type de rÃ©seau sont bilatÃ©rales.
Deux individus sont voisins dans le graphe associÃ© s'ils ont collaborÃ©.

On a observÃ© des caractÃ©ristiques communes aux graphes reprÃ©sentant les

rÃ©seaux sociaux.

Tout d'abord, ces graphes sont d'une densitÃ© faible. Les modÃ¨les clas-
siques supposent mÃªme un degrÃ© moyen constant [98, 8]. Leskovec et al. [62]
nuancent cette supposition en observent sur des rÃ©seaux Ã©voluant au court
du temps que ğ‘š âˆˆ ğ’ª(ğ‘›ğ‘), avec ğ‘ mesurÃ© entre 1,05 et 1,68.

Ensuite, on observe que les distances dans ces graphes sont courtes [61].
Ainsi, en passant de voisin en voisin, il est possible d'atteindre n'importe quel
autre point du graphe en un nombre faible d'intermÃ©diaires, mÃªme si le graphe
en question a beaucoup de noeuds. Ils s'agit de l'une des caractÃ©ristiques des
graphes petit monde [70].

La distribution du degrÃ© des noeuds est proche d'une loi de puissance [8].
La probabilitÃ© qu'un noeud alÃ©atoire du graphe soit de degrÃ© ğ‘˜ est proche de
ğ‘˜âˆ’ğ›¾, avec ğ›¾ dÃ©pendant du graphe, le plus souvent entre 2 et 4. Cette loi de

14

J. Creusefond

2.3. Fonctions de qualitÃ©

probabilitÃ© a pour consÃ©quence qu'il existe une grande diversitÃ© des degrÃ©s
des noeuds, avec quelques noeuds Ã  degrÃ© trÃ¨s important et un grand nombre
de noeuds Ã  degrÃ© faible.

Une propriÃ©tÃ© sociologique importante dans les rÃ©seaux sociaux est l'ho-
mophilie [68] : les individus connaissent des personnes qui leur sont similaires.
La consÃ©quence structurelle est que l'on observe beaucoup de triangles, c'est-
Ã -dire des triplets d'individus formant des 3-cliques. En eet, si deux indivi-
dus ğ‘ et ğ‘ se connaissent, et que ğ‘ connaÃ®t ğ‘ mais pas de ğ‘, ğ‘ a la volontÃ© et
l'occasion de former un lien avec ğ‘ :

 Si ğ‘ et ğ‘ sont similaires, et que ğ‘ et ğ‘ sont similaires, il est probable

que ğ‘ soit similaire Ã  ğ‘.

 Du fait de la relation de ğ‘ avec ğ‘, ğ‘ a l'opportunitÃ© de former un lien

avec ğ‘.

Cette propriÃ©tÃ© explique aussi l'apparition de sous-graphes denses dans les
rÃ©seaux sociaux.

2.3 Fonctions de qualitÃ©

Dans cette section, je dÃ©cris les fonctions de qualitÃ© que j'utilise pour

Ã©tudier les communautÃ©s.

Yang et Leskovec [103] ont dÃ©ni quatre caractÃ©ristiques qu'ils estiment

axiomatiquement  dÃ©sirables  dans les communautÃ©s recherchÃ©es.

 La densitÃ© interne : les noeuds Ã  l'intÃ©rieur de la communautÃ© sont trÃ¨s

connectÃ©s entre eux.

 La sÃ©parabilitÃ© : la communautÃ© prÃ©sente des caractÃ©ristiques diÃ©-
rentes de son entourage. Par exemple, les noeuds de la communautÃ©
ont plus de voisins Ã  l'intÃ©rieur qu'Ã  l'extÃ©rieur de celle-ci.

 La cohÃ©sion interne : les caractÃ©ristiques de la communautÃ© sont ro-
bustes Ã  la suppression de noeuds ou d'arÃªtes. Par exemple, il est nÃ©-
cessaire de supprimer un grand nombre des arÃªtes d'une communautÃ©
pour qu'elle ne soit plus connexe.

 La fermeture triadique : pour ğ‘¢, ğ‘£, ğ‘¤ des noeuds de la communautÃ©, si

(ğ‘¢, ğ‘£) âˆˆ ğ¸ et (ğ‘£, ğ‘¤) âˆˆ ğ¸, alors gÃ©nÃ©ralement (ğ‘¢, ğ‘¤) âˆˆ ğ¸.

Ces caractÃ©ristiques ne sont pas complÃ¨tement indÃ©pendantes, par exemple
une forte densitÃ© interne est souvent corrÃ©lÃ©e avec une fermeture triadique
importante.
Une fonction de qualitÃ© est une application ğ‘(ğ’(ğ‘‰ )) â†’ R qui quantie
ces caractÃ©ristiques sur une partition an d'obtenir un rÃ©sultat numÃ©rique.

J. Creusefond

15

Chapitre 2. Rappels

J'utilise la convention que les fonctions de qualitÃ© doivent retourner un
haut score pour des  clusters  ayant des caractÃ©ristiques considÃ©rÃ©es comme
prÃ©fÃ©rables par les auteurs de ces fonctions. Je normalise les quelques fonc-
tions de qualitÃ© ayant un comportement inverse. Comme ces fonctions de
qualitÃ© sont systÃ©matiquement comprises entre 0 et 1, pour une fonction de
qualitÃ© non normalisÃ©e ğ‘ğ‘“ j'utilise la fonction ğ‘1âˆ’ğ‘“ = 1 âˆ’ ğ‘ğ‘“.
Les fonctions de qualitÃ© sont prÃ©sentÃ©es Tab. 2.2 page 18.

La Surprise [1] et la Signifiance [92] sont basÃ©es sur le calcul d'une dis-
similaritÃ© de distribution, la divergence de Kullback-Leibler [57]. Dans notre
cas, elle n'est utilisÃ©e que pour des distributions binaires (un Ã©vÃ¨nement et
son complÃ©ment). Il s'agit de la quantitÃ© d'information perdue quand la dis-
tribution de rÃ©fÃ©rence est utilisÃ©e pour approcher l'autre distribution. Je note
ğ‘¦ comme la probabilitÃ© de l'un de ces deux Ã©vÃ¨nements dans la distribution
de rÃ©fÃ©rence et ğ‘¥ la mÃªme probabilitÃ© dans l'autre distribution. La divergence
de Kullback-Leiber est dÃ©crite Eq. 2.1.

ğ·(ğ‘¥||ğ‘¦) = ğ‘¥ log(

) + (1 âˆ’ ğ‘¥) log(

ğ‘¥
ğ‘¦

1 âˆ’ ğ‘¥
1 âˆ’ ğ‘¦

)

(2.1)

La distribution de rÃ©fÃ©rence de la Surprise correspond Ã  l'Ã©vÃ¨nement
qu'une paire de noeuds alÃ©atoires soit Ã  l'intÃ©rieur de la mÃªme communautÃ©.
Elle est comparÃ©e Ã  la distribution de l'Ã©vÃ¨nement oÃ¹ une arÃªte alÃ©atoire
est interne Ã  une communautÃ©. La Signiance est une somme de divergences,
une par communautÃ©, dont la distribution de rÃ©fÃ©rence est toujours la mÃªme :
celle de l'Ã©vÃ¨nement qu'une paire de noeuds alÃ©atoires soient reliÃ©s dans le
graphe. L'autre distribution de chaque divergence correspond Ã  la probabilitÃ©
qu'une paire de noeuds soit connectÃ©e dans la communautÃ© considÃ©rÃ©e. Ces
deux fonctions mesurent la densitÃ© interne. J'utilise la dÃ©nition de [91] qui
approxime asymptotiquement la valeur de la surprise.

Certaines fonctions de qualitÃ© sont dÃ©nies au niveau de la commu-
nautÃ©, c'est-Ã -dire qu'elles calculent une qualitÃ© pour chaque  cluster .
Leur entrÃ©e est donc Ã©tendue pour inclure un  cluster  ğ‘ en plus de la par-
tition ğ¶. Je prends la somme de cette fonction sur tous les  clusters  pour
la calculer sur la partition entiÃ¨re.
Le Cut-ratio [99] correspond Ã  la probabilitÃ© qu'il existe une arÃªte (ğ‘¢, ğ‘£) âˆˆ
ğ¸ pour deux noeuds alÃ©atoires ğ‘¢ et ğ‘£ tels que ğ‘¢ âˆˆ ğ‘ et ğ‘£ âˆˆ ğ‘‰ âˆ–ğ‘. Cette fonction
mesure la sÃ©parabilitÃ©.
La Conductance [51] correspond Ã  la probabilitÃ© qu'une arÃªte alÃ©atoire
(ğ‘¢, ğ‘£) âˆˆ ğ¸ telle que |{ğ‘¢, ğ‘£} âˆ© ğ‘| â‰¥ 1 soit externe. Cette fonction mesure la
sÃ©parabilitÃ©.

16

J. Creusefond

2.3. Fonctions de qualitÃ©

Je fais le choix de pondÃ©rer ici les mesures de conductance et de cut-ratio
avec la taille de la communautÃ© en nombre de noeuds. En eet, ces fonctions
sont pensÃ©es originellement pour Ãªtre appliquÃ©es au niveau de la communautÃ©,
et pas pour Ãªtre agrÃ©gÃ©es au niveau de la partition. Cette pondÃ©ration a pour
but qu'une communautÃ© ait une inuence proportionnelle Ã  sa taille sur le
score agglomÃ©rÃ©.

La ModularitÃ© a Ã©tÃ© proposÃ©e par Girvan et Newman [39]. Comme je
le dÃ©taille Sec. 2.4, plusieurs algorithmes trÃ¨s utilisÃ©s sont basÃ©s sur cette
fonction [9, 20]. Elle mesure la diÃ©rence entre le nombre d'arÃªtes internes
Ã  la communautÃ© (le premier terme) et l'espÃ©rance de cette valeur dans le
modÃ¨le de conguration (le second terme). Le modÃ¨le de conguration (ou
 conguration model ) correspond au mÃªme graphe dont les arÃªtes sont
coupÃ©es en deux et ces demi-arÃªtes sont rattachÃ©es de maniÃ¨re alÃ©atoire.
Ainsi, si un groupe d'individus a une densitÃ© de connexion signicativement
supÃ©rieure Ã  ce que le modÃ¨le prÃ©voit, ces connexions ne sont pas explicables
par des branchements alÃ©atoires.

La modularitÃ© quantie la densitÃ© interne ainsi que la sÃ©parabilitÃ©. La
densitÃ© interne est reprÃ©sentÃ©e par le nombre d'arÃªtes internes. On remarque
aussi qu'une augmentation du nombre d'arÃªtes externes entraÃ®ne une diminu-
tion de la modularitÃ©, du fait de la comparaison avec le modÃ¨le. La modularitÃ©
mesure donc aussi la sÃ©parabilitÃ©.

La ModularitÃ© locale [73] est similaire Ã  la modularitÃ©, mais le modÃ¨le
de conguration est modiÃ©. Les demi-arÃªtes de ce modÃ¨le ne peuvent Ãªtre
rattachÃ©es qu'entre des communautÃ©s voisines, notÃ©es ğ‘£ğ‘œğ‘–ğ‘ ğ‘–ğ‘›ğ‘ (ğ‘). La modu-
laritÃ© locale mesure la densitÃ© interne ainsi que la sÃ©parabilitÃ©.

La DensitÃ© de modularitÃ© [19] consiste en la modularitÃ© dont on lui
soustrait une pÃ©nalitÃ© suivant sa connectivitÃ© externe. Le but est de mettre
l'accent sur la propriÃ©tÃ© de sÃ©parabilitÃ©, tout en conservant la mesure de la
densitÃ© interne.

Certaines fonctions de qualitÃ© sont dÃ©nies au niveau du noeud, c'est-
Ã -dire qu'elles calculent une qualitÃ© pour tous les noeuds du graphe. Leur
entrÃ©e est donc Ã©tendue pour inclure un noeud ğ‘£ en plus du  cluster  ğ‘
dans lequel il est et de la partition ğ¶. An de calculer la fonction sur toute
la partition, la moyenne de la fonction de qualitÃ© est prise.

Le Coefficient local interne de clustering [98] (appelÃ© coecient de
clustering dans ce manuscrit) d'un noeud est la probabilitÃ© que deux de ses
voisins pris alÃ©atoirement dans la mÃªme communautÃ© soient aussi voisins
entre eux. Cette fonction mesure la fermeture triadique.

Cette fonction est utilisÃ©e dans la Permanence [18], oÃ¹ elle est addition-

J. Creusefond

17

Chapitre 2. Rappels

Nom

Coefficient de clus-
tering

ğ‘ğ‘ğ‘™ğ‘¢ğ‘ (ğ¶, ğ‘, ğ‘£) =

Permanence

ğ‘ğ‘ğ‘’ğ‘Ÿğ‘š(ğ¶, ğ‘, ğ‘£) =

1-Flake-ODF

FOMD

1-Cut ratio

1-Conductance

ModularitÃ©

ModularitÃ© locale

DensitÃ© de modula-
ritÃ©

Surprise

Signifiance

ğ‘1âˆ’ğ‘“ ğ‘™ğ‘ğ‘˜(ğ¶, ğ‘, ğ‘£) =

ğ‘ğ¹ ğ‘‚ğ‘€ ğ·(ğ¶, ğ‘, ğ‘£) =

Fonction

2|{ğ‘¢, ğ‘£, ğ‘¤ âˆˆ ğ‘, ((ğ‘£, ğ‘¢), (ğ‘£, ğ‘¤), (ğ‘¢, ğ‘£)) âˆˆ ğ¸3}|

|ğ‘|(|ğ‘| âˆ’ 1)

{ï¸ƒ

ğ‘š(ğ‘£, ğ‘)

maxğ‘â€²âˆˆğ¶âˆ–{ğ‘}(ğ‘š(ğ‘£, ğ‘â€²)) Ã— ğ‘˜ğ‘£

+ ğ‘ğ‘ğ‘™ğ‘¢ğ‘ (ğ¶, ğ‘, ğ‘£) âˆ’ 1

1 quand ğ‘š(ğ‘£, ğ¶) > ğ‘š(ğ‘£, ğ‘‰ âˆ– ğ‘)
0 sinon

ğ‘›

ğ‘›

ğ‘ğ‘šğ‘œğ‘‘(ğ¶, ğ‘) =

1 quand ğ‘š(ğ‘£, ğ‘) > ğ‘‘ğ‘š
0 sinon

ğ‘1âˆ’ğ‘ğ‘¢ğ‘¡(ğ¶, ğ‘) =

ğ‘1âˆ’ğ‘ğ‘œğ‘›ğ‘‘(ğ¶, ğ‘) =

{ï¸ƒ
)ï¸‚
(ï¸‚
Ã— |ğ‘|
1 âˆ’ ğ‘š(ğ‘, ğ‘‰ âˆ– ğ‘)
)ï¸‚
(ï¸‚
|ğ‘|(ğ‘› âˆ’ |ğ‘|)
Ã— |ğ‘|
1 âˆ’ ğ‘š(ğ‘, ğ‘‰ âˆ– ğ‘)
(ï¸‚ ğ‘‰ ğ‘œğ‘™(ğ‘)
)ï¸‚2
(ï¸‚
ğ‘ğ‘‘ğ‘šğ‘œğ‘‘(ğ¶, ğ‘) = ğ‘ğ‘šğ‘œğ‘‘(ğ¶, ğ‘) âˆ’ âˆ‘ï¸
)ï¸€
(ï¸€|ğ‘|
âƒ’âƒ’âƒ’âƒ’âƒ’âƒ’âƒ’âƒ’âˆ‘ï¸€
(ï¸€ğ‘›
)ï¸€
âƒ’âƒ’âƒ’âƒ’âƒ’ ğ‘š(ï¸€ğ‘›
)ï¸€âƒ’âƒ’âƒ’âƒ’âƒ’
(ï¸ƒ
)ï¸€)ï¸ƒ
(ï¸€|ğ‘|

(ï¸‚âˆ‘ï¸€
(ï¸‚|ğ‘|
)ï¸‚
âˆ‘ï¸

ğ‘š(ğ‘ âˆª ğ‘£ğ‘œğ‘–ğ‘ ğ‘–ğ‘›ğ‘ (ğ‘))

ğ‘‰ ğ‘œğ‘™(ğ‘)
âˆ’

ğ‘‰ ğ‘œğ‘™(ğ‘)
ğ‘š(ğ‘, ğ‘â€²)

ğ‘âˆˆğ¶ ğ‘š(ğ‘)

ğ‘âˆˆğ¶

2

ğ‘â€²âˆˆğ¶âˆ–ğ‘

ğ‘š

ğ‘š

ğ·

ğ‘ğ‘ ğ‘–ğ‘”ğ‘›(ğ¶) =

ğ‘š(ğ‘)

ğ‘š

2

ğ‘š(ğ‘)

2

2

ğ‘š(ğ‘)

âˆ’

ğ‘âˆˆğ¶

2

)ï¸ƒ

2ğ‘š

ğ‘ğ‘ ğ‘¢ğ‘Ÿğ‘(ğ¶) = ğ·

ğ‘ğ‘™ğ‘šğ‘œğ‘‘(ğ¶, ğ‘) =

2 Â· ğ‘š(ğ‘ âˆª ğ‘£ğ‘œğ‘–ğ‘ ğ‘–ğ‘›ğ‘ (ğ‘))

)ï¸‚2

Table 2.2  Fonctions de qualitÃ©

nÃ©e Ã  une mesure de la connectivitÃ© du noeud dans sa communautÃ©. Cette
densitÃ© est pondÃ©rÃ©e de telle maniÃ¨re qu'un noeud a une permanence plus
faible s'il est relativement trÃ¨s connectÃ© Ã  une autre communautÃ© en particu-
lier. La Permanence mesure la sÃ©parabilitÃ© ainsi que la fermeture triadique.

La Flake-ODF [34] ( Out-Degree Fraction ) compare directement de-

grÃ© interne et degrÃ© externe. Cette fonction mesure la sÃ©parabilitÃ©.

La FOMD [103] ( Fraction Over Median Degree ) compare le degrÃ©
interne du noeud avec le degrÃ© mÃ©dian ğ‘‘ğ‘š du graphe. Cette fonction mesure
la densitÃ© interne.

18

J. Creusefond

2.4. Algorithmes de dÃ©tection de communautÃ©

2.4 Algorithmes de dÃ©tection de communautÃ©

Dans cette section, je prÃ©sente les algorithmes de dÃ©tection de commu-

nautÃ©s auxquels je fait rÃ©fÃ©rence au long de cette thÃ¨se.

2.4.1 StratÃ©gies de partitionnement

Dans cette partie, je prÃ©sente les diÃ©rentes stratÃ©gies adoptÃ©es par les

algorithmes de dÃ©tection de communautÃ©s.

Les mÃ©thodes de partitionnement de donnÃ©es s'inspirent directement
du problÃ¨me Ã©ponyme, oÃ¹ l'on cherche Ã  grouper des objets gÃ©nÃ©riques. La
stratÃ©gie dans ce domaine est typiquement d'Ã©tablir une fonction de simi-
laritÃ© entre les objets, puis d'exÃ©cuter un algorithme chargÃ© de trouver des
 clusters  oÃ¹ les similaritÃ©s internes sont fortes [50]. On y trouve des tech-
niques de partitionnement hiÃ©rarchique [20] (les communautÃ©s fusionnent ou
se divisent au fur et Ã  mesure de l'exÃ©cution) et de coupure de graphe [35]
(en minimisant le nombre d'arÃªtes entre les parties). On y trouve aussi l'intÃ©-
gration des graphes dans un espace mÃ©trique par une mesure de dissimilaritÃ©
entre les noeuds [83].

Les mÃ©thodes divisives sont des mÃ©thodes de partitionnement hiÃ©rar-
chique qui se basent sur l'identication et la suppression successive des arÃªtes
que l'on suppose Ãªtre entre les  clusters . Ces suppressions dÃ©connectent le
graphe et les composantes connexes sont les communautÃ©s.

Newman et Girvan ont introduit la modularitÃ© [75] qui inspira une sÃ©rie
de mÃ©thodes basÃ©es sur celle-ci. Il a Ã©tÃ© prouvÃ© par Brandes et al. [10] que
trouver la partition optimale en modularitÃ© est un problÃ¨me NP-Complet, ce
qui rend le passage Ã  l'Ã©chelle extrÃªmement coÃ»teux. Des approches d'opti-
misation gloutonne ont Ã©tÃ©s dÃ©veloppÃ©es pour apporter une alternative ac-
ceptable en temps de calcul, comme l'algorithme de Louvain [9]. D'autres
approches existent, comme la mÃ©thode du recuit simulÃ© [42] ou l'analyse
spectrale [74].

En eet, de nombreux algorithmes sont basÃ©s sur des mÃ©thodes spec-
trales. Le spectre d'une matrice spÃ©cique qui dÃ©nit une notion de proxi-
mitÃ© entre les noeuds y est analysÃ©. Les vecteurs propres associÃ©s aux valeurs
propres les plus faibles (sauf le premier, Ã  valeur propre nulle) dÃ©crivent
des  clusters  Ã  forte similaritÃ© interne [72]. En eet, prendre les ğ‘˜ pre-
miers vecteurs propres (en ignorant le premier) permet une projection des
ğ‘› noeuds dans un espace ğ‘˜-dimensionnel. Il sut alors sut d'exÃ©cuter un
partitionnement classique (type k-means) pour trouver des  clusters . La
matrice Laplacienne est traditionnellement utilisÃ©e comme matrice de simi-
laritÃ© entre les noeuds. Cependant, d'autres matrices peuvent Ãªtre utilisÃ©es,

J. Creusefond

19

Chapitre 2. Rappels

comme la matrice de modularitÃ© oÃ¹ la proximitÃ© est le gain en modularitÃ©
apportÃ© par la rÃ©union des noeuds voisins dans le mÃªme  cluster  [74].

Les mÃ©thodes dites dynamiques simulent un processus se dÃ©roulant sur
le graphe. Le modÃ¨le de Potts [101] dÃ©crit un ensemble de particules ayant
chacune un Ã©tat, et une notion de proximitÃ© avec les autres particules. Les
particules s'inuencent entre elles, celles qui sont proches les unes des autres
ont tendance Ã  partager le mÃªme Ã©tat. La stratÃ©gie est alors de trouver les pa-
ramÃ¨tres du modÃ¨le correspondant le mieux aux donnÃ©es. Un autre processus
est celui de la synchronisation, oÃ¹ le systÃ¨me simulÃ© unie progressivement
tous ses Ã©lÃ©ments au mÃªme Ã©tat. Les noeuds d'une communautÃ© Ã©tant proches
les uns des autres, ils ont tendance Ã  Ãªtre localement synchronisÃ©s en premier,
ce qui permet leur identication [4]. D'un autre cÃ´tÃ©, les marches alÃ©atoires
se concentrent dans les sous-graphes denses, ce qui est exploitÃ© par plusieurs
algorithmes [94, 78].

Les mÃ©thodes d'infÃ©rence statistique font l'hypothÃ¨se que le graphe a
Ã©tÃ© gÃ©nÃ©rÃ© suivant un modÃ¨le, et que ce modÃ¨le admet l'appartenance des
noeuds aux diÃ©rentes communautÃ©s en tant que paramÃ¨tre. Il s'agit alors
de trouver les paramÃ¨tres du modÃ¨le qui auraient gÃ©nÃ©rÃ© les donnÃ©es obser-
vÃ©es avec la probabilitÃ© la plus importante. Par exemple, considÃ©rons que les
noeuds Ã  l'intÃ©rieur des communautÃ©s sont connectÃ©s avec une probabilitÃ©
ğ‘ğ‘–ğ‘›, et Ã  l'extÃ©rieur avec une probabilitÃ© ğ‘ğ‘œğ‘¢ğ‘¡ [45]. L'objectif est alors de trou-
ver la partition qui aurait le plus de chances de gÃ©nÃ©rer le graphe observÃ© Ã 
partir de ce modÃ¨le.

Des explications plus dÃ©taillÃ©es sur ces catÃ©gories peuvent Ãªtre trouvÃ©es

dans l'article rÃ©capitulatif de Fortunato [36].

2.4.2 Algorithmes

Dans cette partie, je prÃ©sente les algorithmes utilisÃ©s dans ce manuscrit.
L'algorithme de Louvain [9] optimise la modularitÃ© de maniÃ¨re glou-
tonne. Cet algorithme dÃ©place les noeuds dans le  cluster  de leur voisin de
maniÃ¨re Ã  maximiser le gain en modularitÃ©. Une fois qu'aucun gain en modu-
laritÃ© n'est possible de cette maniÃ¨re, il s'applique rÃ©cursivement au graphe
quotient de la partition. L'algorithme se termine quand le processus rÃ©cursif
cesse d'amÃ©liorer la modularitÃ©.

L'algorithme de Clauset [20], aussi appelÃ© Clauset-Newman-Moore (CNM)

du nom de ses crÃ©ateurs, est une autre approche Ã  l'optimisation gloutonne de
la modularitÃ©. Cet algorithme suit une stratÃ©gie de partitionnement hiÃ©rar-
chique oÃ¹, Ã  chaque Ã©tape, la fusion fournissant la plus forte augmentation de
la modularitÃ© est choisie. L'algorithme s'arrÃªte quand la partition inclut une
unique communautÃ©, et renvoie la partition maximale de modularitÃ© trouvÃ©e.

20

J. Creusefond

2.4. Algorithmes de dÃ©tection de communautÃ©

L'algorithme MCL [94]( Markov CLustering ) est une approche basÃ©e
sur du calcul matriciel. Chaque noeud du graphe est associÃ© Ã  un entier
diÃ©rent entre 1 et ğ‘›. Le graphe est reprÃ©sentÃ© par une matrice ğ´ de taille
ğ‘› Ã— ğ‘› telle que ğ´ğ‘–,ğ‘— = 1/ğ‘˜ğ‘— si (ğ‘–,ğ‘—) âˆˆ ğ¸ et ğ´ğ‘–,ğ‘— = 0 sinon. La matrice ğ´
reprÃ©sente un graphe pondÃ©rÃ© dont les arÃªtes sont pondÃ©rÃ©es par l'inverse du
degrÃ© du noeud source de l'arÃªte.

Cette matrice est Ã©levÃ©e au carrÃ©, ce qui a l'eet de propager les chemins :
il s'agit de l'Ã©tape d'expansion. Ensuite, les Ã©lÃ©ments de la matrice sont Ã©levÃ©s
Ã  une puissance (dÃ©pendante d'un paramÃ¨tre de l'algorithme), et les colonnes
sont normalisÃ©es tels que la somme de leurs Ã©lÃ©ments fasse 1. Cette Ã©tape
augmente la variance du poids des arÃªtes : il s'agit de l'Ã©tape d'ination. En
rÃ©pÃ©tant les Ã©tapes d'expansion et d'ination, les arÃªtes internes des groupes
d'individus fortement connectÃ©es voient leur poids augmenter tandis que le
poids des arÃªtes externes tend vers zÃ©ro. MalgrÃ© son utilisation de la multipli-
cation matricielle, cet algorithme a une complexitÃ© proche du linÃ©aire sur des
graphes peu denses grÃ¢ce Ã  des techniques dites de  pruning , c'est-Ã -dire
de suppression des faibles valeurs Ã©loignÃ©es de la diagonale.

L'algorithme infomap [86] associe Ã  chaque noeud un code en deux par-
ties : un prÃ©xe correspondant Ã  la communautÃ© ainsi qu'un identiant du
noeud dans la communautÃ©. Un chemin peut Ãªtre dÃ©crit par les identiants
des noeuds qu'il parcourt, et le prÃ©xe de communautÃ©s traversÃ©es. L'objec-
tif est de trouver les prÃ©xes communautaires permettant de minimiser le
nombre moyens de bits nÃ©cessaires pour reprÃ©senter une marche alÃ©atoire.
Cette optimisation est faite de maniÃ¨re gloutonne, puis ranÃ©e par le biais
d'un algorithme de recuit simulÃ©.

Un k-core [87] est un ensemble maximal de noeuds liÃ©s aux autres noeuds
de cet ensemble par au moins ğ‘˜ arÃªtes. Les ensembles connexes du  k-core 
sont considÃ©rÃ©s comme les communautÃ©s. Les  k-core  sont obtenus en sup-
primant successivement les noeuds de degrÃ© infÃ©rieur Ã  ğ‘˜.

L'algorithme de label propagation [82] est un processus dynamique
discret simulÃ© sur le graphe. Il attribue initialement une Ã©tiquette contenant
un identiant diÃ©rent pour chaque noeud. L'Ã©tiquette de chaque noeud est
changÃ©e Ã  chaque pas de temps par celle qui apparaÃ®t en majoritÃ© parmi
ses voisins. Quand le processus cesse de modier les Ã©tiquettes, celles-ci sont
retournÃ©es comme Ã©tant les communautÃ©s.

L'algorithme de betweenness [39] est une mÃ©thode divisive. Le critÃ¨re de
suppression d'arÃªte est la  betweenness centrality , une mesure de centralitÃ©
qui compte le nombre de plus courts chemins passant par une arÃªte. La
supposition est que les plus courts chemins traversent frÃ©quemment des arÃªtes
entre les communautÃ©s, du fait de la diÃ©rence de densitÃ© interne/externe.
La suppression de ces arÃªtes isole donc les communautÃ©s les unes des autres.

J. Creusefond

21

Chapitre 2. Rappels

L'algorithme Walktrap [78] utilise les propriÃ©tÃ©s des marches alÃ©atoires
pour Ã©tablir une notion de distance entre les noeuds. Il calcule pour chaque
paire de sommets (ğ‘–,ğ‘—) un poids ğ‘¤ğ‘¡(ğ‘–,ğ‘—) correspondant Ã  la probabilitÃ© qu'une
marche alÃ©atoire aille de ğ‘– Ã  ğ‘— en ğ‘¡ Ã©tapes. Il en dÃ©duit une distance sur les
paires de noeuds, dÃ©crite Eq. 2.2.

âˆšï¸ƒâˆ‘ï¸

ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘¡(ğ‘–,ğ‘—) =

|ğ‘¤ğ‘¡(ğ‘£,ğ‘–) âˆ’ ğ‘¤ğ‘¡(ğ‘£,ğ‘—)|2

ğ‘£âˆˆğ‘‰

ğ‘˜ğ‘£

(2.2)

Cet algorithme suit ensuite une stratÃ©gie de partitionnement hiÃ©rarchique en
fusionnant les communautÃ©s Ã  faible distance.

L'algorithme de Spinglass [85] modÃ©lise le graphe avec le modÃ¨le de
Potts [101], dÃ©crit prÃ©cÃ©demment. Les auteurs en dÃ©duisent une fonction de
score proche de celle de la modularitÃ©, qu'ils optimisent avec la mÃ©thode du
recuit simulÃ©.

L'algorithme Conclude [30] commence par Ã©tablir une notion de distance
similaire Ã  celle Eq. 2.2. Cependant, ğ‘¤ğ‘¡(ğ‘–,ğ‘—) est remplacÃ© par la probabilitÃ©
que l'arc (ğ‘–,ğ‘—) soit traversÃ© par une marche alÃ©atoire de longueur ğ‘¡ depuis une
source alÃ©atoire. Ils appliquent ensuite l'algorithme de Louvain sur le graphe
pondÃ©rÃ© qui en rÃ©sulte.

L'algorithme SCD [79] ( Scalable Community Detection ) optimise de
maniÃ¨re gloutonne un score mesurant la proportion des triangles prÃ©sents Ã 
l'intÃ©rieur des communautÃ©s. An de ne pas avoir Ã  calculer le nombre de
triangles des graphes, cet algorithme approche le score en question. Comme
pour l'algorithme de Louvain, cet algorithme change localement les noeuds
de communautÃ©s et permet en plus aux noeuds de s'isoler dans de nouvelles
communautÃ©s. DÃ¨s que le score du graphe se stabilise, l'algorithme se termine.

2.5 MÃ©thodes de comparaison

Une mÃ©thode de comparaison (ou  extrinsic clustering evaluation me-
tric  [3]) est une fonction Ã©valuant la proximitÃ© entre deux couvertures du
mÃªme ensemble.

La NMI ( Normalized Mutual Information ) est une mÃ©thode de com-
paraison basÃ©e sur la thÃ©orie de l'information. J'utilise la version introduite
par Lancichinetti et al. [58].
Soient deux couvertures ğ¶ et ğ¿ de ğ‘‰ . Soit ğ‘‹ğ‘ une variable alÃ©atoire
associÃ©e au  cluster  ğ‘ âŠ† ğ‘‰ valant 1 si l'Ã©vÃ¨nement qu'un noeud pris
uniformÃ©ment alÃ©atoirement dans ğ‘‰ est inclus dans ğ‘, et 0 sinon. Je note
â„(ğ‘¥) = âˆ’ğ‘¥ Â· log(ğ‘¥). L'entropie jointe ğ»(ğ‘‹ğ‘, ğ‘‹ğ‘™) d'une paire de  clusters 

22

J. Creusefond

ğ‘ âˆˆ ğ¶ et ğ‘™ âˆˆ ğ¿ est calculÃ©e ainsi :

ğ»(ğ‘‹ğ‘ âˆˆ ğ¶, ğ‘‹ğ‘™ âˆˆ ğ¿) =

ğ‘(ğ‘‹ğ‘ = 1, ğ‘‹ğ‘™ = 1) =

ğ‘(ğ‘‹ğ‘ = 1, ğ‘‹ğ‘™ = 0) =

ğ‘(ğ‘‹ğ‘ = 0, ğ‘‹ğ‘™ = 1) =

ğ‘(ğ‘‹ğ‘ = 0, ğ‘‹ğ‘™ = 0) =

2.5. MÃ©thodes de comparaison

â„(ğ‘(ğ‘¥,ğ‘¦))

(2.3)

âˆ‘ï¸

âˆ‘ï¸

ğ‘›

ğ‘¦âˆˆğ‘‹ğ‘™
ğ‘¥âˆˆğ‘‹ğ‘
|ğ‘‹ğ‘ âˆ© ğ‘‹ğ‘™|
|ğ‘‹ğ‘| âˆ’ |ğ‘‹ğ‘ âˆ© ğ‘‹ğ‘™|
|ğ‘‹ğ‘™| âˆ’ |ğ‘‹ğ‘ âˆ© ğ‘‹ğ‘™|
ğ‘› âˆ’ |ğ‘‹ğ‘ âˆª ğ‘‹ğ‘™|

ğ‘›

ğ‘›

ğ‘›

L'entropie conditionnelle ğ»(ğ‘‹ğ‘|ğ‘‹ğ‘™) = ğ»(ğ‘‹ğ‘, ğ‘‹ğ‘™)âˆ’ ğ»(ğ‘‹ğ‘™) mesure la quantitÃ©
d'information nÃ©cessaire pour dÃ©crire le rÃ©sultat de ğ‘‹ğ‘ en sachant ğ‘‹ğ‘™. On
cherche Ã  utiliser l'entropie conditionnelle pour Ã©valuer la proximitÃ© de deux
 clusters . Si ğ‘ et ğ‘™ sont trÃ¨s similaires, cette valeur est faible. Cependant,
c'est aussi le cas si ğ‘™ est le complÃ©ment de ğ‘ dans ğ‘‰ .

En observant les termes de la somme de l'entropie jointe Eq. 2.3, les
auteurs dÃ©nissent la condition suivante pour considÃ©rer deux  clusters 
comme pouvant Ãªtre proches (je note ğ‘(ğ‘,ğ‘) = ğ‘(ğ‘‹ğ‘ = ğ‘, ğ‘‹ğ‘™ = ğ‘)) :

â„(ğ‘(1, 1)) + â„(ğ‘(0, 0)) > â„(ğ‘(1, 0)) + â„(ğ‘(1, 0))

(2.4)

En eet, ils ont remarquÃ© que les termes â„(ğ‘(1,0)) et â„(ğ‘(0,1)) sont dominants
quand ğ‘™ est le complÃ©ment de ğ‘. Les deux autres termes sont dominants quand
ğ‘ et ğ‘™ sont similaires. Je note ğ‘œğ‘ğ‘ (ğ‘, ğ¿) l'ensemble des  clusters  ğ‘™ âˆˆ ğ¿ tels
que ğ‘ et ğ‘™ satisfont la condition 2.4.

Les auteurs dÃ©nissent ensuite l'entropie conditionnelle normalisÃ©e de
l'ensemble ğ¶ğ¶ğ¶ des variables alÃ©atoires associÃ©es aux clusters de ğ¶ par rap-
port Ã  celles de ğ¿, notÃ©es ğ¿ğ¿ğ¿.

âˆ‘ï¸

ğ»(ğ¶ğ¶ğ¶|ğ¿ğ¿ğ¿)ğ‘›ğ‘œğ‘Ÿğ‘š =

1
|ğ¶|

minğ‘™âˆˆğ‘œğ‘ğ‘ (ğ‘,ğ¿) ğ»(ğ‘‹ğ‘|ğ‘‹ğ‘™)

ğ‘âˆˆğ¶

ğ»(ğ‘‹ğ‘)

(2.5)

(2.6)

L'information mutuelle normalisÃ©e est alors dÃ©nie ainsi :
[ğ»(ğ¶ğ¶ğ¶|ğ¿ğ¿ğ¿)ğ‘›ğ‘œğ‘Ÿğ‘š + ğ»(ğ¿ğ¿ğ¿|ğ¶ğ¶ğ¶)ğ‘›ğ‘œğ‘Ÿğ‘š]

ğ‘ ğ‘€ ğ¼(ğ¶, ğ¿) = 1 âˆ’ 1
2

La F-BCubed (fb3) [5] a deux composantes : prÃ©cision et rappel. Je
dÃ©nis un associÃ© d'un noeud ğ‘£ pour une couverture ğ¶ comme un noeud qui
a au moins un  cluster  en commun avec ğ‘£ dans ğ¶. La prÃ©cision ğ‘ğ‘Ÿğ‘’ğ‘(ğ¶, ğ¿)

J. Creusefond

23

Chapitre 2. Rappels

de deux partitions ğ¶ et ğ¿ mesure pour chaque noeud ğ‘£ la proportion de ses
associÃ©s dans ğ¶ qui sont aussi ses associÃ©s dans ğ¿. La moyenne est prise sur
tous les individus. Le rappel correspond Ã  la prÃ©cision dont les partitions
sont Ã©changÃ©es, ğ‘Ÿğ‘ğ‘ğ‘ğ‘’ğ‘™(ğ¶, ğ¿) = ğ‘ğ‘Ÿğ‘’ğ‘(ğ¿, ğ¶). PrÃ©cision et rappel sont agrÃ©gÃ©s
en prenant la moyenne harmonique :

ğ¹ -ğµğ¶ğ‘¢ğ‘ğ‘’ğ‘‘(ğ¶, ğ¿) =

1

2 * ğ‘ğ‘Ÿğ‘’ğ‘(ğ¶,ğ¿)

1

+

1

2 * ğ‘Ÿğ‘ğ‘ğ‘ğ‘’ğ‘™(ğ¶,ğ¿)

(2.7)

AmigÃ³ et al. [3] ont Ã©tendu cette mÃ©trique pour les couvertures, en prenant
en compte le nombre de  clusters  en commun que ğ‘£ et ses associÃ©s ont dans
les deux partitions. Je note ğ¶ğ‘£ = {ğ‘ | ğ‘ âˆˆ ğ¶, ğ‘£ âˆˆ ğ¶} (resp. ğ¿ğ‘£) l'ensemble des
 clusters  dans ğ¶ (resp. ğ¿) dans lesquels apparaÃ®t ğ‘£. Je note ğ‘ğ‘ ğ‘ ğ‘œ(ğ¶, ğ‘£) =
{ğ‘¢ | ğ‘¢ âˆˆ ğ‘‰, ğ¶ğ‘£ âˆ© ğ¶ğ‘¢ Ì¸= âˆ…} l'ensemble des associÃ©s de ğ‘£ dans ğ¶. Les auteurs
dÃ©nissent ainsi la prÃ©cision recouvrante :

âˆ‘ï¸

(ï¸‚ ğ‘šğ‘–ğ‘›(|ğ¶ğ‘£ âˆ© ğ¶ğ‘¢|,|ğ¿ğ‘£ âˆ© ğ¿ğ‘¢|)

|ğ¶ğ‘£ âˆ© ğ¶ğ‘¢|

)ï¸‚â¤â¦

ğ‘ğ‘Ÿğ‘’ğ‘(ğ¶, ğ¿) =

1
ğ‘›

1

|ğ‘ğ‘ ğ‘ ğ‘œ(ğ¶, ğ‘£)|

ğ‘¢âˆˆğ‘ğ‘ ğ‘ ğ‘œ(ğ¶,ğ‘£)

â¡â£

âˆ‘ï¸

ğ‘£âˆˆğ‘‰

(2.8)
Le rappel et la F-BCubed recouvrantes sont dÃ©nis par rapport Ã  cette

prÃ©cision comme pour la version originelle.

L'Omega Index [21] dÃ©nombre les paires de noeuds qui sont dans le mÃªme
nombre de  clusters  dans les deux couvertures. Cette valeur est comparÃ©e
avec son espÃ©rance dans un modÃ¨le oÃ¹ les deux couvertures sont formÃ©es de
noeuds alÃ©atoires. Soit ğ‘¡ğ‘—(ğ¶) l'ensemble des noeuds ayant ğ‘—  clusters  en
commun dans ğ¶. L'Omega Index non ajustÃ© est :

ğœ”ğ‘¢(ğ¶, ğ¿) =

|ğ‘¡ğ‘—(ğ¶) âˆ© ğ‘¡ğ‘—(ğ¿)|

(2.9)

2

)ï¸€ max(|ğ¶|,|ğ¿|)âˆ‘ï¸
1(ï¸€ğ‘›
max(|ğ¶|,|ğ¿|)âˆ‘ï¸
1(ï¸€ğ‘›
)ï¸€2

ğ‘—=0

ğ‘—=0

La mÃªme valeur dans le modÃ¨le nul est :

|ğ‘¡ğ‘—(ğ¶)| Â· |ğ‘¡ğ‘—(ğ¿)|

ğœ”ğ‘’(ğ¶, ğ¿) =

L'OmÃ©ga Index correspond Ã  :

2

ğœ”(ğ¶, ğ¿) =

ğœ”ğ‘¢(ğ¶,ğ¿) âˆ’ ğœ”ğ‘’(ğ¶, ğ¿)

1 âˆ’ ğœ”ğ‘’(ğ¶, ğ¿)

24

J. Creusefond

(2.10)

(2.11)

Chapitre 3

Ã‰tude de la structure
communautaire de rÃ©seaux de
communication par les motifs
temporels

Dans ce chapitre, je propose une adaptation des motifs prenant en
compte le dÃ©lai de rÃ©ception dâ€™un message. Je dÃ©duis dâ€™une com-
paraison avec un modÃ¨le de rÃ©fÃ©rence que les messages dans ces
motifs ont des liens causaux. Jâ€™observe que ces motifs ont des pro-
priÃ©tÃ©s diffÃ©rentes Ã  lâ€™intÃ©rieur et Ã  lâ€™extÃ©rieur des communautÃ©s.
Ces rÃ©sultats prÃ©sentÃ©s dans ce chapitre sont les premiers rÃ©-

sultats dâ€™un travail en cours, commun avec Remy Cazabet.

L'appartenance aux communautÃ©s n'est pas quelque chose de xÃ© dans le
temps. Par exemple, un scientique peut changer de domaine de recherche
au cours de sa carriÃ¨re. Analyser l'Ã©volution d'un rÃ©seau au cours du temps
est essentiel pour pouvoir capturer ces changements.

On dÃ©nit un rÃ©seau temporel comme un rÃ©seau contenant des interactions
inscrites dans le temps. Des exemples classiques de rÃ©seaux temporels sont
les rÃ©seaux d'e-mails [55], les appels tÃ©lÃ©phoniques [11], la proximitÃ© physique
entre des personnes Ã©quipÃ©es de puces RFID [13] et les citations dans les
publications scientiques [17]. Le fait que chaque interaction soit inscrite
dans le temps permet d'observer des dynamiques qui n'apparaissent pas dans
les rÃ©seaux statiques. Par exemple, il a Ã©tÃ© observÃ© dans les rÃ©seaux d'appels
tÃ©lÃ©phoniques que les utilisateurs sont trÃ¨s actifs durant de courtes pÃ©riodes
et sont inactifs le reste du temps [54].

J. Creusefond

25

Chapitre 3. Ã‰tude de la structure communautaire de rÃ©seaux de
communication par les motifs temporels

Pour dÃ©crire ces communications, le graphe temporel peut Ãªtre utilisÃ© [48].

DÃ©finition 3.1 (Graphe temporel). Un graphe temporel ğº = (ğ‘‰, ğ¸) est un
ensemble de noeuds ğ‘‰ et dâ€™arcs ğ¸ = {(ğ‘¢,ğ‘£, ğ‘¡1, ğ‘¡2) | ğ‘¢, ğ‘£ âˆˆ ğ‘‰, ğ‘¡1 âˆˆ R+, ğ‘¡2 âˆˆ
Râ‰¥ğ‘¡1}, oÃ¹ ğ‘¢, ğ‘£ âˆˆ ğ‘‰ sont la source et la destination du lien, ğ‘¡1, ğ‘¡2 sont respec-
tivement la date de dÃ©but et de fin de lâ€™interaction.

Il s'agit donc d'un graphe orientÃ© oÃ¹ plusieurs arcs peuvent exister entre
la mÃªme paire de noeuds. Ã€ chaque arc est associÃ© un intervalle temporel. Je
qualie un arc (ğ‘¢, ğ‘£, ğ‘¡1, ğ‘¡2) âˆˆ ğ¸ de prÃ©sent Ã  un instant ğ‘¡ si ğ‘¡1 â‰¤ ğ‘¡ â‰¤ ğ‘¡2.

Dans ce chapitre, je m'intÃ©resse particuliÃ¨rement aux rÃ©seaux formÃ©s par
des communications Ã©crites instantanÃ©es, du type messagerie en ligne, e-mails
ou SMS. J'utilise donc une sous-catÃ©gorie des graphes temporels adaptÃ©e Ã 
ce type de rÃ©seau, les flux de liens [96]. Il s'agit d'un graphe temporel oÃ¹
ğ‘¡1 = ğ‘¡2.

DÃ©finition 3.2 (Flux de liens). Un flux de liens ğº = (ğ‘‰,ğ¸) est un ensemble
de noeuds ğ‘‰ et dâ€™arcs ğ¸ âŠ‚ ğ‘‰ 2 Ã— R+.

Des algorithmes de dÃ©tection de communautÃ©s ont Ã©tÃ©s conÃ§us pour traiter
les graphes temporels [66, 14]. Ils supposent qu'Ã  chaque instant les arcs
prÃ©sents forment un graphe d'une densitÃ© comparable Ã  celle d'un graphe de
rÃ©seau social. Ils sont par exemple adaptÃ©s Ã  traiter les rÃ©seaux sociaux web
reprÃ©sentÃ©s par un graphe temporel. Les arcs de ces graphes reprÃ©sentent les
relations, de la date de sa crÃ©ation Ã  la date de sa n. Ainsi, les arcs prÃ©sents
Ã  chaque instant de ce graphe reprÃ©sentent des instantanÃ©s du rÃ©seau social
web.

Les rÃ©seaux de communications Ã©crites instantanÃ©es, reprÃ©sentÃ©s en ux
de liens, ont une densitÃ© trÃ¨s faible presque tout le temps. En eet, le nombre
de messages envoyÃ©s par des utilisateurs Ã  chaque instant est extrÃªmement
faible en moyenne. La stratÃ©gie actuelle de dÃ©tection de communautÃ©s sur
ces ux de lien consiste Ã  agrÃ©ger les arcs sur des fenÃªtres temporelles pour
ensuite les traiter comme des graphes temporels denses [47]. Cette approche
nÃ©glige une donnÃ©e des ux de liens : l'ordre des communications Ã  l'intÃ©rieur
des fenÃªtres d'agrÃ©gation. Or, s'il existe une relation entre l'ordre des com-
munications et l'appartenance communautaire des noeuds impliquÃ©s dans
ces communications, cela implique que les algorithmes actuels nÃ©gligent une
donnÃ©e importante.

Dans le but d'observer cette relation, je m'intÃ©resse aux motifs temporels,
dÃ©nis par Zhao et al. [106]. Ces motifs correspondent Ã  la structure formÃ©e

26

J. Creusefond

Figure 3.1  Exemple d'une sÃ©rie de communications respectant le motif
"AB-AC-BC"

par l'enchainement des arcs sur une courte pÃ©riode. Une instance d'un motif
consiste en un ensemble d'arcs dans le graphe temporel. Soit (ğ‘¢, ğ‘£, ğ‘¡1, ğ‘¡2) âˆˆ ğ¸
l'un des arcs d'une instance d'un motif. Les arcs ayant Ã©tÃ©s Ã©mis dans un
intervalle de temps ğ‘Š par ğ‘¢ ou par ğ‘£ peuvent aussi Ãªtre inclus dans cette
instance.

DÃ©finition 3.3 (Instance de motif). Une instance dâ€™un motif sur une fenÃªtre
de taille ğ‘Š âˆˆ R+ est un graphe temporel ğº = (ğ‘‰, ğ¸) tel que âˆ€(ğ‘¢ğ‘–, ğ‘£ğ‘–, ğ‘¡1ğ‘–, ğ‘¡2ğ‘–) âˆˆ
ğ¸, âˆƒ(ğ‘¢ğ‘—, ğ‘£ğ‘—, ğ‘¡1ğ‘—, ğ‘¡2ğ‘—) âˆˆ ğ¸ tel que (ğ‘¢ğ‘–, ğ‘£ğ‘–, ğ‘¡1ğ‘–, ğ‘¡2ğ‘–) Ì¸= (ğ‘¢ğ‘—, ğ‘£ğ‘—, ğ‘¡1ğ‘—, ğ‘¡2ğ‘—), {ğ‘¢ğ‘–, ğ‘£ğ‘–} âˆ©
{ğ‘¢ğ‘—, ğ‘£ğ‘—} Ì¸= âˆ… et 0 < ğ‘¡1ğ‘– âˆ’ ğ‘¡2ğ‘— < ğ‘Š ou 0 < ğ‘¡1ğ‘— âˆ’ ğ‘¡2ğ‘– < ğ‘Š .

Un motif est une classe d'Ã©quivalence de ces instances dans le graphe
temporel Ã©tudiÃ©. Deux instances de motifs ğº1 = (ğ‘‰1, ğ¸1) et ğº2 = (ğ‘‰2, ğ¸2)
sont considÃ©rÃ©s comme Ã©quivalentes s'il existe une application bijective ğ‘“ :
ğ‘‰1 â†’ ğ‘‰2 telle que :

âˆ€ğ‘¢, ğ‘£ âˆˆ ğ‘‰1,âƒ’âƒ’{(ğ‘¢, ğ‘£, ğ‘¡ğ‘, ğ‘¡ğ‘) âˆˆ ğ¸1}âƒ’âƒ’ =âƒ’âƒ’{(ğ‘“ (ğ‘¢), ğ‘“ (ğ‘£), ğ‘¡ğ‘, ğ‘¡ğ‘) âˆˆ ğ¸2}âƒ’âƒ’

Cette fonction d'Ã©quivalence a Ã©tÃ© Ã©tendue par Kovanen et al. [56] pour
prendre en compte l'ordre des arcs Ã  l'intÃ©rieur du motif.

Je fais rÃ©fÃ©rence aux diÃ©rents motifs par les noeuds qui composent la
sÃ©quence temporelle des arcs. Les noeuds sont identiÃ©s par les lettres de
l'alphabet dans l'ordre de leur apparition dans le motif. Par exemple, l'en-
semble de trois arcs {(ğ‘¢,ğ‘£,1,1), (ğ‘¢,ğ‘¤,2,2), (ğ‘£,ğ‘¤,3,3)} est une instance du motif
"AB-AC-BC" avec la fenÃªtre adaptÃ©e, comme illustrÃ© Fig. 3.1.

J. Creusefond

27

uvw(u,v,1,1)(u,w,2,2)(v,w,3,3)Chapitre 3. Ã‰tude de la structure communautaire de rÃ©seaux de
communication par les motifs temporels

L'apparition d'instances de motifs correspond Ã  un type de communi-
cation qui se dÃ©roule entre les utilisateurs reprÃ©sentÃ©s par les noeuds. Par
exemple, une conversation entre deux individus induit un motif de va-et-
vient [106] (type "AB-BA-AB").

Les Ã©tudes au sujet des motifs temporels [106, 89, 104] mettent en avant
la sur-reprÃ©sentation de certains motifs par rapport aux autres, comme la
chaine (type "AB-BC-CD"), le va-et-vient ou l'Ã©toile (type "AB-AC-AD").
NÃ©anmoins, ces observations peuvent trÃ¨s bien provenir de propriÃ©tÃ©s qui
n'ont aucun rapport avec la causalitÃ© des communications, c'est par exemple
le cas de la chaine. On peut donc se poser la question de l'inuence de la
causalitÃ© sur les motifs.

Dans ce but, j'utilise un modÃ¨le oÃ¹ la causalitÃ© n'existe pas entre les mes-
sages Ã©mis. Ce modÃ¨le, que j'appelle modÃ¨le nul, sert de base de comparaison
pour quantier l'inuence de la causalitÃ©. Le modÃ¨le nul est un modÃ¨le de
gÃ©nÃ©ration de graphe. Il prend en entrÃ©e un graphe et fait disparaÃ®tre une
partie de ses propriÃ©tÃ©s [56] ( null model ). Dans le cadre de mes travaux,
j'utilise le  correlation-mixing model  [89] pour gÃ©nÃ©rer des graphes oÃ¹ les
liens causaux entre les messages sont supprimÃ©s. Ce modÃ¨le rend alÃ©atoire
l'ordre des messages Ã©mis par les noeuds.

Notons que le modÃ¨le nul est un modÃ¨le de gÃ©nÃ©ration alÃ©atoire de graphe.
Il est thÃ©oriquement possible de gÃ©nÃ©rer le graphe de base Ã  partir du modÃ¨le.
NÃ©anmoins, la probabilitÃ© d'obtenir le graphe de base est trÃ¨s faible.

Dans le  correlation-mixing model , les propriÃ©tÃ©s structurelles telles que
le nombre d'arcs entre deux noeuds ou leur degrÃ© sont conservÃ©es. Certaines
propriÃ©tÃ©s temporelles persistent aussi, comme la frÃ©quence d'Ã©mission ou la
distribution temporelle des messages. D'un autre cÃ´tÃ©, l'enchaÃ®nement des
messages est dÃ» au hasard et non plus Ã  un lien causal.

Pour chaque mesure sur les motifs, je compare la valeur sur le graphe d'ori-
gine et sur les graphes gÃ©nÃ©rÃ©s par le modÃ¨le nul. Je considÃ¨re les diÃ©rences
statistiquement signicatives entre le modÃ¨le nul et la rÃ©alitÃ© observÃ©e comme
une consÃ©quence de la causalitÃ©, comme dÃ©crit par Tabourier et al. [89]. Dans
ce but, j'Ã©tudie la distribution de probabilitÃ© sur le modÃ¨le nul des diÃ©rentes
mesures en gÃ©nÃ©rant plusieurs instances du modÃ¨le.

J'observe en pratique que ces mesures sont distribuÃ©es suivant une loi
normale. Dans ce cas, on peut utiliser la  rÃ¨gle des 66-95-99,7  [80], qui
indique qu'environ 66% des valeurs se situent Ã  un Ã©cart-type de la moyenne,
95% Ã  deux Ã©carts-types et 99,7% Ã  trois Ã©carts-types. Une valeur qui se
situerait au-delÃ  de trois Ã©cart-types de la moyenne aurait donc moins de
0,3% de chances d'Ãªtre gÃ©nÃ©rÃ©e par cette distribution. Ainsi, pour chaque
mesure ğ‘  sur les donnÃ©es, on mesure la moyenne ğœ‡ğ‘  et l'Ã©cart-type ğœğ‘  sur le
modÃ¨le nul, puis on mesure la crÃ©dibilitÃ© de ce modÃ¨le sur les donnÃ©es par le

28

J. Creusefond

3.1. Adaptation des motifs aux pÃ©riodes dâ€™activitÃ©

biais du z-score :

ğ‘§-ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’(ğ‘ ) =

ğ‘  âˆ’ ğœ‡ğ‘ 
ğœğ‘ 

(3.1)

Si le z-score dÃ©passe trois en valeur absolue, je suppose que le modÃ¨le nul

n'explique pas la valeur de la mesure.

3.1 Adaptation des motifs aux pÃ©riodes dâ€™acti-

vitÃ©

Je traite des rÃ©seaux dans lesquels les communications sont instantanÃ©es,
j'adopte donc le formalisme de ux de liens. Comme Kovanen et al. [56], je
prends en compte l'ordre des Ã©vÃ¨nements dans les motifs.

Je m'intÃ©resse aux rÃ©seaux de communications au sein desquels les indi-
vidus ne sont pas forcÃ©ment conscients de la rÃ©ception d'un message. Il s'agit
typiquement de rÃ©seaux d'e-mails ou des rÃ©ponses Ã  des messages sur des
forums en ligne. Dans ce cas, le lien causal entre deux communications n'est
pas clairement liÃ© au dÃ©lai de rÃ©ponse. En eet, un individu peut mettre un
temps important Ã  rÃ©agir Ã  un message du fait qu'il n'en ait pas conscience.
Ma dÃ©nition des motifs, les a-motifs, prend en compte cette spÃ©cicitÃ©. Elle
correspond Ã  une approche qui dÃ©tecte plus de structures que celle dÃ©nie
par Zhao et al. [106].

Je sÃ©pare l'activitÃ© d'un individu en pÃ©riodes dâ€™activitÃ©. Ces pÃ©riodes sont
des intervalles de temps oÃ¹ un individu Ã©met des messages en un dÃ©lai court.

DÃ©finition 3.4 (ğœ‡-pÃ©riode d'activitÃ©). Pour chaque noeud ğ‘£ âˆˆ ğ‘‰ dâ€™un flux de
liens ğº = (ğ‘‰, ğ¸), je note ğ¸ğ‘£ lâ€™ensemble des messages Ã©mis par ğ‘£ et ğ‘šğ‘’ğ‘‘(ğ‘£ âˆˆ
ğ‘‰ ) la mÃ©diane du temps Ã©coulÃ© entre deux messages Ã©mis par un individu
ğ‘£ sur lâ€™ensemble du graphe. Je note aussi ğ‘¡((ğ‘¢, ğ‘£, ğ‘¥) âˆˆ ğ¸) = ğ‘¥ la fonction
associant la date dâ€™un arc Ã  lâ€™arc lui-mÃªme. Une ğœ‡-pÃ©riode dâ€™activitÃ© dâ€™un
individu ğ‘£ âˆˆ ğ‘‰ est un intervalle de temps [ğ‘; ğ‘] durant lequel ğ‘£ a Ã©mis un
ensemble de messages ğ‘€ (ğ‘,ğ‘) = {ğ‘’ âˆˆ ğ¸ğ‘£ | ğ‘ â‰¤ ğ‘¡(ğ‘’) â‰¤ ğ‘}, qui a les propriÃ©tÃ©s :

â€” âˆƒğ‘’1 âˆˆ ğ‘€ (ğ‘,ğ‘), ğ‘¡(ğ‘’1) = ğ‘ et âˆƒğ‘’2 âˆˆ ğ‘€ (ğ‘,ğ‘), ğ‘¡(ğ‘’2) = ğ‘ et
â€” âˆ€ğ‘’1 âˆˆ ğ‘€ (ğ‘,ğ‘), ğ‘¡(ğ‘’1) Ì¸= ğ‘ â‡’ âˆƒğ‘’2 âˆˆ ğ‘€ (ğ‘, ğ‘), 0 < ğ‘¡(ğ‘’2)âˆ’ğ‘¡(ğ‘’1) â‰¤ ğœ‡Â·ğ‘šğ‘’ğ‘‘(ğ‘£)

â€” âˆ€ğ‘’ âˆˆ ğ¸ğ‘£, ğ‘¡(ğ‘’) < ğ‘ â‡’ ğ‘¡(ğ‘’) < ğ‘ âˆ’ ğœ‡ Â· ğ‘šğ‘’ğ‘‘(ğ‘£) et ğ‘¡(ğ‘’) > ğ‘ â‡’ ğ‘¡(ğ‘’) >

et

ğ‘ + ğœ‡ Â· ğ‘šğ‘’ğ‘‘(ğ‘£).

J. Creusefond

29

Chapitre 3. Ã‰tude de la structure communautaire de rÃ©seaux de
communication par les motifs temporels

C'est-Ã -dire que les messages Ã©mis pendant une pÃ©riode d'activitÃ© de ğ‘£
ne sont pas Ã©loignÃ©s de plus de ğœ‡ Â· ğ‘šğ‘’ğ‘‘(ğ‘£) deux Ã  deux et ces pÃ©riodes sont
maximales. Pour chaque individu ğ‘£ l'ensemble ğ¸ğ‘£ de ses messages Ã©mis est
une suite de ğœ‡-pÃ©riodes d'activitÃ©. Je note ğ‘ğ‘ğ‘¡(ğ‘£, ğ‘¡) la date de n de la derniÃ¨re
pÃ©riode d'activitÃ© avant un temps ğ‘¡ d'un noeud.
Je dÃ©nis maintenant les a-motifs de la mÃªme maniÃ¨re que les motifs,
mais en prenant en compte les pÃ©riodes d'activitÃ©. Soit (ğ‘¢, ğ‘£, ğ‘¡1, ğ‘¡2) âˆˆ ğ¸ l'un
des arcs d'une instance d'un a-motif. Les arcs Ã©mis par ğ‘¢ ou par ğ‘£ avant la
n de leur prochaine pÃ©riode d'activitÃ© peuvent aussi Ãªtre inclus dans cette
instance.

DÃ©finition 3.5 (Instance de a-motif). Une instance de a-motif est un flux
de liens ğº = (ğ‘‰, ğ¸) tel que tout arc ğ‘’ = (ğ‘¢, ğ‘£, ğ‘¡) est soit :

â€” temporellement le premier du flux, âˆ€ğ‘’â€² âˆˆ ğ¸, ğ‘¡(ğ‘’â€²) > ğ‘¡(ğ‘’) ou
â€” âˆƒğ‘¤ âˆˆ ğ‘‰ , ğ‘¡â€² âˆˆ R+, (ğ‘¢, ğ‘¤, ğ‘¡â€²) âˆˆ ğ¸ tel que ğ‘ğ‘ğ‘¡(ğ‘¢, ğ‘¡) < ğ‘¡â€² < ğ‘¡ ou
â€” âˆƒğ‘¤ âˆˆ ğ‘‰ , ğ‘¡â€² âˆˆ R+, (ğ‘£, ğ‘¤, ğ‘¡â€²) âˆˆ ğ¸ tel que ğ‘ğ‘ğ‘¡(ğ‘£, ğ‘¡) < ğ‘¡â€² < ğ‘¡.
La fonction d'Ã©quivalence dÃ©nissant les a-motifs est la mÃªme que celle

des motifs. La dÃ©tection des instances des a-motifs est illustrÃ©e Fig. 3.2.

Figure 3.2  Pour un noeud, les arcs Ã©mis forment des pÃ©riodes d'activitÃ©.
L'ensemble des arcs incidents forme des instances de a-motifs

Pour des raisons combinatoires, je me restreins aux a-motifs de taille 3,
c'est-Ã -dire ceux qui contiennent 3 arcs. Je choisis cette taille car il s'agit

30

J. Creusefond

: PÃ©riode d'activitÃ©t: Arc incident au noeudArcs reÃ§usArcs Ã©mis Î”t > Î¼.med : PrÃ©sence dans la mÃªme instance de a-motif3.1. Adaptation des motifs aux pÃ©riodes dâ€™activitÃ©

Figure 3.3  Les motifs de taille 2. Quand l'ordre importe, l'arc rouge a une
date antÃ©rieure Ã  l'arc bleu.

d'un bon compromis entre le temps de calcul nÃ©cessaire Ã  la dÃ©tection des
instances des a-motifs et la complexitÃ© des structures Ã  observer.

Remarquons que les a-motifs de taille xe sont en nombre ni. Par ex-
emple, il existe 4 a-motifs de taille 2 (illustrÃ©s Fig. 3.3), et 26 a-motifs de
taille 3.

Certaines pÃ©riodes d'activitÃ© incluent des dizaines de communications
tandis que d'autres n'en incluent qu'une. Si une pÃ©riode d'activitÃ© contient ğ‘˜
arcs et que le noeud associÃ© a reÃ§u ğ‘™ arcs avant cette pÃ©riode, alors ğ‘˜ Â· ğ‘™ ins-
tances de a-motifs de taille 2 seront gÃ©nÃ©rÃ©s. Cela signie qu'un message reÃ§u
avant une pÃ©riode d'activitÃ© incluant beaucoup de messages a plus d'impact
qu'un message reÃ§u avant une pÃ©riode d'activitÃ© de petite taille.

Le choix que je fais dans ces travaux est de ne pas favoriser un message
plus qu'un autre en raison de la taille des pÃ©riodes d'activitÃ©. Pour cela,
j'associe une pondÃ©ration aux instances de telle sorte que la somme des poids
de l'ensemble des instances gÃ©nÃ©rÃ©es par un seul arc source donne 1. Ce poids
est calculÃ© de la maniÃ¨re suivante : Ã  partir d'une instance de poids ğ‘, si
cette instance peut Ãªtre Ã©tendue pour gÃ©nÃ©rer ğ‘˜ instances de taille supÃ©rieure,
chacune de ces instances a un poids ğ‘/ğ‘˜. Ainsi, si un arc gÃ©nÃ¨re originellement
ğ‘˜1 instances de taille 2, chacune a un poids 1/ğ‘˜1. Le premier de ces motifs
gÃ©nÃ¨re alors ğ‘˜2 instances de taille 3, chacune d'entre elles a un poids 1/(ğ‘˜1Â·ğ‘˜2).
Le second des motifs de taille 2 gÃ©nÃ¨re ğ‘˜â€²
2 instances, chacune a un poids
1/(ğ‘˜1 Â· ğ‘˜â€²
2), et ainsi de suite. Chaque mesure utilisÃ©e dans les expÃ©riences de
ce chapitre est pondÃ©rÃ©e par cette valeur.

Certains motifs de taille 3 sont gÃ©omÃ©triquement assez similaires entre
eux, comme "AB-AC-BC" et "AB-AC-CB", ou "AB-BC-CB" et "AB-BA-
BC". An de diminuer le nombre d'observations, je me concentre sur quatre
motifs qui ont Ã©tÃ© identiÃ©s comme importants dans la littÃ©rature asso-
ciÃ©e [106, 89, 104]. Il s'agit de l'Ã©toile "AB-AC-AD", du va-et-vient "AB-
BA-AB", du triangle "AB-BC-CA" et de la chaine "AB-BC-CD". J'ajoute
le a-motif de spam "AB-AB-AB".

J. Creusefond

31

Chapitre 3. Ã‰tude de la structure communautaire de rÃ©seaux de
communication par les motifs temporels
3.2 Experiences

Aucun jeu de donnÃ©es ne fournit de vÃ©ritÃ© de terrain d'un graphe temporel.
Il s'agit pourtant d'une donnÃ©e indispensable pour Ã©tudier le lien entre la
structure communautaire et la faÃ§on dont les individus communiquent. Pour
pallier ce manque, j'ai obtenu les donnÃ©es correspondant aux e-mails ayant
transitÃ© sur les serveurs de l'UniversitÃ© de Caen. J'en ai extrait le rÃ©seau de
communication correspondant aux Ã©changes pendant 3 mois, accompagnÃ© de
partitions provenant de l'annuaire.

Il existe trois donnÃ©es permettant d'Ã©tablir une partition du rÃ©seau. Des
utilisateurs sont associÃ©s Ã  une entitÃ© de rattachement, typiquement une
UnitÃ© de Formation et de Recherche ou un Institut Universitaire Technolo-
gique. Le laboratoire de rattachement de chaque chercheur est aussi identiÃ©.
Enn, la section CNU (Conseil National des UniversitÃ©s) est renseignÃ©e, ce
qui associe l'utilisateur Ã  un domaine d'Ã©tude. En rÃ¨gle gÃ©nÃ©rale, un Ã©tudiant
dÃ©pend d'une entitÃ© et d'une section CNU, un chercheur est en plus aectÃ©
Ã  un laboratoire et un personnel de support peut n'Ãªtre attachÃ© qu'Ã  une
entitÃ©.

Le rÃ©seau rÃ©sultant a les caractÃ©ristiques suivantes :
 7 688 665 messages Ã©changÃ©s entre 210 085 adresses,
 1 275 662 messages Ã©changÃ©s entre 26 177 adresses ayant une entitÃ© de

rattachement renseignÃ©e,

 168 507 messages Ã©changÃ©s entre 918 adresses appartenant Ã  un labo-

ratoire,

 378 721 messages Ã©changÃ©s entre 17 275 adresses ayant une section CNU

renseignÃ©es.

Sont reprÃ©sentÃ©es 57 entitÃ©s de rattachement (459 adresses par entitÃ© en
moyenne), 45 laboratoires (20 adresses en moyenne) et 146 sections CNU (118
adresses par section en moyenne). Plus de dÃ©tails sur le contenu du rÃ©seau et
les dÃ©marches qui ont Ã©tÃ©s nÃ©cessaires pour l'obtenir sont disponibles App. A.
Puisqu'il y a trois partitions distinctes, je crÃ©e trois ux de liens Ã  partir de
ce rÃ©seau. Chacun de ces ux de liens correspond aux communications entre
les individus ayant l'une de ces informations indiquÃ©e.

En plus du rÃ©seau de mails de l'universitÃ© de Caen, j'utilise un ensemble des
rÃ©seaux de communication provenant du site web Konect 1. Le seul traitement
eectuÃ© sur ceux-ci est la suppression des boucles et des noeuds de degrÃ© nuls.

1. http://konect.uni-koblenz.de

32

J. Creusefond

Nom

Enron [55]

Facebook [97]
UC Irvine [76]
Radoslaw [69]
Debian [38]
Digg [29]

Linux Kernel Mailing

List (LKML)2
Slashdot [44]

3.2. Experiences

arcs

e-mails

ğ‘›

ğ‘š

noeuds
86978 1134990 employÃ©s
45813 855542 utilisateurs Ã©critures sur les  murs 
Ã©tudiants
1899 59835
167
employÃ©s
82876
34648 316569 utilisateurs
30360 86203 utilisateurs
26885 1028233 utilisateurs

messages
e-mails
rÃ©ponses
rÃ©ponses
rÃ©ponses

51083 139789 utilisateurs

rÃ©ponses

Table 3.1  Les rÃ©seaux de Konect

Aucun des rÃ©seaux de Konect n'est associÃ© Ã  une vÃ©ritÃ© de terrain. Je
gÃ©nÃ¨re une partition de ces ux de liens Ã  partir de l'algorithme de Louvain [9].
Cet algorithme s'applique sur des graphes non temporels. Je gÃ©nÃ¨re donc des
graphes non temporels en utilisant les mÃªmes noeuds que le graphe temporel
et un lien entre deux noeuds si le graphe temporel contient une interaction
entre ceux-ci.

Ces communautÃ©s sont donc gÃ©nÃ©rÃ©es en ignorant l'aspect temporel des
rÃ©seaux. Mon objectif est de dÃ©terminer si les communautÃ©s ainsi gÃ©nÃ©rÃ©es et
les communautÃ©s observÃ©es ont des propriÃ©tÃ©s similaires en ce qui concerne
les motifs.

Je classe ces rÃ©seaux en trois catÃ©gories :

Les plateformes de communication directe oÃ¹ les utilisateurs s'envoient des
messages. L'entreprise Enron a dÃ», au terme d'un procÃ¨s, publier les
e-mails qui ont transitÃ© par ses serveurs. Le rÃ©seau Facebook reprÃ©sente
la publication sur les  murs  dans le rÃ©seau social web, c'est-Ã -dire
des messages publics entre utilisateurs. UC Irvine contient les messages
transmis entre les membres d'une communautÃ© Ã©tudiante de l' Univer-
sity of California . Radoslaw correspond Ã  la communication interne
entre employÃ©s d'une entreprise de manufacture.

Les listes de diusion techniques oÃ¹ les utilisateurs posent et rÃ©pondent Ã 
des questions. Deux listes de diusions sont prÃ©sentÃ©es, celle de Debian
et celle du noyau Linux (LKML)

Les sites d'informations oÃ¹ les utilisateurs commentent un sujet. Les utilisa-
teurs du site Digg peuvent proposer, voter et commenter des actualitÃ©s.

2. http://konect.uni-koblenz.de/networks/lkml-reply

J. Creusefond

33

Chapitre 3. Ã‰tude de la structure communautaire de rÃ©seaux de
communication par les motifs temporels

Le site Slashdot fonctionne de maniÃ¨re similaire et a une orientation
technophile.

Les rÃ©seaux provenant de l'universitÃ© de Caen appartiennent Ã  la premiÃ¨re
catÃ©gorie.

3.2.1 Analyse des propriÃ©tÃ©s des a-motifs

Tout d'abord, j'analyse les statistiques de base des a-motifs an de dÃ©-
terminer les diÃ©rences avec les motifs. Dans ces expÃ©riences, j'ai supposÃ©
qu'une pÃ©riode d'activitÃ© englobait typiquement plusieurs communications.
Pour ğœ‡ = 1 (voir dÃ©nition 3.4), la moitiÃ© des arcs termine une pÃ©riode d'ac-
tivitÃ©, ce qui implique que beaucoup de pÃ©riodes ne contiennent qu'un arc
dans les jeux de donnÃ©es. An d'obtenir des pÃ©riodes d'activitÃ© correspondant
mieux Ã  mes suppositions, j'ai choisi ğœ‡ = 2.

Zhao et al. [106] ont observÃ© que les motifs de chaine et d'Ã©toile sont
les plus frÃ©quents. C'est aussi ce que l'on observe Fig. 3.4. Les a-motifs de
chaÃ®ne sont les plus frÃ©quents (16% en moyenne), suivis par l'Ã©toile (6%) et
le va-et-vient (3%).

Je mesure ensuite le z-score de ces frÃ©quence, prÃ©sentÃ© Fig. 3.5. Je vais
comparer les observations de Tabourier et al. [89] sur un rÃ©seau d'appels
tÃ©lÃ©phoniques avec mes observations sur les rÃ©seaux mentionnÃ©s plus haut.
Comme relevÃ© dans [89], les a-motifs d'Ã©toile sont moins communs dans les
rÃ©seaux rÃ©els que dans le modÃ¨le nul, ce qui se traduit dans mes mesures par
un z-score nÃ©gatif. Les a-motifs de chaine ont un z-score nÃ©gatif, ce qui est
l'inverse de ce que Tabourier et al. avaient relevÃ©. Une explication possible
de cette diÃ©rence est que la dÃ©nition des a-motifs entraine l'apparition de
beaucoup de chaines dans le modÃ¨le nul. En eet, si la fenÃªtre temporelle est
remplacÃ©e par des pÃ©riodes d'activitÃ©, une chaine peut Ãªtre beaucoup plus
facilement initiÃ©e par des Ã©missions alÃ©atoires.

Les z-scores mesurÃ©s ici sont hauts. Ceci implique une diÃ©rence impor-
tante avec le modÃ¨le nul, la causalitÃ© semble donc avoir une inuence impor-
tante sur les a-motifs relevÃ©s.

Sur l'ensemble des rÃ©seaux considÃ©rÃ©s, le spam et le va-et-vient ont des
z-scores toujours positifs tandis que l'Ã©toile a un z-score toujours nÃ©gatif.
Je rejoins l'observation de Zhao et al. : le va-et-vient a le z-score le plus
important. J'apporte une nouvelle information : le a-motif de spam, qui n'a
pas Ã©tÃ© considÃ©rÃ© dans la littÃ©rature, prÃ©sente une frÃ©quence non expliquÃ©e
par le modÃ¨le nul. Je mesure que les a-motifs d'Ã©toile sont statistiquement
plus prÃ©sents dans le modÃ¨le nul que dans les donnÃ©es. J'en dÃ©duis que les
a-motifs d'Ã©toile des donnÃ©es sont majoritairement dues au hasard.

34

J. Creusefond

3.2. Experiences

Figure 3.4  La frÃ©quence des a-motifs des diÃ©rents rÃ©seaux

Figure 3.5  Le z-score de la frÃ©quence des a-motifs des diÃ©rents rÃ©seaux.
Un score dÃ©passant 3 en valeur absolue est considÃ©rÃ© comme trÃ¨s signicatif.
Les valeurs supÃ©rieures Ã  20 ou infÃ©rieures Ã  -20 sont tronquÃ©es.

J. Creusefond

35

Chapitre 3. Ã‰tude de la structure communautaire de rÃ©seaux de
communication par les motifs temporels

Figure 3.6  Le z-score de la durÃ©e entre l'Ã©mission du premier message et
du second

Le a-motif de triangle ne fait pas consensus au niveau du z-score des jeux
de donnÃ©es. Ce a-motif a aussi le z-score moyen le plus faible parmi les a-
motifs observÃ©s. MÃªme si les z-scores du triangle sont en moyenne positifs,
l'inuence de la causalitÃ© sur la frÃ©quence de ces motifs n'est pas claire de
maniÃ¨re gÃ©nÃ©rale.

Une autre indication que les a-motifs sont similaire aux motifs est prÃ©sen-
tÃ©e Fig. 3.6. En eet, pour la plupart des a-motifs, la durÃ©e entre l'Ã©mission
des messages est infÃ©rieure Ã  celle du modÃ¨le nul. Ceci indique un enchaine-
ment plus rapide des communications que ce que prÃ©vu par le modÃ¨le. Comme
il s'agit du critÃ¨re utilisÃ© pour dÃ©nir les motifs, les a-motifs semblent simi-
laires aux motifs.

Le a-motif d'Ã©toile est le seul dont la durÃ©e entre les Ã©missions a un z-score
positif. L'intervalle de temps entre les deux premiers messages des instances
du a-motif Ã©toile est donc plus long dans les donnÃ©es que dans le modÃ¨le nul.
Les jeux de donnÃ©es provenant de l'universitÃ© de Caen ont un z-score
positif sur la durÃ©e du a-motif chaine, contrairement Ã  tous les autres jeux
de donnÃ©es. Il est notable que ces jeux de donnÃ©es couvrent des vacances
scolaires d'une Ã  deux semaines suivant les Ã©tablissements. Il est possible
qu'un grand nombre d'e-mails ait Ã©tÃ© envoyÃ© durant ces vacances, et que ces

36

J. Creusefond

3.2. Experiences

e-mails aient formÃ© des chaines. Le dÃ©lai important de rÃ©ponse serait alors
dÃ» aux vacances.

Je conclue que certains a-motifs sont inuencÃ©s par la causalitÃ©. En eet,
les mesures eectuÃ©es montrent une diÃ©rence importante des propriÃ©tÃ©s des
instances de ces a-motifs entre le modÃ¨le nul et les jeux de donnÃ©es.

On a pu voir que les instances des a-motifs de spam et de va-et-vient sont
plus frÃ©quentes et plus courtes que ces mÃªmes instances dans le modÃ¨le nul.
J'interprÃ¨te ces rÃ©sultats comme dus Ã  un lien causal entre les instances de
ces motifs.

Les instances du a-motif d'Ã©toile ont des propriÃ©tÃ©s inverses : dans les
donnÃ©es, elles sont moins frÃ©quentes et plus longues que dans le modÃ¨le nul.
Or, dans ce modÃ¨le oÃ¹ la causalitÃ© est supprimÃ©e, les a-motifs tels que le
spam et le va-et-vient deviennent moins frÃ©quents. Je suppose alors que le
modÃ¨le forme des instances de a-motifs d'Ã©toile avec les arcs qui composaient
les instances des autres a-motifs dans les donnÃ©es.

Les instances du a-motif de chaine dans les donnÃ©es sont moins frÃ©quentes
et plus courtes que dans le modÃ¨le nul. Ces diÃ©rences suggÃ¨rent que les a-
motifs de chaine observÃ©s sont liÃ©s causalement.

Il n'y a pas de consensus quant Ã  la diÃ©rence de frÃ©quence du motif
de triangle sur les jeux de donnÃ©es. Les z-scores de la durÃ©e sont cependant
majoritairement nÃ©gatifs, ce qui laisse supposer que les triangles sont liÃ©s
causalement.

3.2.2 Etude de la relation entre a-motifs et communau-

tÃ©s

J'Ã©tudie ensuite les arcs utilisÃ©s par les a-motifs, en distinguant arcs in-
ternes aux communautÃ©s et arcs externes. L'objectif de cette expÃ©rience est
de comparer les propriÃ©tÃ©s des a-motifs se produisant entre les communautÃ©s
et ceux se produisant Ã  l'intÃ©rieur. Soit ğ‘¤ğ‘–ğ‘›(ğ‘š) la somme des poids des a-
motifs de type ğ‘š qui utilisent un arc interne. On s'intÃ©resse aux poids relatifs,
ğ‘šâ€²âˆˆğ‘€ ğ‘¤ğ‘–ğ‘›(ğ‘šâ€²) avec ğ‘€ l'ensemble des a-motifs
donc ğ‘¤ğ‘›ğ‘œğ‘Ÿğ‘š
extraits (ici, l'ensemble des a-motifs de taille 3). La distribution de ces poids
est similaire Ã  la Fig. 3.4.

(ğ‘š) = ğ‘¤ğ‘–ğ‘›(ğ‘š)/âˆ‘ï¸€

ğ‘–ğ‘›

Je calcule un ratio entre ces poids internes et les poids externes dÃ©crit

Eq. 3.2.

ğ‘Ÿğ‘ğ‘¡ğ‘–ğ‘œ(ğ‘š) =

ğ‘¤ğ‘›ğ‘œğ‘Ÿğ‘š

ğ‘’ğ‘¥ğ‘¡

max(ğ‘¤ğ‘›ğ‘œğ‘Ÿğ‘š

ğ‘’ğ‘¥ğ‘¡

(ğ‘š) âˆ’ ğ‘¤ğ‘›ğ‘œğ‘Ÿğ‘š
(ğ‘š), ğ‘¤ğ‘›ğ‘œğ‘Ÿğ‘š

ğ‘–ğ‘›

ğ‘–ğ‘›

(ğ‘š)

(ğ‘š))

(3.2)

Si ce ratio dÃ©passe zÃ©ro pour un a-motif, les instances de cet a-motif ont une

J. Creusefond

37

Chapitre 3. Ã‰tude de la structure communautaire de rÃ©seaux de
communication par les motifs temporels

Figure 3.7  Le ratio entre la proportion extÃ©rieure et intÃ©rieure des a-motifs

frÃ©quence relative supÃ©rieure Ã  l'extÃ©rieur des communautÃ©s par rapport Ã 
l'intÃ©rieur. Les rÃ©sultats sont prÃ©sentÃ©s Fig. 3.7.

Tout d'abord, le a-motif de va-et-vient semble avoir une frÃ©quence relative
plus importante Ã  l'intÃ©rieur des communautÃ©s, tous les jeux de donnÃ©es
ayant un ğ‘Ÿğ‘ğ‘¡ğ‘–ğ‘œ(AB-AB-AB) < 0. Le a-motif de spam prÃ©sente les mÃªmes
caractÃ©ristiques, sauf pour le rÃ©seau de Caen_CNU qui a un ratio au-dessus
de zÃ©ro (ratio de 0,16). De mÃªme, les ratios du a-motif de triange sont nÃ©gatifs
sauf pour Debian (ratio de 0,9). L'inverse se produit pour le a-motif d'Ã©toile,
majoritairement plus frÃ©quent sur la frontiÃ¨re des communautÃ©s, sauf pour
Caen_Lab (ratio de âˆ’0,11), et Debian (ratio do âˆ’0,13). Pour le a-motif
chaine, les ratios sont majoritairement positifs mais trois des jeux de donnÃ©es
ont des ratios nÃ©gatifs. Il est donc dicile d'en tirer une conclusion gÃ©nÃ©rale.
La Figure 3.8 montre que la grande majoritÃ© (âˆ¼ 84%) des z-scores du
ratio prÃ©cÃ©demment Ã©tudiÃ© sont positifs. Ceci implique que les ratios dans les
jeux de donnÃ©es sont supÃ©rieurs Ã  ceux du modÃ¨le nul. Donc, dans le jeu de
donnÃ©es, les a-motifs se situent plus souvent Ã  l'extÃ©rieur des communautÃ©s
par rapport Ã  ce que le modÃ¨le nul prÃ©voyait.

Je conclue que ces rÃ©sultats montrent une tendance assez claire pour chaque
a-motif Ã  se dÃ©rouler soit exclusivement Ã  l'intÃ©rieur des communautÃ©s soit

38

J. Creusefond

3.2. Experiences

Figure 3.8  Le z-score du ratio Fig. 3.7

exclusivement Ã  l'extÃ©rieur. D'un cÃ´tÃ©, les instances des a-motifs de chaÃ®ne
et d'Ã©toile sont majoritairement externes. D'un autre cÃ´tÃ©, les instances des
a-motifs de spam, de va-et-vient et de triangle sont majoritairement internes.
Il semble donc que les motifs puissent servir Ã  diÃ©rencier arcs internes et
externes des communautÃ©s. Il y a donc des modes de communication dif-
fÃ©rents Ã  l'intÃ©rieur des communautÃ©s et Ã  l'extÃ©rieur. Dans le premier cas,
on retrouve plutÃ´t des dialogues, comme l'indique les motifs de va-et-vient
et de triangle. Dans le second cas, on identie des motifs de propagation
d'information non rÃ©ciproques.

Les rÃ©sultats montrent que la causalitÃ© a pour eet que les motifs sont
plus externes que prÃ©vu par le modÃ¨le nul. Une interprÃ©tation possible de
ce rÃ©sultat est que c'est sur la frontiÃ¨re des communautÃ©s que se dÃ©roule la
plus grande partie des a-motifs liÃ©s par la causalitÃ©. Une explication est que
les communications qui se dÃ©roulent aux frontiÃ¨res ont besoin de structures
particuliÃ¨res. En eet, les individus qui s'y transmettent des informations
servent de point de transfert entre les deux communautÃ©s, ce qui gÃ©nÃ¨re des
a-motifs spÃ©ciques quand ils sont diusÃ©s.

Enn, on remarque que les communautÃ©s produites par l'algorithme de
Louvain et celles provenant des jeux de donnÃ©es de l'UniversitÃ© de Caen
prÃ©sentent des rÃ©sultats similaires. Cela implique que les propriÃ©tÃ©s tempo-

J. Creusefond

39

Chapitre 3. Ã‰tude de la structure communautaire de rÃ©seaux de
communication par les motifs temporels
relles observÃ©es sont des caractÃ©ristiques de communautÃ©s structurelles. Ces
observations ne diÃ©rencient pas les communautÃ©s observÃ©es sur un rÃ©seau
temporel des communautÃ©s obtenues par un graphe.

Dans ce chapitre, j'ai prÃ©sentÃ© une dÃ©nition alternative des motifs dans
un graphe temporel qui prend en compte les pÃ©riodes d'activitÃ© dans
les communications. Avec l'aide de donnÃ©es fournies par l'UniversitÃ© de
Caen et avec d'autres donnÃ©es de la littÃ©rature, j'ai pu Ã©tablir certaines
propriÃ©tÃ©s de ces motifs. Je relÃ¨ve notamment des diÃ©rences importantes
entre les motifs relevÃ©s sur des donnÃ©es rÃ©elles et les motifs d'un modÃ¨le
nul qui a Ã©tÃ© crÃ©Ã© pour supprimer la causalitÃ© dans le rÃ©seau. Cela porte
Ã  croire que cette version dÃ©tecte des motifs liÃ©s causalement.

J'ai aussi observÃ© le lien entre la structure communautaire et les mo-
tifs. J'ai pu remarquer que certains motifs, comme le spam, le va-et-vient
et le triangle, Ã©taient gÃ©nÃ©ralement plus prÃ©sents Ã  l'intÃ©rieur qu'Ã  l'extÃ©-
rieur des communautÃ©s. Un autre motif, l'Ã©toile, apparait frÃ©quemment Ã 
l'extÃ©rieur des communautÃ©s. En plus, tous les motifs apparaissent plus
frÃ©quemment Ã  l'extÃ©rieur qu'Ã  l'intÃ©rieur des communautÃ©s par rapport
Ã  ce que le modÃ¨le nul prÃ©voyait. Ces observations pourraient aider le dÃ©-
veloppement de la dÃ©tection de communautÃ©s sur ux de liens, en Ã©tant
utilisÃ© en tant que fonction de qualitÃ©, par exemple.

40

J. Creusefond

Chapitre 4

Une nouvelle fonction de qualitÃ© :
la compacitÃ©

Dans ce chapitre, je dÃ©finis une fonction de qualitÃ©, la compa-
citÃ©. Celle-ci est basÃ©e sur un modÃ¨le de diffusion oÃ¹ chaque in-
dividu retransmet directement les informations reÃ§ues Ã  chaque
pas de temps. Dans ce modÃ¨le, une information se diffuse rapi-
dement dans une communautÃ© si les chemins entre ses membres
sont courts. Jâ€™Ã©tudie ensuite cette mesure de maniÃ¨re analytique.
Les travaux prÃ©sentÃ©s dans ce chapitre ont fait lâ€™objet de deux

publications [25, 26].

Dans le chapitre prÃ©cÃ©dent, j'ai Ã©tabli qu'il Ã©tait possible de diÃ©rencier
arcs internes et arcs externes des communautÃ©s en observant l'ordre des com-
munications entre les membres du rÃ©seau.

On sait que la diusion d'information est particuliÃ¨rement rapide au
sein de certaines communautÃ©s comme pour les utilisateurs de forums de
santÃ© [15]. Une faible longueur des chemins accÃ©lÃ¨re la diusion d'informa-
tion [24]. Par consÃ©quent, mesurer la taille des chemins entre les membres
d'une communautÃ© caractÃ©rise en partie la vitesse de diusion des messages
au sein de ses membres.

Ce critÃ¨re de la distance dans les communautÃ©s n'est pas directement
corrÃ©lÃ© au critÃ¨re de sÃ©parabilitÃ© (voir Sec. 2.3). Leskovec et al. [64] comparent
les  clusters  rÃ©sultants de l'application de deux algorithmes de dÃ©tection
de communautÃ©s sur les mÃªmes graphes. Ils observent notamment que les
 clusters  produits par l'un des deux algorithmes prÃ©sentent des chemins
plus courts que ceux de l'autre. Cependant, les  clusters  ayant des chemins
courts ont aussi une moins bonne conductance que ceux produits par l'autre
algorithme.

J. Creusefond

41

Chapitre 4. Une nouvelle fonction de qualitÃ© : la compacitÃ©

Dans ce chapitre, je propose une nouvelle fonction de qualitÃ© appelÃ©e
compacitÃ©. Elle se base sur le diamÃ¨tre pour estimer l'ecacitÃ© d'une diusion
d'information dans une communautÃ©. Je montre ensuite que cette fonction de
qualitÃ© satisfait les propriÃ©tÃ©s de Van Laarhoven et Marchiori [95], conÃ§ues
pour dÃ©crire un comportement intuitif des fonctions de qualitÃ©.

Alors que je note la compacitÃ© ğ‘ğ‘ğ‘œğ‘šğ‘(ğ¶) dans le reste du manuscrit, je la

dÃ©signe par Comp(ğ¶) dans ce chapitre an d'allÃ©ger les notations.

4.1 ModÃ©lisation et dÃ©finition dâ€™une structure

communautaire compacte

Dans cette section, je prÃ©sente une nouvelle fonction de qualitÃ©, la com-

pacitÃ©.

Certaines communautÃ©s permettent une diusion rapide des informa-
tions [15]. La compacitÃ© permet d'identier les communautÃ©s oÃ¹ la diusion
d'information est rapide en mesurant la vitesse de propagation de celles-ci.
Le terme  compacitÃ©  provient du fait que les structures favorisÃ©es par ce
type de mesure ont un diamÃ¨tre faible et sont donc  compactes .

J'utilise l' Independant Cascade Model  [40, 53] avec une probabilitÃ© de
contamination de 1 comme modÃ¨le de diusion d'information. Dans ce mo-
dÃ¨le, un unique individu possÃ¨de initialement une information. Ã€ chaque pas
de temps, chaque individu possÃ©dant l'information la transmet Ã  ses voisins
qui ne la possÃ¨dent pas, en activant l'arÃªte qui les relie. On remarque alors
que le temps nÃ©cessaire Ã  ce que la diusion atteigne toute la communautÃ©
est Ã©gal Ã  la distance maximale entre le noeud d'origine et les autres noeuds
de la communautÃ©. La vitesse de propagation d'une diusion d'information
correspond au nombre moyen d'arÃªtes activÃ©es par pas de temps lors de la
diusion.

Le noeud de dÃ©part d'une diusion a une inuence sur la vitesse de pro-
pagation En eet, une diusion partant d'un noeud proche de tous les autres
dans la communautÃ© a une vitesse de propagation bien plus importante qu'en
partant d'un noeud excentrÃ©. Je considÃ¨re la pire vitesse de propagation dans
le pire des cas. Ce choix permet de garantir que les diusions dans les com-
munautÃ©s  compactes  sont toujours rapides. Le pire des cas a lieu quand
le noeud de dÃ©part d'une diusion se situe Ã  l'extrÃ©mitÃ© d'un diamÃ¨tre.

L'ensemble de ces Ã©lÃ©ments amÃ¨ne Ã  la dÃ©nition formelle de la compacitÃ©.

42

J. Creusefond

4.1. ModÃ©lisation et dÃ©finition dâ€™une structure communautaire compacte

DÃ©finition 4.1 (CompacitÃ©). La compacitÃ© dâ€™un Â« cluster Â» ğ‘ est dÃ©finie par :

â§â¨â© 0

Comp(ğ‘) =

ğ‘š(ğ‘)

ğ‘‘ğ‘–ğ‘ğ‘š(ğ‘)

si ğ‘‘ğ‘–ğ‘ğ‘š(ğ‘) = 0 ou si ğ‘ non connexe

sinon

Pour calculer la compacitÃ© d'une partition, on somme la compacitÃ© des

 clusters  qui la composent.

Le dÃ©savantage de l'utilisation du diamÃ¨tre est que la complexitÃ© de sa
mesure est quadratique en la taille de la communautÃ©. De plus, le calcul doit
Ãªtre refait entiÃ¨rement en cas de modication de la partition. Je note donc
que la compacitÃ© est plus adaptÃ©e Ã  l'Ã©valuation de partitions, qui peut Ãªtre
faite sur des rÃ©seaux de taille rÃ©duite, qu'Ã  de l'optimisation gloutonne.

La compacitÃ© n'utilisant que les arcs internes, elle n'est pas aectÃ©e par
les relations des membres de la communautÃ© avec l'extÃ©rieur de celle-ci. Ainsi,
tout ensemble de noeuds est optimal en compacitÃ© si ses noeuds forment une
clique.

La compacitÃ© et les fonctions se basant sur la sÃ©parabilitÃ© ne favorisent
pas les mÃªmes  clusters . Pour l'illustrer, je compare la compacitÃ© et la
modularitÃ© sur des exemples jouet. J'appelle informellement  satellite  un
noeud de degrÃ© 1 et  pont  un noeud Ã  la jonction de sous-parties denses
du graphe, comme le noeud grisÃ© Fig. 4.1a.

La modularitÃ© a tendance Ã  favoriser les  clusters  qui incluent des
satellites et des ponts (par exemple Fig. 4.1). Sur cet exemple, la partition
prÃ©sentÃ© Fig. 4.1a a une modularitÃ© plus importante qu'en Fig. 4.1b, oÃ¹ le
satellite ainsi que le pont sont dans leur propre  cluster . La modularitÃ©
peut donc Ãªtre utilisÃ©e dans une application oÃ¹ chaque noeud doit Ãªtre classÃ©
dans une communautÃ© non triviale. NÃ©anmoins, cette approche n'est pas
adaptÃ©e quand le but est de trouver des communautÃ©s oÃ¹ la transmission
d'informations est ecace. La compacitÃ© correspond Ã  une approche plus
conservatrice : si un utilisateur n'a qu'une seule connexion, il semble dicile
de conclure sur son appartenance communautaire.

Un autre exemple soulignant la diÃ©rence entre les deux mesures est prÃ©-
sentÃ© Fig. 4.2. La partition optimale en modularitÃ© sÃ©pare les noeuds de la
3-clique centrale pour grouper les satellites connectÃ©s aux noeuds participant
Ã  la clique. D'un autre cÃ´tÃ©, la compacitÃ© favorise la cohÃ©sion interne, par
consÃ©quent son optimum regroupe la 3-clique centrale et isole les satellites.
On peut Ã©tendre l'exemple en considÃ©rant une ğ‘˜-clique centrale oÃ¹ chaque
noeud est de plus connectÃ© Ã  ğ‘˜ + 1 satellites. Pour tout ğ‘˜ > 2 entier, la
modularitÃ© favorisera systÃ©matiquement le regroupement avec les satellites
tandis que la compacitÃ© favorisera la conservation de la clique centrale.

J. Creusefond

43

Chapitre 4. Une nouvelle fonction de qualitÃ© : la compacitÃ©

(a) Partition incluant noeuds satellites et de connexion

(b) Partition excluant noeuds satellites et de connexion

Figure 4.1  ModularitÃ© and compacitÃ© de deux partitions du mÃªme graphe

Figure 4.2  Un cas simple d'une clique centrale avec des satellites.

44

J. Creusefond

qmod=0.194Comp=2qmod=0.194Comp=2qmod=0.136Comp=3qmod=-0.003Comp=0qmod=0.182Comp=3qmod=-0.012Comp=0ModularitÃ©maximale     CompacitÃ©maximale4.2. Respect des axiomes de Van Laarhoven et Marchiori

4.2 Respect des axiomes de Van Laarhoven et

Marchiori

Dans cette section, je montre que la compacitÃ© respecte un ensemble de
propriÃ©tÃ©s conÃ§ues pour reprÃ©senter un comportement intuitif de la commu-
nautÃ©.

Van Laarhoven et Marchiori [95] ont crÃ©Ã© un ensemble de six axiomes :
invariance par permutation, invariance dâ€™Ã©chelle, richesse, monoto-
nicitÃ©, localitÃ© et continuitÃ©. Selon eux, une fonction de qualitÃ© devrait
respecter ces axiomes dans le contexte du partitionnement de graphes. Ces
axiomes sont diÃ©rents des propriÃ©tÃ©s prÃ©sentÃ©es Sec. 2.3. En eet, ces pro-
priÃ©tÃ©s sont utilisÃ©es dans les dÃ©nitions des communautÃ©s. Les axiomes de
Van Laarhoven et Marchiori sont indÃ©pendants des dÃ©nitions des commu-
nautÃ©s.

Dans leur article [95], les auteurs prouvent notamment que la modularitÃ©
ne respecte pas les axiomes de localitÃ© et de monotonicitÃ©. Ils ne prÃ©sentent
aucune fonction de qualitÃ© sans paramÃ¨tre satisfaisant tous ces axiomes.

Ces propriÃ©tÃ©s portent sur des graphes pondÃ©rÃ©s. Je dÃ©nis maintenant la
compacitÃ© sur les graphes pondÃ©rÃ©s. La communication entre deux individus
proches permet souvent une transmission rapide des informations entre ces
individus [53]. An d'utiliser le mÃªme formalisme que Van Laarhoven et Mar-
chiori [95], un poids fort sur une arÃªte signie une grande anitÃ© donc une
vitesse de transmission faible. Utiliser la distance classique d'un graphe pon-
dÃ©rÃ© (c'est-Ã -dire la somme des poids des arÃªtes) produit un rÃ©sultat contraire
Ã  ce que je souhaite obtenir. Je considÃ¨re donc le poids associÃ© aux arÃªtes
comme Ã©tant une vitesse de transmission, l'inverse de celui-ci Ã©tant alors le
temps de transmission. Dans un graphe pondÃ©rÃ© (ğ‘‰, ğ‘¤), la fonction de lon-
gueur d'un chemin ğœ‹ que j'utilise est la suivante :

âˆ‘ï¸

ğ‘™ğ‘’ğ‘›(ğœ‹) =

1

ğ‘¤(ğ‘’)

ğ‘’âˆˆğœ‹

(4.1)

Cette dÃ©nition de la longueur d'un chemin est utilisÃ©e par la compacitÃ© dans
le calcul du diamÃ¨tre. Le numÃ©rateur correspond Ã  la somme du poids des
arÃªtes internes au  cluster  considÃ©rÃ©.

Je vais maintenant montrer que la compacitÃ© respecte les six axiomes de

Van Laarhoven et Marchiori.

DÃ©finition 4.2 (Invariance par permutation). Une fonction de qualitÃ© ğ‘„
est invariante par permutation si, pour tous graphes ğº = (ğ‘‰,ğ‘¤), toute

J. Creusefond

45

Chapitre 4. Une nouvelle fonction de qualitÃ© : la compacitÃ©

partition ğ¶ âˆˆ ğ’(ğ‘‰ ) et tout isomorphisme ğ‘“ qui Ã  ğº associe ğ‘“ (ğº) = (ğ‘‰ â€², ğ‘¤â€²),
on a ğ‘„ğº(ğ¶) = ğ‘„ğ‘“ (ğº)(ğ‘“ (ğ¶)).

Intuition : Une fonction de qualitÃ© ne devrait pas dÃ©pendre de la reprÃ©sen-
tation du graphe.

ThÃ©orÃ¨me 4.3. La compacitÃ© est invariante par permutation.

DÃ©monstration. Par abus de notation, j'utilise ğ‘“ sur des  clusters  et des
noeuds. Prouvons que les distances sur les graphes pondÃ©rÃ©s sont invariantes
par permutation, en utilisant la notion de longueur dÃ©nie Eq. 4.1 :

ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘“ (ğº)(ğ‘“ (ğ‘¢), ğ‘“ (ğ‘£)) =

=

min

ğœ‹âˆˆÎ ğ‘“ (ğº)(ğ‘“ (ğ‘¢),ğ‘“ (ğ‘£))

(ğ‘™ğ‘’ğ‘›ğ‘“ (ğº)(ğœ‹))

(ğ‘™ğ‘’ğ‘›ğº(ğ‘“âˆ’1(ğœ‹)))

min

ğœ‹âˆˆÎ ğº(ğ‘¢,ğ‘£)

= ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘¢, ğ‘£)

Ceci implique que la compacitÃ© est invariante par permutation :
(ğ‘“ (ğ‘–),ğ‘“ (ğ‘—))âˆˆğ‘“ (ğ‘)2 ğ‘¤â€²(ğ‘“ (ğ‘–), ğ‘“ (ğ‘—))

Compğ‘“ (ğº)(ğ‘“ (ğ¶)) =

ğ‘“ (ğ‘)âˆˆğ‘“ (ğ¶)

max(ğ‘“ (ğ‘¢),ğ‘“ (ğ‘£))âˆˆğ‘“ (ğ¶)2(ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘“ (ğº)(ğ‘“ (ğ‘¢),ğ‘“ (ğ‘£)))

(ğ‘“ (ğ‘–),ğ‘“ (ğ‘—))âˆˆğ‘“ (ğ‘)2 ğ‘¤(ğ‘–, ğ‘—)

=

ğ‘“ (ğ‘)âˆˆğ‘“ (ğ¶)

max(ğ‘“ (ğ‘¢),ğ‘“ (ğ‘£))âˆˆğ‘“ (ğ‘)2(ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘¢, ğ‘£))

âˆ‘ï¸
âˆ‘ï¸

âˆ‘ï¸€
âˆ‘ï¸€

Compğ‘“ (ğº)(ğ‘“ (ğ¶)) = Compğº(ğ¶)

La compacitÃ© est stable par isomorphisme, et est donc invariante par permu-
tation.

DÃ©finition 4.4 (Invariance en Ã©chelle). Une fonction de qualitÃ© ğ‘„ est inva-
riante en Ã©chelle si pour tous les graphes ğº = (ğ‘‰, ğ‘¤), toutes les partitions
ğ¶1, ğ¶2 âˆˆ ğ’(ğ‘‰ ) de ğº et toutes les constantes ğ›¼ > 0, ğ‘„ğº(ğ¶1) â‰¤ ğ‘„ğº(ğ¶2) si et
seulement si ğ‘„ğ›¼ğº(ğ¶1) â‰¤ ğ‘„ğ›¼ğº(ğ¶2), oÃ¹ ğ›¼ğº = (ğ‘‰, ğ›¼ Â· ğ‘¤) est le graphe ğº dont
les poids des arÃªtes est multipliÃ© par ğ›¼.

Intuition : Le poids des arÃªtes a souvent une Ã©chelle choisie arbitrairement.
Tout changement sans inversion de cette Ã©chelle ne devrait pas avoir d'impact
sur le classement des partitions par la fonction de qualitÃ©.

ThÃ©orÃ¨me 4.5. La compacitÃ© est invariante en Ã©chelle

46

J. Creusefond

4.2. Respect des axiomes de Van Laarhoven et Marchiori

DÃ©monstration. CommenÃ§ons par prouver une corrÃ©lation linÃ©aire des lon-
gueurs des chemins entre ğº et ğ›¼ğº.

ğ‘™ğ‘’ğ‘›ğ›¼ğº(ğ‘£0, ..., ğ‘£ğ‘˜) =

ğ‘™ğ‘’ğ‘›ğ›¼ğº(ğ‘£0, ..., ğ‘£ğ‘˜) =

ğ‘˜âˆ’1âˆ‘ï¸

1

ğ›¼ Â· ğ‘¤(ğ‘£ğ‘–, ğ‘£ğ‘–+1)

ğ‘–=0
ğ‘™ğ‘’ğ‘›ğº(ğ‘£0, ..., ğ‘£ğ‘˜)

ğ›¼

Du fait que les longueurs des chemins sont corrÃ©lÃ©s linÃ©airement, les che-

mins minimums sont les mÃªmes dans ğº et dans ğ›¼ğº, ce qui implique :

ğ‘‘ğ‘–ğ‘ ğ‘¡ğ›¼ğº(ğ‘¢, ğ‘£) =

min

ğœ‹âˆˆÎ ğ›¼ğº(ğ‘¢,ğ‘£)

ğ‘™ğ‘’ğ‘›ğ›¼ğº(ğœ‹)

=

=

ğ‘™ğ‘’ğ‘›ğº(ğœ‹)

ğ›¼

min

ğœ‹âˆˆÎ ğ›¼ğº(ğ‘¢,ğ‘£)
ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘¢, ğ‘£)

ğ›¼

Par le mÃªme raisonnement, ğ‘‘ğ‘–ğ‘ğ‘šğ›¼ğº(ğ‘) = ğ‘‘ğ‘–ğ‘ğ‘šğº(ğ‘)/ğ›¼ La compacitÃ© peut

Ãªtre Ã©crite de la maniÃ¨re suivante :

Compğ›¼ğº(ğ¶) =

=

âˆ‘ï¸
âˆ‘ï¸

ğ‘âˆˆğ¶

âˆ‘ï¸
âˆ‘ï¸

(ğ‘–,ğ‘—)âˆˆğ‘2

ğ‘âˆˆğ¶

(ğ‘–,ğ‘—)âˆˆğ‘2

ğ‘¤ğ›¼ğº(ğ‘–, ğ‘—)
ğ‘‘ğ‘–ğ‘ğ‘šğ›¼ğº(ğ‘)
ğ›¼2 ğ‘¤ğº(ğ‘–, ğ‘—)
ğ‘‘ğ‘–ğ‘ğ‘šğº(ğ‘)

= ğ›¼2Compğº(ğ¶)

Par consÃ©quent, pour toutes partitions ğ¶1, ğ¶2 âˆˆ ğ’(ğ‘‰ ), si Compğº(ğ¶1) â‰¥
Compğº(ğ¶2) alors ğ›¼2Compğº(ğ¶1) â‰¥ ğ›¼2Compğº(ğ¶2), ce qui implique Compğ›¼ğº(ğ¶1) â‰¥
Compğ›¼ğº(ğ¶2). La compacitÃ© est donc invariante en Ã©chelle.

DÃ©finition 4.6 (Richesse). Une fonction de qualitÃ© ğ‘„ est riche si pour
tous les ensembles ğ‘‰ et toutes les partitions ğ¶* âˆˆ ğ’(ğ‘‰ ), il existe un graphe
ğº = (ğ‘‰, ğ‘¤) tel que ğ¶* est la partition ğ‘„-optimale de ğ‘‰ , câ€™est-Ã -dire que
ğ¶* = arg maxğ¶âˆˆğ’(ğ‘‰ ) ğ‘„ğº(ğ¶).
Intuition : N'importe quelle partition d'ensemble de noeuds devrait pouvoir
Ãªtre optimale par rapport Ã  la fonction de qualitÃ©, si la structure du graphe
correspond.

J. Creusefond

47

Chapitre 4. Une nouvelle fonction de qualitÃ© : la compacitÃ©

ThÃ©orÃ¨me 4.7. La compacitÃ© est riche
DÃ©monstration. âˆ€ğ¶* âˆˆ ğ’(ğ‘‰ ), soit ğº = (ğ‘‰, ğ‘¤) un graphe tel que, âˆ€(ğ‘–, ğ‘—) âˆˆ ğ‘‰ 2,
ğ‘¤(ğ‘–, ğ‘—) = 1 si âˆƒğ‘ âˆˆ ğ¶* tel que ğ‘– âˆˆ ğ‘ et ğ‘— âˆˆ ğ‘ (ğ‘– et ğ‘— appartiennent au
mÃªme  cluster ) et ğ‘¤(ğ‘–, ğ‘—) = 0 sinon. ğº est donc un graphe dont toutes
les composantes connexes sont des cliques, et ces cliques sont les  clusters 
composant ğ¶*. Soit ğ¶ âˆˆ ğ’(ğ‘‰ ) une partition optimale en compacitÃ© de ğº,
c'est-Ã -dire que arg maxğ·âˆˆğ’(ğ‘‰ ) Compğº(ğ·) = ğ¶.
Si âˆƒğ‘ âˆˆ ğ¶ tel que âˆƒ(ğ‘–, ğ‘—) âˆˆ ğ‘2, ğ‘¤(ğ‘–, ğ‘—) = 0, alors ğ‘– et ğ‘— ne sont pas dans
le mÃªme  cluster  dans ğ¶*. Donc, ğ‘ est dÃ©connectÃ©, ce qui implique que
sa compacitÃ© est nulle. Si ğ‘ est composÃ©e de ğ‘˜ composantes connexes, on
crÃ©e ğ‘˜ nouveaux  clusters  (ğ‘1, ..., ğ‘ğ‘˜) contenant chacun les noeuds d'une
composante connexe diÃ©rente. Remarquons que la compacitÃ© de chacun de
ces  clusters  est positive, et donc supÃ©rieure ou Ã©gale Ã  la compacitÃ© de ğ‘.
Soit ğ¶â€² âˆˆ ğ’(ğ‘‰ ) telle que ğ¶â€² = ğ¶ âˆ– ğ‘ âˆª {ğ‘1, ..., ğ‘ğ‘˜}. Alors :

Comp(ğ¶â€²) = Comp(ğ¶ âˆ– ğ‘) + Comp({ğ‘1, ..., ğ‘ğ‘˜})

â‰¥ Comp(ğ¶ âˆ– ğ‘) + Comp(ğ‘)

â‡” Comp(ğ¶â€²) â‰¥ Comp(ğ¶)

Ces scores sont Ã©gaux si et seulement si tous les noeuds de ğ‘ ont un degrÃ©
nul. Nous pouvons donc conclure que âˆ€ğ‘ âˆˆ ğ¶, ğ‘ est connexe ou composÃ©e
uniquement de noeuds Ã  degrÃ© nul (condition de connexitÃ©).
Soient ğ‘1, ğ‘2 âˆˆ ğ¶, ğ‘1 Ì¸= ğ‘2 tels que âˆƒğ‘– âˆˆ ğ‘1, âˆƒğ‘— âˆˆ ğ‘2 avec ğ‘¤(ğ‘–, ğ‘—) = 1. Il y a
donc une ou plusieurs arÃªtes entre deux  clusters  dans ğ¶. Alors ğ‘– et ğ‘— sont
dans le mÃªme  cluster  dans ğ¶* et dans diÃ©rents  clusters  dans ğ¶. Les
noeuds ğ‘– et ğ‘— ont un degrÃ© non nul, donc par la condition de connexitÃ© les
 clusters  ğ‘1 et ğ‘2 sont tous deux connexes, ce qui implique que ğ‘1 âˆª ğ‘2 est
connexe. Nous appelons ğ¶â€² âˆˆ ğ’(ğ‘‰ ) la partition correspondant Ã  ğ¶ oÃ¹ ğ‘1 et ğ‘2
ont Ã©tÃ©s remplacÃ©s par leur fusion, formellement ğ¶â€² = (ğ¶âˆ–{ğ‘1, ğ‘2})âˆª{ğ‘1âˆªğ‘2}).

Comp(ğ¶â€²) = Comp(ğ¶ âˆ– {ğ‘1, ğ‘2}) + Comp({ğ‘1 âˆª ğ‘2})

â‰¥ Comp(ğ¶ âˆ– {ğ‘1, ğ‘2}) + Comp(ğ‘1) + Comp(ğ‘2) +
> Comp(ğ¶ âˆ– {ğ‘1, ğ‘2}) + Comp(ğ‘1) + Comp(ğ‘2)

â‡” Comp(ğ¶â€²) > Comp(ğ¶)

ğ‘¤(ğ‘–,ğ‘—)

ğ‘‘ğ‘–ğ‘ğ‘š({ğ‘1 âˆª ğ‘2})

Du fait que ğ¶ soit optimal par rapport Ã  Comp, il n'y a aucune arÃªte entre les
 clusters  de ğ¶, ce qui est Ã©quivalent Ã  âˆ€ğ‘ âˆˆ ğ¶, âˆƒğ‘â€² âˆˆ ğ¶*, ğ‘â€² âŠ† ğ‘ (condition
de maximalitÃ©).

48

J. Creusefond

4.2. Respect des axiomes de Van Laarhoven et Marchiori

Les deux conditions rÃ©unies impliquent que tout  cluster  dans ğ¶ est
soit une composante connexe maximale de ğº (et donc un  cluster  dans
ğ¶*) ou un ensemble de noeuds de degrÃ© nul. Comme tout ensemble contenant
un noeud de degrÃ© nul a la mÃªme compacitÃ© (zÃ©ro), ğ¶* a la mÃªme compacitÃ©
que toute autre partition optimale en compacitÃ©. Donc ğ¶* est une partition
de ğº de compacitÃ© maximale. La compacitÃ© est donc riche.

Avant de dÃ©nir la monotonicitÃ©, j'ai besoin de dÃ©nir la notion dâ€™amÃ©lio-

ration ğ¶-consistante d'un graphe par rapport Ã  une partition.

DÃ©finition 4.8 (AmÃ©lioration ğ¶-consistante). Soit ğº = (ğ‘‰, ğ‘¤) un graphe et
ğ¶ âˆˆ ğ’(ğ‘‰ ). Un graphe ğºâ€² = (ğ‘‰, ğ‘¤â€²) est une amÃ©lioration ğ¶-consistante
de ğº si pour tous les noeuds ğ‘– et ğ‘—, ğ‘¤â€²(ğ‘–, ğ‘—) â‰¥ ğ‘¤(ğ‘–, ğ‘—) quand ğ‘– est dans la
mÃªme communautÃ© que ğ‘— et ğ‘¤â€²(ğ‘–, ğ‘—) â‰¤ ğ‘¤(ğ‘–, ğ‘—) quand ğ‘– nâ€™est pas dans la mÃªme
communautÃ© que ğ‘—.

DÃ©finition 4.9 (MonotonicitÃ©). Une fonction de qualitÃ© ğ‘„ est monotone
si pour tous les graphes ğº, toutes les partitions ğ¶ âˆˆ ğ’(ğ‘‰ ) de ğº et toutes les
amÃ©liorations ğ¶-consistantes ğºâ€² de ğº, ğ‘„ğºâ€²(ğ¶) â‰¥ ğ‘„ğº(ğ¶)

Intuition : La fonction de qualitÃ© ne peut pas contredire la supposition de
base de la structure communautaire : ce sont des zones denses du graphe.

ThÃ©orÃ¨me 4.10. La compacitÃ© est monotone

DÃ©monstration. Du fait de l'indÃ©pendance de la compacitÃ© au poids des
arÃªtes externes, elle n'est pas aectÃ©e par la diminution du poids des arÃªtes
externes d'une amÃ©lioration ğ¶-consistante. Nous n'analyserons donc que l'ef-
fet de l'augmentation du poids des arÃªtes Ã  l'intÃ©rieur des  clusters .
âˆ€ğ‘ âˆˆ ğ¶, âˆ€ğœ‹ un chemin dans le sous-graphe de ğº induit par ğ‘, ğ‘™ğ‘’ğ‘›ğº(ğœ‹) â‰¥
ğ‘™ğ‘’ğ‘›ğºâ€²(ğœ‹) (car tous les poids sont augmentÃ©s ou identiques). Ainsi, ğ‘‘ğ‘–ğ‘ğ‘šğº(ğ‘) â‰¥
ğ‘‘ğ‘–ğ‘ğ‘šğºâ€²(ğ‘). Donc

ğ‘¤â€²(ğ‘–, ğ‘—)
ğ‘‘ğ‘–ğ‘ğ‘šğºâ€²(ğ‘)

= Compğºâ€²(ğ‘)

âˆ‘ï¸

(ğ‘–,ğ‘—)âˆˆğ‘2

â‰¤ âˆ‘ï¸

(ğ‘–,ğ‘—)âˆˆğ‘2

ğ‘¤(ğ‘–, ğ‘—)

ğ‘‘ğ‘–ğ‘ğ‘šğº(ğ‘)

Compğº(ğ‘) =

.

Une amÃ©lioration ğ¶-consistante implique donc une compacitÃ© supÃ©rieure

ou Ã©gale Ã  la compacitÃ© initiale. La compacitÃ© est monotone.

Avant de dÃ©nir la localitÃ©, j'ai besoin de dÃ©nir la notion dâ€™entente sur un

voisinage pour les graphes.

J. Creusefond

49

Chapitre 4. Une nouvelle fonction de qualitÃ© : la compacitÃ©

DÃ©finition 4.11 (Entente sur un voisinage). Soient ğº1 = (ğ‘‰1, ğ‘¤1) et ğº2 =
(ğ‘‰2, ğ‘¤2) deux graphes et soit ğ‘‰ğ‘ âŠ† ğ‘‰1âˆ©ğ‘‰2 un sous-ensemble des noeuds que ces
deux graphes ont en commun. Ces graphes sâ€™entendent sur le voisinage
de ğ‘‰ğ‘ si ğ‘¤1(ğ‘–, ğ‘—) = ğ‘¤2(ğ‘–, ğ‘—) pour tout ğ‘–, ğ‘— âˆˆ ğ‘‰ğ‘ et
(i) ğ‘¤1(ğ‘–, ğ‘—) = ğ‘¤2(ğ‘–, ğ‘—) pour tout ğ‘– âˆˆ ğ‘‰ğ‘ et ğ‘— âˆˆ ğ‘‰1 âˆ© ğ‘‰2,
(ii) ğ‘¤1(ğ‘–, ğ‘—) = 0 pour tout ğ‘– âˆˆ ğ‘‰ğ‘ et si ğ‘— âˆˆ ğ‘‰1 âˆ– ğ‘‰2,
(iii) ğ‘¤2(ğ‘–, ğ‘—) = 0 pour tout ğ‘– âˆˆ ğ‘‰ğ‘ et si ğ‘— âˆˆ ğ‘‰2 âˆ– ğ‘‰1.

Ceci signie que les noeuds appartenant Ã  ğ‘‰ğ‘ sont connectÃ©s exactement

aux mÃªmes noeuds avec les mÃªmes poids dans les deux graphes.

DÃ©finition 4.12 (LocalitÃ©). Une fonction de qualitÃ© ğ‘„ est locale si pour
tous les graphes ğº1 = (ğ‘‰1, ğ‘¤1) et ğº2 = (ğ‘‰2, ğ‘¤2), si âˆƒğ‘‰ğ‘ âŠ† ğ‘‰1 âˆ© ğ‘‰2 tel que
ğº1 et ğº2 sâ€™entendent sur le voisinage de ğ‘‰ğ‘, et pour tout ğ¶ğ‘, ğ·ğ‘ âˆˆ ğ’(ğ‘‰ğ‘),
ğ¶1 âˆˆ ğ’(ğ‘‰1 âˆ– ğ‘‰ğ‘) et ğ¶2 âˆˆ ğ’(ğ‘‰2 âˆ– ğ‘‰ğ‘), si ğ‘„ğº1(ğ¶ğ‘ âˆª ğ¶1) â‰¥ ğ‘„ğº1(ğ·ğ‘ âˆª ğ¶1) alors
ğ‘„ğº2(ğ¶ğ‘ âˆª ğ¶2) â‰¥ ğ‘„ğº2(ğ·ğ‘ âˆª ğ¶2).

Intuition : Un changement local du rÃ©seau ne devrait pas avoir d'incidence
sur les prÃ©fÃ©rences dans une partie Ã©loignÃ©e du rÃ©seau. Comme soulignÃ© par
les auteurs de ces axiomes [95], le problÃ¨me de la limite de rÃ©solution observÃ©
par Fortunato et Barthelemy [37] est fortement liÃ© Ã  la satisfaction de la
localitÃ©. La limite de rÃ©solution est le fait que la partition optimale en la
fonction de qualitÃ© ne peut pas contenir des  clusters  de petite taille par
rapport Ã  la taille du graphe.

ThÃ©orÃ¨me 4.13. La compacitÃ© est locale
DÃ©monstration. Soient ğº1 = (ğ‘‰1, ğ‘¤1) et ğº2 = (ğ‘‰2, ğ‘¤2) deux graphes et ğ‘‰ğ‘ âŠ†
ğ‘‰1 âˆ© ğ‘‰2 tel que ğº1 et ğº2 s'entendent sur le voisinage de ğ‘‰ğ‘. Du fait de la
dÃ©nition 4.11, on a âˆ€(ğ‘–, ğ‘—) âˆˆ ğ‘‰ 2
ğ‘ , ğ‘¤1(ğ‘–,ğ‘—) = ğ‘¤2(ğ‘–, ğ‘—). Donc âˆ€ğ¶ âˆˆ ğ’(ğ‘‰ğ‘),
Compğº1(ğ¶) = Compğº2(ğ¶).
On obtient donc âˆ€ğ¶ğ‘, ğ·ğ‘ âˆˆ ğ’(ğ‘‰ğ‘), âˆ€ğ¶1 âˆˆ ğ’(ğ‘‰1 âˆ– ğ‘‰ğ‘) et âˆ€ğ¶2 âˆˆ ğ’(ğ‘‰2 âˆ– ğ‘‰ğ‘)

Compğº1(ğ¶ğ‘ âˆª ğ¶1) â‰¥ Compğº1(ğ·ğ‘ âˆª ğ¶1)

â‡” Compğº1(ğ¶ğ‘) + Compğº1(ğ¶1) â‰¥ Compğº1(ğ·ğ‘) + Compğº1(ğ¶1)
â‡” Compğº1(ğ¶ğ‘) â‰¥ Compğº1(ğ·ğ‘)
â‡” Compğº2(ğ¶ğ‘ âˆª ğ¶2) â‰¥ Compğº2(ğ·ğ‘ âˆª ğ¶2)

La compacitÃ© est donc locale.

50

J. Creusefond

4.2. Respect des axiomes de Van Laarhoven et Marchiori

DÃ©finition 4.14 (ContinuitÃ©). Une fonction de qualitÃ© ğ‘„ est continue si
pour tout ğœ– > 0 et tout graphe ğº = (ğ‘‰, ğ‘¤), il existe un ğ›¿ > 0 tel que pour tout
graphe ğºâ€² = (ğ‘‰, ğ‘¤â€²), si ğ‘¤(ğ‘–, ğ‘—)âˆ’ ğ›¿ < ğ‘¤â€²(ğ‘–, ğ‘—) < ğ‘¤(ğ‘–, ğ‘—) + ğ›¿ pour tous les noeuds
ğ‘– et ğ‘—, alors ğ‘„ğºâ€²(ğ¶) âˆ’ ğœ– < ğ‘„ğº(ğ¶) < ğ‘„ğºâ€²(ğ¶) + ğœ– pour toutes les partitions
ğ¶ âˆˆ ğ’(ğ‘‰ ).
Intuition : Une fonction de qualitÃ© doit Ãªtre peu sensible au bruit.

ThÃ©orÃ¨me 4.15. La compacitÃ© est continue

DÃ©monstration. Cette dÃ©nition de continuitÃ© correspond Ã  la continuitÃ©
standard d'une fonction Ã  variables multiples. La fonction de distance utilisÃ©e
est le maximum de la valeur absolue de la diÃ©rence entre les poids des arÃªtes
entre deux graphes partageant le mÃªme ensemble de noeuds. Appelons cette
fonction de distance ğ‘‘((ğ‘‰, ğ‘¤ğº), (ğ‘‰, ğ‘¤ğºâ€²)) = max(ğ‘–,ğ‘—)âˆˆğ‘‰ 2(|ğ‘¤ğº(ğ‘–, ğ‘—) âˆ’ ğ‘¤ğºâ€²(ğ‘–, ğ‘—)|).
Notons qu'il s'agit d'une distance au sens formel : les propriÃ©tÃ©s de positivitÃ©,
symÃ©trie et d'identitÃ© sont immÃ©diates. La preuve de l'inÃ©galitÃ© triangulaire
suit :

ğ‘‘(ğºğ‘¥, ğºğ‘¦) + ğ‘‘(ğºğ‘¦, ğºğ‘§) = max
(ğ‘–,ğ‘—)âˆˆğ‘‰ 2
+ max
(ğ‘–,ğ‘—)âˆˆğ‘‰ 2

(|ğ‘¤ğ‘¥(ğ‘–,ğ‘—) âˆ’ ğ‘¤ğ‘¦(ğ‘–,ğ‘—)|)

(|ğ‘¤ğ‘¦(ğ‘–,ğ‘—) âˆ’ ğ‘¤ğ‘§(ğ‘–,ğ‘—)|)

(|ğ‘¤ğ‘¥(ğ‘–,ğ‘—) âˆ’ ğ‘¤ğ‘¦(ğ‘–,ğ‘—)| + |ğ‘¤ğ‘¦(ğ‘–,ğ‘—) âˆ’ ğ‘¤ğ‘§(ğ‘–,ğ‘—)|)
(|ğ‘¤ğ‘¥(ğ‘–,ğ‘—) âˆ’ ğ‘¤ğ‘¦(ğ‘–,ğ‘—) + ğ‘¤ğ‘¦(ğ‘–,ğ‘—) âˆ’ ğ‘¤ğ‘§(ğ‘–,ğ‘—)|)

â‰¥ max
(ğ‘–,ğ‘—)âˆˆğ‘‰ 2
â‰¥ max
(ğ‘–,ğ‘—)âˆˆğ‘‰ 2
â‰¥ ğ‘‘(ğºğ‘¥, ğºğ‘§)

Comme nous considÃ©rons une notion de continuitÃ© standard, nous pourrons
utiliser des propriÃ©tÃ©s connues, comme la continuitÃ© de la combinaison de
fonctions continues.
Lemme 4.16. Pour un graphe connexe ğº = (ğ‘‰, ğ‘¤), âˆ€(ğ‘,ğ‘) âˆˆ ğ‘‰ 2, ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘, ğ‘)
est continue

Preuve du lemme 4.16 : Soit ğºğ‘› = (ğ‘‰, ğ‘¤ğ‘›) une sÃ©quence de Cauchy de
graphes. Alors âˆ€(ğ‘–,ğ‘—) âˆˆ ğ‘‰ 2, (ğ‘¤ğ‘›(ğ‘–,ğ‘—))ğ‘›âˆˆN est aussi une sÃ©quence de Cauchy.
Par dÃ©nition, âˆƒğ‘¤ tel que ğ‘¤ğ‘›(ğ‘–,ğ‘—) â†’ ğ‘¤(ğ‘–,ğ‘—) (dans ce contexte, â†’ signie
 converge vers quand ğ‘› â†’ âˆ ) et il existe un graphe ğº = (ğ‘‰, ğ‘¤) tel que
ğºğ‘› â†’ ğº. On suppose ğº connexe.
âˆ€(ğ‘, ğ‘) âˆˆ ğ‘‰ 2, soit ğœ‹ = (ğ‘0 = ğ‘, ğ‘1, ..., ğ‘ğ‘˜âˆ’1, ğ‘ğ‘˜ = ğ‘) un chemin tel que
ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘, ğ‘) = ğ‘™ğ‘’ğ‘›ğº(ğœ‹), c'est-Ã -dire un chemin minimal dans ğº entre ğ‘ et ğ‘.

J. Creusefond

51

Chapitre 4. Une nouvelle fonction de qualitÃ© : la compacitÃ©

âˆ‘ï¸€

Si âˆƒğ‘– âˆˆ [0 : ğ‘˜ âˆ’ 1] tel que ğ‘¤(ğ‘ğ‘–, ğ‘ğ‘–+1) = 0, alors ğ‘™ğ‘’ğ‘›ğº(ğœ‹) n'est pas dÃ©ni et
donc ce n'est pas un chemin minimal. Du fait de la dÃ©nition d'un graphe
connexe, un chemin entre ğ‘ et ğ‘ existe, donc âˆ€ğ‘– âˆˆ [0 : ğ‘˜ âˆ’ 1], ğ‘¤(ğ‘ğ‘–, ğ‘ğ‘–+1) > 0.
est continue en (ğ‘¤(ğ‘0, ğ‘1), ..., ğ‘¤(ğ‘ğ‘˜âˆ’1, ğ‘ğ‘˜)). Donc ğ‘™ğ‘’ğ‘›ğºğ‘›(ğœ‹) â†’

Comme âˆ€ğ‘– âˆˆ [0 : ğ‘˜âˆ’1], ğ‘¤ğ‘›(ğ‘ğ‘–, ğ‘ğ‘–+1) â†’ ğ‘¤(ğ‘ğ‘–, ğ‘ğ‘–+1) Ì¸= 0, alors ğ‘“ (ğ‘¥0, ..., ğ‘¥ğ‘˜âˆ’1) =
ğ‘–âˆˆ[0:ğ‘˜âˆ’1]
ğ‘™ğ‘’ğ‘›ğº(ğœ‹).
Comme ğ‘‘ğ‘–ğ‘ ğ‘¡ğºğ‘›(ğ‘, ğ‘) â‰¤ ğ‘™ğ‘’ğ‘›ğºğ‘›(ğœ‹),

1
ğ‘¥ğ‘–

ğ‘‘ğ‘–ğ‘ ğ‘¡ğºğ‘›(ğ‘, ğ‘) â‰¤ lim sup
ğ‘›â†’+âˆ
ğ‘›â†’+âˆ ğ‘™ğ‘’ğ‘›ğºğ‘›(ğœ‹) = ğ‘™ğ‘’ğ‘›ğº(ğœ‹) = ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘, ğ‘)

ğ‘™ğ‘’ğ‘›ğºğ‘›(ğœ‹)

= lim

ğ‘‘ğ‘–ğ‘ ğ‘¡ğºğ‘›(ğ‘, ğ‘) â‰¤ ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘, ğ‘)

lim sup
ğ‘›â†’+âˆ

lim sup
ğ‘›â†’+âˆ

lim inf

ğ‘›â†’+âˆ ğ‘‘ğ‘–ğ‘ ğ‘¡ğºğ‘›(ğ‘, ğ‘) â‰¤ lim sup
ğ‘›â†’+âˆ

ğ‘‘ğ‘–ğ‘ ğ‘¡ğºğ‘›(ğ‘, ğ‘), donc

lim inf

ğ‘›â†’+âˆ ğ‘‘ğ‘–ğ‘ ğ‘¡ğºğ‘›(ğ‘, ğ‘) â‰¤ lim sup
ğ‘›â†’+âˆ

ğ‘‘ğ‘–ğ‘ ğ‘¡ğºğ‘›(ğ‘, ğ‘) â‰¤ ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘, ğ‘)

(4.2)
ğ‘‘ğ‘–ğ‘ ğ‘¡ğºğ‘›(ğ‘, ğ‘) â‰¤ ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘, ğ‘), donc âˆƒğ‘›0 âˆˆ N tel que âˆ€ğ‘› â‰¥

Soit ğœ– > 0. lim sup
ğ‘›â†’+âˆ

ğ‘›0, ğ‘‘ğ‘–ğ‘ ğ‘¡ğºğ‘›(ğ‘, ğ‘) â‰¤ (1 + ğœ–)ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘, ğ‘).

1

2 Ã— ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘, ğ‘)

Soit ğ‘›1 âˆˆ N tel que âˆ€ğ‘› â‰¥ ğ‘›1, ğ‘‘(ğº, ğºâ€²) â‰¤
Par dÃ©nition, âˆ€(ğ‘–,ğ‘—) âˆˆ ğ‘‰ Ã— ğ‘‰ , |ğ‘¤ğ‘›(ğ‘–, ğ‘—) âˆ’ ğ‘¤(ğ‘–, ğ‘—)| â‰¤
Pour ğ‘› âˆˆ N, soit ğœ‹ğ‘› un chemin entre ğ‘ et ğ‘ tel que ğ‘‘ğ‘–ğ‘ ğ‘¡ğºğ‘›(ğ‘, ğ‘) =
ğ‘™ğ‘’ğ‘›ğºğ‘›(ğœ‹ğ‘›). Si ğœ‹ğ‘› n'est pas un chemin dans ğº pour ğ‘› â‰¥ max(ğ‘›0, ğ‘›1), alors
ğ‘–+1) Ì¸= 0 et
, ğ‘(ğ‘›)
pour ğœ‹ğ‘› = (ğ‘(ğ‘›)
ğ‘¤(ğ‘(ğ‘›)

), âˆƒğ‘– âˆˆ [0 : ğ‘˜ğ‘› âˆ’ 1] tel que ğ‘¤ğ‘›(ğ‘(ğ‘›)

2 Ã— ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘, ğ‘)

0 , ..., ğ‘(ğ‘›)
ğ‘˜ğ‘›

, ğ‘(ğ‘›)

1

.

.

ğ‘–

ğ‘–

ğ‘–+1) = 0. Dans ce cas,
ğ‘–+1)| = |ğ‘¤ğ‘›(ğ‘(ğ‘›)
, ğ‘(ğ‘›)

|ğ‘¤ğ‘›(ğ‘(ğ‘›)

ğ‘–

ğ‘–

ğ‘–+1) âˆ’ ğ‘¤(ğ‘(ğ‘›)
, ğ‘(ğ‘›)

ğ‘–

ğ‘–+1)| â‰¤
, ğ‘(ğ‘›)

1

2 Ã— ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘, ğ‘)

â‡’ ğ‘™ğ‘’ğ‘›ğºğ‘›(ğœ‹ğ‘›) â‰¥

1
ğ‘¤ğ‘›(ğ‘(ğ‘›)

ğ‘–

, ğ‘(ğ‘›)
ğ‘–+1)

â‰¥ 2 Ã— ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘, ğ‘)

Ceci est contradictoire car ğ‘™ğ‘’ğ‘›ğºğ‘›(ğœ‹ğ‘›) = ğ‘‘ğ‘–ğ‘ ğ‘¡ğºğ‘›(ğ‘, ğ‘) â‰¤ (1 + ğœ–)ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘, ğ‘) pour
ğ‘› â‰¥ ğ‘›0. Donc, pour ğ‘› â‰¥ max(ğ‘›0, ğ‘›1), ğœ‹ğ‘› est aussi un chemin dans ğº.

Soit ğ‘›2 âˆˆ N tel que âˆ€ğ‘› â‰¥ ğ‘›2, ğ‘‘(ğº, ğºğ‘›) â‰¤ ğœ–ğ‘¤ğ‘šğ‘–ğ‘› avec ğ‘¤ğ‘šğ‘–ğ‘› = ğ‘šğ‘–ğ‘›ğ‘’âˆˆğ‘‰ 2,ğ‘¤(ğ‘’)Ì¸=0ğ‘¤(ğ‘’).

D'abord, notons que

âˆ€ğ‘’ âˆˆ ğ‘‰ 2, ğ‘¤ğ‘›(ğ‘’) â‰¥ ğ‘¤(ğ‘’) âˆ’ ğœ–ğ‘¤ğ‘šğ‘–ğ‘› â‰¥ (1 âˆ’ ğœ–)ğ‘¤ğ‘šğ‘–ğ‘›

52

J. Creusefond

4.2. Respect des axiomes de Van Laarhoven et Marchiori

Ensuite

|ğ‘™ğ‘’ğ‘›ğºğ‘›(ğœ‹ğ‘›) âˆ’ ğ‘™ğ‘’ğ‘›ğº(ğœ‹ğ‘›)| = | âˆ‘ï¸
âˆ‘ï¸
â‰¤ âˆ‘ï¸
â‰¤ âˆ‘ï¸

=

ğ‘–âˆˆ[0:ğ‘˜ğ‘›âˆ’1]

ğ‘–âˆˆ[0:ğ‘˜ğ‘›âˆ’1]

ğ‘–âˆˆ[0:ğ‘˜ğ‘›âˆ’1]

ğ‘–âˆˆ[0:ğ‘˜ğ‘›âˆ’1]
|ğ‘‰ |ğœ–

ğ‘–

1
ğ‘¤ğ‘›(ğ‘(ğ‘›)
|ğ‘¤ğ‘›(ğ‘(ğ‘›)
ğ‘¤ğ‘›(ğ‘(ğ‘›)

ğ‘–

ğ‘–

|

ğ‘–

âˆ’

1
, ğ‘(ğ‘›)
, ğ‘(ğ‘›)
ğ‘¤(ğ‘(ğ‘›)
ğ‘–+1)
ğ‘–+1)
ğ‘–+1)|
ğ‘–+1) âˆ’ ğ‘¤(ğ‘(ğ‘›)
, ğ‘(ğ‘›)
, ğ‘(ğ‘›)
ğ‘–+1) Ã— ğ‘¤(ğ‘(ğ‘›)
, ğ‘(ğ‘›)
, ğ‘(ğ‘›)
ğ‘–+1)
ğœ–ğ‘¤ğ‘šğ‘–ğ‘›
ğ‘–+1) Ã— ğ‘¤(ğ‘(ğ‘›)
, ğ‘(ğ‘›)
ğœ–ğ‘¤ğ‘šğ‘–ğ‘›

, ğ‘(ğ‘›)
ğ‘–+1)

ğ‘–

ğ‘–

ğ‘–

ğ‘–

ğ‘¤ğ‘›(ğ‘(ğ‘›)
(1 âˆ’ ğœ–)ğ‘¤ğ‘šğ‘–ğ‘› Ã— ğ‘¤ğ‘šğ‘–ğ‘›

ğ‘¤ğ‘šğ‘–ğ‘›(1 âˆ’ ğœ–)

ğ‘¤ğ‘šğ‘–ğ‘›(1 âˆ’ ğœ–)

|ğ‘™ğ‘’ğ‘›ğºğ‘›(ğœ‹ğ‘›) âˆ’ ğ‘™ğ‘’ğ‘›ğº(ğœ‹ğ‘›)| â‰¤
Du fait que ğ‘™ğ‘’ğ‘›ğº(ğœ‹ğ‘›) â‰¥ ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘, ğ‘), alors ğ‘™ğ‘’ğ‘›ğºğ‘›(ğœ‹ğ‘›) â‰¥ ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘, ğ‘) âˆ’
|ğ‘‰ |ğœ–
ğ‘›â†’+âˆ ğ‘™ğ‘’ğ‘›ğºğ‘›(ğœ‹ğ‘›) â‰¥ ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘, ğ‘). En combinant avec Eq. 4.2 :
ğ‘‘ğ‘–ğ‘ ğ‘¡ğºğ‘›(ğ‘, ğ‘) â‰¤ ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘, ğ‘) â‰¤ lim inf
â‡’ lim

ğ‘›â†’+âˆ ğ‘™ğ‘’ğ‘›ğºğ‘›(ğœ‹ğ‘›)

. Donc lim inf

lim sup
ğ‘›â†’+âˆ

ğ‘›â†’+âˆ ğ‘‘ğ‘–ğ‘ ğ‘¡ğºğ‘›(ğ‘, ğ‘) = ğ‘‘ğ‘–ğ‘ ğ‘¡ğº(ğ‘, ğ‘)

Ce qui prouve que la distance entre deux noeuds d'un graphe connexe est

une fonction continue.
Fin de la preuve du lemme 4.16

Prouvons maintenant la continuitÃ© de la fonction sur des  clusters  non
connexes. An de simplier les notations, nous travaillons directement sur
les sous-graphes induits en Ã©tendant la compacitÃ© pour prendre un graphe en
entrÃ©e :

â§â¨â© 0
âˆ‘ï¸€

Comp(ğº) =

ğ‘’âˆˆğ‘‰ 2 ğ‘¤(ğ‘’)
ğ‘‘ğ‘–ğ‘ğ‘š(ğº)

si |ğ‘‰ | = 1 ou ğº non connexe
sinon

Du lemme 4.16, nous savons que ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘¢, ğ‘£) est continue pour tous les graphes
connexes, et ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘¢, ğ‘£) > 0. Le maximum d'un ensemble de fonctions conti-
nues est continu, ce qui signie que ğ‘‘ğ‘–ğ‘ğ‘š(ğº) est continu pour tous les graphes
connexes et ğ‘‘ğ‘–ğ‘ğ‘š(ğº) > 0. Une combinaison de fonction continues est conti-
nue, et 1/ğ‘¥ est continue en R+. Comp(ğº) est donc continue sur tous les graphes
connexes.

Prouvons maintenant que Comp(ğº) est continue sur des graphes non connexes.

De la mÃªme maniÃ¨re que dans la preuve du lemme 4.16, nous prenons une

J. Creusefond

53

Chapitre 4. Une nouvelle fonction de qualitÃ© : la compacitÃ©

sÃ©quence de Cauchy de graphes (ğºğ‘›)ğ‘›âˆˆN : ğºğ‘› = (ğ‘‰, ğ‘¤ğ‘›) â†’ ğº = (ğ‘‰, ğ‘¤),
mais ğº est cette fois non connexe. Pour tout ğ‘› âˆˆ N, si ğºğ‘› est non connexe,
Comp(ğºğ‘›) = 0 = Comp(ğº).

Si ğºğ‘› est connexe, soient ğ‘ et ğ‘ des noeuds dans deux composantes
ğ‘˜ = ğ‘) âˆˆ

connexes diÃ©rentes de ğºğ‘›. Tout chemin ğœ‹ğ‘› = (ğ‘(ğ‘›)
Î ğºğ‘›(ğ‘, ğ‘) est tel que âˆƒğ‘—, ğ‘¤(ğ‘(ğ‘›)

0 = ğ‘, ğ‘(ğ‘›)

1 , ..., ğ‘(ğ‘›)

, ğ‘(ğ‘›)

ğ‘—

âˆ‘ï¸

ğ‘—+1) = 0. Par dÃ©nition,
â‰¥ 1
ğ‘¤(ğ‘›)
ğ‘šğ‘–ğ‘›

1
ğ‘¤ğ‘›(ğ‘(ğ‘›)

, ğ‘(ğ‘›)
ğ‘–+1)

ğ‘–

ğ‘–âˆˆ[0:ğ‘˜âˆ’1]

ğ‘™ğ‘’ğ‘›(ğœ‹ğ‘›) =

ğ‘šğ‘–ğ‘› = minğ‘–âˆˆ[0:ğ‘˜âˆ’1](ğ‘¤ğ‘›(ğ‘(ğ‘›)

oÃ¹ ğ‘¤(ğ‘›)
et ğ‘ sont dans deux composantes connexes diÃ©rentes de ğº,
Donc

ğ‘–+1)). Comme ğºğ‘› converge vers ğº, et que ğ‘
ğ‘šğ‘–ğ‘› = 0+.

ğ‘›â†’+âˆ ğ‘¤(ğ‘›)
lim

, ğ‘(ğ‘›)

ğ‘–

ğ‘›â†’+âˆ ğ‘‘ğ‘–ğ‘ ğ‘¡ğºğ‘›(ğ‘¢, ğ‘£) = lim
lim

ğ‘›â†’+âˆ min
ğœ‹âˆˆÎ (ğ‘¢,ğ‘£)

ğ‘™ğ‘’ğ‘›ğºğ‘›(ğœ‹) = +âˆ

.

âˆ‘ï¸€
(ğ‘–,ğ‘—)âˆˆğ‘‰ 2 ğ‘¤ğ‘›(ğ‘–,ğ‘—) =âˆ‘ï¸€
Comme le diamÃ¨tre est la distance maximale entre toutes les paires de
ğ‘›â†’+âˆ ğ‘‘ğ‘–ğ‘ğ‘š(ğºğ‘›) = +âˆ. Par dÃ©nition d'une sÃ©quence de Cauchy,

(ğ‘–,ğ‘—)âˆˆğ‘‰ 2 ğ‘¤(ğ‘–,ğ‘—). Donc,

lim

noeuds,
lim
ğ‘›â†’+âˆ

ğ‘›â†’+âˆ Comp(ğºğ‘›) = lim
lim
ğ‘›â†’+âˆ

= 0 = Comp(ğº)

âˆ‘ï¸

ğ‘¤ğ‘›(ğ‘’)

ğ‘‘ğ‘–ğ‘ğ‘š(ğºğ‘›)

ğ‘’âˆˆğ‘‰ 2

Ce qui implique que, pour tout graphe non connexe ğº, Comp est continue en
ğº.

Comme la compacitÃ© est la somme des Comp(ğº) appliquÃ©s aux sous-

graphes induits par la partition, la compacitÃ© est continue.

Dans ce chapitre, j'ai prÃ©sentÃ© une nouvelle fonction de qualitÃ©, la com-
pacitÃ©. Celle-ci mesure la vitesse de propagation de la diusion de l'infor-
mation dans la communautÃ© dans le pire des cas. Les diÃ©rents exemples
montrent que cette fonction privilÃ©gie des structures denses. J'ai aussi
prouvÃ© que la compacitÃ© satisfait les six axiomes de Van Laarhoven et
Marchiori. Ceci implique notamment qu'elle n'est pas aectÃ©e par une
limite de rÃ©solution.

Ce critÃ¨re de qualitÃ© peut Ãªtre utilisÃ© par un algorithme de dÃ©tection
de communautÃ©s. En eet, en simulant des diusions, il est possible de
dÃ©tecter des communautÃ©s. C'est le sujet du prochain chapitre.

54

J. Creusefond

Chapitre 5

Une mÃ©thode de dÃ©tection de
communautÃ©s basÃ©e sur
lâ€™algorithme du LexDFS

Les algorithmes de parcours de graphe peuvent amener des infor-
mations sur la structure du graphe. Câ€™est le cas du LexDFS [23]
(Â« Lexicographical Depth-First Search Â»), une variante du DFS.
Je lâ€™utilise pour un algorithme de dÃ©tection de communautÃ©s, et
Ã©tudie les communautÃ©s ainsi crÃ©Ã©es.

Les travaux prÃ©sentÃ©s dans ce chapitre ont fait lâ€™objet de deux

publications [25, 26].

Weng et al. [100] ont observÃ© des phÃ©nomÃ¨nes de diusions dans twitter.
Ils constatent que certaines diusions se limitent Ã  la communautÃ© dont elles
sont originaires. Ces diusions intra-communautaires ont des caractÃ©ristiques
proches d'un modÃ¨le oÃ¹, Ã  chaque pas de temps, l'individu ayant le plus de
voisins informÃ©s devient lui-mÃªme informÃ©.

Dans ce modÃ¨le, prenons ğ‘¢ et ğ‘£ deux voisins tels que ğ‘¢ est informÃ© et
ğ‘£ ne l'est pas. La probabilitÃ© que ğ‘¢ transmette l'information Ã  ğ‘£ augmente
avec le nombre de voisins de ğ‘£ dÃ©jÃ  informÃ©s. Il s'agit de la caractÃ©ristique du
renforcement. J'utilise cette caractÃ©ristique comme base d'un algorithme an
de dÃ©tecter les communautÃ©s dans lesquelles ces diusions se concentrent.

Dans ce chapitre, je prÃ©sente cet algorithme, qui est de complexitÃ© log-
linÃ©aire. Il est basÃ© sur plusieurs itÃ©rations du LexDFS [23], un algorithme de
parcours de graphe visitant en prioritÃ© les noeuds dont les voisins ont dÃ©jÃ 
Ã©tÃ©s visitÃ©s. J'utilise les parcours produits pour gÃ©nÃ©rer des communautÃ©s,
que j'Ã©tudie ensuite expÃ©rimentalement.

J. Creusefond

55

Chapitre 5. Une mÃ©thode de dÃ©tection de communautÃ©s basÃ©e sur
lâ€™algorithme du LexDFS

Zhou et Lipowsky [107] ont montrÃ© qu'utiliser des marches alÃ©atoires biai-
sÃ©es pouvait Ãªtre utilisÃ© pour la dÃ©tection de communautÃ©s. Yucel et al. [105]
ont rÃ©cemment proposÃ© d'utiliser des marches alÃ©atoires avec mÃ©moire empÃª-
chant le marcheur de revenir sur le dernier noeud visitÃ©. Leurs marches sont
aussi biaisÃ©es de telle maniÃ¨re Ã  augmenter la probabilitÃ© de retour sur un
noeud dÃ©jÃ  visitÃ© rÃ©cemment. Une adaptation de ces techniques permettrait
de biaiser des marches alÃ©atoires pour prendre en compte le renforcement. La
limite de ces algorithmes est leur complexitÃ©. Les auteurs ont montrÃ© qu'ils
nÃ©cessitaient au moins un temps quadratique en la taille du graphe. Mon
objectif est d'obtenir un algorithme de complexitÃ© raisonnable, utilisable en
pratique.

5.1 Un algorithme de partitionnement basÃ© sur

le LexDFS

Cette section prÃ©sente une mÃ©thode basÃ©e sur l'algorithme de parcours de
graphe LexDFS introduit par Corneil et Krueger [23]. Il s'agit d'une variation
de l'algorithme DFS (cf Sec. 2.1).

Le LexDFS est de parcourir le graphe visitant en prioritÃ© les noeuds dont
les voisins ont Ã©tÃ©s rÃ©cemment visitÃ©s. Le LexDFS Ã©tiquette chaque noeud
avec une liste d'entiers, initialement vide. Lors de la ğ‘–-Ã¨me Ã©tape du LexDFS,
on rÃ©cupÃ¨re tous les voisins non visitÃ©s du noeud courant. Pour chacun de ces
voisins, le nombre ğ‘– est ajoutÃ© au dÃ©but de son Ã©tiquette. Le noeud Ã  visiter Ã 
la prochaine Ã©tape est choisi uniformÃ©ment au hasard parmi les noeuds ayant
l'Ã©tiquette la plus grande dans l'ordre lexicographique.

Un exemple d'exÃ©cution du LexDFS est prÃ©sentÃ© Fig. 5.1. Dans cet ex-
emple, Ã  l'issue de la premiÃ¨re Ã©tape, le LexDFS choisit entre les trois noeuds
ayant l'Ã©tiquette [1]. Ã€ l'issue de la deuxiÃ¨me Ã©tape, le LexDFS ignore le voisin
ayant l'Ã©tiquette [2] car il n'avait pas Ã©tÃ© dÃ©couvert Ã  l'itÃ©ration prÃ©cÃ©dente.
Le pseudo-code de l'algorithme du LexDFS est prÃ©sentÃ© Alg. 3. Celui-ci
utilise deux attributs des noeuds. L'attribut ğ‘™ğ‘’ğ‘¥ est l'Ã©tiquette, reprÃ©sentÃ©e
par un vecteur. L'attribut ğ‘£ğ‘–ğ‘ ğ‘–ğ‘¡ğ‘’ indique l'itÃ©ration Ã  laquelle un noeud a Ã©tÃ©
visitÃ©. S'il n'a pas Ã©tÃ© visitÃ©, cet attribut vaut zÃ©ro.

J'utilise le LexDFS comme base pour un algorithme de dÃ©tection de com-
munautÃ©s. J'appelle informellement une zone dense un ensembles de noeuds
tels que chacun de ces noeuds a un nombre important de voisins Ã  l'intÃ©rieur
de cet ensemble. Un LexDFS parcourant une zone dense augmente la prioritÃ©
de visite des autres noeuds de cette zone. Une fois Ã  l'intÃ©rieur d'une zone
dense, le LexDFS a tendance Ã  en visiter tous les noeuds avant de la quitter.

56

J. Creusefond

5.1. Un algorithme de partitionnement basÃ© sur le LexDFS

Figure 5.1  PremiÃ¨res Ã©tapes d'exÃ©cution du LexDFS sur un exemple. Les
itÃ©rations se lisent de gauche Ã  droite.

J'utilise cette caractÃ©ristique pour dÃ©tecter ces ensembles de noeuds. Nous
verrons que cette intuition est conrmÃ©e empiriquement.

Je dÃ©cris maintenant l'algorithme de dÃ©tection de communautÃ©s, le Lex-

Clustering. Un score est attribuÃ© aux arÃªtes, prÃ©sentÃ© Eq. 5.1.

âˆ€(ğ‘¢, ğ‘£) âˆˆ ğ¸, ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’(ğ‘¢, ğ‘£) = 1 âˆ’ |ğ‘¢.ğ‘£ğ‘–ğ‘ ğ‘–ğ‘¡ğ‘’ğ‘‘ âˆ’ ğ‘£.ğ‘£ğ‘–ğ‘ ğ‘–ğ‘¡ğ‘’ğ‘‘|

ğ‘›

(5.1)

Plus la visite des deux noeuds incidents Ã  une arÃªte est rapprochÃ©e, plus
son score est fort. Les arÃªtes de poids sont de bonnes candidates pour Ãªtre
des arÃªtes intra-communautaires.

L'algorithme calcule la moyenne de ce score sur un ensemble d'exÃ©cutions
du LexDFS. Les expÃ©riences montrent que 10 d'exÃ©cutions susent pour s'as-
surer de la convergence des scores (voir Sec. 5.2). L'algorithme place ensuite
chaque noeud dans son propre  cluster . Enn, il fusionne successivement
les  clusters  reliÃ©s par des arÃªtes Ã  fort score. On peut voir sur l'exemple
Fig. 5.2 que des zones denses du graphes sont ainsi rÃ©vÃ©lÃ©es. Le pseudo-code
associÃ© est prÃ©sentÃ© Alg. 4

La Fig. 5.2 prÃ©sente une exÃ©cution de la mÃ©thode sur un rÃ©seau extrait
de Facebook, prÃ©sentÃ© dans la Sec. 5.2. Les arÃªtes sont achÃ©es si elles sont
Ã  l'intÃ©rieur d'un  cluster . Pour des raisons de lisibilitÃ©, les  clusters 
de taille 1 n'y sont pas reprÃ©sentÃ©s. On peut voir dans la Fig. 5.2b qu'une
structure dense apparaÃ®t. En comparant les Fig. 5.2b et 5.2c, on observe
que les  clusters  apparaissent et Ã©voluent sÃ©parÃ©ment avant de fusionner.

J. Creusefond

57

11/31/31/311/21/22[1][1][1][][2,1][2,1][2]112[3,2,1][2]3[3,2,1]21/3: Ã©tiquette: noeud visitÃ©: probabilitÃ©de transitionChapitre 5. Une mÃ©thode de dÃ©tection de communautÃ©s basÃ©e sur
lâ€™algorithme du LexDFS

Algorithme 3 : LexDFS(G,s)

DonnÃ©es : Un graphe ğº et un noeud de dÃ©part ğ‘ 

1 dÃ©but

// Initialisation des attributs pour tous les noeuds

pour ğ‘£ âˆˆ ğ‘‰ faire
ğ‘£.ğ‘™ğ‘’ğ‘¥ â† ()
ğ‘£.ğ‘£ğ‘–ğ‘ ğ‘–ğ‘¡ğ‘’ â† 0

ğ‘ğ‘–ğ‘™ğ‘’ â† (ğ‘ )
ğ‘– â† 1
tant que ğ‘ğ‘–ğ‘™ğ‘’ Ì¸= () faire

ğ‘£ â† ğ‘‘Â´ğ‘’ğ‘ğ‘–ğ‘™ğ‘’(ğ‘ğ‘–ğ‘™ğ‘’)
ğ‘£.ğ‘£ğ‘–ğ‘ ğ‘–ğ‘¡ğ‘’ â† ğ‘–
ğ‘£ğ‘œğ‘–ğ‘  â† [ ]
pour ğ‘¢ âˆˆ ğ‘£ğ‘œğ‘–ğ‘ ğ‘–ğ‘›ğ‘ (ğ‘£) faire

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

// Marque le noeud comme visitÃ©

si ğ‘¢.ğ‘£ğ‘–ğ‘ ğ‘–ğ‘¡ğ‘’ = 0 alors
ğ‘ ğ‘¢ğ‘ğ‘ğ‘Ÿğ‘–ğ‘šğ‘’(ğ‘ğ‘–ğ‘™ğ‘’, ğ‘¢)
ğ‘¢.ğ‘™ğ‘’ğ‘¥ â† (ğ‘–, ğ‘¢.ğ‘™ğ‘’ğ‘¥)
ğ‘£ğ‘œğ‘–ğ‘  â† [ğ‘£ğ‘œğ‘–ğ‘ , ğ‘¢]

// Ajoute ğ‘– Ã  lâ€™Ã©tiquette

// Trie par ordre lexicographique des Ã©tiquettes.

// Lâ€™ordre des Ã©tiquettes Ã©gales est alÃ©atoire.
ğ‘¡ğ‘Ÿğ‘–ğ‘’(ğ‘£ğ‘œğ‘–ğ‘ )
// Place les voisins en haut de la pile
ğ‘’ğ‘šğ‘ğ‘–ğ‘™ğ‘’(ğ‘ğ‘–ğ‘™ğ‘’, ğ‘£ğ‘œğ‘–ğ‘ )
ğ‘– â† ğ‘– + 1

Notamment, en bas Ã  gauche de la Fig. 5.2c, deux communautÃ©s ont fusionnÃ©
en une seule.

Je montre maintenant que la complexitÃ© en temps de la mÃ©thode est dans
ğ’ª(ğ‘š Ã— ğ‘™ğ‘œğ‘”(ğ‘š) + (ğ‘› + ğ‘š log log(ğ‘›)) Ã— ğ‘™), oÃ¹ ğ‘™ est le nombre d'exÃ©cutions
du LexDFS, ğ‘š le nombre d'arÃªtes et ğ‘› le nombre de noeuds. Il a dÃ©jÃ  Ã©tÃ©
montrÃ© que le LexDFS est dans ğ’ª(min(ğ‘›2, ğ‘› + ğ‘š log log(ğ‘›)) [22]. Comme
je m'intÃ©resse Ã  des graphes dont le nombre d'arÃªtes est d'ordre infÃ©rieur
au quadratique [62], la complexitÃ© se rÃ©duit pour mes applications Ã  ğ’ª(ğ‘› +
ğ‘š log log(ğ‘›)).
Je m'intÃ©resse Ã  la complexitÃ© de l'Alg. 4. Le calcul des scores des arÃªtes
est dans ğ’ª(ğ‘š), et le tri des arÃªtes suivant leur score est dans ğ’ª(ğ‘šÃ— ğ‘™ğ‘œğ‘”(ğ‘š)).
Les fusions successives de  clusters  est un cas d'union d'ensemble disjoints.

58

J. Creusefond

5.1. Un algorithme de partitionnement basÃ© sur le LexDFS

(a) Graphe initial

(b) 1800Ã¨me itÃ©ration

(c) 2700Ã¨me itÃ©ration

Figure 5.2  Les  clusters  d'un extrait du rÃ©seau Facebook Ã  diÃ©rentes
Ã©tapes du Lex-Clustering

J. Creusefond

59

Chapitre 5. Une mÃ©thode de dÃ©tection de communautÃ©s basÃ©e sur
lâ€™algorithme du LexDFS

Algorithme 4 : Lex-Clustering(ğº, ğ‘™)

DonnÃ©es : Graphe ğº, nombre d'itÃ©rations ğ‘™

1 dÃ©but

pour ğ‘– â† 1 Ã  ğ‘™ faire

2

3

4

5

6

7

8

9

10

11

// ExÃ©cute un LexDFS Ã  partir dâ€™un noeud alÃ©atoire
LexDFS(ğº, randnode(ğ‘‰ ))
pour (ğ‘¢,ğ‘£) âˆˆ ğ¸ faire

ğ‘  â† 1 âˆ’ |ğ‘¢.ğ‘£ğ‘–ğ‘ ğ‘–ğ‘¡ğ‘’ âˆ’ ğ‘£.ğ‘£ğ‘–ğ‘ ğ‘–ğ‘¡ğ‘’|
ğ‘’.ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ â† (ğ‘’.ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ Ã— (ğ‘– âˆ’ 1) + ğ‘ )/ğ‘–

ğ‘š

ğ‘œğ‘Ÿğ‘‘ğ‘œğ‘› â† ğ‘¡ğ‘ğ‘ğ‘™ğ‘’ğ‘ğ‘¢(ğ¸)
ğ‘¡ğ‘Ÿğ‘–ğ‘’(ğ‘œğ‘Ÿğ‘‘ğ‘œğ‘›)
ğ¶ â† {{ğ‘£} | ğ‘£ âˆˆ ğ‘‰ }
pour ğ‘– â† 1 Ã  |ğ‘œğ‘Ÿğ‘‘ğ‘œğ‘›| faire
(ğ‘£,ğ‘¢) â† ğ‘œğ‘Ÿğ‘‘ğ‘œğ‘›[ğ‘–]
ğ‘“ ğ‘¢ğ‘ ğ‘–ğ‘œğ‘›ğ‘›ğ‘’(ğ¶, ğ‘ğ‘™ğ‘¢ğ‘ ğ‘¡ğ‘’ğ‘Ÿ(ğ‘£), ğ‘ğ‘™ğ‘¢ğ‘ ğ‘¡ğ‘’ğ‘Ÿ(ğ‘¢))

// Stocke ğ¸ dans un tableau

// Trie les arÃªtes par score dÃ©croissant

// CrÃ©e un cluster par noeud

Ce problÃ¨me est rÃ©solu par un algorithme quasi-linÃ©aire de Tarjan [90], de
complexitÃ© ğ’ª(ğ‘š Ã— ğ›¼(ğ‘š)) (on eectue au maximum ğ‘š fusions). La fonction
ğ›¼(ğ‘š) est l'inverse de la fonction d'Ackerman, qui a une croissance d'ordre
supÃ©rieur Ã  l'exponentiel. ğ›¼(ğ‘š) croÃ®t donc plus lentement qu'une fonction
log. La complexitÃ© est dominÃ©e par le terme dans ğ’ª(ğ‘š log(ğ‘š)).

La complexitÃ© nale est dans ğ’ª(ğ‘š log(ğ‘š) + (ğ‘› + ğ‘š log log(ğ‘›)) Ã— ğ‘™).

5.2 Ã‰valuation expÃ©rimentale du Lex-Clusering

Cette section prÃ©sente une Ã©tude expÃ©rimentale ayant pour but d'analyser

les rÃ©sultats produits par le Lex-Clustering.

An de limiter le temps de calcul, j'utilise une heuristique pour approcher
le diamÃ¨tre requis par la compacitÃ© (voir Chap. 4). Cette heuristique consiste
en deux BFS [67] et s'exÃ©cute en temps linÃ©aire. Le premier BFS commence
Ã  un noeud alÃ©atoire dans le  cluster . On calcule ensuite l'excentricitÃ© du
dernier noeud visitÃ© par le premier parcours, en utilisant un second BFS.
J'approche le diamÃ¨tre par cette valeur. Cette heuristique ore une bonne
approximation en pratique.

An d'analyser le Lex-Clustering, j'utilise les rÃ©seaux suivants :

facebook [65] (ğ‘› = 4039, ğ‘š = 88234) est un extrait du rÃ©seau social

60

J. Creusefond

5.2. Ã‰valuation expÃ©rimentale du Lex-Clusering

Ã©ponyme. Certains utilisateurs ont installÃ© une application 1 ayant un
but explicite de collecte de donnÃ©es pour la recherche. Cette application
a collectÃ© la liste d'amis des utilisateurs qui forment ce rÃ©seau.

astro [62] (ğ‘› = 17903, ğ‘š = 196972) est un rÃ©seau de co-publication scienti-
ques dans le domaine de l'astrophysique, extrait de la plate-forme de
publication en ligne arXiv 2. Les noeuds sont des auteurs, et il existe
une arÃªte entre deux auteurs s'ils ont publiÃ© un article ensemble.

enron [55] (ğ‘› = 36692, ğ‘š = 183831) provient de l'entreprise Ã©ponyme qui
a Ã©tÃ© forcÃ©e par la justice amÃ©ricaine Ã  rendre public l'intÃ©gralitÃ© des
e-mails envoyÃ©s et reÃ§us par ses employÃ©s 3. Chaque noeud reprÃ©sente
un individu, et il existe une arÃªte entre deux individus si un e-mail a
transitÃ© de l'un Ã  l'autre.

5.2.1 Vitesse de convergence du Lex-Clustering

J'Ã©tudie tout d'abord la vitesse de convergence du Lex-Clustering vers une
solution stable. J'utilise la diÃ©rence de l'ordre des arÃªtes pour dÃ©cider de la
convergence. En eet, cet ordre dÃ©termine directement le comportement de
la mÃ©thode. Le coecient de rang de Spearman mesure la corrÃ©lation entre
deux ordres :

(5.2)

ğ‘†(x, y) = 1 âˆ’

6(ğ‘¥ğ‘– âˆ’ ğ‘¦ğ‘–)2
|x| Â· (|x|2 âˆ’ 1)

|x|âˆ‘ï¸

ğ‘–=1

OÃ¹ x et y sont les vecteurs contenant l'ordre des scores. J'observe l'Ã©volution
de cette valeur au fur et Ã  mesure des itÃ©rations du LexDFS.

Cette expÃ©rience est importante pour dÃ©terminer la valeur de ğ‘™ dans l'al-
gorithme prÃ©sentÃ© Alg. 4. La Fig. 5.3 prÃ©sente les rÃ©sultats. Les trois jeux de
donnÃ©es considÃ©rÃ©s convergent de la mÃªme maniÃ¨re : commenÃ§ant Ã  0,5, le co-
ecient de rang de Spearman dÃ©passe 0,95 aprÃ¨s quatre itÃ©rations. Il continue
ensuite Ã  augmenter et est aux alentours de 0,99 aprÃ¨s dix itÃ©rations. C'est
pour cette raison que j'utilise 10 itÃ©rations dans les autres expÃ©riences.

1. http://snap.stanford.edu/socialcircles
2. www.arxiv.org
3. www.ferc.gov/industries/electric/indus-act/wec/enron/info-release.asp

J. Creusefond

61

Chapitre 5. Une mÃ©thode de dÃ©tection de communautÃ©s basÃ©e sur
lâ€™algorithme du LexDFS

Figure 5.3  Convergence du coecient de rang de Spearman du score des
arÃªtes sur plusieurs exÃ©cutions du LexDFS

5.2.2 Ã‰tude des Â« clusters Â» individuels

J'analyse maintenant les propriÃ©tÃ©s des  clusters  que le Lex-Clustering
forme au cours du partitionnement hiÃ©rarchique. Dans la continuitÃ© de la
comparaison avec la modularitÃ©, je compare les rÃ©sultats Ã  ceux de l'algo-
rithme de Clauset [20] (voir Sec. 2.4) qui optimise cette valeur de faÃ§on glou-
tonne. Comme il s'agit Ã©galement d'un algorithme hiÃ©rarchique, l'algorithme
de Clauset gÃ©nÃ¨re donc le mÃªme nombre de  clusters  que le Lex-Clustering
au cours du processus de fusion. Le nombre de  clusters  observÃ©s n'inuen-
cera donc pas la comparaison entre les deux algorithmes.

Pour reprÃ©senter les rÃ©sultats, j'utilise le NCP plot ( Network Commu-
nity Prole plot ) introduit par Leskovec et al. [63]. Le NCP plot permet de
visualiser le rÃ©sultat d'une mesure par rapport Ã  la taille des  clusters .

Certaines fonctions de qualitÃ© dÃ©pendent de la taille de la communautÃ©,
comme la modularitÃ© et la compacitÃ©. Comme les NCP plot reprÃ©sentent dÃ©jÃ 
la taille en tant que dimension, je prÃ©fÃ¨re utiliser des mesures ne dÃ©pendant
pas directement de la taille : le diamÃ¨tre, la conductance et le coecient de
clustering. J'utilise ici la conductance non normalisÃ©e [51] dÃ©crite Eq. 5.3.

ğ‘ğ‘ğ‘œğ‘›ğ‘‘ =

ğ‘š(ğ‘, ğ‘‰ âˆ– ğ‘)

ğ‘‰ ğ‘œğ‘™(ğ‘)

J. Creusefond

(5.3)

62

5.2. Ã‰valuation expÃ©rimentale du Lex-Clusering

Figure 5.4  Cardinal de l'ensemble des  clusters  de chaque taille

Tout d'abord, je relÃ¨ve Fig. 5.4 la distribution du cardinal des  clusters .
On peut noter que, dans tous les graphes, Lex-Clustering produit beaucoup
de  clusters  de taille infÃ©rieure Ã  100. On peut aussi voir qu'il n'existe
gÃ©nÃ©ralement qu'un  cluster  pour les tailles supÃ©rieures Ã  300. L'algorithme
de Clauset, d'un autre cÃ´tÃ©, produit relativement peu de petits  clusters 
et plusieurs grands  clusters . J'en dÃ©duis que le Lex-Clustering produit un
 cluster  de taille moyenne pour le fusionner ensuite avec tous les autres.
Les NCP plots sont reprÃ©sentÃ©s Fig. 5.5, Fig. 5.6 et Fig. 5.7. Sur chaque
graphe, les rÃ©sultats du Lex-Clustering sont reprÃ©sentÃ©s par des croix rouges
et ceux de l'algorithme de Clauset en vert. La colonne de gauche de ces gures
trace les croix vertes au-dessus des croix rouges, et inversement pour la co-
lonne de droite. Ainsi, la colonne de gauche met les rÃ©sultats de l'algorithme
de Clauset en valeur, tandis que la colonne de droite favorise la visualisa-
tion des rÃ©sultats du Lex-Clustering. Cette reprÃ©sentation est choisie car les
rÃ©sultats se superposent frÃ©quemment.

Les rÃ©sultats de la conductance sont prÃ©sentÃ©s Fig. 5.5. Les deux algo-
rithmes ont des rÃ©sultats similaires sur des petits  clusters  de taille in-
fÃ©rieure Ã  80, exceptÃ© sur le jeu de donnÃ©es facebook, oÃ¹ le Lex-Clustering

J. Creusefond

63

Chapitre 5. Une mÃ©thode de dÃ©tection de communautÃ©s basÃ©e sur
lâ€™algorithme du LexDFS

produit Ã©galement des  clusters  de faible conductance. D'un autre cÃ´tÃ©,
les grands  clusters  de taille supÃ©rieure Ã  300 produits par l'algorithme de
Clauset ont une conductance plus faible que ceux du Lex-Clustering.

Les NCP plot du coecient de clustering sont prÃ©sentÃ©s Fig. 5.6. On peut
voir sur ces rÃ©sultats une grande variance du coecient de clustering pour les
deux algorithmes. Les deux algorithmes ne semblent pas optimiser le critÃ¨re
du coecient de clustering.

Le diamÃ¨tre des  clusters  individuels est prÃ©sentÃ© Fig. 5.7. Sur les rÃ©-
seaux astro et enron, les petits  clusters  du Lex-Clustering ont un diamÃ¨tre
variÃ©, tandis que ceux de Clauset ont un diamÃ¨tre assez faible. Alors que les
grands  clusters  produits par l'algorithme de Clauset prÃ©sentent un dia-
mÃ¨tre variÃ©, ceux du Lex-Clustering ont un diamÃ¨tre relativement faible.

En rÃ©sumÃ© : on observe que le Lex-Clustering produit un unique  clus-
ter  de taille moyenne qui absorbe tous les autres. Il produit aussi un grand
nombre de petits  clusters . Ces expÃ©riences montrent que toutes les fonc-
tions de qualitÃ© ne peuvent Ãªtre utilisÃ©es pour Ã©valuer des  clusters . La
multiplicitÃ© des dÃ©nitions des communautÃ©s fait que les algorithmes de dÃ©-
tection de communautÃ©s sont trÃ¨s diÃ©rents les uns des autres, et c'est aussi
le cas pour les mÃ©triques. Ces expÃ©riences montrent qu'il est dicile pour
un algorithme dont la conception de prend pas en compte une mÃ©trique de
satisfaire celle-ci.

64

J. Creusefond

5.2. Ã‰valuation expÃ©rimentale du Lex-Clusering

Figure 5.5  NCP plot de la conductance

J. Creusefond

65

Chapitre 5. Une mÃ©thode de dÃ©tection de communautÃ©s basÃ©e sur
lâ€™algorithme du LexDFS

Figure 5.6  NCP plot du coecient de clustering

66

J. Creusefond

5.2. Ã‰valuation expÃ©rimentale du Lex-Clusering

Figure 5.7  NCP plot du diamÃ¨tre

J. Creusefond

67

Chapitre 5. Une mÃ©thode de dÃ©tection de communautÃ©s basÃ©e sur
lâ€™algorithme du LexDFS
5.2.3 Ã‰tude des partitions

J'analyse maintenant les partitions produites par le Lex-Clustering au

cours de son exÃ©cution.

Parmi toutes les partitions rÃ©sultantes d'un algorithme hiÃ©rarchique, il
est nÃ©cessaire d'en sÃ©lectionner une. La meilleure partition est traditionnelle-
ment [78, 20] sÃ©lectionnÃ©e en identiant le maximum d'une fonction de qua-
litÃ© lors du partitionnement hiÃ©rarchique. J'appelle sÃ©lecteur une fonction
de qualitÃ© dont le maximum global est utilisÃ© pour sÃ©lectionner une partition.
Dans cette expÃ©rience, je compare l'Ã©volution de la modularitÃ©, du coecient
de clustering, de la conductance normalisÃ©e et de la compacitÃ© des partitions
produites au cours du partitionnement hiÃ©rarchique. L'objectif de cette ex-
pÃ©rience est donc de dÃ©terminer les fonctions qui peuvent Ãªtre utilisÃ©e en tant
que sÃ©lecteur du Lex-Clustering.

Comme on peut le voir Fig. 5.8 et Fig. 5.9, le coecient de clustering et
la conductance ne semblent pas adaptÃ©s pour Ãªtre des sÃ©lecteurs. En eet, on
remarque que ce sont des fonctions qui atteignent leur maximum Ã  la n des
fusions, ce que l'on sait Ãªtre un mauvais partitionnement. Le partitionnement
du Lex-Clustering Ã  la n des fusions de ses  clusters  correspond Ã  un
 cluster  gÃ©ant et Ã  des petits  clusters . On cherche des petits  clusters 
oÃ¹ l'information se diuse rapidement, ce partitionnement n'est donc pas
adaptÃ©. Comme vu prÃ©cÃ©demment, les rÃ©sultats du Lex-Clustering ne sont
pas valorisÃ©s par le coecient de clustering et la conductance.

Comme on peut le voir Fig. 5.10 et Fig. 5.11, la modularitÃ© et la compa-
citÃ© sont adaptÃ©s pour Ãªtre utilisÃ© en tant que sÃ©lecteurs du Lex-Clustering.
En eet, ces deux fonctions produisent un pic clair correspondant Ã  leur
maximum global. Ce pic est situÃ© loin de la n de l'exÃ©cution.

Je note aussi que le maximum global ne correspond pas Ã  la mÃªme itÃ©-
ration suivant la fonction de qualitÃ© considÃ©rÃ©e. Par exemple, la compacitÃ©
prÃ©sente un maximum global aprÃ¨s 14 000 fusions sur le rÃ©seau enron. D'un
autre cÃ´tÃ©, la partition correspondant au maximum de conductance se situe
aux alentours de 33 000 itÃ©rations. Ainsi, le choix du sÃ©lecteur peut chan-
ger les rÃ©sultats de maniÃ¨re radicale. J'Ã©tudie l'inuence du sÃ©lecteur dans
l'expÃ©rience prÃ©sentÃ©e Sec. 5.2.4.

En rÃ©sumÃ© : la modularitÃ© et la compacitÃ© sont Ã -priori de bons sÃ©-
lecteurs. Le coecient de clustering retourne systÃ©matiquement un rÃ©sultat
trivial. La conductance a un bon comportement sur facebook, mais ne corres-
pond pas aux attentes sur enron et astro. Enn, je remarque que le choix du
sÃ©lecteur peut avoir une incidence importante sur la partition sÃ©lectionnÃ©e.

68

J. Creusefond

5.2. Ã‰valuation expÃ©rimentale du Lex-Clusering

Figure 5.8  Ã‰volution du coecient de clustering lors des partitionnements
hiÃ©rarchiques

Figure 5.9  Ã‰volution de la conductance lors des partitionnements hiÃ©rar-
chiques

J. Creusefond

69

Chapitre 5. Une mÃ©thode de dÃ©tection de communautÃ©s basÃ©e sur
lâ€™algorithme du LexDFS

Figure 5.10  Ã‰volution de la modularitÃ© lors des partitionnements hiÃ©rar-
chiques

Figure 5.11  Ã‰volution de la compacitÃ© lors des partitionnements hiÃ©rar-
chiques

70

J. Creusefond

5.2. Ã‰valuation expÃ©rimentale du Lex-Clusering

5.2.4 Comparaison avec des vÃ©ritÃ©s de terrain

Je compare ensuite les partitions fournies par diÃ©rents sÃ©lecteurs et des
vÃ©ritÃ©s de terrain. Cette expÃ©rience mesure si les partitions fournies par le
Lex-Clustering ressemblent Ã  celles extraites de l'environnement d'origine du
graphe. Les paramÃ¨tres expÃ©rimentaux sont dÃ©taillÃ©s au Chap. 6, qui prÃ©sente
une mÃ©thodologie incluant ces expÃ©riences. Celles-ci correspondent Ã  l'Ã©tape 3
de la mÃ©thodologie prÃ©sentÃ©e Sec. 6.1 de ce chapitre. J'ai exclu le coecient
de clustering en tant que sÃ©lecteur dans ces expÃ©riences.

actors amazon cora CS dblp football ickr github lj youtube

ğ‘™ğ‘’ğ‘¥ğ‘‘ğ‘“ ğ‘ ğ‘ğ‘œğ‘šğ‘
ğ‘™ğ‘’ğ‘¥ğ‘‘ğ‘“ ğ‘ ğ‘ğ‘œğ‘›ğ‘‘
ğ‘™ğ‘’ğ‘¥ğ‘‘ğ‘“ ğ‘ ğ‘šğ‘œğ‘‘

6
2
1

2
3
4

6
3
6

9
2
6

2
4
3

5
8
6

6
9
4

4
2
1

7
5
4

7
8
6

Table 5.1  Les rangs fournis par comparaison avec la vÃ©ritÃ© de terrain
(NMI) des rÃ©sultats du Lex-Clustering avec diÃ©rents sÃ©lecteurs

actors amazon cora CS dblp football ickr github lj youtube

ğ‘™ğ‘’ğ‘¥ğ‘‘ğ‘“ ğ‘ ğ‘ğ‘œğ‘šğ‘
ğ‘™ğ‘’ğ‘¥ğ‘‘ğ‘“ ğ‘ ğ‘ğ‘œğ‘›ğ‘‘
ğ‘™ğ‘’ğ‘¥ğ‘‘ğ‘“ ğ‘ ğ‘šğ‘œğ‘‘

3
9
2

6
1
5

8 6,5 3
2
6
6 6,5 2

3

3
8
6

1
8
7

1
9
3

1
9
5

4
9
5

Table 5.2  Les rangs fournis par comparaison avec la vÃ©ritÃ© de terrain (fb3)
des rÃ©sultats du Lex-Clustering avec diÃ©rents sÃ©lecteurs

Pour chaque graphe, j'applique les algorithmes Louvain, Clauset, MCL,
Infomap, label propagation et 3-core (cf Sec. 2.4), en plus du Lex-Clustering
avec les trois sÃ©lecteurs. Le rÃ©sultat de chacun de ces algorithmes est en-
suite comparÃ© aux vÃ©ritÃ©s de terrain de chacun de ces rÃ©seaux en utilisant la
NMI [58] et la F-BCubed [5]. Les Ã©lÃ©ments des tables 5.1 et 5.2 prÃ©sentent
les rangs du Lex-Clustering avec diÃ©rents sÃ©lecteurs parmi les algorithmes
Ã©tudiÃ©s. Les algorithmes sont classÃ©s en ordre dÃ©croissant. Les rangs vont de
1 Ã  9.

Comme l'expÃ©rience prÃ©cÃ©dente le laissait supposer, l'utilisation de diÃ©-
rents sÃ©lecteurs peut changer radicalement le rÃ©sultat. Par exemple ğ‘™ğ‘’ğ‘¥ğ‘‘ğ‘“ ğ‘ ğ‘ğ‘œğ‘›ğ‘‘
est de rang 2 pour cora, F-BCubed tandis que ğ‘™ğ‘’ğ‘¥ğ‘‘ğ‘“ ğ‘ ğ‘ğ‘œğ‘šğ‘ est de rang 8. On
peut voir que la NMI et la F-BCubed fournissent des rÃ©sultats signicati-
vement diÃ©rents. Le coecient de rang de Spearman moyen entre les deux
classements est de 0,21, ce qui indique en gÃ©nÃ©ral une corrÃ©lation faible.

J. Creusefond

71

Chapitre 5. Une mÃ©thode de dÃ©tection de communautÃ©s basÃ©e sur
lâ€™algorithme du LexDFS

Chaque rang sera rÃ©fÃ©rencÃ© dans le paragraphe suivant sous la forme ğ‘Ÿğ‘ğ‘›ğ‘”-

ğ‘›ğ‘šğ‘–/ğ‘Ÿğ‘ğ‘›ğ‘”-ğ‘“ ğ‘ğ‘ğ‘¢ğ‘ğ‘’ğ‘‘.

On remarque tout d'abord que la conductance fournissent des partitions
relativement proches de celles d'amazon par rapport aux autres algorithmes :
3/1. La conductance comme sÃ©lecteur du Lex-Clustering produit de trÃ¨s bons
scores sur ces graphes amazon (3/1), cora (3/2) et CS (4/2). Les partitions
sÃ©lectionnÃ©es par cette fonction de qualitÃ© ont cependant de trÃ¨s mauvais
rÃ©sultats sur le reste des jeux de donnÃ©es. La compacitÃ© et la modularitÃ©
ont des rÃ©sultats relativement similaires : de bons scores sur les donnÃ©es dblp
(2/3, 3/2), actors (6/3, 1/2) et github (4/1, 1/3).

En rÃ©sumÃ©, comparer de multiples fonctions de qualitÃ© en tant que sÃ©-
lecteurs du Lex-Clustering permet d'obtenir des rÃ©sultats signicativement
diÃ©rents. La conductance a de trÃ¨s bons rÃ©sultats sur les rÃ©seaux liÃ©s Ã  la
publication scientique (un contexte, comme dÃ©crit Chap. 6). L'utilisation
de la compacitÃ© et de la modularitÃ© donne de bons rÃ©sultats sur des rÃ©seaux
de collaboration : dblp, actors et github. La qualitÃ© d'un sÃ©lecteur est donc
dÃ©pendante de la vÃ©ritÃ© de terrain. On remarque que certains sÃ©lecteurs cor-
respondent Ã  plusieurs vÃ©ritÃ©s de terrain.

En m'inspirant d'Ã©tudes portant sur la diusion de l'information dans
les rÃ©seaux sociaux, j'ai proposÃ© d'utiliser le LexDFS pour dÃ©tecter des
communautÃ©s. Cet algorithme de parcours de graphe visite les zones
denses du graphe en un nombre faible d'itÃ©rations. J'ai utilisÃ© cette pro-
priÃ©tÃ© dans un algorithme hiÃ©rarchique de complexitÃ© log-linÃ©aire, le Lex-
Clustering. Les expÃ©riences ont montrÃ© que cet algorithme produit des
rÃ©sultats trÃ¨s proches de ce qui est observÃ© dans diÃ©rents jeux de don-
nÃ©es, suivant la fonction de qualitÃ© utilisÃ©e comme sÃ©lecteur.

Nous avons vu que l'on pouvait Ã©valuer un algorithme de dÃ©tection
de communautÃ©s de plusieurs faÃ§ons. Des fonctions de qualitÃ© et des
jeux de donnÃ©es peuvent Ãªtre utilisÃ©s pour cette Ã©valuation. D'un cÃ´tÃ©,
les propriÃ©tÃ©s mesurÃ©es par les fonctions de qualitÃ© sont bien identiÃ©es.
D'un autre cÃ´tÃ©, les implications de la proximitÃ© des rÃ©sultats avec les
vÃ©ritÃ©s de terrain sont moins claires. Dans le prochain chapitre, j'Ã©tudie
la relation entre les deux mÃ©thodes d'Ã©valuation.

72

J. Creusefond

Chapitre 6

Lâ€™Ã©valuation de structures
communautaires

On peut Ã©valuer les partitions dâ€™un graphe en appliquant des fonc-
tions de qualitÃ© et en les comparant Ã  des vÃ©ritÃ©s de terrain. Dans
ce chapitre, je fais le lien entre les deux mÃ©thodes en analysant
la corrÃ©lation entre les classements des partitions selon chaque
Ã©valuation.

Les travaux prÃ©sentÃ©s dans ce chapitre ont fait lâ€™objet de la

publication [27].

Yang et Leskovec [103] distinguent communautÃ©s structurelles et fonc-
tionnelles. Les communautÃ©s structurelles sont dÃ©nies par les propriÃ©tÃ©s du
graphe, tandis que les communautÃ©s fonctionnelles sont caractÃ©risÃ©es par un
passÃ© ou un intÃ©rÃªt commun de leurs membres.

Ces communautÃ©s fonctionnelles apparaissent notamment dans les mÃ©ta-
donnÃ©es associÃ©es aux rÃ©seaux. Par exemple, on trouve l'appartenance expli-
cite Ã  des groupes dans les mÃ©tadonnÃ©es des sites web de rÃ©seaux sociaux.

Une motivation de la dÃ©tection de communautÃ©s peut Ãªtre la recherche de
communautÃ©s fonctionnelles. Dans ce but, les algorithmes sont comparÃ©s aux
mÃ©tadonnÃ©es, utilisÃ©es alors comme vÃ©ritÃ© de terrain (par exemple [52, 79]).
Un algorithme est considÃ©rÃ© comme performant dans ce cas si les partitions
qu'il produit sont similaires aux mÃ©tadonnÃ©es.

Je dÃ©nis la cohÃ©rence entre fonctions de qualitÃ© et vÃ©ritÃ©s de terrain. Soit
une fonction de qualitÃ© ğ‘„. Soit une vÃ©ritÃ© de terrain ğ‘€ d'un graphe ğº. Soit
un ensemble ğ´ de partitions de ğº. En utilisant ğ‘„ pour Ã©valuer les partitions
de ğ´, on obtient un classement ğ¶ğ‘„(ğ´) des partitions. De la mÃªme maniÃ¨re,
on obtient un classement ğ¶ğ‘€ (ğ´) en comparant avec la vÃ©ritÃ© de terrain. Je
qualie la fonction de qualitÃ© ğ‘„ et la vÃ©ritÃ© de terrain ğ‘€ de cohÃ©rentes si

J. Creusefond

73

Chapitre 6. Lâ€™Ã©valuation de structures communautaires

ğ¶ğ‘„(ğ´) et ğ¶ğ‘€ (ğ´) ont un coecient de rang de Spearman important (Eq. 5.2).
Dans ce chapitre, j'analyse la cohÃ©rence entre fonctions de qualitÃ© et vÃ©ri-
tÃ©s de terrain. J'identie des vÃ©ritÃ©s de terrain ayant une cohÃ©rence similaire
avec les fonctions de qualitÃ©, et j'appelle ces ensembles des contextes. Je
dÃ©termine aussi les fonctions de qualitÃ© correspondant le mieux Ã  chaque
contexte.

Utiliser ces vÃ©ritÃ©s de terrain a rÃ©cemment Ã©tÃ© critiquÃ© par Peel et al. [77].
Ils prÃ©sentent quatre raisons pour que le rÃ©sultat d'un algorithme de dÃ©tection
de communautÃ©s ne soit pas similaire Ã  la vÃ©ritÃ© de terrain :

1. la structure de la vÃ©ritÃ© de terrain n'est pas liÃ©e Ã  la structure du rÃ©seau,
2. la structure de la vÃ©ritÃ© de terrain et l'algorithme de dÃ©tection de com-

munautÃ©s capturent des aspects diÃ©rents du rÃ©seau,

3. le rÃ©seau ne prÃ©sente pas de structure communautaire,
4. l'algorithme de dÃ©tection de communautÃ©s n'est pas adaptÃ© Ã  la dÃ©tec-

tion des communautÃ©s fonctionnelles.

Pour les auteurs, utiliser les mÃ©tadonnÃ©es comme vÃ©ritÃ© de terrain Ã©quivaut
Ã  supposer que seul le cas 4 est possible.

Tout d'abord, il n'est pas clair que les cas 2 et 4 sont diÃ©rents. En
eet, chaque algorithme capture un aspect diÃ©rent du rÃ©seau, et c'est la
pertinence de cet aspect qui fait la pertinence de l'algorithme. Ensuite, les
cas 1 et 3 impliquent que le rÃ©seau et les mÃ©tadonnÃ©es ne correspondent
pas aux suppositions que je fais sur les propriÃ©tÃ©s des rÃ©seaux sociaux. Je
considÃ¨re donc la comparaison des partitions avec les vÃ©ritÃ©s de terrain comme
pertinente pour la recherche de communautÃ©s fonctionnelles.

Le lien entre les communautÃ©s fonctionnelles et structurelles est aussi
Ã©tudiÃ© par Hric et al. [49]. Ils montrent que les algorithmes de dÃ©tection de
communautÃ©s actuels produisent des partitions assez Ã©loignÃ©es des vÃ©ritÃ©s de
terrain et soulignent la nÃ©cessitÃ© d'algorithmes plus adaptÃ©s.

Les fonctions de qualitÃ© ont Ã©tÃ©s Ã©tudiÃ©es par d'autres auteurs.
Yang et Leskovec [103] ont analysÃ© 12 fonctions de qualitÃ© pouvant Ãªtre
appliquÃ©es au niveau de la communautÃ©. Leurs expÃ©riences identient les
propriÃ©tÃ©s que mesurent ces fonctions de qualitÃ©.

Almeida et al. [2] ont comparÃ© le rÃ©sultat de quatre algorithmes en utili-
sant cinq fonctions de qualitÃ© sur cinq jeux de donnÃ©es. Ils ont notamment
observÃ© que certaines fonctions de qualitÃ© ont tendance Ã  favoriser des  clus-
ters  de plus grande taille, et inversement.

74

J. Creusefond

6.1. MÃ©thodologie expÃ©rimentale

Chakraborty et al. [18] ont utilisÃ© une mÃ©thodologie similaire Ã  celle que
je mets en place dans le but de mesurer la performance de leur fonction de
qualitÃ© sur quelques jeux de donnÃ©es. Les approches diÃ¨rent donc par le
but, mais aussi par l'Ã©chelle : les expÃ©riences que je mets en place incluent
un nombre bien plus important de jeux de donnÃ©es, fonctions de qualitÃ© et
d'algorithmes.

6.1 MÃ©thodologie expÃ©rimentale

Mes expÃ©riences ont deux objectifs. Tout d'abord, j'identie des contextes.
Ensuite, je repÃ¨re les fonctions de qualitÃ© cohÃ©rentes avec chaque contexte.
Pour chaque graphe ayant une vÃ©ritÃ© de terrain, j'exÃ©cute les Ã©tapes sui-

vantes :

1. L'application d'algorithmes de dÃ©tection de communautÃ©s sur le graphe.
2. Le calcul de fonctions de qualitÃ© sur les partitions rÃ©sultantes.
3. La comparaison des partitions de l'Ã©tape 1 avec la vÃ©ritÃ© de terrain,

crÃ©ant un score de rÃ©fÃ©rence pour chaque partition.

4. La mesure de la cohÃ©rence entre chaque vÃ©ritÃ© de terrain et chaque

fonction de qualitÃ©.

Les Ã©tapes de cette mÃ©thodologie sont reprÃ©sentÃ©es Fig. 6.1.
AprÃ¨s l'exÃ©cution de ces Ã©tapes pour chaque jeu de donnÃ©es, j'applique
le coecient de rang de Spearman entre les rÃ©sultats de cohÃ©rence des dif-
fÃ©rentes fonctions de qualitÃ© pour chaque paire de graphes. Cette derniÃ¨re
Ã©tape permet l'identication de contextes. Je peux ensuite, par l'analyse des
mesures produite par l'Ã©tape 4, reconnaÃ®tre les fonctions de qualitÃ© cohÃ©rentes
avec des contextes.

J. Creusefond

75

Chapitre 6. Lâ€™Ã©valuation de structures communautaires

Figure 6.1  Ã‰tapes de la mÃ©thodologie expÃ©rimentale

6.2 ParamÃ¨tres expÃ©rimentaux

Les algorithmes de dÃ©tection de communautÃ© utilisÃ©s sont Louvain, Clau-
set, MCL, Infomap, Label propagation et 3-core (voir Sec. 2.4) ainsi que
LexDFS (voir Chap. 5). Les fonctions de qualitÃ© utilisÃ©es sont Coecient de
clustering, Permanence, 1-Flake-ODF, FOMD, 1-Cut-ratio, 1-Conductance,
ModularitÃ©, Surprise et Signiance (voir Sec. 2.3) ainsi que la CompacitÃ©
(voir Chap. 4) Les mÃ©thodes de comparaison utilisÃ©es sont la NMI et la fb3.
Elles sont dÃ©crites Sec. 2.5.

J'applique la mÃ©thodologie sur 10 rÃ©seaux. Les noeuds qui n'appartiennent
Ã  aucun  cluster  dans les vÃ©ritÃ©s de terrain sont supprimÃ©s et seule la
composante connexe la plus grande est utilisÃ©e. Je note â†’ pour les rÃ©seaux
orientÃ©s, et

pour les communautÃ©s chevauchantes.

RÃ©seaux de collaboration (voir Tab. 6.1). Ces rÃ©seaux reprÃ©sentent des
individus travaillant ensemble.

Le rÃ©seau  Computer Science  (CS) provient de la mÃªme source que
le rÃ©seau  DBLP . CS est cependant composÃ© uniquement de scientiques
travaillant en informatique. De plus, les vÃ©ritÃ©s de terrain sont diÃ©rentes. Les
rÃ©seaux  actors  et  github  sont construit Ã  partir de graphes bipartis,
et sont composÃ©s de cliques Ã  l'intÃ©rieur des communautÃ©s.

1. http://snap.stanford.edu/data/
2. http://konect.uni-koblenz.de
3. https://github.com/blog/466-the-2009-github-contest

76

J. Creusefond

SpearmanVÃ©ritÃ©sde terrainGraphesPartitionnementMÃ©thodes decomparaisonFonctionsde qualitÃ©PartitionsScores de rÃ©fÃ©renceScores12346.2. ParamÃ¨tres expÃ©rimentaux

Nom

ğ‘š
DBLP1 [103] 130k 333k

ğ‘›

noeuds
auteurs

arÃªtes

co-auteur

CS [16][17]

401k 1428k

auteurs

co-auteur

communautÃ©s
publiÃ© dans le
mÃªme ouvrage

domaine de
publication

Actors

(imdb)2 [8]
Github23

124k 20490k

acteurs

lm commun

lms

40k 22278k dÃ©veloppeurs co-contributions

projets

Table 6.1  RÃ©seaux de collaboration

Nom

ğ‘›

ğ‘š

noeuds

communautÃ©s
LiveJournal1 [103] 1143k 16881k bloggeurs  follow  â†’ groupes explicites
317k youtubeurs  follow  â†’ groupes explicites
51k
368k 11916k utilisateurs  follow  â†’ groupes explicites

Youtube1 [103]

Flickr [71]

arÃªtes

Table 6.2  Sites web de rÃ©seaux sociaux

Sites web de rÃ©seaux sociaux (Â« Online Social Networks Â», OSN)
(voir Tab. 6.2). Ces rÃ©seaux reprÃ©sentent des relations explicites entre indi-
vidus sur des sites web.

Le site web  LiveJournal  permet de poster des blogs en ligne.  You-
tube  est une plate-forme de partage de vidÃ©os. L'activitÃ© principale sur
 Flickr  est le partage de photographies. Ces sites incluent la possibilitÃ© de
se connecter entre utilisateurs. Ils permettent aux utilisateurs de rejoindre
librement des groupes explicites.

Sur ces sites, les liens sont orientÃ©s. Les auteurs originaux ont cependant
considÃ©rÃ© que les traiter comme des rÃ©seaux non dirigÃ©s Ã©tait raisonnable du
fait que la plupart des liens existaient dans les deux sens.

RÃ©seaux proches des rÃ©seaux sociaux (voir Tab. 6.3). Les noeuds de
ces rÃ©seaux ne reprÃ©sentent pas des individus, mais les rÃ©seaux en eux-mÃªmes
dÃ©crivent une forme d'interaction sociale.

1. http://snap.stanford.edu/data/

J. Creusefond

77

Chapitre 6. Lâ€™Ã©valuation de structures communautaires

Nom

ğ‘› ğ‘š
Amazon1 [103] 148k 267k

noeuds
produits

arÃªtes

communautÃ©s

achat commun

catÃ©gories

Football [39]

115 613

Ã©quipes de

1 match ou plus

divisions

Cora2 [88]

23k 89k

football
articles

scientiques

citations â†’

catÃ©gories

frÃ©quent

Table 6.3  RÃ©seaux semi-sociaux

 Amazon  renseigne les produits frÃ©quemment achetÃ©s avec ceux que
l'on consulte. Les catÃ©gories de produits forment la vÃ©ritÃ© de terrain. Le
rÃ©seau  Football  correspond aux matchs d'Ã©quipes de football universitaires
amÃ©ricaines en automne 2000, et les mÃ©tadonnÃ©es sont les divisions. Le rÃ©seau
 Cora  est formÃ© d'un ensemble de publications scientiques provenant d'un
dÃ©pÃ´t en ligne. Les publications sont liÃ©es par une arÃªte si l'une cite l'autre,
et les mÃ©tadonnÃ©es sont les domaines scientiques des papiers.

RÃ©seaux artificiels J'utilise le benchmark de Lancichinetti-Fortunato-Radicchi
(LFR) [59] comme outil d'Ã©tude de la mÃ©thodologie. Il s'agit d'un modÃ¨le de
gÃ©nÃ©ration de graphes et de structures communautaires.

Plusieurs paramÃ¨tres permettent de modier le comportement de ce mo-

dÃ¨le :

 ğ‘› : le nombre de noeuds,
 Ë†ğ‘˜ : le degrÃ© moyen,
 ğ‘˜ğ‘šğ‘ğ‘¥ : le degrÃ© maximum,
 ğœ‡ : le ratio degrÃ© externe/degrÃ© interne des noeuds,
 ğ‘¡1 : le coecient de la loi de puissance de la distribution des degrÃ©s
 ğ‘¡2 : le coecient de la loi de puissance de la distribution des tailles des

communautÃ©s,

 Ë†ğ‘ğ‘ : coecient de clustering moyen,
 ğ‘œğ‘› : le nombre de noeuds appartenant Ã  plusieurs communautÃ©s,
 ğ‘œğ‘š : le nombre de communautÃ©s auxquels ceux-ci appartiennent.

1. http://snap.stanford.edu/data/
2. http://konect.uni-koblenz.de

78

J. Creusefond

6.3. Optimisations

ğ‘›

nom
LFRa 10 000
LFRb 100 000
LFRc 10 000
LFRd 10 000
LFRe 10 000

Ë†ğ‘˜
50
50
100
50
100

ğ‘˜ğ‘šğ‘ğ‘¥
1k
2,5k
500
1k
500

ğœ‡
0.1
0.1
0.4
0.1
0.4

ğ‘¡1
2.5
2.5
2.1
2.5
2.1

ğ‘¡2
2.5
2.5
2.0
2.5
2.0

Ë†ğ‘ğ‘
0.2
0.2
0.1
0.2
0.1

ğ‘œğ‘›
8k
80k
8k
0
0

ğ‘œğ‘š
4
4
5
0
0

Table 6.4  Les paramÃ¨tres des cinq classes de rÃ©seaux articiels LFR

Comme prÃ©sentÃ© Ã  la Tab. 6.4, je compose 5 classes de rÃ©seaux. Celles-ci
sont diÃ©renciÃ©es par les paramÃ¨tres du LFR qui les gÃ©nÃ¨rent. Je les crÃ©e
de telle maniÃ¨re que les classes a, b et d ont beaucoup de paramÃ¨tres du
LFR en commun, et les classes c et e sont diÃ©rentes. Les rÃ©seaux de la
classe a prÃ©sentent des communautÃ©s sÃ©parÃ©es (ğœ‡ faible) et chevauchantes.
La classe b a les mÃªmes paramÃ¨tres que la classe a, mais avec 10 fois plus de
noeuds. Notons que le degrÃ© maximal n'Ã©volue pas de maniÃ¨re linÃ©aire avec
l'augmentation de taille, mais par la loi de puissance de paramÃ¨tre 2,5. Ainsi
une multiplication par 10 entraÃ®ne une augmentation par 101/2,5 âˆ¼ 2,5.

La classe c a des paramÃ¨tres trÃ¨s diÃ©rents de la classe a, sauf en ce qui
concerne la taille. Les classes d et e sont respectivement similaires aux classes
a et c, mais les communautÃ©s n'y sont pas chevauchantes.

6.3 Optimisations

Trois mesures prennent beaucoup de ressources dans ces expÃ©riences : le
calcul du diamÃ¨tre, le comptage des triangles et la fb3. Pour le calcul du
diamÃ¨tre, j'utilise la mÃªme approche que celle dÃ©veloppÃ©e Sec. 5.2. ğ‘“ğ‘ğ‘™ğ‘¢ğ‘  et
ğ‘“ğ‘ğ‘’ğ‘Ÿğ‘š nÃ©cessitent le calcul du nombre de triangles internes qui peut Ãªtre trÃ¨s
grand pour des graphes ayant des zones trÃ¨s denses. La fb3 est en ğ’ª(|ğ‘|2) en
temps pour le calcul des valeurs de la communautÃ© ğ‘, ce qui pose problÃ¨me
pour les communautÃ©s de taille importante.

J'Ã©chantillonne ces valeurs. La borne de Hoeding [46] permet de borner
l'erreur ainsi faite, les Ã©chantillons Ã©tant i.i.d et dans l'intervalle [0,1]. Cette
borne donne une indication du nombre d'Ã©chantillons ğ‘¡ nÃ©cessaires pour ob-
tenir une prÃ©cision satisfaisante. Soit ğ‘ la probabilitÃ© que l'erreur rÃ©sultant
de l'Ã©chantillonnage dÃ©passe ğœ–. La borne est alors :

ğ‘ƒ (|ğ‘‹ âˆ’ ğ¸[ğ‘‹]| â‰¥ ğœ–) = ğ‘ â‰¤ 2ğ‘’âˆ’2ğ‘›ğœ–2 â‡” ğ‘› â‰¥ ğ‘™ğ‘›(ğ‘/2)
âˆ’2ğœ–2

(6.1)
J'utilise 5000 Ã©chantillons, ce que signie que ğ‘ â‰¤ 5% et ğœ– â‰¤ 0.02. En pra-

J. Creusefond

79

Chapitre 6. Lâ€™Ã©valuation de structures communautaires

tique, on observe des erreurs d'environ 10âˆ’4, ce qui est trop faible pour per-
turber les rÃ©sultats.

Du fait que je prenne en compte le classement des mesures, des erreurs
bornÃ©es peuvent avoir des eets non bornÃ©s si des mesures ont des rÃ©sultats
trÃ¨s proches. De plus, quelques algorithmes de dÃ©tection de communautÃ©
sont alÃ©atoires, ce qui implique une potentielle diÃ©rence incontrÃ´lable dans
les rÃ©sultats. An d'observer l'inuence de ces eets, les calculs ont Ã©tÃ©s
eectuÃ©s entiÃ¨rement plusieurs fois. Il n'a Ã©tÃ© observÃ© que des diÃ©rences
minimes entre les rÃ©sultats.

6.4 RÃ©sultats

J'applique la mÃ©thodologie sur les graphes gÃ©nÃ©rÃ©s par le LFR. Pour
chaque classe, je gÃ©nÃ¨re alÃ©atoirement trois rÃ©seaux avec les paramÃ¨tres dÃ©-
crits Sec. 6.2. Ainsi, je peux observer l'eet de l'alÃ©atoire dans le processus de
gÃ©nÃ©ration du LFR sur la stabilitÃ© de la mÃ©thode. Les rÃ©sultats sont reportÃ©s
Tab. 6.5 et Tab. 6.6 pour la NMI et la fb3 respectivement.

c2

c3

d1 d2 d3

e1

e2

a1 a2 a3 b1 b2 b3 c1

e3
a1 - 1.00 1.00 0.98 0.99 0.45 0.40 -0.23 -0.09 0.53 0.53 0.53 0.69 0.31 0.95
- 1.00 0.98 0.99 0.45 0.40 -0.23 -0.09 0.53 0.53 0.53 0.69 0.31 0.95
a2 -
a3 -
- 0.98 0.99 0.45 0.43 -0.22 -0.07 0.53 0.53 0.53 0.69 0.31 0.94
-
- 0.99 0.48 0.35 -0.15 0.01 0.53 0.53 0.53 0.69 0.31 0.92
-
-
b1 -
b2 -
-
-
-
- 0.46 0.34 -0.21 -0.07 0.53 0.53 0.53 0.69 0.31 0.94
b3 -
- 0.29 0.03 0.21 0.15 0.15 0.15 0.67 0.56 0.42
-
-
-
-
0.07 0.15 0.27 0.27 0.27 0.30 0.25 0.41
-
-
-
-
-
c1 -
0.90 0.34 0.34 0.34 -0.12 0.05 -0.32
-
-
-
-
-
c2 -
c3 -
-
-
-
-
-
0.22 0.22 0.22 -0.03 0.20 -0.16
d1 -
- 1.00 1.00 0.47 0.12 0.47
-
-
-
-
-
- 1.00 0.47 0.12 0.47
-
-
-
-
-
-
d2 -
d3 -
-
-
-
-
-
-
-
0.47 0.12 0.47
0.76 0.70
-
-
-
-
-
-
-
e1 -
-
-
-
-
-
-
-
e2 -
0.35
e3 -
-
-
-
-
-
-
-

-
-
-
-
-
-
-
-
-

-
-
-
-
-
-
-
-

-
-
-
-
-
-
-

-
-
-
-

-
-
-

-
-

-

Table 6.5  La corrÃ©lation entre le classement des fonctions de qualitÃ© four-
nies par la NMI pour les graphes synthÃ©tiques du LFR

Dans la Tab. 6.5, on peut voir que les scores intra-classes sont particu-
liÃ¨rement Ã©levÃ©s. Les fonctions de qualitÃ© ont donc des classements similaires
pour les graphes des mÃªmes classes. Il y a cependant quelques exceptions.

80

J. Creusefond

6.4. RÃ©sultats

Par exemple, le classement des fonctions de qualitÃ© sur c1 semble Ãªtre plus
proche de celui des graphes de la classe a que de sa propre classe. L'exis-
tence de ces variations est due Ã  la nature alÃ©atoire du modÃ¨le gÃ©nÃ©rateur.
La mÃ©thodologie utilisant la NMI est donc sensible Ã  des variations dues aux
paramÃ¨tres non contrÃ´lÃ©s par le modÃ¨le LFR.

Les similaritÃ©s attendues sont observÃ©es : les graphes de la classe a ont
des scores globalement proches de ceux des classes b et d. Cependant, les
graphes de la classe e sont proches de ceux de la classe a, une observation
qui est aussi vraie pour la fb3 (cf Tab. 6.6). Le fait que les communautÃ©s de
la classe e ne soient pas chevauchantes semble donc diminuer l'impact de la
diÃ©rence des autres paramÃ¨tres sur la proximitÃ© entre les classes a et e.

Ainsi, l'application de la mÃ©thodologie avec la NMI comme mÃ©thode de
comparaison a globalement le comportement attendu. La procÃ©dure est par-
fois inuencÃ©e par des caractÃ©ristiques alÃ©atoires dans le modÃ¨le LFR.

c1

c2

c3

d1

d2

d3

e1

e2

a1 a2 a3 b1 b2 b3

e3
a1 - 0.99 1.00 0.95 0.94 0.96 -0.23 -0.50 -0.44 0.72 0.72 0.72 0.89 0.89 0.88
a2 -
- 0.99 0.94 0.93 0.94 -0.26 -0.48 -0.42 0.70 0.70 0.70 0.89 0.87 0.88
- 0.95 0.94 0.96 -0.23 -0.50 -0.44 0.72 0.72 0.72 0.89 0.89 0.88
-
a3 -
- 1.00 1.00 -0.26 -0.49 -0.44 0.80 0.80 0.80 0.90 0.92 0.93
-
-
b1 -
b2 -
-
-
-
- 1.00 -0.27 -0.48 -0.43 0.80 0.80 0.80 0.90 0.92 0.93
-0.25 -0.49 -0.43 0.80 0.80 0.80 0.90 0.91 0.92
-
-
-
-
b3 -
0.62 0.76 -0.27 -0.27 -0.27 -0.42 -0.38 -0.37
-
-
-
-
c1 -
c2 -
-
-
-
-
0.90 -0.26 -0.26 -0.26 -0.49 -0.51 -0.37
c3 -
-0.31 -0.31 -0.31 -0.47 -0.47 -0.39
-
-
-
-
1.00 1.00 0.75 0.78 0.79
-
-
-
-
d1 -
d2 -
1.00 0.75 0.78 0.79
-
-
-
-
d3 -
-
-
-
-
0.75 0.78 0.79
e1 -
0.98 0.96
-
-
-
-
-
-
-
-
e2 -
0.96
e3 -
-
-
-
-

-
-
-
-
-
-
-
-
-
-

-
-
-
-
-
-
-
-
-

-
-
-
-
-
-
-
-

-
-
-
-
-
-
-

-
-
-
-
-
-

-
-
-
-
-

-
-
-
-

-
-
-

-
-

-

Table 6.6  La corrÃ©lation entre le classement des fonctions de qualitÃ© four-
nies par la NMI pour les graphes synthÃ©tiques du LFR

Dans la Tab. 6.6, on observe que les corrÃ©lations en utilisant la fb3 ne
prÃ©sente aucune valeur entre -0.2 et 0.6. Il n'y a donc pas de corrÃ©lation faible.
La classe c est considÃ©rÃ©e comme trÃ¨s diÃ©rente des autres car ses rÃ©sultats
sont tous anticorrÃ©lÃ©s avec ceux des autres classes. La corrÃ©lation intra-classes
est particuliÃ¨rement forte, supÃ©rieure Ã  0.95 pour toutes les classes sauf la c
oÃ¹ l'alÃ©atoire semble avoir un lÃ©ger rÃ´le, avec une corrÃ©lation c1/c2 Ã  0.62.

J. Creusefond

81

Chapitre 6. Lâ€™Ã©valuation de structures communautaires

Comme indiquÃ© prÃ©cÃ©demment, les rÃ©sultats de la fb3 ne semblent pas prendre
en compte la diÃ©rence de paramÃ¨tres de la classe e.

En conclusion, les rÃ©sultats de la fb3 sont moins sensibles Ã  la gÃ©nÃ©ration
alÃ©atoire du LFR que ceux de la NMI. Cependant, la diÃ©rence de recouvre-
ment fait que la classe e est considÃ©rÃ©e comme ressemblante aux autres.

J'applique la mÃªme mÃ©thodologie sur l'ensemble des donnÃ©es rassemblÃ©es.
L'objectif est alors d'identier les contextes. Contrairement au LFR, il n'y a
pas de contrÃ´le prÃ©cis des propriÃ©tÃ©s des rÃ©seaux en question, simplement la
connaissance de l'environnement d'origine des rÃ©seaux.

Les rÃ©sultats des jeux de donnÃ©es rÃ©els sont bien moins extrÃªmes que ceux
des graphes gÃ©nÃ©rÃ©s. NÃ©anmoins, on peut voir Tab. 6.7 et 6.8 que les tuples de
jeux de donnÃ©es (cora, CS) et (flickr, lj, youtube) ont un score important
par les deux mÃ©thodes de comparaison.

Cette observation est explicable par la similaritÃ© de l'origine de ces rÃ©-
seaux. MÃªme si ce que reprÃ©sentent les noeuds est diÃ©rent, Cora et CS
correspondent tous deux Ã  des publications scientiques et leurs vÃ©ritÃ©s de
terrain Ã  des domaines de publication. Youtube, ickr et lj ont aussi des
mÃ©caniques similaires : la crÃ©ation de lien est due Ã  un individu suivant les
publications d'un autre, et les structures communautaires sont des groupes
explicites. Les autres corrÃ©lations observÃ©es diÃ¨rent suivant la mÃ©thode de
comparaison utilisÃ©e.

CS actors amazon cora dblp ickr football github
youtube
- 0.923 0.281 0.972 0.302 0.103 0.245 0.014 0.253 -0.187
0.264 0.899 0.276 0.168 0.318 0.105 0.262 -0.077
-
actors
amazon -
0.280 0.965 -0.231 0.523 -0.033 -0.269 -0.336
cora
0.327 0.115 0.213 0.052 0.334 -0.191
-
-0.238 0.453 0.031 -0.241 -0.357
-
dblp
0.180 0.367 0.808 0.759
ickr
-
football
-
0.350 -0.191 0.117
0.329 0.549
github -
-
0.587
youtube -

-
-
-
-
-
-
-
-
-

-
-
-
-
-
-
-
-

lj

-
-

CS

lj

-
-
-
-

-
-
-

-

-
-
-
-
-
-
-

-
-
-
-
-
-

-
-
-
-
-

Table 6.7  Le coecient de Spearman des lignes de Tab.6.9 (NMI)

Tab. 6.7, NMI : Je note tout d'abord que le tuple (cora, CS) est Ã©tendu
par un autre rÃ©seau de collaboration Ã  (cora, CS, actors). J'observe de plus

82

J. Creusefond

6.4. RÃ©sultats

une corrÃ©lation inattendue : (dblp, amazon). Comme observÃ© Tab. 6.9, ces
rÃ©sultats sont dus Ã  de multiples valeurs de cohÃ©rence proches de zÃ©ro. Les
autres corrÃ©lations observÃ©es avec la NMI sont Ã©galement observÃ©es avec la
fb3.

CS actors amazon cora dblp ickr football github
-
actors
-
amazon -
-
cora
-
dblp
-
ickr
football
-
github -
-
youtube -

youtube
-0.070 0.920 0.970 0.502 0.224 -0.434 -0.344 -0.351 -0.035
-0.052 -0.157 0.472 -0.091 0.776 0.774 0.434 0.227
0.935 0.411 0.189 -0.455 -0.378 -0.316 -0.105
0.409 0.358 -0.456 -0.381 -0.266 0.040
0.250 0.163 0.187 0.143 0.456
0.154 0.156 0.533 0.790
0.911 0.719 0.497
0.654 0.414
0.760

-
-
-
-
-
-
-
-
-

lj

-
-

CS

lj

-
-
-
-

-
-
-

-
-
-
-
-
-
-
-

-
-
-
-
-
-
-

-
-
-
-
-
-

-
-
-
-
-

-

Table 6.8  Le coecient de Spearman des lignes de Tab. 6.10 (fb3)

Tab. 6.8, fb3 : On note une autre corrÃ©lation surprenante Tab. 6.8 entre
le rÃ©seau de co-achats et les rÃ©seaux de publication (amazon, cora, CS).
Ces corrÃ©lations proviennent encore une fois des valeurs de cohÃ©rence faibles
observÃ©es Tab. 6.10.

Les rÃ©seaux avec une forte densitÃ© interne, (actor, football, github),
ont une forte corrÃ©lation interne en observant les classements des fonctions
de qualitÃ© avec la fb3. Le point commun de ces rÃ©seaux est une densitÃ© Ã©levÃ©e
Ã  l'intÃ©rieur des communautÃ©s.

J'analyse maintenant les corrÃ©lations entre les fonctions de qualitÃ© et les
mÃ©thodes de comparaison. Je cherche principalement les fonctions cohÃ©rentes
avec les jeux de donnÃ©es des contextes.

En utilisant la fb3 (Tab. 6.10), on voit qu'aucune fonction de qualitÃ©
n'a de cohÃ©rence haute et consistante dans le contexte des OSN (ickr, lj,
youtube). Cependant, les rÃ©sultats de la NMI et de la fb3 sont anti-corrÃ©lÃ©s
dans ce contexte, avec des coecients de Spearman allant de -0.71 Ã  -0.89.
Ainsi, Tab. 6.9 montre que la modularitÃ© a de fortes valeurs de cohÃ©-
rence avec les rÃ©sultats de la NMI dans ce contexte. La propriÃ©tÃ© du rapport

J. Creusefond

83

Chapitre 6. Lâ€™Ã©valuation de structures communautaires

ickr

cc
0.00 -0.71 0.75 1.00 0.61 0.07 0.61
-0.21 -0.86 0.43 1.00 0.21 -0.18 0.50
youtube 0.36 -0.89 0.96 1.00 0.79 0.39 0.68
0.06 0.69 -0.06 1.00 0.06 -0.06 0.19
0.00 0.82 -0.25 1.00 0.00 -0.14 0.14

cora
CS

lj

0.14
0.07
0.32
0.25
0.11
0.07
0.69
0.06
0.61 -0.04
actors -0.54 0.46 -0.89 1.00 -0.21 -0.50 -0.21 -0.21 -0.39
football 0.38 0.38 0.10 1.00 0.88 0.38 -0.37 0.56
0.38
github -0.29 -0.36 -0.11 1.00 -0.07 0.11 -0.11 -0.04 -0.43
amazon -0.30 0.03 -0.97 1.00 -0.97 -0.12 -0.97 -0.87 0.03
dblp -0.43 0.89 -0.96 1.00 -0.96 -0.32 -0.89 -0.57 0.18

fb3 mod nmi perm sign cond FOMD comp cut_ratio f-odf sur
0.61 -0.75
0.50 -0.32
0.68 0.61
0.19 -0.06
0.00 -0.46
-0.32 -0.57
-0.33 0.38
0.07 -0.04
-0.97 -0.44
-0.86 -0.46

-0.01
0.35
0.31
0.44
0.32
-0.21
-0.87
-0.14
-0.96
-0.88

Table 6.9  Le coecient de Spearman de la NMI(vÃ©ritÃ© de terrain, algo-
rithmes) comparÃ© aux rÃ©sultats de la fonction de qualitÃ©

densitÃ© interne/externe Ã©voquÃ©e Chap. 4 semble prÃ©valoir pour ce contexte
en utilisant la NMI. En eet, les fonctions de qualitÃ© ayant un score Ã©levÃ©
prennent toutes cette propriÃ©tÃ© en compte (modularitÃ©, permanence, f-odf et
conductance).

Les rÃ©sultats des deux mÃ©thodes de comparaison sur les rÃ©seaux du contexte
de la collaboration scientique (cora, CS) sont corrÃ©lÃ©s avec la FOMD. Une
FOMD Ã©levÃ©e implique qu'un grand nombre d'individus a un degrÃ© interne
Ã©levÃ©, elle mesure donc la propriÃ©tÃ© de densitÃ© interne. On note le score as-
sez Ã©levÃ© de certaines fonctions mesurant le ratio interne/externe (cut-ratio,
conductance, f-odf).

On n'observe aucune fonction de qualitÃ© cohÃ©rente avec les rÃ©seaux prÃ©-
sentant une densitÃ© interne importante (football, github, actors) avec la NMI.
Cependant, la comparaison avec la fb3 est cohÃ©rente avec la signature et de
la surprise, les deux fonctions de qualitÃ© globales. Elles ont toutes deux la
caractÃ©ristique de comparer la densitÃ© interne Ã  un modÃ¨le nul.

Les deux rÃ©seaux n'appartenant pas Ã  un contexte, amazon et dblp, ne
prÃ©sentent aucune corrÃ©lation satisfaisante avec les fonctions de qualitÃ© uti-
lisÃ©es. Il est possible que les caractÃ©ristiques de ces communautÃ©s soient trÃ¨s
Ã©loignÃ©es de ce que l'on connaÃ®t.

J'observe aussi que la compacitÃ© est cohÃ©rente avec les rÃ©sultats de la fb3
sur les rÃ©seaux Ã  densitÃ© interne importante (football, github, actors). En plus
d'un intÃ©rÃªt thÃ©orique, la compacitÃ© est donc expÃ©rimentalement cohÃ©rente
avec un contexte.

84

J. Creusefond

6.4. RÃ©sultats

youtube 0.04 1.00 -0.86 -0.89 -0.61 -0.07 -0.54 0.04

0.46

ickr

lj

cora
CS

-0.64 1.00 0.04 0.69 0.29 -0.75 0.50
-0.50 1.00 -0.14 0.82 0.14 -0.75 0.39

cc
0.18 1.00 -0.21 -0.71 0.07 0.04 0.07
0.39
0.29 1.00 -0.54 -0.86 -0.14 0.39 -0.46 -0.36 -0.11
0.14
0.89 -0.75
0.75 -0.61
actors 0.29 1.00 -0.07 0.46 -0.79 0.43 -0.79 -0.79 0.18
football 1.00 1.00 0.68 0.38 0.25 1.00 -0.96 -0.05 1.00
github -0.29 1.00 0.39 -0.36 -0.57 0.71 -0.61 -0.79 0.71
amazon -0.86 1.00 -0.04 0.03 -0.04 -0.89 0.00
0.25 -0.93
dblp -0.68 1.00 -0.79 0.89 -0.79 -0.57 -0.64 -0.32 -0.07

fb3 mod nmi perm sign cond FOMD comp cut_ratio f-odf sur
0.07 0.29
-0.46 0.32
-0.54 -0.32
0.50 -0.75
0.18 -0.93
-0.64 0.36
-0.93 1.00
-0.93 0.71
0.00 -0.79
-0.61 -0.71

0.60
-0.38
-0.19
0.79
0.59
-0.79
-0.21
-0.57
-0.01
-0.67

Table 6.10  Le coecient de Spearman de la fb3(vÃ©ritÃ© de terrain, algo-
rithmes) comparÃ© aux rÃ©sultats de la fonction de qualitÃ©

Dans ce chapitre, j'ai prÃ©sentÃ© une mÃ©thodologie permettant d'Ã©tudier
la relation entre l'Ã©valuation par les fonctions de qualitÃ© et l'Ã©valuation
par les vÃ©ritÃ©s de terrain. Ces travaux ont abouti Ã  l'identication de
trois contextes qui correspondent aux sites web de rÃ©seaux sociaux, aux
rÃ©seaux de collaboration scientiques et aux rÃ©seaux Ã  densitÃ© interne
importante. Pour chacun de ces contextes, les deux mÃ©thodes de compa-
raison ont permis de trouver des fonctions de qualitÃ© cohÃ©rentes avec les
vÃ©ritÃ©s de terrain de ces contextes.

Ces travaux conrment l'hypothÃ¨se de base : les vÃ©ritÃ©s de terrain
peuvent Ãªtre regroupÃ©es en diÃ©rents contextes. Identier ces contextes
permet de catÃ©goriser les jeux de donnÃ©es et de mieux comprendre leur
utilisation. Cette identication ne peut se gÃ©nÃ©raliser que si les chercheurs
peuvent facilement analyser ces larges volumes de donnÃ©es. Dans le cadre
de cette thÃ¨se, j'ai dÃ©veloppÃ© un logiciel facilitant cette dÃ©marche, le
 Community Detection Algorithm Comparator  (CoDACom), prÃ©sentÃ©
au prochain chapitre.

J. Creusefond

85

Chapitre 6. Lâ€™Ã©valuation de structures communautaires

86

J. Creusefond

Chapitre 7

CoDACom : une boÃ®te Ã  outils
pour la dÃ©tection de
communautÃ©s

CoDACom est un logiciel permettant dâ€™appliquer une chaÃ®ne de
traitements liÃ©s Ã  la dÃ©tection de communautÃ©s : algorithmes de
dÃ©tection de communautÃ©s, fonctions de qualitÃ©, mÃ©thodes de com-
paraison. Cet outil permet dâ€™analyser sÃ©parÃ©ment chaque Ã©tape du
processus. Ce logiciel est facilement extensible et permet notam-
ment la comparaison dâ€™une nouvelle mÃ©thode avec celles dÃ©jÃ  im-
plÃ©mentÃ©es.

Dans ce chapitre, je prÃ©sente le logiciel CoDACom ( Community Detec-
tion Algorithm Comparator ). Il regroupe une large collection d'outils pour
la dÃ©tection de communautÃ©s. Il peut notamment Ãªtre utilisÃ© pour :

 appliquer diÃ©rents algorithmes de dÃ©tection de communautÃ©s sur des

graphes,

 appliquer diÃ©rentes fonctions de qualitÃ© sur des partitions,
 appliquer diÃ©rentes mÃ©thodes de comparaison entre les vÃ©ritÃ©s de ter-

rain et des partitions,

 Ã©valuer la performance des algorithmes et des fonctions de qualitÃ©,
 identier des contextes.

CoDACom est facilement extensible, un utilisateur peut donc ajouter ses
propres algorithmes/fonctions/mÃ©thodes et les comparer Ã  celles dÃ©jÃ  im-
plÃ©mentÃ©es. Ce logiciel a d'ailleurs Ã©voluÃ© depuis sa conception, et certains

J. Creusefond

87

Chapitre 7. CoDACom : une boÃ®te Ã  outils pour la dÃ©tection de
communautÃ©s

Figure 7.1  L'interface web de CoDACom, en mode dÃ©monstration. Le
chargement de chiers sur le serveur est dÃ©sactivÃ© dans ce mode.

traitements ont Ã©tÃ© implÃ©mentÃ©s depuis la rÃ©alisation des expÃ©riences du cha-
pitre prÃ©cÃ©dent.

CoDACom a Ã©tÃ© Ã©crit en Bourne Shell, C++ (utilisant la bibliothÃ¨que
igraph [28]) et Python. Ce logiciel utilise les autotools 1 pour la compilation
et la gestion des dÃ©pendances. Il est disponible, librement et gratuitement,
sur http://codacom.greyc.fr. Ce site web dÃ©crit aussi son installation et
son utilisation. CoDACom est utilisable via une interface web (Fig. 7.1) ou
en ligne de commande. Je vais dÃ©tailler les fonctionnalitÃ©s de CoDACom en
m'appuyant sur l'interface web.

7.1 Utilisation et fonctionnalitÃ©s

Dans cette section je prÃ©sente l'utilisation de l'interface graphique de

CoDACom. Je dÃ©cris ensuite comment Ã©tendre le logiciel.

Je prÃ©sente les commandes gÃ©nÃ©rales ainsi que la partie prÃ©traitement de
CoDACom Fig. 7.2. Les deux premiers boutons de commande gÃ©nÃ©rales ( 1a

et 1b ) permettent respectivement de dÃ©sÃ©lectionner et sÃ©lectionner toutes
les options de l'interface, c'est-Ã -dire :

1. https://www.gnu.org/software/automake/manual/html_node/Autotools-

Introduction.html

88

J. Creusefond

7.1. Utilisation et fonctionnalitÃ©s

Figure 7.2  Les commandes gÃ©nÃ©rales et la partie prÃ©traitement de l'inter-
face web de CoDACom

 les graphes Ã  convertir 5 (Fig. 7.2),

 les algorithmes de dÃ©tection de communautÃ©s Ã  exÃ©cuter 10 (Fig. 7.10),

 les fonctions de qualitÃ© Ã  appliquer 12 (Fig. 7.11),

 les methodes de comparaison Ã  utiliser 15 (Fig. 7.11).

Le bouton 2 sÃ©lectionne uniquement les algorithmes de dÃ©tection de com-
munautÃ©s linÃ©aires, ce qui peut Ãªtre utile dans le cas d'un traitement sur des
grands graphes. La liste des algorithmes linÃ©aires est crÃ©Ã©e manuellement et
maintenue par le gestionnaire du serveur. Le bouton 3 permet d'obtenir le
chier de log de la derniÃ¨re exÃ©cution de CoDACom.

Un exemple de chier de log est prÃ©sentÃ© Fig. 7.3. Pour des raisons de
prÃ©sentation, la premiÃ¨re colonne contenant le  timestamp  de chaque Ã©vÃ¨-
nement a Ã©tÃ© supprimÃ©e.

La partie prÃ©traitement prÃ©sentÃ©e Fig. 7.2 rÃ©cupÃ¨re et normalise les entrÃ©es
Ã  traiter. Cette partie peut Ãªtre dÃ©sactivÃ©e comme prÃ©sentÃ© Fig. 7.1 an de
ne pas surcharger le serveur. La zone 4 permet de charger sur le serveur les
chiers de graphe et les vÃ©ritÃ©s de terrain qui leur sont associÃ©es. Les formats

J. Creusefond

89

1a23456781bChapitre 7. CoDACom : une boÃ®te Ã  outils pour la dÃ©tection de
communautÃ©s

Figure 7.3  Le chier de log d'une exÃ©cution de CoDACom. Les algorithmes
SCD, LexDFS, label propagation et Clauset sont appliquÃ©s Ã  deux entrÃ©es,
football et karate.

acceptÃ©s sont : graphml 2, gml 3, lgl 4 et ncol 5, et sont reconnus par l'extension
du chier. Un chier ayant une autre extension est lu comme un chier ncol.
Tous ces formats ont une structure de donnÃ©es en liste d'adjacences. Pour
chaque format, je fournis un exemple de deux noeuds reliÃ©s par une arÃªte
Fig. 7.4, 7.5, 7.6 et 7.7. Le format ncol Ã©tant trÃ¨s compact, je l'utilise comme
format interne Ã  CoDACom.

Les chiers de vÃ©ritÃ©s de terrain contiennent, pour chaque ligne, un noeud
suivi des identiants des communautÃ©s auxquelles il appartient. Un exemple
de deux noeuds dont le premier appartient Ã  deux  clusters  et qui ont un
 cluster  en commun (illustrÃ© Fig. 7.8) est fourni Fig. 7.9. J'utilise aussi
ce format pour reprÃ©senter les partitions produites par les algorithmes de

2. http://graphml.graphdrawing.org/
3. http://www.fim.uni-passau.de/index.php?id=17297&L=1
4. http://lgl.sourceforge.net/
5. http://lgl.sourceforge.net/

90

J. Creusefond

7.1. Utilisation et fonctionnalitÃ©s

<?xml version=" 1 . 0 " encoding="UTFâˆ’8"?>
<graphml xmlns=" h t t p : // graphml . graphdrawing . org /xmlns"
x m l n s : x s i=" h t t p : //www. w3 . org /2001/XMLSchemaâˆ’i n s t a n c e "
x s i : s c h e m a L o c a t i o n=" h t t p : // graphml . graphdrawing . org /xmlns

   h t t p : // graphml . graphdrawing . org /xmlns /1.0/ graphml . xsd ">

<graph i d="G" e d g e d e f a u l t=" u n d i r e c t e d ">

<node i d="0"/>
<node i d="1"/>
<edge s o u r c e="0" t a r g e t="1"/>

</graph>
</graphml>

Figure 7.4  Deux noeuds liÃ©s par une arÃªte dans le format Graphml

graph
[

node
[

i d 0

]
node
[

i d 1

]

[

]

edge

source 0
target 1

]

#0
1

Figure 7.5  Deux noeuds liÃ©s par une arÃªte dans le format GML

Figure 7.6  Deux noeuds liÃ©s par une arÃªte dans le format LGL

J. Creusefond

91

Chapitre 7. CoDACom : une boÃ®te Ã  outils pour la dÃ©tection de
communautÃ©s

0 1

Figure 7.7  Deux noeuds liÃ©s par une arÃªte dans le format ncol

dÃ©tection de communautÃ©s.

Figure 7.8  Deux noeuds, n0 et n1, appartiennent respectivement aux
 clusters  (c1, c2) et (c1)

0 1 2
1 1

Figure 7.9  Le chier de vÃ©ritÃ© de terrain illustrÃ© Fig. 7.8

Une fois chargÃ©s sur le serveur, les graphes apparaissent dans la zone 5 .
Ceux pour lesquels une vÃ©ritÃ© de terrain a Ã©tÃ© fournie sont achÃ©s en bleu. Le
bouton de rafraichissement 6 met Ã  jour la liste dans le cas oÃ¹ des graphes
seraient ajoutÃ©s/supprimÃ©s sans passer par l'interface. Un bouton ayant cette
fonction est situÃ© sous chacune des listes similaires de l'interface.

Le prÃ©traitement (bouton 7 ) supprime les boucles (arÃªtes incidentes
Ã  un seul noeud) et ne conserve que la composante connexe la plus grande.
L'identiant des noeuds est modiÃ© pour correspondre Ã  l'ordre de visite d'un
BFS Ã  partir d'un noeud choisi uniformÃ©ment alÃ©atoirement. Ainsi, les indices
des noeuds sont consÃ©cutifs, ce qui est nÃ©cessaire pour certains traitements
de CoDACom. Le prÃ©traitement est appliquÃ© sur les chiers sÃ©lectionnÃ©s dans
la zone 5 . Un chier de correspondance faisant le lien entre les noeuds du
chier de base et le chier prÃ©traitÃ© est disponible via le bouton 8 en plus
des chiers prÃ©traitÃ©s eux-mÃªmes.

92

J. Creusefond

n0n1c2c17.1. Utilisation et fonctionnalitÃ©s

Figure 7.10  La partie traitement de l'interface web de CoDACom

La partie traitement (Fig. 7.10) permet d'appliquer des algorithmes de dÃ©-
tection de communautÃ©s aux graphes prÃ©traitÃ©s. La zone 9 liste les graphes
disponibles. La zone 10 permet la sÃ©lection des algorithmes de dÃ©tection
de communautÃ©s Ã  utiliser pour le traitement. CoDACom inclut les douze
algorithmes de dÃ©tection de communautÃ©s prÃ©sentÃ©s Sec. 2.4. Le bouton 11
exÃ©cute le traitement, qui consiste Ã  appliquer les algorithmes sÃ©lectionnÃ©s
zone 10 sur les graphes sÃ©lectionnÃ©s zone 9 . L'application de chaque algo-
rithme sur chaque graphe peut Ãªtre faite en parallÃ¨le, le nombre maximal de
processus est congurÃ© au niveau du serveur. Le bouton 12 permet d'obte-
nir les chiers de rÃ©sultat. Le format des rÃ©sultat est le mÃªme que les vÃ©ritÃ©s
de terrain fournies en zone 4 .

Les parties analyse et conversion de CoDACom sont prÃ©sentÃ©es Fig. 7.11.
La partie analyse Ã©value les partitions obtenues Ã  l'Ã©tape prÃ©cÃ©dente en leur
appliquant des fonctions de qualitÃ© et par comparaison avec les vÃ©ritÃ©s de
terrain. La zone 13 ache les trois mÃ©thodes de comparaison disponibles :

NMI, F-BCubed et Omega-Index (voir Sec. 2.5). Les boutons 14 permettent
de comparer les partitions fournies par les algorithmes entre elles en utilisant
les mÃ©thodes sÃ©lectionnÃ©es en zone 13 et de tÃ©lÃ©charger les chiers de rÃ©sul-
tat (un par graphe). Un exemple de chier de rÃ©sultat est fourni Fig. 7.12.

J. Creusefond

93

9101112Chapitre 7. CoDACom : une boÃ®te Ã  outils pour la dÃ©tection de
communautÃ©s

Figure 7.11  Les parties analyse et conversion de l'interface web de Co-
DACom

Figure 7.12  Un exemple de rÃ©sultat du module de comparaison sur le
rÃ©seau football. Chaque ligne et chaque colonne correspond Ã  un algorithme
de dÃ©tection de communautÃ©s. Pour chaque paire d'algorithmes, la valeur de
la mÃ©thode de comparaison est fournie (ici, la F-BCubed).

La zone 15 permet de sÃ©lectionner les fonctions de qualitÃ© Ã  appliquer sur
les partitions. CoDACom inclut les fonctions de qualitÃ© prÃ©sentÃ©es Sec. 2.3.
Les boutons 16 permettent :

1. d'appliquer les fonctions de qualitÃ© sÃ©lectionnÃ©es zone 15 aux parti-

tions produites par les algorithmes,

2. de comparer les partitions aux vÃ©ritÃ©s de terrain en utilisant les mÃ©-

thodes de comparaison sÃ©lectionnÃ©es en zone 13 ,

3. d'obtenir un chier par graphe contenant les rÃ©sultats des fonctions de
qualitÃ© et de la comparaison avec les vÃ©ritÃ©s de terrain (par exemple
Fig. 7.13),

94

J. Creusefond

131415161718197.1. Utilisation et fonctionnalitÃ©s

4. de comparer la cohÃ©rence entre fonctions de qualitÃ© et vÃ©ritÃ©s de terrain,
5. d'obtenir un chier de rÃ©sultat par mÃ©thode de comparaison prÃ©sentant

cette cohÃ©rence (par exemple Fig. 7.14),

6. de mesurer la corrÃ©lation entre les rÃ©sultats des diÃ©rents graphes Ã 

l'Ã©tape prÃ©cÃ©dente,

7. d'obtenir un chier de rÃ©sultat par mÃ©thode de comparaison prÃ©sentant

cette corrÃ©lation (par exemple Fig. 7.15).

Figure 7.13  Un exemple de rÃ©sultat du module de qualitÃ© sur le rÃ©seau
football. Les lignes correspondent Ã  des algorithmes de dÃ©tection de commu-
nautÃ©s, et les colonnes correspondent Ã  des mÃ©thodes de comparaison ainsi
qu'Ã  des fonctions de qualitÃ©. Pour les fonctions de qualitÃ©, les valeurs sont
le rÃ©sultat de la fonction sur la partition gÃ©nÃ©rÃ©e par l'algorithme. Pour les
mÃ©thodes de comparaison, les valeurs sont le rÃ©sultat de la comparaison entre
cette partition et la vÃ©ritÃ© de terrain.

Figure 7.14  Un exemple de rÃ©sultat de cohÃ©rence entre fonctions de qua-
litÃ© et vÃ©ritÃ©s de terrain utilisant la F-BCubed. Les lignes correspondent Ã 
des graphes et les colonnes sont les mÃªmes que en Fig. 7.13. Les valeurs
correspondent Ã  la cohÃ©rence entre la vÃ©ritÃ© de terrain et les fonctions (voir
Chap. 6).

Je dÃ©cris maintenant la partie conversion. Les boutons 17 gÃ©nÃ¨rent et
permettent de tÃ©lÃ©charger un chier de graphe au format graphml permettant
de visualiser les rÃ©sultats des algorithmes. Ce chier contient, en plus du
graphe, les communautÃ©s en tant qu'Ã©tiquettes des noeuds. Les arÃªtes sont
aussi Ã©tiquetÃ©es selon qu'elles soient internes ou externes aux communautÃ©s.
Un exemple de visualisation d'un chier de sortie de ce module est prÃ©sentÃ©

J. Creusefond

95

Chapitre 7. CoDACom : une boÃ®te Ã  outils pour la dÃ©tection de
communautÃ©s

Figure 7.15  CorrÃ©lation entre les cohÃ©rences prÃ©sentÃ©es Fig. 7.14. Les
lignes et les colonnes correspondent Ã  des graphes. Les valeurs sont le coe-
cient de rang de Spearman appliquÃ© aux lignes du chier de cohÃ©rence.

Figure 7.16  Visualisations avec le logiciel Gephi(https://gephi.org/)
d'un chier de rÃ©sultat. Il s'agit de l'algorithme de Louvain [9] (Ã  gauche) et
de MCL [94] (Ã  droite) appliquÃ© Ã  un jeu de donnÃ©es extrait de Facebook [65].

Fig. 7.16. Le module tex 18 transforme les chiers de rÃ©sultat des analyses
en tableaux LATEXpour une intÃ©gration dans un document de ce type. Le
module quotient 19 crÃ©e, pour chaque partition, le graphe quotient associÃ©
au format graphml.

CoDACom peut facilement intÃ©grer de nouvelles implÃ©mentations d'algo-
rithmes de dÃ©tection de communautÃ©s. L'intÃ©gration d'une implÃ©mentation
est rÃ©alisÃ©e grÃ¢ce Ã  un script qui a un rÃ´le d'intermÃ©diaire. Ce script a pour
rÃ´le d'exÃ©cuter le programme en normalisant les entrÃ©es/sorties. Ce script
doit Ãªtre fourni par l'utilisateur souhaitant intÃ©grer un nouvel algorithme. Si
ce script est placÃ© dans le dossier adÃ©quat, il est appelÃ© au cours de l'exÃ©cution
de CoDACom.

96

J. Creusefond

7.2. Travaux connexes

L'intÃ©gration de nouvelles fonctions de qualitÃ© et mÃ©thodes de compa-
raison se fait en C++. Il s'agit d'Ã©tendre la classe abstraite adÃ©quate et
de rÃ©fÃ©rencer la nouvelle classe dans une classe de  supervision . Pour
les mÃ©thodes de comparaison, la classe abstraite est AbstractCM, prÃ©sen-
tÃ©e Fig. 7.17. Pour les fonctions de qualitÃ©, il existe trois classes abstraites
reprÃ©sentant les diÃ©rents niveaux de localitÃ© (voir Sec. 2.3). Ces classes sont
AbstractQF ( Quality Function ), AbstractSCQF ( Single Cluster Qua-
lity Function ) et AbstractSVQF ( Single Vertex Quality Function ). Ces
classes peuvent Ãªtre Ã©tendues de la mÃªme maniÃ¨re que AbstractCM.

class Ab s t r a c t C M {
public :

virtual ~ A b s t r a c t CM () = 0;
virtual double apply ( std :: vector < std :: list < long > >& memb1 ,
std :: vector < std :: list < long > >& memb2 )

std :: string g e t D e s c r i p t i o n ();
std :: string getName ();

= 0;

protected :

std :: string name ;
std :: string d e s c r i p t i o n ;

};

Figure 7.17  L'en-tÃªte de AbstractCM. Une classe lle devra redÃ©nir le
destructur et la mÃ©thode abstraite apply.

7.2 Travaux connexes

Cette section prÃ©sente diÃ©rents outils pour la dÃ©tection de communautÃ©s.
Plusieurs bibliothÃ¨ques de graphes implÃ©mentent des solutions pour la

dÃ©tection de communautÃ©s :

 igraph [28] implÃ©mente sept algorithmes de dÃ©tection de communautÃ©s,
une fonction de qualitÃ© et cinq mÃ©thodes de comparaison non chevau-
chantes

 SNAP 6 inclut six algorithmes de dÃ©tection de communautÃ©s

L'inconvÃ©nient principal de ces bibliothÃ¨ques est l'utilisation du langage de
programmation associÃ© et la faible quantitÃ© de tests implÃ©mentÃ©s. Tous les

6. http://snap.stanford.edu/snap/doc.html

J. Creusefond

97

Chapitre 7. CoDACom : une boÃ®te Ã  outils pour la dÃ©tection de
communautÃ©s

algorithmes implÃ©mentÃ©s dans ces bibliothÃ¨ques produisant des  clusters 
non chevauchants sont intÃ©grÃ©s dans CoDACom.

Un logiciel similaire Ã  CoDACom est Circulo 7, qui fournit quinze algo-
rithmes de dÃ©tection de communautÃ©s, une trentaine de fonctions de qualitÃ©
et implÃ©mente l'Omega-Index [102] comme mÃ©thode de comparaison. Il n'in-
clut pas d'interface graphique.

Je note tout d'abord que les fonctions de qualitÃ© de Circulo elles pro-
viennent toutes de l'article [103] de Yang et Leskovec. Parmi ces fonctions de
qualitÃ©, la moitiÃ© de ces fonctions sont des mesures statistiques telles que la
moyenne et le maximum du degrÃ© des noeuds et du coecient de clustering
local. Circulo n'inclut que des fonctions de qualitÃ© au niveau communautÃ©.
Les algorithmes de Circulo sont implÃ©mentÃ©s et appelÃ©s en python, ce qui
est une forte restriction sur le langage de programmation de tout chercheur
souhaitant ajouter son implÃ©mentation au systÃ¨me. Par consÃ©quent, des al-
gorithmes connus avec des implÃ©mentations trÃ¨s ecaces ne sont pas inclus,
comme l'implÃ©mentation de l'algorithme de Louvain 8. Enn, le GraphML a
Ã©tÃ© choisi comme format de graphe interne alors qu'il est trÃ¨s redondant, ce
qui entraÃ®ne des chiers volumineux pour des graphes de grande taille.

J'en conclue que Circulo et CoDACom rÃ©pondent Ã  deux besoins diÃ©-
rents. Circulo est utile pour obtenir un ensemble de statistiques sur divers
algorithmes de dÃ©tection de communautÃ©s, sur des graphes de taille restreinte
(les exemples donnÃ©s vont jusqu'au million d'arÃªtes). Il n'eectue aucun des
traitements permettant d'Ã©tablir la cohÃ©rence des fonctions de qualitÃ© avec
les vÃ©ritÃ©s de terrain. Il ne permet donc pas d'identier des contextes. Co-
DACom permet de plus d'Ã©valuer facilement un nouvel algorithme avec des
fonctions de qualitÃ© provenant de travaux divers. Certaines des implÃ©men-
tations inclues peuvent Ãªtre exÃ©cutÃ©es sur des graphes de trÃ¨s grande taille,
comme SCD [79] qui peut traiter un rÃ©seau incluant plus d'un milliard et
demi d'arÃªtes sur un ordinateur de bureau.

Dans ce chapitre, j'ai prÃ©sentÃ© un logiciel nommÃ© CoDACom. Celui-ci
permet d'appliquer une chaÃ®ne de traitements liÃ©s Ã  la dÃ©tection de com-
munautÃ©s, de la normalisation des entrÃ©es Ã  l'analyse des rÃ©sultats. Il
inclut douze algorithmes de dÃ©tection de communautÃ©s, douze fonctions
de qualitÃ© et trois mÃ©thodes de comparaison. L'interface web permet de
gÃ©rer facilement des calculs distants. CoDACom est disponible, librement
et gratuitement, sur http://codacom.greyc.fr.

7. http://lab41.org/circulo-a-community-detection-evaluation-framework/
8. https://sourceforge.net/projects/louvain/

98

J. Creusefond

Chapitre 8

Conclusion

Nous avons vu que pour dÃ©tecter les communautÃ©s dans un rÃ©seau social,

il faut :

 identier les propriÃ©tÃ©s structurelles que l'on estime importantes pour

l'application ;

 construire un cadre d'Ã©valuation, ce qui peut se faire de l'une ou des

deux maniÃ¨res suivantes :

 choisir une ou plusieurs fonctions de qualitÃ© Ã©valuant ces propriÃ©tÃ©s

structurelles ;

 choisir les vÃ©ritÃ©s de terrain qui dÃ©nissent les communautÃ©s rÃ©elles ;
 sÃ©lectionner l'algorithme de dÃ©tection correspondant le mieux aux be-

soins.

Dans cette thÃ¨se, j'ai proposÃ© une mÃ©thodologie complÃ¨te qui adresse
chacun des points Ã©voquÃ©s ci-dessus. Ma contribution Ã  l'identication des
propriÃ©tÃ©s structurelles est la dÃ©nition des a-motifs. Un a-motif permet de
caractÃ©riser diÃ©remment les communications internes Ã  une communautÃ©
des communications externes. J'ai identiÃ© que les a-motifs de type va-et-
vient, spam et triangle sont caractÃ©ristiques de l'intÃ©rieur des communautÃ©s,
tandis que le a-motif de chaÃ®ne est caractÃ©ristique de l'extÃ©rieur des commu-
nautÃ©s (voir Chap 3). En ce qui concerne le cadre d'Ã©valuation, j'ai dÃ©ni
une nouvelle fonction de qualitÃ© : la compacitÃ©. La compacitÃ© permet d'iden-
tier des groupes d'individus entre lesquels la diusion d'une information est
rapide (voir Chap. 4). La dicultÃ© lors de l'Ã©valuation par les fonctions de
qualitÃ© est de dÃ©terminer si elles favorisent des communautÃ©s rÃ©elles. Dans
ce but, Ã©tablir la cohÃ©rence entre fonctions de qualitÃ© et vÃ©ritÃ©s de terrain
est crucial. J'ai proposÃ© une mÃ©thodologie permettant de quantier l'adÃ©qua-
tion entre fonctions de qualitÃ© et vÃ©ritÃ©s de terrain (voir Chap 6). Le logiciel

J. Creusefond

99

Chapitre 8. Conclusion

CoDACom, que j'ai Ã©crit, assiste les praticiens dans l'application de cette mÃ©-
thodologie (voir Chap 7). Ce logiciel est disponible sous la licence Cecill-B Ã 
l'adresse suivante : http://codacom.greyc.fr. Enn, j'ai conÃ§u un nouvel
algorithme de dÃ©tection de communautÃ©s : le Lex-Clustering. Cet algorithme
utilise l'algorithme de parcours de graphe LexDFS pour dÃ©tecter des commu-
nautÃ©s. Le principe du LexDFS est de parcourir le graphe en favorisant les
voisins des noeuds dÃ©jÃ  visitÃ©s. Le Lex-Clustering trouve des communautÃ©s
qui favorisent la compacitÃ© (voir Chap. 5.

Je vais maintenant dÃ©tailler chacune de ces contributions.

8.1 A-motifs

Le chapitre 3 prÃ©sente de nouveaux critÃ¨res pour la dÃ©tection de com-
munautÃ©s dans les rÃ©seaux temporels. Il y est montrÃ© que la faÃ§on dont les
communications s'enchainent (dÃ©crite par les a-motifs) a un lien avec la struc-
ture communautaire. En eet, certains a-motifs apparaissent plus Ã  l'intÃ©rieur
qu'Ã  l'extÃ©rieur des communautÃ©s.

J'ai montrÃ©, par l'utilisation de modÃ¨les nuls, que la causalitÃ© a une in-
uence sur les a-motifs et leur densitÃ© interne/externe aux communautÃ©s. Or,
l'agrÃ©gation des rÃ©seaux sur des fenÃªtres temporelles est frÃ©quemment utili-
sÃ©e pour dÃ©tecter les communautÃ©s sur les rÃ©seaux de communication. Cette
opÃ©ration dÃ©truit la causalitÃ© des communications sur ces fenÃªtres. L'agrÃ©ga-
tion du rÃ©seau met de cÃ´tÃ© une information qui pourrait aider Ã  la dÃ©tection
de communautÃ©s. La prochaine Ã©tape de ce travail est de savoir si la causa-
litÃ© des communications est une information indispensable Ã  la dÃ©tection de
communautÃ©s sur les rÃ©seaux de communication.

8.2 Lex-Clustering et compacitÃ©

Le chapitre 4 prÃ©sente la dÃ©nition d'une nouvelle fonction de qualitÃ© :
la compacitÃ©. Celle-ci se fonde sur un modÃ¨le de diusion simple de l'infor-
mation dans un groupe, l' Independant Cascade Model  [40, 53] avec une
probabilitÃ© de transmission de 1. La compacitÃ© mesure la vitesse de propaga-
tion de cette diusion. Dans le chapitre 4, je compare la compacitÃ© Ã  d'autres
fonctions de qualitÃ©. J'y montre que la compacitÃ© pÃ©nalise les structures oÃ¹
des individus sont peu connectÃ©s au reste du groupe. Je montre aussi que la
compacitÃ© satisfait les axiomes de Van Laarhoven et Marchiori [95].

L'inconvÃ©nient de cette fonction de qualitÃ© est son temps de calcul. Il est
donc dÃ©raisonnable de crÃ©er un algorithme de dÃ©tection de communautÃ©s basÃ©

100

J. Creusefond

sur le calcul explicite de la compacitÃ©. En pratique, j'utilise une approxima-
tion du diamÃ¨tre pour pouvoir calculer la compacitÃ©. J'ai conÃ§u la compacitÃ©
en tant que fonction de qualitÃ© car, selon moi, la vitesse de la diusion d'in-
formation dans une communautÃ© est sa caractÃ©ristique principale.

Le chapitre 5 prÃ©sente un nouvel algorithme hiÃ©rarchique de dÃ©tection
de communautÃ©s basÃ© sur l'algorithme du LexDFS : le Lex-Clustering. Il se
base sur un algorithme de parcours de graphe visitant en prioritÃ© les noeuds
voisins des noeuds visitÃ©s rÃ©cemment. C'est par l'exÃ©cution rÃ©pÃ©tÃ©e de ce
parcours que les arÃªtes intra-communautaires sont dÃ©tectÃ©es. J'utilise ensuite
un algorithme hiÃ©rarchique pour dÃ©tecter les communautÃ©s Ã  partir de ces
arÃªtes. Le Lex-Clustering produit des  clusters  denses, comme montrÃ©
par la comparaison avec des vÃ©ritÃ©s de terrain.Cet algorithme produit des
 clusters  favorisÃ©s par la compacitÃ©.

8.3 Fonctions de qualitÃ© et vÃ©ritÃ©s de terrain

Le chapitre 6 prÃ©sente une mÃ©thodologie pour Ã©tablir la cohÃ©rence entre

les fonctions de qualitÃ© et les vÃ©ritÃ©s de terrain.

J'observe que certaines fonctions de qualitÃ© Ã©valuent les partitions de
maniÃ¨re cohÃ©rente avec certaines vÃ©ritÃ©s de terrain. De plus, il existe des
ensembles de vÃ©ritÃ©s de terrain qui prÃ©sentent des rÃ©sultats semblables quand
on compare entre elles leur cohÃ©rence avec les fonctions de qualitÃ©. J'appelle
ces ensembles de vÃ©ritÃ©s de terrain des contextes. Une fonction de qualitÃ©
peut Ãªtre cohÃ©rente avec les vÃ©ritÃ©s de terrain d'un contexte, mais incohÃ©rente
avec ceux d'un autre. Identier le contexte d'un rÃ©seau sans vÃ©ritÃ© de terrain
permet de connaÃ®tre la fonction de qualitÃ© Ã  utiliser pour Ã©valuer les diÃ©rents
algorithmes de dÃ©tection de communautÃ©s.

Notons que, mÃªme si l'ensemble des donnÃ©es utilisÃ©es par ces expÃ©riences
est de taille importante, il est impossible de savoir si d'autres contextes
existent dans d'autres vÃ©ritÃ©s de terrain sans les avoir analysÃ©s. Il serait
donc intÃ©ressant d'enrichir ces rÃ©sultats par l'analyse de vÃ©ritÃ©s de terrain
supplÃ©mentaires.

Il s'agit de l'un des objectifs du logiciel CoDACom, prÃ©sentÃ© au chapitre 7.
Ce logiciel est aussi adaptÃ© Ã  divers besoins en dÃ©tection de communautÃ©s
grÃ¢ce Ã  la bibliothÃ¨que d'outils qu'il contient. Il inclut notamment une suite
de tests permettant l'analyse d'algorithmes de dÃ©tection de communautÃ©s,
de fonctions de qualitÃ© et de vÃ©ritÃ©s de terrain. Il est de plus facilement
extensible grÃ¢ce Ã  sa conception modulaire. Il contient aussi une interface
web permettant de le manipuler. CoDACom est disponible Ã  l'adresse http:
//codacom.greyc.fr/.

J. Creusefond

101

102

J. Creusefond

Annexe A

DÃ©marches et description du
rÃ©seau dâ€™e-mails de lâ€™universitÃ© de
Caen

La premiÃ¨re dÃ©marche fut une Ã©tude de faisabilitÃ©, Ã©paulÃ©e par la Direc-
tion des SystÃ¨mes d'Information (DSI). Il s'est avÃ©rÃ© que les mÃ©tadonnÃ©es des
e-mails Ã©mis et reÃ§us par des adresses gÃ©rÃ©es par l'universitÃ© Ã©taient facile-
ment rÃ©cupÃ©rables par le biais de logs. De plus, un service d'adresses LDAP
( Lightweight Directory Access Protocol ) contient des mÃ©tadonnÃ©es sur les
individus utilisant les adresses en question.

La question lÃ©gale s'est alors posÃ©e, la protection des donnÃ©es privÃ©es
informatiques Ã©tant gÃ©rÃ©e par la Commission Nationale de l'Informatique et
des LibertÃ©s (CNIL). J'ai donc identiÃ© les mÃ©tadonnÃ©es intÃ©ressantes pour
l'Ã©tude, et ai contactÃ© l'interlocuteur privilÃ©giÃ© pour les questions relatives Ã 
la CNIL, le Correspondant Informatique et LibertÃ©es (CIL).

Le principe de base est de rendre la levÃ©e de l'anonymat extrÃªmement
dicile par un individu isolÃ©. Il a donc fallu revoir certaines mÃ©ta-donnÃ©es
pour qu'elles ne permettent pas une identication trop aisÃ©e des individus im-
pliquÃ©s. Par exemple, certains laboratoires sont de petite taille (infÃ©rieure Ã 
cinq). La liste des membres de ce laboratoire est, le plus souvent, disponible
facilement en ligne. Si l'Ã¢ge ou le sexe est une mÃ©ta-donnÃ©e fournie, il de-
vient aisÃ© d'obtenir les mÃ©ta-donnÃ©es des communications d'un membre du
laboratoire en particulier. C'est pourquoi nous avons, par exemple, dÃ©cidÃ©
d'exclure l'Ã¢ge des mÃ©ta-donnÃ©es extraites pour le personnel, et ne fournir
que des tranches d'Ã¢ges de deux ans pour les Ã©tudiants, avec deux tranches
extrÃªmales (moins de 18 ans et plus de 30 ans).

Ensuite, un membre de la DSI a eectuÃ© les traitements d'extraction,
de normalisation et d'anonymisation des donnÃ©es. Ceux-ci ont Ã©tÃ©s eectuÃ©s

J. Creusefond

103

sur des serveurs sÃ©curisÃ©s et les clefs de correspondance entre les donnÃ©es non
anonymisÃ©es et anonymisÃ©es ont Ã©tÃ©s dÃ©truites aprÃ¨s traitement. La procÃ©dure
entiÃ¨re a Ã©tÃ© prÃ©sentÃ©e au CIL, qui a validÃ© le traitement d'anonymisation et
la mise Ã  disposition du jeu de donnÃ©es Ã  la communautÃ© scientique.

An d'avoir au mieux possible une bijection entre les utilisateurs et les
adresses, les traitements eectuÃ©s Ã  partir du rÃ©seau brut sont les suivants :
 suppression des adresses invalides (fautes de frappe dans le destinataire,

. . .)

 rÃ©union des alias internes
Les donnÃ©es s'Ã©talent sur une pÃ©riode de trois mois durant l'annÃ©e scolaire
2015-2016. Les mÃ©tadonnÃ©es collectÃ©es sur les e-mails sont les champs FROM,
TO et DATE, c'est-Ã -dire les informations nÃ©cessaires pour le ux de liens.
Pour les utilisateurs actifs durant cette pÃ©riode, les mÃ©tadonnÃ©es suivantes
sont rassemblÃ©es :

 type : si l'utilisateur est une personne ou une liste de diusion
 catÃ©gorie : la catÃ©gorie socioprofessionnelle (employÃ© ou Ã©tudiant)
 sexe
 Ã¢ge : seulement pour les Ã©tudiants, par tranche de deux ans entre 18 et

30 ans

 l'entitÃ© administrative de rattachement, comme l'UnitÃ© de Formation et
de Recherche (UFR) ou un Institut Universitaire Technologique (IUT)

 laboratoire
 section du Conseil National des UniversitÃ©s (CNU) : la discipline que

pratique l'individu (informatique, biologie, etc.)

104

J. Creusefond

Bibliographie

[1] Rodrigo Aldecoa and Ignacio MarÃ­n. Surprise maximization reveals
the community structure of complex networks. Scientific Reports, 3,
January 2013.

[2] HÃ©lio Almeida, Dorgival Guedes, Wagner Meira Jr, and Mohammed J.
Zaki. Is there a best quality metric for graph clusters ? In Machine
Learning and Knowledge Discovery in Databases, pages 4459. Sprin-
ger, 2011.

[3] Enrique AmigÃ³, Julio Gonzalo, Javier Artiles, and Felisa Verdejo. A
comparison of extrinsic clustering evaluation metrics based on formal
constraints. Information retrieval, 12(4) :461486, 2009.

[4] Alex Arenas, Albert DÃ­az-Guilera, and Conrad J. PÃ©rez-Vicente. Syn-
chronization reveals topological scales in complex networks. Physical
review letters, 96(11) :114102, 2006.

[5] Amit Bagga and Breck Baldwin. Entity-based cross-document corefe-
rencing using the vector space model. In Proceedings of the 17th In-
ternational Conference on Computational Linguistics-Volume 1, pages
7985. Association for Computational Linguistics, 1998.

[6] Eytan Bakshy, Jake M. Hofman, Winter A. Mason, and Duncan J.
Watts. Everyone's an inuencer : quantifying inuence on twitter. In
Proceedings of the fourth ACM international conference on Web search
and data mining, pages 6574. ACM, 2011.

[7] Eytan Bakshy, Itamar Rosenn, Cameron Marlow, and Lada Adamic.
The role of social networks in information diusion. In Proceedings of
the 21st international conference on World Wide Web, pages 519528.
ACM, 2012.

[8] Albert-LÃ¡szlÃ³ BarabÃ¡si and RÃ©ka Albert. Emergence of scaling in ran-

dom networks. Science, 286(5439) :509512, 1999.

[9] Vincent D. Blondel, Jean-Loup Guillaume, Renaud Lambiotte, and
Fast unfolding of communities in large net-

Etienne Lefebvre.

J. Creusefond

105

works. Journal of Statistical Mechanics : Theory and Experiment,
2008(10) :P10008, 2008.

[10] Ulrik Brandes, Daniel Delling, Marco Gaertler, Robert GÃ¶rke, Martin
Hoefer, Zoran Nikoloski, and Dorothea Wagner. On modularity â€“ NP-
Completeness and beyond. Citeseer, 2006.

[11] JuliÃ¡n Candia, Marta C. GonzÃ¡lez, Pu Wang, Timothy Schoenharl,
Greg Madey, and Albert-LÃ¡szlÃ³ BarabÃ¡si. Uncovering individual and
collective human dynamics from mobile phone records. Journal of Phy-
sics A : Mathematical and Theoretical, 41(22) :224015, 2008.

[12] Qiang Cao, Michael Sirivianos, Xiaowei Yang, and Tiago Pregueiro. Ai-
ding the detection of fake accounts in large scale social online services.
In Presented as part of the 9th USENIX Symposium on Networked Sys-
tems Design and Implementation (NSDI 12), pages 197210, 2012.

[13] Ciro Cattuto, Wouter Van den Broeck, Alain Barrat, Vittoria Colizza,
Jean-FranÃ§ois Pinton, and Alessandro Vespignani. Dynamics of Person-
to-Person Interactions from Distributed RFID Sensor Networks. PLoS
ONE, 5(7) :e11596, July 2010.

[14] Remy Cazabet, Frederic Amblard, and Chihab Hanachi. Detection
In Social
of overlapping communities in dynamical social networks.
Computing (SocialCom), 2010 IEEE Second International Conference
on, pages 309314. IEEE, 2010.

[15] D. Centola. The Spread of Behavior in an Online Social Network Ex-

periment. Science, 329(5996) :11941197, September 2010.

[16] Tamal Chakraborty, Sujit Sikdar, Vihar Tammana, Niloy Ganguly, and
Arjun Mukherjee. Computer science elds as ground-truth communi-
ties : Their impact, rise and fall. In Proceedings of Advances in So-
cial Networks Analysis and Mining (ASONAM), 2013, pages 426433.
IEEE, 2013.

[17] Tanmoy Chakraborty, Sandipan Sikdar, Niloy Ganguly, and Animesh
Mukherjee. Citation interactions among computer science elds : a
quantitative route to the rise and fall of scientic research. Social
Network Analysis and Mining, 4(1) :118, 2014.

[18] Tanmoy Chakraborty, Sriram Srinivasan, Niloy Ganguly, Animesh Mu-
kherjee, and Sanjukta Bhowmick. On the permanence of vertices in
network communities. In Proceedings of the 20th ACM SIGKDD Inter-
national Conference on Knowledge Discovery and Data Mining, KDD
2014, pages 13961405, New York, NY, USA, 2014. ACM.

106

J. Creusefond

[19] Mingming Chen, Tommy Nguyen, and Boleslaw K. Szymanski. A new
metric for quality of network community structure. arXiv preprint
arXiv :1507.04308, 2015.

[20] Aaron Clauset, M. Newman, and Cristopher Moore. Finding com-
munity structure in very large networks. Physical Review E, 70(6),
December 2004.

[21] Linda M. Collins and Clyde W. Dent. Omega : A General Formulation
of the Rand Index of Cluster Recovery Suitable for Non-disjoint Solu-
tions. Multivariate Behavioral Research, 23(2) :231242, April 1988.

[22] Derek G. Corneil, Barnaby Dalton, and Michel Habib. LDFS-Based
Certifying Algorithm for the Minimum Path Cover Problem on Co-
comparability Graphs. SIAM Journal on Computing, 42(3) :792807,
January 2013.

[23] Derek G. Corneil and Richard M. Krueger. A unied view of graph
searching. SIAM Journal on Discrete Mathematics, 22(4) :12591276,
January 2008.

[24] Robin Cowan and Nicolas Jonard. Network structure and the dif-
fusion of knowledge. Journal of Economic Dynamics and Control,
28(8) :15571575, June 2004.

[25] Jean Creusefond, Thomas Largillier, and Sylvain Peyronnet. Finding
compact communities in large graphs. In Proceedings of Advances in
Social Networks Analysis and Mining (ASONAM), 2015, pages 1457
1464. ACM, 2015.

[26] Jean Creusefond, Thomas Largillier, and Sylvain Peyronnet. A lexdfs-
based approach on nding compact communities. In From Social Data
Mining and Analysis to Prediction and Community Detection. Springer,
2016.

[27] Jean Creusefond, Thomas Largillier, and Sylvain Peyronnet. On the
