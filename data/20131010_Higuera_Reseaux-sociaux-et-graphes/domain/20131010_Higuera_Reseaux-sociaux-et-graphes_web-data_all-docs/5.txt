http://archipel.uqam.ca/5023/1/M9814.pdf

UNIVERSITÉ DU QUÉBEC À MONTRÉAL 

NETSIM : 

UN LOGICIEL DE MODÉLISATION ET DE SIMULATION DE RÉSEAUX 

D'INFORMATION 

MÉMOIRE 

PRÉSENTÉ 

COMME EXIGENCE PARTIELLE 

DE LA MAÎTRISE EN INFORMA TIQUE 

PAR 

MÉLANIE LORD 

AVRIL2007 

.. 

UNIVERSITÉ DU QUÉBEC À MONTRÉAL 

Service des bibliothèques 

· 

Avertissement 

La diffusion de ce  mémoire se fait dans le' respect des droits de son auteur, qui a signé 
le formulaire  Autorisation de  reproduire. et de  diffuser un  travail de  recherche  de. cycles 
supérieurs (SDU-522- Rév.01-2006).  Cette  autorisation .stipule que  <<conformément · à 
l'article  11  du  Règlement  no  8  des  études  de  cycles  supérieurs, {l'auteur]  concède  à 
l'Université  du  Québec  à  Montréal  une  licence  non  exclusive  d'utilisation  et  de . 
publication  oe  la  totalité  ou  d'une  partie  importante  de  [son]  travail  de  recherche  pour 
des  fins  pédagogiques  et  non  commerciales.  Plus  précisément,  [l'auteur]  autorise 
l'Université. du Québec à Montréal à reproduire, diffuser, prêter, distribuer ou vendre des  · 
copies  de. [son]  travail  de  recherche  à  des fins  non  commerciales  sur quelque  support 
que ce soit, y compris l'Internet.  Cette licence et cette autorisation n'entraînent pas une 
renonciation  de [la]  part [de  l'auteur] à [ses]  droits  moraux ni  à  [ses] droits de  propriété 
intellectuelle.  Sauf  ententé  contraire,  [l'auteur]  conserve  la  liberté  de  diffuser  et  de 
commercialiser ou non ce travail dont [il] possède un exemplaire .. » 

REMERCIEMENTS 

Ce document témoigne de l'achèvement d'un long processus de recherche que j'ai entrepris  il 

y  a deux ans  déjà.  Au  cours  de cette aventure,  la chance m'a été  donnée  de  côtoyer nombre 

de  gens  qui  ont  eu,  directement  ou 

indirectement,  une 

influence  positive  sur 

1 'accomplissement de  ce  projet.  Ils  ont  été  mes  formateurs,  mes  amis,  mes  conseillers,  mes 

collègues,  ma  famille  et  chacun  d'eux,  à  leur  manière,  a  contribué  à  la  réalisation  de  ce 

mémoire. 

Je  souhaite  remercier  M.  Daniel  Memmi,  professeur  au  département  d'informatique  à 

l'Université du  Québec à Montréal, de m 'avoir dirigée dans  mes travaux de recherche.  Il  a su 

me guider et me donner les outils et les ressources nécessaires pour mener à terme ce projet. 

Je tiens  aussi  à  remercier Alexandre Blondin-Massé, étudiant à  la  maîtrise en  informatique  à 

1 'Université  du  Québec  à  Montréal,  pour  sa  gentillesse  et  le  temps  qu'il  a  consacré  à  la 

programmation de certaines composantes du  logiciel NetSim. 

J'ai  effectué  mon  travail  de  recherche,  en  grande  partie,  au  laboratoire  d' informatique 

LATECE. 

Je  remercie  les  étudiants  de  ce  laboratoire  de  constamment  contribuer  à 

l'ambiance stimulante qui  y règne.  Plus particulièrement, je remercie Ghizlane El Boussaidi, 

étudiante au  doctorat en informatique à 1 'Université de Montréal , pour ses bons conseils. 

Enfin, je remercie ma famille dont le soutien est toujours inconditionnel. 

Table des matières 

LISTE DES FIGURES  - - - - - - - - - - - - - - - - - - - - - - --

LISTE DES TABLEAUX 

RÉSUMÉ 

CHAPITRE 1 

INTRODUCTION 

1.1  Contexte 

1.2  Pr oblématique 

1.3  Obj ectifs de rech erche et méthodologie 

1.3 .1  Création d 'un langage de modélisation de réseaux d' information 
1.3.2  Implémentation d'un logiciel d' interprétation du langage de modélisation 
1.3.3  Simulation de réseaux d'information divers à l'aide de NetSim 

1.4  Plan du mémoire 

vi 
viii 

ix 

1 

1 

3 

9 
9 
10 
11 

11 

CHAPITRE Z 
LES RÉSEAUX SOCIAUX  ______________________  13 

2.1  Introduction 

- - - - - - - ---------------------------------------

13 

2.2  Un domaine de recherche en pleine expansion __________ _____ l4 
2.2.1  Les réseaux sociaux dans la gestion  de  la connaissance 
14 
2.2.2  Les réseaux sociaux comme aide à la recherche d'information 
16 
2.2.3  Les entreprises en  réseaux 
17 
2.2.4  Conception d'une future génération de l'Internet inspirée des réseaux sociaux_18 

2.3  Analyse des structures relationnelles ____________________ l8 
18 
20 

2.3 .1  Définition et représentation d'un réseau social 
2.3.2  L'approche structurale 

2.4  Revue des modèles actuels 

2.4.1  Modèles théoriques 
2.4.2  Modèles statistiques de réseaux sociaux 

30 
31 
43 

2.4.3  Approche par modélisation  ascendante  _ ________ ___ _ _ 

2.5  Outils de modélisation et simulation 

IV 

46 

48 

2.6  Conclusion __________________________  50 

CHAPITRE3 
LANGAGE DE  MODÉLISATION NETSIM  _________________  52 

3.1  Introduction  ______ ___________________  52 

3.2  Les entités du  langage ______ ____________ ____ 53 

3.3  Syntaxe d'écriture des définitions du modèle 

55 
3.3. 1  Généralités 
55 
3.3.2  Les constantes 
56 
3.3 .3  Les attributs 
56 
3.3.4  Les fo nctions 
58 
3.3.5  Exempl e d' écriture des défi niti ons du  modèle d' amitié de Jin, Girvan  et Newman 68 

3.4  Syntaxe d'écriture des  règles du modèle _______________ 71 
7 1 
78 
82 

3 .4.1  Les actions 
3.4.2  Commandes d' exécution  de  la simul ati on 
3.4.3  Exemple d'écriture des règ les du  modèle d' amitié de Jin , Girvan et Newman _ 

3.5  Conclusion _ ___________ __ ___ _________ 84 

CHAPITRE 4 

NETSIM  :  UNE PLATE-FORME DE MODÉLISATION ET  SIMULATION DE  RÉSEAUX 
D'INFORMATION  _________________________ 85 

4.1  Introduction  _ __ __ ____ ________________ 85 

4.2  Fonctionnement général de NetSim  ________________  85 

4.3  Détail d ' implémentation de NetSim  ________________  96 
96 
107 
Il 0 
114 
11 5 
116 

4.3 .1  Initiali sati on du  logiciel 
4.3.2  Traduction du  modèle NetSim en modèle Java 
4.3.3  Éc riture des classes Java  d' exéc uti on de  la simulat ion 
4.3.4  Compilati on de la  simulation 
4.3.5  Exéc uti on de  la  si mulation 
4.3.6  Données de  réseaux externes 

4.4  Conclusion ______ ____________________ 120 

v 

CHAPITRE 5 
RÉSULTATS DE SIMULATION AVEC  NETSIM _ ____________ __ 121 

5.1  Introduction  _________________________ 121 

5.2  Simulation d ' un  modèle de J'évolution d ' un résea u d 'a mis  ________ 121 
12 1 
124 
125 

5.2 .1  Le  modèle théorique 
5.2.2  Le  modèle traduit en langage NetSim 
5.2 .3  Résultats de  simul ation 

5.3  Simulation d'un modèle de J'évolution du Web _______ ______ 130 
130 
132 
137 

5.3 .1  Le  modèle théorique 
5.3.2  Le  modèle traduit en  langage NetSim 
5.3.3  Résultats de simulation 

5.4  Conclusion __________________________ 141 

CHAPITRE6 
CONCLUSION  ET  PERSPECTIVE  ___________________  142 

6.1  Contributions  ____ _____________________ 142 

6.2  Travaux futurs  ________________________ 144 

ANNEXE A 

CODE GÉNÉRÉ DYNAMIQUEMENT DES CLASSES D' EXÉCUTION  DE  LA SIMULATION DU 

MODÈLE DU  RÉSEAU  D'AMIS DE JIN,  GIRVAN ET  NEWMAN __________  145 

ANNEXEB 
INTERFACE GRAPHIQUE DE  NETSIM _________________  152 

RÉFÉRENCES 

162 

Liste des figures 

Figure  1.2.1  Repérage de structures  typiques  par visualisati on graphique ...... ..................... ...  8 

Figure 2.3.1.2  Chemin s de longueur  x dans une matrice sociométrique .. ..... .. ... ........... ...... . 20 

Figure 2.3.2 .2. 1  Illustrati on du « Kite Network  » développé par David  Krackhardt... .......... 28 

Figure 2.3.2.3. 1  Autonomie des acteurs dans di fférentes structures  relati onnelles .... .... .... ...  30 

Fi gure 2.4.1 .1  Voisinage de  Von Neumann et voisinage de Moore dan s un  automate 
cellul aire ...... .. ..... .... .. ... .... ......... .......... ............ .... ..... .. .... .... ....................... .... .. .... ........ ... ........... 32 

Fi gure 2.4.1.2  Graphe al éatoire avec N =  6 et z= 2 .. ....... ....... ..... ... ..... .......... ... .... ....... ......... .. 34 

Figure 2.4.1.3  Treillis régulier avec  z =  4 ........... .......... .. .... ........... ...... ...... .... ..... .. ................ 35 

Fi gure 2.4.1.4  Modèle  jJ  ex posa nt  l' effet des  petits mond es et la propri été de transiti vité 36 

Fi gure 2.4. 1.5  Modèle de petits mondes de Dorogovtsev et Mendes ..... ...... ..... .. .............. ..... 37 

Figure 2.4.1.6  Modèle du  réseau  indépend ant de l' éc hell e illustrant  l'attachement 
préférentiel . ...... ...... ..... ..... ... ... .. ............. ........... .... ......... ......... .................. ...... .. ... .. ............. ..... . 39 

Figure 3.2. 1  Hi érarchie des entités de NetSim ........................... .... ....... ... ... .... ................... ....  55 

Fi gure 3.4.2.1  Phases d' exécuti on et  command e d' arrêt automatiqu e de la simulation ..... ...  80 

Figure 4.2. 1  Fonct ionnement général de NetSim .. ....... .... ..... ............... ...... .... .. ................... ... 86 

Figure 4.2.2  Diagramme de classes  UML  des classes principa les  nécessa ires  à la 
constructi on d' un  modèle dans NetSim ...... ....... ...... .... .... .... .... ....... ........... ...... ...... ... .... .... ....... 87 

Fi gure 4.2.3  Représentation en mémoire d' un  modèle NetSim  du  réseau  d'ami s ...... ..... ...... 90 

Fi gure 4.2.4  Di agramme de classes  UML des principales classes de contrôle de la simulation 
... ..... ..... ..... ..... .. .. ............. ......... ............ ...... ........ ... ... ............................. ... ... ..... .............. ....... ....  93 

Figure 4.2.5  Structure de données représentant le graph e de NetSim  en mémoire ........ ....... . 94 

Figure  4.3. 1.1  Fichier de config uration XML des di stri but ions in iti ales du  résea u offertes par 
NetSi1n  ......... ... ........... ..... ............... ................. ....... ........... .... ............. ..... ... ... .......... .. .. ....... ...... 97 

Figure 4.3.1.2  Les  attributs de  la  classe  Distribution Data .... ....... ......... ............... ........ ......... 99 

Y li 

Figure 4.3.1 .3  Di agramme UML  représentant  les  classes d' implémentation des 
configurations initiales du  réseau ............ ........... ... .. .................... ... ... ... ..... ......... ......... .... ... ... 100 

Fi gure 4.3 .1.4  Fichier de classement des opérateurs de NetSim .. .. .... ...... .... ... ... ..... ...........  102 

Figure 4.3.1.5  Fichi ers de correspondance des opérateurs de NetSim  avec  les  opérateurs ou 
les méthodes Java ........................................................................... .. ......................................  103 

Figure 4.3 .1 .6  Fichi er de correspond ance entre les fonctions NetSim  défini es sur  l'entité 
network et les  méthodes Java  qui  les  impl émentent.. .. ........ .. .. .. .. ...... .................. ............ ......  106 

Figure 4.3 .3.1  Di agramme de classes  UML  représentant  les classes d' exécuti on de la 
simul ation .... .... .. ....... ....... ............. ... .......... .... .. .. .... ..... ..... ....... ........... .. .......... .. .... ..... ... ...........  1 1 0 

Figure 4.3.6.1  Données de réseau x externes dan s le format NetSim XML .. .......... ... .. .... .....  117 

Figure 4.3.6.2  Vi suali sati on de données de réseau externes dans NetSim ...........................  11 9 

Fi gure 5.2.3. 1  Réseau initial de la simulation du  réseau d'ami s à t =  0 (625  liens) .. .. .........  125 

Fi gure  5.2 .3.2  Évolution du  réseau d'ami s au cours de la simulati on dans NetSim ...... .. ....  128 

Figure 5.3 .1 .1  Attachement  préférenti el dans le réseau du  Web .......... ...... .. ......................  13 1 

Figure 5.3.3 .1  Évo lution du  réseau  du  Web au cours de la simul ation .. .... .. .... ...... ...... ..... ...  138 

Figure 5.3.3.2  Distributi on des degrés du  résea u généré par simul ation au temps t =  600 ..  139 

Figure 5.3 .3 .3  Distributi on logarithmique des degrés  du  réseau  généré  par simulati on au 
temps t =  600 ......................... .. .... ..................................................................................... ......  140 

Figure 8 .1  Création d' un  nouveau  projet .... ..................... .. .. .. ..............................................  152 

Figure 8 .2  Enreg istrement du  nouveau  proj et sur  le di sque .... ........ ....................................  153 

Figure 8 .3  Éc riture de notes de proj et et création d' une nouve lle simulati on .. .... .......... .. .. . 154 

Figure 8 .4  Choix d' une configuration initiale dans les paramètres généraux de la simulation 
... .. ......................... .......... ..... .... ... ....... ... .... .... .... ...... .... ........ ..... .. .... .......... ...............................  155 

Figure 8 .5  Choix des autres  paramètres généraux de la simulati on ...... ........ ............ ..... ......  156 

Fi gure 8 .6  Écriture des définiti ons du  modèle et vérifi cation syntax ique (avec erreurs) .. ..  157 

Figure  8 .7  Vérifi cati on syntaxique des définiti ons du  modèle (sans erreurs) ........ .. ...... .....  158 

Figure 8 .8  Éc riture des règles du  modè les et  vérifica tion syntax ique (sans erreurs)  ..........  !59 

Figure 8 .9  Initi ali sation de  la  simu lati on  (bouton « start  ») ............ ...... ...... ...................... ...  160 

Figure 8. 10  Visualisat ion de  la config urati on initiale du  réseau ...... .. .. ...... .. ...... .... .... .... .. .. . 16 1 

' 

Liste des tableaux 

Tab leau 3.2.1  Les entités du  lan gage NetS im ... .. ... ... ........ ...... ..................... .......... ....... ....... ...  54 

Tableau 3.3.3. 1.1  Attributs prédéfi ni s sur  l'entité node ... .................... ......... .. ...... ...... ... ... .... . 57 

Tab leau 3.3.3. 1.2  Attributs prédéfi ni s sur  l' entité link ..... .... ..... .......... ... ............ .... ... ....... ... . 57 

Tableau 3.3.4. 1  Opérateurs arithmétiques  binaires de NetSi m ...... ...... ....... .. ... ...... ............ .... 59 

Tab leau 3.3.4.2  Opérateurs arithmétiques un aires de NetS im  .......... ........ ............... ...... .. .. .. .. 59 

Tab leau 3.3.4.3  Opérateurs boo léens binaires de NetSim ... ..... .. ... ...... ... .. .......... ... ......... ........  60 

Tab leau 3.3.4.4  Opérateur boo léen unaire de NetSim ... .... .... ......... ... ....... ......... ...... ... ........ ....  60 

Tab leau 3.3.4.5  Opérateur d'affectation ........ ..... ........... .. ... ... .......... ...... .... .......... ..... ..... .. .. .....  60 

Tab leau 3.3 .4. 1. 1  Fonctions prédéfi nies sur  l'ent ité world ..... .. .................. .... ... .... ..... ... ... ... ..  6 1 

Tab leau 3.3 .4.1 .2  Fonctions prédéfinies sur  l' entité network  ...... .... ..... .... ....... ....... .......... ..... 61 

Tab leau 3.3.4. 1.3  Fonctions prédéfi nies sur l' ent ité link ....... ...... .... ........ ......... ............. ........ 62 

Tab leau 3.3.4. 1.4  Fonctions prédéfini es sur  l' en tité node ...... ... ... .... ....... ... .. ...... ...... ...... ...... .. 63 

Tabl eau 3.4. 1.1  Les actions du  langage NetS im ..... ......... ............ .. ... ........ .... .... ...... ........ ... .... . 72 

Tab leau 4.3.1.1  Description  des  ba li ses du  fichier  XML de configuration des distributions 
initiales du  réseau offerte par NetSim  .. ........... ........... ...... ........... .. .... .... ... .... .. ......... ..... ........... 98 

Tableau 5.2.3.1  Com paraison des va leurs des  paramètres utili sées dans la simulation de 
NetSim  avec ce lles  utili sées dans la simulati on des auteurs du  modèle ... .... ............. ... ... .. ... 126 

Tableau 5.2.3.2  Évolution du  coefficient  de trans iti vité au cours de la simulation du  réseau 
d' amis .... ................. ............ ............ .... .. ..... ....... .. ............... .. ....... ................. .... ..... .. .. ........ .... .. 129 

Tab leau 5.3. 1.1  Calcu l de  la probabilité  D , pour  l'ajout de  nouveaux  liens, qui  tient compte 
de  l' attachement préférentiel dans  le modèle du  Web ...... .... ... ................ .... ......... ... ..... ....... .. 132 

Résumé 

Les  réseaux  électroniques  basés  sur  Intern et  ont  beaucoup  accé léré  la  circulation  de 
l'information  dans  notre  société  moderne,  mais  on  commence  à  voir  que  les  échanges 
d'information  s'effectuent  d'abord  dans  le  cadre  de  réseaux  soc iaux.  Le  Web  comporte 
égal ement  une structure en  réseau, mai s ce ll e-ci est assez particulière. 

Ces  différents  types  de  réseaux  d'info rmation  montrent  à  la  fois  des  caractéri stiques 
communes  et  des  spécificités  dont  il  convient  de  tenir  compte.  Pour  des  raisons  à  la  fo is 
techniques,  soci ales et économiques,  il  est donc  utile de chercher à  modéli ser  les  réseaux  pa r 
lesquels circul ent  info rmation et conn aissances. 

En nous inspirant des acquis  importants en soc iolog ie structural e et en analyse  mathématique 
de  réseaux,  nous avons développé  un e approc he de  modélisation des  réseaux  par simulati on. 
Nous  avons  tout  d' abord  développé  un  langage  de  modéli sati on  qui  se  veut  le  plus  fl ex ibl e 
poss ibl e  tout  en  demeurant  simple  et  abordabl e  pour  des  utilisateurs  vari és.  Pour  ce  fa ire, 
nous nous sommes  in spirés  de modèles  ex istants de  la  littérature et avons tenté d' en abstraire 
les concepts essentiels que devrait offrir un  tel langage. 

Ensuite,  nous avons  réali sé  NetSim,  un e  pl ate-fo rme  paramétrable  de  génération de  réseaux 
capable  d' interpréter  ce  langage  et  permettant  de  tester  di verses  hypothèses  sur  la  structure 
des  réseaux  que l'on peut  observer empiriquement.  Cet outil  offre auss i des fonctionnalités de 
vi sualisation, sous forme de graphe, de l'évolution du  réseau dans le temps. 

Finalement, nous avons obtenu  des  résultats plutôt convaincants quant  à  l' utili sati on de notre 
logiciel  pour  modéli ser  et  simuler  di vers  ty pes  de  modèles  de  l' évo lution  temporell e  de  la 
structure des résea ux.  Les  phénomènes observés  par simul ation s'apparentent effect ivement à 
certain s fa its observés dans la  réa lité. 

Ce  logiciel  pourra  servir  d'outil  de  rec herc he,  d'ex périmentation,  de  visualisati on  et  de 
formation dans un  domaine en plein  déve loppement. 

Mots-clés: Réseaux d' informati on, réseaux soc iaux,  modéli sati on, simul ation. 

CHAPITRE  1 

Introduction 

1. 1  Contexte 

Les  réseaux  d' information  sont  des  réseaux  par  lesquels  circulent 

informa tion  et 

connaissances.  Cette défi nition est assez vague, mai s exc lut tout de même un  bon nombre de 

réseaux  :  les  réseaux  de  tran sport  comme  les  résea ux  rout iers  ou  les  lignes  aériennes,  les 

réseaux  de  distribution  comme  les  aqueducs,  le système  sanguin,  les  systèmes  de  livraisons 

par  cami ons ou  par  avions,  etc.  Cependant, cette  di stinct ion n'est pas toujours au ss i claire. 

Par  exem ple,  les  réseaux  routiers  servent  aussi  à  distribuer  le  courrier  qui  est  en  soi  de 

1' information. 

Ce que nous entendons par  information  et/ou connaissances consiste  en tout ce  qui  est util e et 

pertinent  à une entité cognitive pour accomplir une tâche,  résoudre un  prob lème, comprendre 

un e situation, faire  des choix, planifier ou  adopter tel ou  te l comportement  dan s des  situati ons 

diverses.  Par  exemple, si  je sa is, par  le biais  de  la  météo,  qu ' il  va  pleuvoir  le  lendemain , je 

ne  planifierai  certainement  pas  d'aller  faire  un  pique-nique.  Nous  in siston s  ici  sur  le 

caractère  de  la  pertinence.  Une  informat ion  inutile  n'est  pas  vra iment  une  informati on  au 

sens  où  nous  l' entend ons  puisqu ' ell e  ne  détermine  aucun ement  nos  comportements  ni  ne 

motive  nos  choix.  En  ce  sens,  le  degré  de  pertinence  d' une  information  dépend  d' un 

contexte.  En effet, le fait  de  savo ir s' il  pleuvra  le  lendemain  m' importe  peu si je planifie  de 

rester  à  la  maison.  Si  je  sui s  pilote  d'avion,  par  contre,  ma  connaissance  des  conditions 

météorologiques aura  beaucoup plus d' importance que si je travaille comme bib li othéca ire. 

Au  cours  d' une journée,  un  professionnel  moderne  utilise  des  milliers  d' informations  pour 

accomplir son travail.  Ces  informations proviennent  de  plusieurs sources te lles  que  les  livres 

2 

spécialisés,  les  graphiques,  les  cartes,  les  encyc lopédies,  les  codes  et  conventions,  les 

ord inateurs, le courrier électronique,  le  téléphone,  les discussions entre col lègues, les fichi ers 

et les bases de données, le WWW, etc . 

Nous  utili sons  le  concept  de  réseaux  d' information  pour  tenter  de  décrire  la  manière  dont 

1' information  et  les  connaissances  sont  partagées  entre  div erses  entités;  pour  essayer  de 

formali ser ces échanges d' informati on. 

Les résea ux  par  lesquels circu lent information  et connaissances sont  nombreux.  Notre corps, 

par  exempl e,  contient  plusieurs  réseaux  qui  permettent  à  l' inform ation de  circul er  afin  qu e 

celui-ci  puisse fonctionner  normalement.  Parmi  ces  réseaux, on peut  mentionner  le  système 

nerveux  formé  de  neurones  qui  communiquent  entre  eux  par  la  transmission  de  messages 

chimiques  appe lés  neurotransmetteurs.  Si  ce  système  de  communication  se  détériore,  le 

fonctionnement  normal  du  corps  est  en péril.  Par  exemple,  la  maladie  de  Parkinson, qui  est 

une  affection dégénérative du  système  nerveux,  est  causée  par  le  manque  de  production  de 

dopamine (neurotransmetteur)  dan s  le  système  nerveux.  Ce la entrave  la  bonne  transmi ss ion 

des  messages  entre  les neurones  et  il  en  résulte  une  ri gidité  musculaire et  des  tremblements 

du  corps. 

Le  Web est  aussi une  vaste  source  d' information.  Sa  structure,  formée  de  pages  Web  étant 

reliées  entre  ell es  par des  hyperliens,  forme  un  immense  résea u  pass if,  mais dans  lequel on 

peut  navi guer  à  l' aide d' un  fureteur  Web.  On  y transmet des  requêtes  (U RL)  et au retour, on 

reçoit  des  pages d' informati on. 

Nous remarquons cependant que, parce que nous foncti onnons la  plupart du  temps en soc iété, 

la  majorité  des  info rmations  que  nous  recevons  proviennent  de  notre  milieu  socia l  et  sont 

pertinentes  au  se in  même  de  ce  mili eu.  Nous  parlons  ici d' un  type  particu lier  de  réseaux 

d' informati on : les réseaux soc iaux.  Le  concept de  réseaux  soc iaux  tente de formali ser plus 

particulièrement  les  échanges d' information  entre des  individus ou  des groupes soc iaux.  Ces 

échanges  s' effectuent  par les  relations qu ' entretiennent  les  entités  soc iales  entre elles.  Nous 

échangeons  constamment  de  l' information  et  des  connaissances  avec  nos  ami s  ou  nos 

3 

collègues  de  travail.  Nous  entretenons  diffé rents  types  de  relations:  relations  fili ales, 

d' amitié,  de  conse il, de  pouvoir, de collaborati on, d'a ide, de  coopération , etc .  La  nature de 

1' info rmation que  nous échangeons avec  une  personne dépend  du  type  de  relation que  nous 

entretenons  avec  ce ll e-ci.  En  effet,  nos  suj ets  de  discussion  seront  certainement  différents 

se lon  que  nous  di sc utons  avec  un  ami  proc he,  un  collègue  de  trava il  ou  notre  médec in  de 

fa mill e.  Bref,  les  réseaux  sociaux  sont  des  réseaux  par  lesquels  circule  un  bon  nombre 

d' informations  et  de  connaissances  qui  nous  sont  très  utiles  dans  la  gestion  de  nos 

comportements sociaux. 

L' évoluti on  des  technologies  a  grandement  favo risé  les  échanges  soc taux.  Les  résea ux 

téléph oniques,  par exempl e,  permettent  la transmission d' info rmations entre indi vidus.  Avec 

l' arri vée de l' Internet, les  réseaux se sont  multipliés: outre le courrier électronique, on assiste 

à l'émergence  de nombreuses  communautés  virtuelles dont  les membres  communiquent entre 

eux en utili sant  des  outil s comme  les  blogues,  les  wiki s,  les  forums et les  espaces  virtuels de 

co llaboration.  Le  WWW  n'est  pas  un  réseau soc ial en soi,  mais  peut  s'y  apparenter en ce 

sens  que  les  pages  Web  (informati on)  sont  conçues  par  des  individus  et  peuvent  être 

consultées  par des  indi vidu s.  Contrairement  aux  réseaux  soc iaux,  le  Web est  une  structure 

pass ive, mais qui  permet, d' une certaine manière, l'échange d' informations entre individus. 

1.2  Problématique 

Plus on a accès  à  l' information et aux connaissances, meilleures  sont  nos  chances  de réuss ite 

dans l' accompli ssement  de nos  buts.  Ce la est vrai dans tous les  domaines.  Que ce  so it  pour 

prédire la tend ance  du  marché en économ ie, pour  rédiger un  article scientifique, pour  obtenir 

une  promoti on,  pour  accroître  notre. pouvo ir  de  négociation,  pour  gérer  le  personnel d' une 

entreprise, pour demeurer compétitif sur  le  marché, pour déc ider d' investir  ou non dans une 

re lation, l' info rm ati on est une ressou rce  indis pensable. 

Ainsi,  pour  des  ra isons  à  la  fo is  tec hniques,  soc iales  et  économ iques,  il  est  donc  uti le  de 

chercher à  comprendre  les  réseaux  par  lesquels  circulent  info rmation et connaissances. 

Il 

ex iste déj à un  certain  nombre d'approches  pertinentes. 

4 

Pour  les  réseaux  soc 1aux  en  parti culier,  la  soc iologie  structurale  a  élaboré  des  méth odes 

formelles  d'analyse  de réseaux basées sur  la théorie des  graphes  (Lazega,  1998).  Cepend ant, 

ces  enquêtes  soc iologiques  restent  le  plus souvent  lentes  et  laborieuses, car ell es  mobilisent 

un  grand  nombre de ressources : elles sont souvent  très coûteuses, demandent  la participation 

d' un  grand  nombre  d' individus  et  peuvent  parfo is  s'échelonner  sur  plusieurs  années.  De 

plus,  les  études  empiriques  concernant  l' évolution  temporelle  de  la  structure  des  réseaux 

sociaux  sont  essenti elles,  mais  restent  encore  à  un  état  embryonnaire à cause  du  manque  de 

données  de  réseaux  propres  à  ce  genre  d'étude.  En  effet,  il  n' est  pas  fac il e  d' obtenir  des 

données  de  réseaux  pertinentes  s' échelonn ant  sur  une  bonne  période  de  temps et  présentant 

toute  l' inform ati on  nécessa ire  à  la  reconstruction d' un  réseau du  passé  et  de  son  évoluti on 

temporelle.  Bien que ces  études  so ient  assez  rares, elles  ne sont  pas  inex istantes.  Je citera i 

comme exemple  l' étu de des  réseaux de co llaboration sc ientifique, en physique et en bi olog ie, 

conduite  par  (Newman,  2001 ),  pour  tester  l' hypothèse  que  la  transitivité  ams1  qu e 

l' attachement  préférentiel sont des  propri étés de certain s réseaux soc iaux. 

Ce  réseau  de co llaborati on sc ientifique comprend  des  indi vidus qui  sont  reliés  ensemble s' il s 

sont  co-auteurs d' un  même ouvrage  scientifique.  Pour ce fa ire, Newman tira les  info rmations 

de deux sources bibliographiques: 

1.  The  Los  A lam os  E-print  Archi ve,  un e  base  de  données  en  phys ique  dont  les  ouvrages 

sont  soumis par les auteurs eux-mêmes. 

2.  Medline,  une  base  de  données  d' ouvrages  publiés  en  biologie  et  en  médec ine  qui  est 
profess ionnell ement  maintenue par les  instituts nationaux de  la santé (N ati onal In stitutes 
of Hea lth). 

Bien  qu 'aucune  de  ces  bases  de  données  n'enregistre  la  date  de  publication  exacte  des 

ouvrages  qu ' elles contiennent,  les  deux  peuvent fournir  l' ordre dans  lequel  les  ouvrages  ont 

été aj outés à leur base de données respecti ve. 

Newman  a  donc  recueilli  les  données  de  co llaboration  sur  un  interva lle  de  six  ann ées  en 

prenant  les donn ées des cinq premi ères années  pour reconstruire le réseau de collaboration.  Il 

5 

a ensuite étudi é l'évo lution de  la  topologie du  réseau en considérant le passage de la  structure 

du  réseau obtenu  les cinq  premières  années à la structure du  réseau obtenu  à la sixième  année. 

Pour  ce  qui  est  des  réseaux électroniques  basés  sur  Internet,  il  est  poss ible de  les  étudier en 

recueill ant  des  traces  électroniques  de  communications  entre  individu s  et  de  reproduire  le 

graphe de ces  échanges  à des fins  d'analyse.  Nous citerons comme exemple l' article de  Paul 

Mutton (Mutton , 2004)  dans  lequel celui-ci  décrit  une méthode pour  infé rer le réseau soc ial  à 

partir  d'un  groupe d' utili sateurs  d' IRC  (Internet  Relay  Chat) .  Tout  d'a bord ,  un  robot  (bot) 

IRC  est  utilisé  pour  écouter  sur  un  canal  donné.  Ce lui-ci  procède  ensuite  à  une  analyse 

heuristique  des  événements  recen sés  et  crée  une  approx imation  mathématique  du  réseau 

soc ial.  Finalement,  le  robot  peut  produire  une  visualisation graphique du  réseau  inféré.  On 

obtient  alors un  réseau  d' interactions qui  peut être analysé. 

Les  courriels  sont  aussi  des  traces  électroniques  de  communi cations  entre  personnes  qu1 

peuvent  être utilisées pour recréer le réseau d' interactions.  Par exempl e, (V iegas et al. , 2004) 

décrivent deux  logiciels qui  utilisent  les  archi ves  de  cou rriels d' un  individu  pour recréer son 

réseau  soc ial person nel.  Ces  log iciels analysent  les  réseaux  soc iaux  qui  peuvent être dérivés 

des  informations concernant  1 'envoyeur, le ou les  destinataires, le suj et et la date d'envo i des 

courriels.  En analysant les destinataires des  courriels, il  est possible de dériver un  graph e des 

relations soc iales  pouvant  ensuite  être  visualisé.  De  plus, se lon  la  date des  courri els,  on peut 

rec réer et visualiser l'évo lution de  ce  réseau soc ial dans  le temps. 

L'étude  de  la  structure  du  Web  est  auss1 pertinente  pour  comprendre  les  ph énomènes 

soc iologiques  qui  caractérisent  son évo lution.  Considérons  le  Web  com me  un  graphe dirigé 

dans  leq uel  les  pages  Web  sont  les  nœuds  et  les  hyperliens  sont  les  arcs.  On  peut  alors  se 

demander, par exemp le, quel  est son diamètre, à quoi  ressemble la distribution des degrés des 

noeud s ou  bien  quelle est la longueu r moyenne du  chemi n all ant d' une  page  Web à n' importe 

quell e autre (ces notions seront  explicitées  par la su ite).  La  compréhension de  la structure du 

Web  permet,  par  exemple,  d' améliorer  les  algorithmes  d'exploration  de  la  Toile  et  de 

recherche d' informations. 

6 

Pour  étud ier et ana lyser  la structure du  Web,  il  fa ut  d' abord  la cartographier.  Pour  ce  faire, 

on  peut  commencer  avec  quelques  pages  Web  et  découvrir  d' autres  pages  en  suivant  les 

hyperliens  des  pages  initiales.  Puis,  on  suit  les  liens  des  pages  nouve ll ement  découvertes 

pour  en  découvrir  d'autres  et ainsi  de  suite.  On construit  ainsi  un  graphe  qui  représente  la 

topologie du  Web.  Cependant, cette technique a ses  limitations. 

Il  est en effet impossible de 

couvrir  le  Web  dans  son  enti er,  car  si  aucune  des  pages  Web  découvertes  au  cours  du 

processus de  cartographie  ne pointe  vers  une page  particulière,  cette dernière ne sera  jamais 

trouvée.  De  plus,  les  pages  Web  so nt  tellement  nombreuses  (quelques  milli ards)  que  cela 

rend  le  processus  d'exploration  très  long.  La  cartograph ie  du  Web  ne  peut  donc  être  que 

partielle.  Un  exempl e d'étude du  Web par cartographie est donné dans l' article de (Broder et 

al, 2000). 

En  résumé,  les  enquêtes  soc iologiques  sur  le  terrain  mobilisent  un  grand  nombre  de 

ressources.  De  plus,  la  co ll ecte  des  données  est  un  problème  difficile  lorsqu ' il  s'ag it 

d'étudi er l'évolution temporell e de  la structure de réseaux d' information  divers.  Finalement, 

dans  le  cas  particulier de  la cartographie  du  Web, cell e-c i est assez  coûteuse et ne  peut  être 

que partiell e étant donné l' immensité de ce  réseau. 

Bien  que ces méthodes demeurent essentielles, la modéli sation et la simul ation par ordinateur 

nous  semblent  indiquées,  dans  certains  cas,  pour  pallier  ce  problème.  Un  modèle  n' a 

cependant  pas  la  prétention  de  représenter  parfaitement  la  réa lité.  Dans  cette  optique,  la 

modéli sation  ne  doit  pas  être  vue  comme  une  alternati ve  à  l' étude  de  terrain,  mais  plutôt 

comme une approc he comp lémentaire très  util e pour tester ou formuler certaines  hypothèses. 

Les  résultats de simul ations devront tôt ou tard  être comparés aux  ph énomènes observés dans 

la  réalité,  mais  nous  croyons  la  modéli sation  présente  tout  de  même  un  certain  nombre 

d'avantages  pour  la compréhension  de  phénomènes  particuliers.  Elle demeure  un  ou ti 1 à  ne 

pas négliger tout en gardant  à l' esprit  les  limites de nos  modèles. 

Il  existe  déjà  plusieurs  modè les  de  réseaux d' information  provenant  de  diverses  disciplines 

telles  que la physique, les  mathématiques et la soc iologie.  Ces modèles tentent de représenter 

partiellement  des  phénomènes  particuliers  observés  dan s  le  monde  rée l,  tel s  que  la 

7 

transitivité, 

l'effet  des  petits  mondes  et  l'homophilie  dan s 

les 

réseaux  soc 1aux  ou 

l'attachement  préférentiel dans  le réseau du  Web. 

Ces modèles sont  pour la plupart des  modèles statiques, mai s de plus en  plus, on commence à 

concevo ir  des  modèles  dynamiques  de  l'évolution de  la  structure  de  réseaux  d' information 

dans  le  temps  (Jin,  Girvan  et  Newman,  200 1 ;  Albert  et  Barabasi,  2000).  Les  modèles 

statiques  sont  souvent  défini s  par  un  algorithme  qui  permet  de  construire  une  structure 

particulière  de  réseau qui  possède  les  caractéristiques  que  l' on  veut  démontrer.  Un  modèl e 

dynamique,  quant  à  lui ,  fait  intervenir  la  notion  de  temps. 

Il  cons iste  en  un  ensemble  de 

règles  servant  à  construire  ou  modifier  le  réseau.  En  général,  ces  règles  doivent  être 

effectuées, se lon  certaines  probabilités  ou  cond itions, à chaque  pas de temps.  On  peut  alors 

observer  une  modification  de  la  topologie  du  réseau  dans  le  temps.  Le  but  de  ce  type  de 

modéli sation  est  souvent  d'étudier  les  mécanismes  qui  produi sent  des  structures  de  résea ux 

possédant certaines caractéristiques observées dans le mond e rée l. 

Une  grand e  partie  des  modèles  ex istants  prennent  la  forme  d' un  graphe  dans  lequel  les 

sommets  représentent  les  entités  du  réseau  et  les  arcs  ou  arêtes  du  graph e  représentent  les 

relations  entre  ces  entités.  Par  exemple,  dans  le cas  du  Web,  les  sommets  représentent  les 

pages  Web et  les  arcs  représentent  les  hyperliens  qui  reli ent  les  pages  entre  elles.  Pour  un 

réseau  soc ial,  les  sommets  représentent  les  individus  (acteurs)  de  l' ensemb le  soc ial  et  les 

1 iens représentent  les relation s (d'amitié, par exemple) qu ' il s ont  entre  eux.  La  représentation 

sous  forme  de  graphe  est  particulièrement  intéressante,  car  ell e  permet  l' utili sation  de  la 

théorie des graph es et de  l'a lgèbre  matriciell e pour  l'analyse de  la structure des  résea ux. 

La  vi suali sation du  réseau  sous  forme  de  graphe est  auss i très  avantageuse.  Ell e  permet  de 

constater  rapidement,  sans  autre  analyse,  s' il  semb le  se  former  certains  agencements 

particuliers dan s  la structure du  réseau  étud ié.  La  figure  1.2. 1 illustre  quelques  exemples de 

structures  particu 1 ières pouvant être faci lement  repérées  par la vi suai isation  graphique. 

8 

Figure 1.2.1  Repérage de structures typiques par visualisation graphique 
La  visualisation graphique est un  atout  considérable dans  l'étude  structurale des  réseaux.  Elle permet 
de repérer rapidement  certaines  caractéristiques du  réseau.  Supposons, par  exemple, que  les  réseaux 
ci-dessus  sont  des  réseaux  sociaux.  La  figure  (a)  montre  une  structure  en  fo rme  d'étoile.  On  y 
remarque  fac ilement  un  acteur  central  qui  de  ce  fait,  a  beaucoup  d' influence  sur  la  circu lation  de 
l' information vers  les  acteurs  périphériques,  car  chaq ue  acteur  périphérique  doit  passer  par  l'acteur 
central pour communiquer avec  les autres.  La figure (b)  montre une structu re  en  forme  d'arborescence 
qui  induit  tout  de  suite  l' idée  d'une  hiérarchie.  La  fi gure  (c)  montre  un  réseau où  l' on  remarque 
facilement  la création de petites communautés distinctes  au sein  du  réseau. 

Dans  le  cadre  de  ce  trava il ,  les  modèl es  qui  nous  intéressent  plus  particulièrement  sont  les 

modè les  dynamiques  pouvant être représentés  sous fo rme de graphe.  Étant  donné qu ' il s sont 

dynamiques,  nous  pouvons  les  simuler  par  ordinateur  pour  observer  leurs  changements 

structuraux au  cours du  temps.  Bien qu ' il  ex iste beaucoup d'outil s (log iciels et librairies) qui 

aident  à  la  programmation  d' un  modè le  dans  le  but  de  le  simul er  et  de  le  vi sualiser,  on 

constate  que  la  plupart  de  ces  outil s  sont  assez  comp lexes  et  demand ent  souvent  une  bonne 

connaissance  de  divers 

langages  de  programmation.  Aussi,  dans  bien  des  cas, 

la 

programmation  de  la  simulation  est  propre  à  un  modèle  ou  une  classe  de  modè les  en 

particulier et tout  le trava il  de  programmati on est à recommencer lorsque !" on veut  simuler un 

modèle différent. 

Dans cette optique, nous avons élaboré  un  langage de  modé li sation de  réseaux d' information 

simple  et  abordable  pou r  des  utili sateurs  variés.  Nous  avons  ensuite  réa li sé  NetSim,  une 

plate-forme  de  simulation  paramétrable,  capab le  d' interpréter  ce  langage  de  modé li sat ion. 

NetSim  permet  de  modifier  fac ilement  et  rapidement  les  règles  et  les  paramètres  de  divers 

9 

modèles  et permet au ss i la vi sua i isati on, sous forme de graphe, de 1 ' évo luti on de  la structure 

du  réseau dans le temps. 

1.3  Objectifs de recherche et méthodologie 

1.3.1  Création d'un  langage de modélisation de réseaux d'information 

Notre  premier obj ectif est la créati on d' un  langage  de modélisation de réseaux d' information 

facile  à  ut ili ser  pour  les  concepteurs  de  modèles  qui ,  le  plus  souvent,  ne  sont  pas  des 

informaticiens.  Notre  but  est  de  trouver  une  façon  d'exprimer  les  règles  des  modèles 

dynamiques  de  manière  intuitive  pour  l' util isateur,  qui  refl ète  l'esprit  du  modèle.  Pour  ce 

fa ire, nous avons observé  différents modèles  dynamiques  de réseaux ex istants (Jin , Girvan et 

Newman,  2001  ;  Barabas i et  Albert,  1999 ;  Albert  et  Barabas i,  2000)  et  avons  tenté  d'en 

abstraire  les  concepts  essentiels  que  devrait exprim er  un  tel  langage.  En  parti cul ier,  nous 

avons  passé  en  revue  les  entités,  les  structures  et  les  actions  de  base  nécessa ires  pour 

modéliser  ce  domaine.  Ce  langage  a  d'abord  été  élaboré  pour  déc rire  des  modèles  de 

l'évo lution  de  la  structure  des  réseaux  soc iaux  et  du  Web,  mais  reste  assez  soup le  pour 

exprimer une certain e vari été d' autres  modèles de résea ux d' info rmati on. 

Parce  que  nous dés irons concevoir  un  langage  qu i, d ' une  part, est auss i générique (fl exib le) 

que  poss ib le,  mais  d' autre  part,  demeure  simp le  et  abordab le  pour  des  util isateurs  divers, 

nous avons dli  cerner  le champ  d'appli cation de  notre  langage  de  modélisation  par quelques 

principes  généraux.  Les  principes  sui vants  aident  à  déterminer  les  types  de  modèles 

dynamiqu es  pouva nt  être traduits dan s ce  langage : 

1.  Le  modèle doit représenter le réseau d' inform ati on sous forme de graphe. 

2.  L' ensemble  des  règles  du  modèle  s' app lique,  se lon  certaines  probabilités  ou 

conditi ons, à chaque pas  de temps. 

10 

3.  Le  modèle  peut  définir  des  attributs  sur  les  nœuds,  les  li ens  ou  le  réseau  global 

pourvu  que ceux-ci  soient  numériques.  L' ensembl e des  valeurs de chaque attribut au 

temps  t  est  ce  qui  détermine  l' état  du  réseau  au  temps  t.  Les  valeurs  des  attributs 

peuvent  changer  au  cours  du  temps,  se lon  certaines  probabilités  ou  conditi ons  qui 

peuvent dépendre de 1 'état du  système. 

4.  Les  règles  du  modèle  peuvent  concerner  la  suppress ion  ou  l' aj out  de  nœud s  ou  de 

liens  ou  bien  la  modificati on  des  attributs  des  nœuds,  des  liens  ou  du  réseau.  Le 

modèle peut  spécifier l' exécution des  règ les  en fonction de  l' état du  système ou selon 

certaines probabilités ou conditi ons qui  peuvent dépendre de l'état du  système. 

1.3.2  Implémentation d'un  logiciel d'interprétation du  langage de modélisation 

Notre  deuxième  obj ectif  est  de  concevoir  un 

logiciel  de  simul ation  (NetSim)  capabl e 

d' interpréter 

les  modèles  écrits  dan s  notre 

langage  de  modéli sation  et  offrant  des 

fonctionn alités de visuali sation de l' évolution temporelle de la structure des  réseaux simulés. 

Nous  voulons  plus  parti culièrement  concevo ir  une  plate-forme  générique  de  générati on  de 

réseaux  qui  peut  être  facilem ent  extensible.  Nous  avons  donc  déterminé  quelques 

fonctionnalités  importantes à réali ser dans le cadre de ce  travail , mais nous voul ons concevoir 

ce 

log iciel  dans  1 'optique  de 

fa ci 1 iter  1' implémentation  éventuell e  de  nouvelles 

fonctionnai ités. 

L'aspect  visuali sati on,  sous  forme  de  graphe,  est  auss i  une  ca ractéri stique  importante  que 

nous  désirons  impl émenter.  Comme  nous  l' avons  vu  bri èvement  à  la  secti on  1.2,  la 

visuali sati on graphique permet de reconnaître instantanément certa ins moti fs  structuraux dans 

le résea u simulé.  Dans certain s cas, cette reconnaissance  in stantanée  peut  rapid ement  valider 

ou  in va l id er nos  hypothèses  initiales  ou alors  nous  con du ire  à fo rmuler d'autres  hypothèses 

sur  les caractéristiq ues de  la structure des réseaux étudiés. 

1 1 

JI  s'agit  à  la  fo is  d'étudier  des  phénomènes  soc iaux  remarquabl es  et  de  contribuer  à  la 

modéli sati on de  réseaux  variés.  La  plupart  des  travaux  techniques  actuels  ne  ti ennent  pas 

suffi samment  compte  des  aspects  soc iaux  de  la  communication  et  restent  ain si en  deçà  de 

leur  potenti el d'utili sati on.  Nous  attendons de  ce  projet  la  poss ibilité  de modéliser finem ent 

des  réseaux  pertinents  pour  la circul ation de  l'information.  Ce la  nous semble  très  utile,  par 

exemple, pour  le déve loppement  de nouve ll es applications de communication électronique ou 

de travai 1 collaborati f par ordinateur. 

Ce  logiciel  pourra  servir  d'outil  de  recherche,  d'expérimentation,  de  visualisati on  et  de 

formation dans  un  domaine en  plein  déve loppement.  Le  système  est  conçu en ce  but,  avec 

un e  interface  appropriée  pour  contribuer  en  particulier  à  la  modéli sation  de  l'évolution 

temporell e des  réseaux. 

1.3.3  Simulation de réseaux d'information divers à  l'aide de NetSim 

Notre  derni er obj ectif  de  recherche  est  de tester di ffé rents  modèles  dynamiques  de  réseaux 

d' information  ex istants  à  l' aide  de  NetSim .  Nous  voulons  alors  comparer  les  résultats 

obtenus  de  nos  simul ations  avec  les  résultats  de  simulati on  obtenu s  par  les  auteurs  des 

modèles étudiés et avec  les phénomènes observés dans le monde rée l. 

1.4  Plan du mémoire 

Dans  le chapitre 2, nous ex pliquons di fférentes  notions qui  concern ent  un  type parti culier de 

réseaux  d' informati on :  les  résea ux  soc iaux.  Ce  chapitre  vise  principalement  à  présenter  le 

contexte théorique qui  a motivé la  concepti on d' une plate-forme générique de modélisation et 

de  simulation de réseaux d' informati on et plus particulièrement, de réseaux soc iaux. 

Dans un  premi er temps, nous montrerons que  les  réseaux  sociaux occupent  une grande pl ace 

da ns notre soci été  et  qu' il est pertinent de  vou loir chercher à les comprendre.  En second  lieu, 

nous expliquerons quelques  méthodes  d'analyses  des  réseaux soc iaux  tirées  de  la soc iologie 

structura le.  Ensuite, nous verrons  que  l'étude des  réseaux  sociaux, par modéli sation , a don né 

12 

lieu  à  une  grande  variété  de  modèles  provenant  de  domain es  divers  et  nous  commenterons 

quelques-uns  de  ces  modèles.  Finalement,  nous  di scuterons  des  types  d' outil s  qui  ex istent 

pour  modéli ser, simuler  et  visualiser  les  réseaux  soc iaux  en  les  posi tionnant  par  rapport  au 

logiciel NetSim. 

Au  chapitre  3,  nous  présentons  le  langage  de  modélisation  de  NetSi m.  Nous  verrons  les 

entités, les  attributs et les  fonctions qui  le composent  et la faço n d' exprimer, dans ce  langage, 

les  définiti ons  et  les  règles  des  modèles  que  l' on  veut  simul er.  Pour  ce  fa ire,  nous 

commenterons  plusieurs  exemples  pour  fi nalement  écrire  un  modèle  complet  tiré  de  la 

1 ittérature. 

Dans  le  chapitre  4,  nous  expliquons  l' architecture  et  le  foncti onnement  de  NetSim .  Nous 

présenterons tout d'abord  une  vue  d' ensembl e  du  fo nctionnement  de cette  plate-fo rme  pour 

ensuite  expliquer,  de  façon  plus  détaill ée,  certaines  foncti onn alités  que  nous  consid érons 

comme  les plus importantes. 

Le chapitre  5  prése nte  les  résultats  obtenus des  sim ulat ions  que  nous  avo ns  effectuées  avec 

NetSim .  Nous  modéli serons  différents  modèles  de  la  littérature  à  l'a id e  du  langage  de 

modéli sation  de NetSim  et comparerons nos  résultats de simul ati on avec  les  résultats obtenu s 

par les auteurs de ces  modèles.  Auss i, nous tenterons de faire  le  parallèle entre  nos  résultats 

et les phénomènes que nous pouvons observer dans la réa lité. 

Finalement,  dans  le  chapitre  6,  nous  présentons  la  conclusion  de  ce  trava il  de  recherche. 

Nous  rappellerons  nos  pri nci pales  réa lisations  et  proposerons  diffé rentes  avenues  de 

recherche  qui  seraient  intéressantes  pour 

la  continuation  de  ce  proj et  dans  le  futur. 

CHAPITRE  2 

Les réseaux sociaux 

2. 1  Introduction 

Nous consacrons un  chapitre entier sur  les  résea ux soc iaux, car ce  ty pe particulier de réseaux 

d' information est  un  domaine de  recherche en  plein  déve loppement  tout  en ayant  une assez 

longue  hi stoire.  En effet, les  réseaux  électroniques  basés  sur  Internet  ont bea ucoup  accé léré 

la  circulation de  l' information dans notre soc iété modern e,  mais on commence  à  vo ir que  les 

échanges d' informations s'effectuent d'abord  dans le cadre de réseaux soc iaux. 

On remarque, entre autres, l' apparition mass ive  de log iciels dits soc iaux (ex. : les  wikis et les 

blogues).  Les  outil s de co llaboration traditionnels (collecticiels), orientés projet, ava ient  pour 

but  d'aider  les  orga nisations à  communiquer.  co llaborer et à  coord onner  leurs  acti vités  afin 

d'accomplir  une  tâche commune  aux  membres  du  groupe  (Elli s,  Gibbs et  Rein,  199 1 ).  Les 

logiciels  soc iaux  visent  un  tout  autre  objectif.  Ces  logiciels  sont  destinés  à  promouvo ir  les 

interactions  entre  personnes  incluant  la  communication  en  temps  rée l  (ex.:  messagen e 

instantanée)  ou  en  temps  différé  (ex. :  espace  virtuel  de  co llaborati on,  messagen e 

électronique, fo rums).  Ils offrent  auss i la poss ibilité aux  indi vidus ou aux groupes  d'éva luer 

les  contributions de  leurs co llègues  et supportent  la représentati on et  la gestion électroniqu e 

des  réseaux  soc iaux  personnels  des  individus  tout  en  leur  permettant  de  les  déve lopper 

(Lamy, 2004). 

Dans ce  chapitre, nous voyons comment  le déve loppement  remarquable des  réseaux soc iaux 

infl uence,  entre  autres,  le  domai ne  de  la  gestion  de  la  connaissance,  le  déve loppement 

d'outil s pour  l'a ide à la  recherche d' informations, la tendance, de plus en plus grand e, qu ' ont 

14 

les  entreprises  à  se  regrouper en  réseaux  pour  affronter le  marché ain si que  la  perception de 

ce qui  pourrait bien être la future génération de l' Internet. 

En  second  lieu,  nous  présentons  quelques  méthodes  d' analyse  de  réseaux  soc iaux  proposés 

par  la  soc iologie  structurale,  car  celles-ci  peuvent  s'avérer  très  utiles  pour  comprendre  et 

analyser la structure des  réseaux générés par modélisation et simul ation. 

Ensuite, étant  donné que nous nous intéressons particulièrement  à l' étude des  réseaux soc iaux 

par modéli sati on, nous  présentons  une  revue  partielle des  modèles  actuels.  Encore  une fois, 

on remarque que  l' intérêt pour  les  réseaux sociaux  se  retrouve dans plusieurs di sc iplines.  En 

effet, nous verrons des  modèles  provenant  de champs d'études  auss i variés  que  la  phys ique, 

les  mathématiques, l'économie et la  sociologie. 

Finalement,  nous  pos itionnons  les  pnnc1paux  outil s  de  modéli sation  et  de  simulation  de 

réseaux soc iaux par rapport au logiciel que nous proposons dans ce  projet. 

2.2  Un  domaine de  recherche en pleine expansion 

2.2.1  Les  réseaux sociaux dans la  gestion de la  connaissance 

La  gestion  de  la  conn aissance  (knowledge  management)  s' intéresse  à  l' organi sati on,  la 

création,  le  partage  et  la  circulation  de  la  connaissance  au  se in  d' un e  organi sati on:  ell e 

cherche  à  mettre  à  profit  la  connaissance  déj à  di sponible  et  tente  de  susc iter  la  créati on  de 

nouvelles connaissances. 

La  première génération de la gestion des  connaissances  re posa it  sur l' idée de  l' importance de 

sui vre  et  documenter  tous  les  processus  de  l'organi sation  afin  que  cette  information  so it 

access ible  à  tous,  dans  un  environnement  corporatif,  par  exempl e,  un  Intranet.  Les 

entreprises  ont  alors  investi des  sommes  importantes  da ns  diffé rentes  tec hnologies  comm e 

des  collecticiels  qui  deva ient,  justement,  les  aider  à  gérer  et  coordonner  leurs  acti vités. 

Cependant, cet effort  s'est révé lé peu  productif, car on  a réalisé  que tout  le travail  nécessaire 

15 

à  rend re  accessible  cette  info rmation  était  tro p  énorme  par  rapport  au  nombre  de  gens  qui 

utilisa ient rée llement 1 'Intranet mis à leur dispos ition. 

La  seconde  génération  de  la  gestion  de  la  connaissance  s' est  inspiré  de  la  théorie  des 

systèmes  com plexes  et  de  ce ll e  du  chaos.  Le  modèle  class ique  d'organi sati on  fe rmée 

« intégrée  » a  été  rempl acé  par  un  modèle  organisationnel  compri s  en  tant  que  système 

complexe  à  l' intérieur  duquel  des  entités  interdépendantes  sont  capabl es  de  réagir  à  leur 

environnement.  Par exemple,  des  études  (Baker et Go llub,  1990) ont  montré  qu ' un  système 

complexe fo nctionne à son max imum  lorsqu ' il  est au bord du  chaos.  Le bord du chaos (edge 

of chaos) , est  un  terme qui  a été  introduit  par Chri s Langton de  l' in stitut  Santa  Fe  et désigne 

l' état  critique  dans  leq uel  se  trouve  le  système  au  moment  où  une  toute  petite  flu ctuation 

pourrait  le  pousser  so it  vers  un  comportement  chaotique,  so it  vers  un  comportement  stab le. 

Lorsqu ' un  système  compl exe  est au  bord du  chaos,  il est  dans  un  état  où  les  changements 

peuvent  survenir  fac ilement  et de façon spontanée.  Ains i,  l' id entification et  la  pro longat ion 

de  cet état ont des  impli cations  intéressantes  au  niveau de  l'organi sation des  entreprises  qui 

do ivent  constamment  s'adapter et réagir rapidement au  marché sans cesse changeant. 

Cette  nouve lle  faço n d'a border  la gesti on de  la  connaissance  donne  la  pri orité  à  la  manière 

dont  les  gens constru isent et  util isent  la connaissance.  Elle s' intéresse aux  interacti ons entre 

les  personnes  fo rmant  le  réseau  social  qu ' est  l' organisation.  Auj ourd' hu i,  donc,  les 

gesti onnaires  comprennent  bien  l' importance  des  connaissances  dites  tac ites  (connaissances 

personnelles,  subjecti ves,  intu itives,  relevant  de 

l'expérience,  assoc iées  à  un  contexte 

spéc ifi que)  tant  que  cell es,  plus  tôt  convoitées  par  la  première  génération  de  gest ion  de  la 

connaissance, dites  ex plicites  (codifiées,  sémantiques,  fo rmell es, fac il ement  com muni cab les, 

extériori sées).  Les  connaissances  tac ites  se  communiquent  par  la  soc iali sation.  (Nonaka, 

1991 ).  Celles-ci  se  transmettent  donc  à  travers  les  interactions  huma ines  et  plu sieurs 

technologies  sont  ma intenant  employées  à  favoriser  ces  interactions.  Ce  sont  les  logic iels 

sociaux tels que  le courrier électroniq ue, Usenet, IRC, la messagerie  instantanée, les  blogues, 

les  wikis, NNTP, folksonomy et  les communautés virtuell es en  ligne.  On  parle maintenant de 

l' âge de la  connex ion  plutôt que de  celui de  l' information. 

16 

2.2.2  Les  réseaux sociaux comme aide à la  recherche d'information 

Pour débusquer l' information  pertinente,  les  réseaux sociaux s'avèrent souvent  très utiles.  La 

recherche d' informati on est généralement entravée  par deux  choses: la difficulté de faire une 

requête  préc ise  lorsque  l' utili sateur  ne connaît  pas  bien  le  suj et  et  le  fait  que  beaucoup  de 

connaissances  sont  tac ites  et  donc  difficilement  access ibles.  En général,  la  meilleure  façon 

de remédier à ce  problème est de  demander une ass istance humaine.  Ainsi, de plus en plus de 

systèmes  informatiques  sont  développés  dans  cette  optique  et  utili sés  pour  créer  des 

communautés  virtuell es  et  faciliter  la  locali sation  de  la  bonne  personne  dans  la  recherche 

d' information (M emmi  et Nérot, 2003). 

Les méthodes classiques de recherche d' informati on ne tiennent  pas  compte de l'aspect soc ial 

de  la producti on et  la consommati on de l' information.  De  plus en plus,  des  techniques  plus 

actuelles 

tentent  d' intégrer  des 

informations  à  propos  de  l' environnement  soc ial  de 

l' utili sateur  et  de  sa  position  dans  le  réseau  soc ial  afin  d'améliorer  l'effi cac ité  de  sa 

recherche. 

Par exemple,  le  moteur  de  recherche  Google  a  été  le  premier à  intégrer  une  analyse  de  la 

structure du  graphe du  Web dans ses  algorithmes  de recherche (Brin  et Page,  1998).  Comme 

on  sa it,  Google  renvo ie  en  priorité  les  pages  sur  lesquelles  pointent  le  plus  de  liens,  en 

considérant  que c'est un  bon indi ce de leur crédibilité et de leur pertinence. 

Le 

logiciel  Human  Links  (http://www.human-l inks.com)  est  un  moteur  de  recherche 

di stribué,  construit  se lon  une  architecture  poste-à-poste  (peer-to-peer),  qui  expl oite 

1 ' experti se co llective des  uti 1 isateurs.  Lorsqu ' un  utili sateur se connecte au système, il  dev ient 

un  nœud  dans ce  réseau poste-à-poste (peer-to-peer) et de ce fait, contribue implicitement  à la 

rec herche  d' information.  Le  système  extrait  automatiquement  un  profi l  spéc ifique  pour 

chaque  utili sateur  à  partir  de  ses  marque-pages  Web,  par  exemple  (d 'a utres  in fo rmat ions 

peuvent aussi être  ut ilisées)  et  la similarité entre  les  profi ls des  utilisateurs défi nit  un  réseau 

virtuel.  Dans  ce  réseau,  les  ut il isateu rs  sont  considérés  comme  étant  proches  les  un s  des 

autres  si leurs profi ls sont  similaires  et non parce  qu ' ils sont  adj acents dans la structure réell e 

du  graphe.  Lorsqu ' un  utilisateur soumet une requête au système, cette requête est propagée  à 

17 

travers  le réseau poste-à-poste  pour  localiser des  experts  potentiel s sur  le  sujet en comparant 

la  requête  avec  les  profils  des  utilisateurs.  Lorsqu ' un  expert  est  trouvé,  le  système  peut 

fonctionner  de  deux  façons  différentes :  il  peut  demander  à  l' expert  s' il  est  prêt  à  aider 

l' auteur  de  la  requête,  ou  bien  il  peut  utiliser  le  profil  de  l'expert  pour  raffiner  la  requête 

initiale  puis  reprendre  sa  recherche.  Ce  logiciel  peut  donc  être  utilisé  pour  trouver  des 

documents aussi  bien que de  l'experti se  humaine. 

Referra!Web  (Kautz,  Selman  et  Shah,  1997)  est  un  autre  exemple.  Ce  système  a  pour  but 

d' améliorer  la  recherche  d' information  en  construisant  un  réseau soc ial  puis en trouvant  un 

ex pert dan s ce  réseau .  Les  liens soc iaux  sont extraits automatiquement  du  Web en observant 

les cooccurrences des noms propres cités dan s les  pages  Web.  Par exemple, les co-auteurs de 

publication s  dans  les  bibliographies  ou  les  membres  d' un  même  département  universitaire 

seront  considérés  comme  étant  en  relation  les  uns avec  les  autres.  Ce  réseau  peut  alors être 

utilisé  pour loca li ser des experts sur  un  suj et particulier en suivant  les  li ens soc iaux. 

Une  di sc uss ion plus complète sur l' utili sation  des  réseaux soc iaux comme aide à la  recherche 

d' informati on est présentée dan s l'article de  (Kirsch, Gnasa et Cremers, 2006). 

2.2.3  Les entreprises en  réseaux 

Pour  soutenir  la  concurrence  et  maintenir  un  bon  nivea u  de  prod uctivité,  dans  une  soc iété 

technologique  où les  produits sont  v désuets, où les techn olog ies  évo luent  constamment et où 

les  entrepri ses  doivent  répondre  rapidement  à  la  demande,  de  plus  en  plus,  « pour  créer 

davantage  de  valeur  et  soutenir  des  ga ins  de  producti vités,  les  entreprises  devront  s' ouvrir 

vers  l'extérieur  et  identifier  de  nouvelles  façons  de  coordonner  leurs  activités  autour  de 

réseaux  réunissant un  grand  nombre d' entrepri ses.» (Poulin, 2004).  La  mise en  commun des 

ressources a pour  but de favoriser  l' innovati on et ainsi, permettre  aux entrepri ses de demeurer 

concurrentielles.  Dans cette optique, il  serait  avantageux, par exemple, d'étudier les types  de 

structures relationnelles qui  favor isent l'émergence de  l' innovation. 

18 

2.2.4  Conception  d'une future génération de  l'Internet inspirée des réseaux 
sociaux 

Il  ex iste,  en  ce  moment,  une  proposition  qui  pourrait  bien  devenir  la  future  génération 

d' Internet :  la  création  d' un  réseau  soc ial  augmenté  (Augmented  socia l  network  ASN)  qui 

bâtirait  identité et confiance à l' intérieur de  l' architecture  d' Internet.  ASN  (Jordan , Hauser et 

Foster,  2003)  propose  une  forme  de  citoyenneté  en  ligne  et  a  pour  but  de  faciliter 

1' introduction  entre  personnes  qu i  partagent 

les  mêmes  affin ités  ou  des 

intérêts 

complémentaires  à  travers  le  réseau  soc ial. 

Il  n'est  pas  certain  que  ASN  dev ienn e 

effectivement  l' Internet du  futur, mai s  cette  propos ition  montre  encore  l' intérêt des  réseaux 

sociaux dans l'actualité. 

2.3  Analyse des structures relationnelles 

2.3.1  Définition et représentation d'un  réseau social 

Un  réseau  soc ial  peut  être  défi ni  comme  étant  un  ensemble  de  relati ons  entre  un  ensemb le 

fini  d' indi vidu s,  ceux-c i fa isant fi gure d' acteurs (ou d·agents)  à l' intéri eur du  résea u. 

Il  est  poss ib le  d' id entifi er  plusieurs  types  de  relati ons  (collaboration,  soutien,  contrôle, 

consei l, influence,  parenté,  am itié,  etc.)  qu ' entretiennent  les  acteurs les  un s avec  les  autres au 

se in  d' un  ensemble  social.  À  titre  d'exempl e,  prenons  les  empl oyés  d' un e entreprise.  On 

peut  alors  se  demander qui  co llabore  avec  qui  au se in  de  cette  soc iété.  On obtient  alors  un 

réseau soc ial formé  de  l' ensemble des  relations de coll aborat ion entre  les  employés de  cette 

entreprise.  Dans  cet exemple, le résea u est constitué de  relations entre  individus, mais nous 

pourrions,  de  la  même  façon ,  considérer  les  relations  qui  ex istent  entre  différe nts  groupes 

soc1aux.  Dans  ce  cas,  l'acteur  n' est  plus  un  indi vidu,  mai s  un  ensemble  d' individus.  Par 

exempl e,  nous  pourri ons  étudier  les  relati ons  de  co ll aborat ion  entre  plusieurs  entreprises, 

chaq ue entreprise fa isant figure d'acteur à 1' intérieur du  réseau. 

Les  réseaux  sociaux,  de  par  leur  nature,  peuvent  facilement  être  représentés  sous  form e  de 

graphe : chaque acteur du  réseau  social  est représenté  par  un  sommet (ou  noeud) du  graphe et 

19 

chaque  relation  entre  deux 

indi vidus  est  représentée  par  une  arête  (si  la  relation  est 

bidirectionnelle) ou  un  arc (si  la relation  est unidirectionnelle) du  graphe.  Par ana logie,  il  est 

donc  possible  d'appliquer  les  concepts  de  la  théorie  des  graphes  aux  réseaux  sociaux.  On 

peut alors parler de  proximité,  de di stance, de densité, etc. 

Par  exemple,  il  existe  plusieurs  mesures  de  di stance.  L' une  d'entre  ell es  est  la  distance 

géodésique  qui  mesure  le  plus  court  chemin  entre  deux  sommets.  Lorsque  la  di stance 

géodésique entre deux acteurs est faibl e, on dit que les  acteurs sont  proc hes  l' un  de  l'autre,  s i 

el le  est  grande,  on  dit  qu ' ils  sont  éloignés  l' un  de  l' autre.  Le  diamètre  d' un  graphe 

correspond  à  la longueur du  plus  long  géodésique  reli ant  n' importe quell e  paire de sommets 

dans  le  graphe.  C'est la di stance géodésique  maximale entre deux membres. 

Aussi , on  dit  d' une  relation  qu 'e lle est directe  si  la  di stance entre  les  deux  acteurs est  d' un 

seul  pas et qu 'e lle est  indirecte sinon.  Sachant  que  dan s un  graphe den sommets,  le nombre 

de  li ens  possibles  est  égal  à  n(n-1)  pour  un  graphe  orienté et à n(n- 1)12  pour  un  graph e  non 

ori enté,  on  peut alors calculer la densité d' un  graphe de  cette façon  : 

Densité  =  nombre de relations directes 1 nombre de relations possibles 

Ceci  n'est  qu ' un  bref aperçu  des  applications  possib les  de la théorie des  graphes  aux  réseaux 

sociaux,  mai s  ce  qu ' il  faut  retenir  ici  est  que  l'étude  des  ensembl es  soc iaux  sous  forme  de 

réseaux  permet  l' application  de  mesures  qui  peuvent  s' avérer  très  utiles  lors de  l' ana lyse  de 

la  structure  relationnell e.  De  plu s,  l' information  contenue  dans  un  graphe  peut  être 

représentée  dans  une  matrice. 

La  représentation  matri ciell e  permet  alors  l' utili sation 

d'opérations  algébriques  matrici ell es  dans  l'analyse  des  réseaux .  On  appell e  matrice 

sociométrique  une  matrice  qui  montre  tous  les  arcs  (relations  directes)  d' un  graphe.  Pour 

connaître  la di stribution  des  relations  indirectes  de  x  pas,  il  suffit  d'é lever cette  matrice  à  la 

puissance x.  La fi gure 2.3.1 .2 illustre ce cas. 

L------------------------------------------------------------------------------------------------------~ 

~ -

20 

1  2  3  4  5  6  7 

0  0  0  1  0  1  0 
0  0  0  0  0  0  0 
0  1  0  0  0  0  0 
1  0  1  0  0  0  0 
0  0  0  1  0  0  0 
0  0  0  0  0  0  0 
1  0  0  0  1  0  0 

2 
3 

4 

5 

6 

7 

(a) Graphe  G 

(b)  Matri ce sociom étrique M 

représentant le graphe G 

2 
3 
4 
5 
6 

7 

1  2  3  4  5  6  7 
0  1  0  0  0  0 
0  0  0  0  0  0  0 
0  0  0  0  0  0  0 
0  1  0  1  0  1  0 
1  0  1  0  0  0  0 
0  0  0  0  0  0  0 
0  0  0  2  0  1  0 

(c)  M 2 

1  2  3  4  5  6  7 

1  2  3  4  5  6  7 

2 

3 

4 

5 

6 

7 

0  1  0  1  0  1  0 
0  0  0  0  0  0  0 
0  0  0  0  0  0  0 
1  0  1  0  0  0  0 
0  1  0  1  0  1  0 
0  0  0  0  0  0  0 
2  0  2  0  0  0  0 

(d ) M3 

1  0  1  0  0  0  0 
0  0  0  0  0  0  0 
0  0  0  0  0  0  0 
0  1  0  1  0  1  0 
1  0  1  0  0  0  0 
0  0  0  0  0  0  0 
0  2  0  2  0  2  0 

2 

3 

5 

6 

7 

(e) M4 

Figure 2.3.1.2  C hemin s d e  longueu r  x d a ns  un e ma trice soc iométriqu e 
La  matr ice  sociométr ique  de  la  fi gure  (b)  montre  tous  les  chemins  de  longueur  1 contenus  dans  le 
graph e G  de  la  fi gure (a). 
Il  suffit  d'élever cette matrice  à  la  pu issance  x  pour  obtenir  un e  matrice du 
nombre  de  chemins  de  longueur  x  pour  aller  du  iicme so mm et  (ligne)  vers  le / me so mm et  (co lonne), 
pour  tous  les  sommets  du  graphe.  Par  exemp le,  la  fi gure  (c)  montre  la  matrice  M  élevée  au  carré. 
Cette  matr ice  contient  donc  tous  les  chemins  de  longueur  2.  Ainsi, on peut  y  observer qu ' il ex iste  2 
chemins  de  longueur  2  pour  aller du  sommet 7 au so mm et 4  ca r  M2(7)[4] =  2.  La  même  chose  peut 
être  observée  da ns  les  fi gures  (d)  et  (e)  pour  les  matri ces  M:;  et  M'' qui  montrent  respecti vement  le 
nombre  de  chem ins  de  longueur  3  et  le  nombre  de  chemins  de  longueur  4  allant  d' un  so mm et  à  un 
autre pour tous  les sommets du  graphe. 

2.3.2  L'approche structurale 

Dans  le champ de  la soc iologie,  l'approche structura le (Lazega,  1998)  est une méthode qu i a 

été  déve loppée  pour  étudi er  les  résea ux  soc iaux afin  de  mi eux comprendre  les  phénomènes 

sociolog iques.  Ce lle-ci tente de formaliser et de systémati ser les  relations entre  les  acteurs à 

l'aid e d'outils  mathématiques  ou stati stiques, ce  qui  la  di stingue d'autres  méthodes  uti lisées 

en soc iologie qui  sont souvent  plus info rmelles et plus qualitati ves. 

- - - - - - - - - - - - - - - - - - --

21 

L'approche  structurale propose  donc  diverses  mesures  pour  l'analyse des réseaux relati onnels 

et nous en verrons quelques-unes dans les sections suivantes. 

2.3.2.1  Procédures de  repérages de sous-groupes cohésifs 

Ces  procédures  permettent  de  représenter  et  de  décrire  le  système  au  n1veau  macro  en 

fournissant  des  techniques  de  partiti onnement  du  réseau  en sous-ensembles.  La  descri ption 

des  relations  entre  les  sous-ensembles  donne  une  fl ex ibilité  qui  permet  un  va-et-vient 

constant  entre  le  niveau  structural  et  le  ni veau  loca l.  Un sous-groupe  cohésif est  un  sous(cid:173)

ensemble  d' acteurs  fortement  reli és  entre  eux  et  la  soc iologie  structurale  propose  plusieurs 

méthodes  pour  repérer différents types  de  sous-groupes  dans  la structure globale.  Que lques(cid:173)

unes de ces  méthodes sont expliquées ci-dessous. 

Méthode sans 1 ' usage de critères fixes 

Cette  méthode  repose  sur  la  compara1son  entre  la  fréquence  relative  des  relati ons  entre 

membres  d'un  sous-groupe  (relations  internes)  et  ce lles  entre  membres  et  non-m em bres 

(relations  externes).  C'est  la  proportion  donnée  par  la  divi sion  de  la  densité  des  relations 

internes  par  la  densité  des  relations  internes  et  externes.  Ces  sous-groupes  ex isten t  parce 

qu ' il s sont  relati vement  plus cohés ifs  en comparaison au reste du  réseau. 

Ces  sous-groupes  cohés ifs  sont  construits  par  l' ad dition  success ive  de  membres  à  un  sous(cid:173)

ensemb le initial tant que  la  proportion  mesurée ne  varie pas trop. 

Méthode basée sur  la  réciprocité compl ète 

Cette  méthode  repose  sur  la définition  de  cliques.  Les  cliques  sont  des  sous-ensembles  de 

membres tous adjacents  les  uns  aux  autres  (sous-graphe  maximum  comp let  de trois  sommets 

ou  plus).  Cela signifie que  les  membres d' une  même clique  se  cho isissent  tous  entre eux.  Si 

un  membre appartient à plusieurs cl iques, on  parle de cliques superposées. 

22 

Cette faço n de définir  un  sous-groupe cohés if est très  sévère, car  l'absence d' un  seul  arc peut 

empêcher un  graph e d'être  une clique.  Ce  phénomène se  produi sant  assez souvent  dans  les 

réseaux  di spersés,  par  exemple,  cette  méthode  ri sque  d'être  inutilisable  dans  plusieurs  cas. 

Les méthodes suivantes sont  moins strictes. 

Méthode basée sur  l'accessibilité et le di amètre 

Cette  méthode  repose  sur  la  définiti on de  la  n-c lique.  Ce lle-ci est  défini e  comme  un  sous(cid:173)

graphe  max imal  dans  lequel la distance  géodés ique  la  plus grande qui  sépare deux sommets 

n'est  pas  supérieure  à  n.  L' important,  ici, contrairement  aux cliques, n'est donc  pas  que  les 

membres  so ient  tous  adjacents,  mais  qu ' il s  so ient  accessibles  les  un s  aux  autres,  sur  un e 

courte di stance. 

Cette  méthode est donc  moin s sévère que  la méthode  basée sur  la réc iproc ité complète,  mai s 

présente  auss i ses  jmües .  ..En  effet,  e cbemj iLqui  mène  un  membre de  la clique à  un  autre 

membre  peut  passer par un  ou même  plusieurs membres  à  l'extérieur  de  la clique et le sous(cid:173)

groupe  ain si  formé  peut  ne  pas  être  auss i  cohésif qu ' on  le  voudrait.  Par  contre,  il  ex iste 

certaines so lutions à ce probl ème : 

n-clan : consiste à  exc lure  toutes  les  cliques  qui  conti ennent  des  géodés iques  dont  l' un  des 

membres  n'est pas  un  membre du  sous-groupe. 

n-club :  consiste  à  définir  un  sous-graphe  max im al  de  diamètre  n  dans  lequel on  n' inclut 

aucun  membre qui  so it  à une di stance  géodés ique inférieure ou éga le à n de  tous les  membres 

du  sous-graphe. 

Méthode basée sur  le nombre de membres adj ace nts 

Cette  approche  se  fonde  sur  la  défin ition  d' un  nombre  minimum  d' acteurs  adjacents  à  tous 

les  autres  membres  du  sous-ensemble. 

Il  n' est  donc  pas  nécessaire  que  tous  soient  reliés  à 

23 

tous,  ma1 s  plutôt  que  tous  les  membres  du  sous-groupe  aient  des  li ens  adjacents  avec 

« beaucoup » d' autres  membres. 

Cette  méthode est plus robuste et moin s vulnérable que  la méthode des  n-cliques,  car si l' on 

retire un  membre du  sous-groupe,  la structure n'est pas modifiée  contrairement à une n-cliqu e 

qui  elle,  n' ex isterait  plus. 

Pour construire ce genre de sous-groupes, il  exi ste deux  approches  : 

k-plex : spéc ifie le nombre de 1 iens qui  peuvent  manquer. 

k-cores : spéc ifie le nombre de li ens obligatoires. 

Méthode de l'équi va lence  structural e 

La méthode de  1 'équi va lence  structurale se  di stin gue des  tec hniques  d' identifi cati on de sous(cid:173)

groupes  cohés ifs  menti onnées  précédemment.  En effet, ce ll e-ci cherche davantage  à définir 

des  sous-ensembles  d' acteurs  ayant  le  même  pro fi 1  relati onnel  qu ' à  id entifie r  des  sous(cid:173)

groupes d'acteurs qui  ne font qu ' interagir entre eux. 

L' équi val ence  structural e  cherche  donc  à  déterminer  les  sous-groupes  d' acteurs  qui  jouent 

des  rôles  similaires  dans  le  réseau, qui  ont  des  relations  comparabl es  avec  d'a utres  acteurs. 

Dans  cet  ordre  d' id ées,  la  substitution  de  deux  acteurs  structuralement  équi va lents,  dans  le 

réseau, ne devrait  pas  fa ire de diffé rence. 

L'équi va lence  structurale,  tell e  qu 'e ll e  vient  d'être  défini e,  est  une  propriété  qu ' il  est 

pratiquement  imposs ibl e  d' observer  dans  la  vie  soc iale.  Deux  personnes  n'ont  jamais  le 

même  profil  relationnel :  il s  n'ont  j amais  exactement,  par  exemple,  les  mêmes  ami s  ou 

ennemis.  Pour cette  raison, l'équiva lence  structurale se  calcule de  façon  statist ique.  JI existe 

plusieurs  techniques  de  mesure  de  l' éq uiva lence  structurale, dont  les  modèles  catégoriques 

(block models) et l' utili sat ion de  la di stance euclidienne (Lazega,  1998). 

24 

Méthode de l'équiva lence régulière 

Le but  de  l'analyse  des  sous-groupes  fo ndée  sur  l'équi va lence  structurale est de  repérer des 

sous-ensembles d' acteurs au profil  relati onnel semblable c'est-à-dire, qui  ont  les  mêmes  liens 

avec  les  mêmes  membres  du  reste  du  système. 

Il  s' ensuit  donc  qu ' une  telle  analyse  ne 

permet pas  de déce ler des  statuts et des  rôles  qui  ne soient  pas  exc lu sivement  spéc ifiques à la 

population  étud iée.  Cette  méthode  ne  peut  donc  pas  être  utili sée  pour  comparer  deux 

populations différentes.  C'est pour tenter de dépasser cette limite que l' équi va lence réguli ère 

a été introduite. 

L' équivalence  régulière  est,  en  que lque  sorte,  une  fo rme  plus  relâchée  d' équi va lence. 

Contrairement  à  l' équi va lence  structurale, l' équi va lence  réguli ère n' ex ige  pas  qu ' un  individu 

ait  les  mêmes  relati ons  avec  tous  les  membres  du  système.  Deux  acteurs  sont  dits 

réguli èrement  équi va lents  s' il s  ont  au  moins  une  relation  avec  des  indi vidus  eux-mêmes 

équivalents.  On  produit  ain si des  cl asses  corrélati ves  qui  se  défini ssent  les  un es  par rapport 

aux  autres. 

Par  exemple,  la  classe  « ense ignant »  est  défini e  par  ra pport  à  la  classe 

« étudi ant » (et  vice  versa)  et,  se lon  l'équi va lence  régulière,  il  suffi t  de  n' avo ir  qu' un  seul 

étudiant  pour être considéré comme fa isant  partie de la classe des  ense ignants. 

Cependant, cette méthode  a auss i ses  limites.  La  prat ique de cette forme d' analyse  peut, en 

effet, engendrer des  classes  si abstraites  qu ' on peut  difficilement  les  retrouver dans  la réa lité 

des systèmes soc iaux étudiés. 

2.3.2.2  Procédures de positionnement des acteurs dans la structure 

Les  mesures de centralité et de prestige sont des  mesures  de la pos ition relati ve  des acteurs au 

sein  d' un  système soc ial.  Ell es serve nt  à identifi er les acteurs les  plus importants qui  sont  les 

plus susceptibles de contrôler l' alloca tion des  ressources. 

25 

Centralité 

Un  acteur  est  très  central  lorsqu ' il  est  engagé  dans  beaucoup  de  relations  (directes  ou 

indirectes).  Ici, la direction  des  arcs  ne compte  pas, donc  cette  mesure peut  être utilisée  pour 

des relations orientées ou non. 

Soit g,  le  nombre de sommets d'un  graphe (nombre d' acteurs dans le réseau). 

Centralité de degré Cd  (degree):  Ta ille du  résea u de l' acteur (nombre de  liens) 

Interprétation: Plus un acteur est central, plus il est actif dans le !>ystème. 

Cd;= L Xii 

où  Xii est la  valeur du  lien  de  i à j 

j 

L Xii 

C ',1;  = -1

-· -
g -1 

(normali sation) 

Centralité de  proximité Cc  (closeness): Nombre  minimum de  pas que  l' acteur doit effectuer 

pour entrer en contact avec  les  autres  acteurs du  système.  On  ne  peut  pas  ca lculer cet  indice 

lorsque le réseau  comprend  plusieurs composantes connexes. 

lnte1prétation :  mesure  d'autonom ie,  d 'indépendance  à  1 'égard  du  contrôle  exercé  par 

d 'autres. 

1 

Cc,= - - , pour tous  les  j  f::.  i 

g Ldu 

j= l 

26 

où  du est la di stance géodés ique entre les acteurs i etj et où  I du est la di stance totale entre 

g 

.J = I 

l' acteur  i et tous  les  autres  acteurs du  système.  Au max imum, cet  indice = 

1 

(g- 1) 

lorsque 

l' acteur est adj acent  à tous les autres acteurs. 

g -1 

C 1 Ci= - g-

= (g - l )Cci  (normali sation) 

I du 
j = l 

C 1 Ci vaut 1 lorsque l' acteur i est adj acent à tous les autres. 

Centralité  d'intermédiarité  C8  (betweeness):  Proporti on des  géodés iques  entre  j  et  k  qui 
passent  par  i. 

Interprétation :  Contrôle  exercé par  l 'acteur  sur  les  interactions  entre  deux  autres  acteurs. 

Lorsque  deux  acteurs  ne  sont  pas  adjacents,  ils  dépendent  d 'autres  acteurs  pour  leurs 

échanges  et  ces  acteurs  intermédiaires peuvent  avoir  la  capacité  de  bloquer  la  circulation 

des  ressources.  Plus  un  acteur  se  trouve  au  milieu  et  constitue  un  point  de  passage 

nécessaire  sur des chemins que d 'autres do ivent utiliser pour communiquer entre eux, p lus  il 

est central de  ce point de  vue. 

I g,k(i) 
Cs, =""".J<_k _ _  _ 

gik 

pour  i-::;!:.  j , k  où  g,k  = l'ensembl e des géodésiq ues entrej et k et où  gik(i) = un  chemin entre 

jet k passant par i. 

Le  minimum = 0  si  i ne  tombe sur aucun  géodésique. 

27 

Le maximum = 

(g- l )(g-2) 

2 

si  l'acteur se  trouve sur toutes  les géodésiques. 

C'  _  Cs; 

B; -

(g- l )(g-2)  (normalisation) 

2 

Les  différentes  mesures  de  centralités  déterminent  l' importance  d' un  acteur  dans  le  réseau 

social.  La  figure  2.3 .2.2.1  illustre  le « Kite Network  » développé  par  David  Krackhardt (tiré 

de « How to  do  Social  Network  »,  www.orgnet.com/sna.html).  Cette  figure  illustre  très  bien 

les  différentes  mesures  de  centralité.  On  observe  que  dans  ce  réseau,  Lucie  obtient  le 

meilleur résultat pour la  centralité de  degré,  car c' est elle  qui  possède  le  plus de  liens  directs. 

Cependant,  le  fait  d'avoir  plusieurs  relations  n'est  pas  toujours  aussi  important  que  les 

personnes  avec  qui  on  entretient  ces  relations.  En  effet,  on  remarque  que  les  contacts  de 

Lucie  font  tous  partie  de  sa  propre  clique,  il s  sont  tous  reliés  entre  eux. 

Il  aurait  été  plus 

avantageux  pour  Lucie  d'avoir  des  contacts  hors  clique  afin  de  devenir  un  intermédiaire 

obligé entre  les  membres de  sa  clique et ces contacts extérieurs. 

De  son  côté,  Manon  possède  peu de  liens directs, moins  que  la  moyenne dans  le  réseau.  Son 

score  de  centralité  de  degré  est  donc  relativement  petit  par  rapport  aux  autres  membres  du 

réseau.  Par  contre,  du  point  de  vue  de  la  centralité  d' intermédiarité,  elle  occupe  une  des 

meilleures  positions  dans  le  réseau .  Elle  joue  le  rôle  de  l' unique  intermédiaire  entre  les 

membres de  la  clique de  gauche et  les deux  membres à sa droite.  Elle  peut ainsi  contrôler les 

communications entre  ces  deux  parties.  Elle  est en position  de  pouvoir, car sans ell e, Justin 

et Louise  ne  pourraient  pas avoir accès  à  l' information  et aux  connaissances provenant de  la 

clique  de  Lucie.  Un  acteur  ayant  un  fort  degré  de  centralité  d' intermédiarité  a  beaucoup 

d' influence sur la  circulation des connaissances dans  le  réseau . 

Jean  et J im  possèdent un  peu  moins de connexions que  Lucie cependant,  la  structure de  leurs 

connexions directes et  indirectes  leur permet d'avoir accès à tou s les autres  acteurs du  réseau 

plus rapidement que n' importe quel autre membre.  lis ont accès aux plus courts chemins vers 

tous  les  autres  acteurs. 

Ils  sont  proches  de  tout  le  monde  et  possèdent  donc  le  score  de 

28 

centralité de  prox imité le plus élevé.  Ils sont  alors dans une exce llente pos ition pour exercer 

un  contrôle sur  le flux  d' informati on dans le réseau, car il s ont la  meilleure visibilité de ce qui 

y circul e. 

Justin  ) - - - - - {  Louise 

Figure 2.3.2.2.1  Illu stration  du «  Kite  Network » développé par  David  Krackhardt 

Prestige 

Prestige  de  degré:  Un  acteur  est  prestigieux  lorsqu ' il  reçoit  beaucoup  de  choix. 

Ici,  la 

direction des arcs a son importance  donc cet indi ce  ne peut  être ca lculé que  pour  les  relati ons 

orientées.  Le  prestige  de  degré  correspond  au  ca lcul  du  demi-degré  intérieur.  C'est  le 

nombre de  choix reçus (arcs entrants). 

lnte1prétation  : Plus cet indice  est grand, plus 1 'acteur est populaire. 

Prestige par proximité : Est une extension du  prestige  de  degré.  Ce  dernier ne compte que 

les  acteurs  adjacents  à  i  mais  on  peut  généra liser  cet  indice  en  définissa nt  un  « domaine 

d'influence  de  i »  et  uti liser  les  re lat ions  directes  et  indirectes  à  l' intérieur  de  ce  domaine 

pour calculer le prestige par proximité. 

lntelprétation : Plus cet indice est grand, plus 1 'acteur est populaire. 

29 

Prestige basé sur le  statut ou  le  rang : Si  un  acteur est en  relation  avec  des  membres  eux(cid:173)

mêmes prestigieux, cela augmente son propre prestige. 

2. 3.2.3  Une procédure d 'association entre positions et comportements des 
acteurs 

Les  structures  relationnelles  entre  les  acteurs  et  la  position  de  ceux-ci  dans  le  réseau 

influencent  leur  comportement.  La  description des  structures  relationnelles  cherche à  mettre 

en  lumière  les  contraintes  que  la  structure  fait  peser  sur  le  comportement  des  acteurs,  la 

manière dont  les  acteurs gèrent ces contraintes et les  processus  de restructuration qui  peuvent 

en  résulter.  De  ce  point  de  vue,  on  peut  s' interroger  sur  la  compos ition  particulière  des 

structures  relationnell es  qui  contraignent  davantage  les  acteurs  ou  qui ,  au  contraire,  leur 

offrent  davantage  d'opportunités.  La  structure  relationnelle  peut  donc  procurer aux  acteurs 

du  pouvoir,  comme  on  l'a  vu  avec  la  centralité  et  le  presti ge,  mai s  aussi,  certaines  formes 

d' autonomie. 

Autonomie 

L'autonomi e  est  la  capacité  de  pouvo ir  substituer  une  relation  à  une  autre,  d'avoir  une 

alternative  relati onnelle.  On  peut  attribuer  un  score d' autonomie  à chaque  acteur  du  réseau 

en  comptant, par exemple, le  nombre de contacts non  redondants de chacune de  ses  relations. 

Un  acteur  qui  possède  beaucoup  de  contacts  non  redondants  n'est  pas  en  pos iti on 

d'autonomie.  Cette  mesure  cherche  à  vo ir  qui ,  dans  le  réseau,  a  le  pouvoir  de  ne  pas  se 

lai sser  confiner  dans  une  relati on  incontourn able.  La  figure  2.3.2.3. 1 (a)  montre  le  sous(cid:173)

réseau de  l'acteur  i.  On  voit qu ' il  n'y a aucune  relation  entre  les  différents contacts de  i  ce 

qui  procure  à  cet  acteur  un  grand  pouvoir  d 'acti on  étant  donné  qu ' il  est  le  seul  point  de 

communication  poss ibl e  pour  que  les  acteurs  cl  à  c8  puissent  communiquer  entre  eux. 

L'acteur  i  dev ient  une  relation  incontournable  et  peut  alors  contrôler  plus  facilement  les 

ressources  qui  ci rcul ent  en  passant  nécessa irement  par  lui .  Il  a  une  grande autonomie.  Les 

acteurs  cl  à  c8,  par  ai lleurs,  ne  sont  pas  très  autonomes,  car  il s  ne  possèdent  aucune 

alternative  relationnelle  pour  se  rejoindre  les  uns  les autres.  La  figure  2.3.2.3 .1 (b)  montre 

une  structure  relat ionnel le  similaire,  mai s  dans  laquelle  l' acteur  j  possède  les  r~ lation s 

30 

illustrées  par  les  lignes  de  tirets dan s  la fi gure.  Dans cet  exemple,  pour  communiquer avec 

-

les contacts c2, c3, c4, c6 et c7,  l' acteur)  n' est pas dans l' obligation de  passer pari.  Il  a donc 

une  alternati ve  relationnelle  pour  rejoindre  ces  contacts  et  possède,  de  ce  fait,  une  certaine 

autonomi e.  Par contre, )  doit  absolument  passer  pari s' il  veut  communiquer avec  cl  et c5. 

De son côté, l' acteur i a beaucoup  moins de pouvoir sur  la circulation des  ressources que dans 

la  structure relationnelle  montrée  en (a), car étant  donné que plusieurs de ses contacts directs 

peuvent  communiqu er  entre  eux,  il s  peuvent  au ssi  s'organi ser  et  offrir  une  certaine 

résistance. 

c1 

c7 

c1 

c7 

. 
c3 

\ 

cS 

(a) 

c4 

c6 

c6 

c4 

cS 

(b) 

Figure 2.3.2.3.1  Autonomie des acteurs dan s différentes structures relationnelles. 

Plus  un  acteur  possède  de  contacts  non  redondants  dans  le  réseau,  plus  ses  relati ons  sont 

uniques,  plus  il  ri sque d' être  paralysé  par  la structure  relati onnelle.  D' autre  part,  plus  il  est 

relié à des  contacts  non reliés  entre eux, plus  il  y  a de  « trous » dans  la structure,  plus  il  est 

autonome,  car  les  indi vidu s  qui  l' entourent  ne  sont  pas  organi sés  entre  eux.  Ainsi,  la 

structure des  relati ons d' un  acteur peut  augmenter ou limiter sa  liberté d'action et lui  procurer 

plus ou moins d'autonomie. 

2.4  Revue des modèles actuels 

Les  modèles  actuels  de  réseaux  soc1aux  prov iennent  de  plusieurs  di sc iplines  te lles  que  la 

phys ique,  les  mathématiques,  la sociologie, l' économie et  la psychologie  soc iale.  Dans cette 

31 

section, sans faire une énumérati on exhaustive de tous  les modèles  ex istants, nous présentons 

quelques  modèles  importants provenant de domaines  divers. 

2.4.1  Modèles théoriques 

Une  grande  partie  des  modèles  soc iaux  viennent  de  la  phys ique  avec  l'adaptation  de  lois 

phys iques  à  la  modélisation  des  systèmes  soc iaux.  Ces  modèles  se  concentrent  plus 

particulièrement  sur  les  propriétés  de  la  structure globale des  réseaux  san s  tenir  compte  des 

di fférences  de  types  de  liens  ou  des  propriétés  des  agents.  Comme  exemple  de  modèles 

théoriques,  nous  présentons  ici  les  automates  ce llulaires,  les  petits  mondes,  le  modèle  de 

réseau indépendant de l'échelle« sca le-free  » et final ement, un  modèle de réseaux d' amis. 

Automate ce llul aire 

Le  champ  de 

la  modéli sati on  soc iale  a  hérité  de  plusieurs  outil s  provenant  des 

mathématiques, de  la  phys ique et en  parti culier, des  automates  ce llulaires  (Wolfram,  1986). 

La  structure  d ' interactions  sous-j ace nte  à  ces  modèles  est,  en  général,  un e  gri Ile  ré gui ière 

dans  laquelle chaque case  représente  un e ce llul e et où  l' enviro nnement  soc ial est  représenté 

par  la grill e entière.  Les  vo isins  de chaque ce llul e sont  alors déterminés  par  leur  prox imité 

spati ale  sur  la  grille,  selon  un  voisin age  de  Yon Neumann  ou de  Moore,  par  exempl e.  La 

figure 2.4.1 .1  illustre ces  deux types de voisinage. 

32 

(a) 

(b) 

Figure 2.4.1.1  Voisinage de Von  Neumann et  voisinage de Moore dans un  automate cellulaire 
Dans cette  figure,  les  vo isins de  la cellule  noire  sont  représentés en  gris.  (a)  Le  voisinage  de  Yon 
Neumann  relie  une  cellule  à  ses  quatre  voisins  (nord, sud, est,  ouest). 
(b)  Le  voisinage  de  Moore 
ajoute quatre vois ins de  plus que celui  de  Yon  Neumann  (nord-est, sud-est, sud-ouest et nord-ouest). 

Le jeu de  la vie (The  Game Of Life) est un  exempl e populaire d' automate ce llul aire qui  a été 

in venté par  le mathématicien John  Comvay.  Ce jeu consiste en une co ll ection de ce llules qui , 

se  basant sur quelques  règles  math émat iques  simples,  peuvent vivre, mourir ou se  reproduire. 

Étant  donné  les conditions  initi ales,  les  ce llul es  forment  divers  motifs  à mesure que  le jeu se 

pou rsuit.  Les  règles se  présentent com me suit  : 

Pour un  espace occupé sur  la grille : 

1.  Chaque ce llul e avec  moins de  deux  vo isins meurt de  solitude. 

2.  Chaque ce llule avec plus de trois  vois in s meurt d' une surpopulation . 

3.  Chaque ce llule avec deux ou  troi s vo isin s survit. 

Pour un  espace non occupé sur  la grille : 

4.  Chaque ce llul e vide entourée  de 3  voisins naît (la case devi ent occupée). 

Pour  généraliser  ce  type  de  modèle,  (Flache  et  Hegselmann ,  2001)  proposent  différentes 

structures de grill es  régu li ères formées, par exemple, de ce llul es triangulaires  ou hexagonales 

et d'autres  irrégu lières déterminées d' après  un  diagramme de  Voronoï. 

- -- - -- - - - - - -- - - - -·- - - - - .  -------·  - - - - - - - - - - - - -- - - - - -

33 

Le  problème  principal  rencontré  dan s  cette  approche  est  qu 'on  part  d' une  mosaïque 

bidimensionnelle et qu ' on dérive ensuite,  de cette mosaïque,  la  loca li sation des  cellul es  et de 

leur  voisinage .  Cette  méthode  peut  s' avérer  limitative  pour  modéli ser des  systèmes  soc iaux 

qui  ne  sont  pas  seulement  situés  dans  un  espace  géographique.  De  plus, dans  ce  genre  de 

modèle, on ne peut  pas  modifier fac il ement  la connecti vité moyenne du  graphe, car il  y a un 

nombre fi xe de quatre ou huit voisins pour  les  voisinages de Yon Neum ann  ou de Moore.  En 

ce  qui  concerne  les  grill es  générées  par un  diagramme de Yoronoï, il  est poss ible d' ajuster la 

connectivité moyenne du  graphe,  mai s à l' intérieur de certaines  limites. 

Les  petits mondes 

L'effet des  petits  mondes (small  world  effect) a été largement étudié.  La premi ère ex périence 

conduite  en ce  sens fut  ce ll e de (Mil gram,  1967)  qui  donna  lieu à  l'expression bien connu e 

des  six  degrés  de  séparation  (Guare,  1990).  Cette  express ion  signifie  que  le  nombre  de 

contacts  interposés  entre  un e  personne  choisie  au  hasard  et  n' importe  quell e  autre  dans  le 

monde est d' environ six.  De nombreuses autres  études  ultérieures  prouvèrent  auss i que si le 

nombre  six  n'est  pas  nécessairement  le  nombre  juste,  il  n' en  demeure  pas  moin s  que  la 

chaîne de contacts qui  relie entre eux  deux indi vidu s, choisis aléatoirement  sur  la pl anète, est 

très  petite  par  rapport  à  la  population  enti ère : si  l' on ca lcul e  la  di stance  qui  sépare  chacun 

d' entre  nous de n' importe quel autre  indi vidu  sur  la planète, en terme de nombre de contacts 

interposés pour se rendre de 1 ' un  à 1 'autre, le monde est petit (K orte et Mi !gram,  1970). 

Certains  sc ientifiques  ont  donc  essayé  de  dé fi n ir  la  structure  d' interactions  de  leur  modèle 

pour représenter cet effet des  petits mond es  observé dans la réa lité. 

Le  modèle  le  pl us  sim ple  est  le  graphe  aléatoire.  Les  graphes  aléato ires  ont  largement  été 

étudiés en mathématique, en particuli er par (Erdos et Rényi,  1960). 

On suppose  une popul ation  de N  individus  et  le nombre z,  appe lé  le  nombre  de  coordination 

du  réseau,  est  le  nombre  moyen de contacts  que  possède chaque  individu  du  réseau .  Il  y  a 

34 

donc  - Nz  connexions symétriq ues au  total  dans  le réseau .  On  peut  construire  un  tel  graphe 

1 
2 

en traçant N sommets et  en  reliant  - Nz paires de  sommets chois is aléatoirement.  La  fi gure 

1 
2 

2.4.1.2 illustre  un  graphe aléatoire de  6 sommets et ayant  une  connectivité  moyenne de 2. 

Figure 2.4.1.2  Graphe aléatoire avec N  =  6 et z= 2 

Il  est  faci le de  montrer  que ce  genre  de  réseau  présente  l'effet  des  petits  mondes.  En  effet, 

supposons  que A  est  un  des  sommets  d' un  graphe  aléatoire.  A  possède  donc  z  voisins  qui 
Il  s'ensuit que A  possède z voisins directs, i 
possèdent  à leur  tour z voi sin s et  ainsi de suite. 
deuxièmes  voisins, z3  troi sièmes  voisins etc.  Dans  la vie courante, un  individu  a en moyenn e 
entre  100 et  1000 conna issa nces ain si, z4 se trouve entre  108 et  10 12

,  ce qui  est comparab le à la 

population  mondiale  actuelle.  Sachant  que  la di stance  entre  deux  nœuds  est  la  longueur du 

plus  court  chemin  qui  relie  ces  nœud s,  on  définit  le  diamètre  d' un  graphe  comme  la  plus 

grande  di stance  entre deux  de  ses  sommets.  Le  diamètre  D  d' un  graphe  aléatoire  est donné 

par  z D = N  qui  implique  que  D  =log N 1 log z.  On  voit  que  D  augmente  très  lentement 

avec  l'augmentation de  la population N. 

Outre  l' effet  des  petits  mondes,  une  autre  caractéristique  importante  observée  dans  les 

systèmes  sociaux  est  la  transitivité  (clustering)  qui  signifie  que  deux 

ind iv idu s  qui 

connai ssent  une  même  personne  ont  de  fortes  chances  de  se  rencontrer.  En  d' autres  mots, 

dans  un  réseau  soc ial,  si  A  connaît  B  et  C,  la  probabilité  que  B  et  C  se  connaissent  est 

beaucoup plus élevée que  la probabilité que deux  person nes  simplement  chois ies  au  hasard  se 

connaissent, car ils ont un  contact comm un  qui  est A. 

35 

Bien que  les  graph es  al éatoires  montrent  parfaitement  la  propriété des  petits mondes,  ceux-ci 

ne  représentent  pas  la  propri été  de  transitivité  que  1 'on  peut  observer  dans  la  plupart  des 

réseaux sociaux. 

Supposons alors  un  graphe  représenté  par  un  treillis  réguli er  à  une  dimension,  pouvant  être 

circulaire,  dans  lequel ch aque  sommet  est  relié  à  ses  z  vo isins  les  plus  proches.  La  fig ure 

2.4. 1.3  montre un  tel graphe avec z =  4. 

Figure 2.4.1.3  Treillis régulier avec z = 4 

Dans  la fi gure 2.4. 1.3 , on remarque que  beaucoup  des  vo isin s  immédi ats de chaque sommet 

sont  auss i des  vo isin s  l' un  de  l' autre.  Ce  type  de  graphe  représente  donc  la  propriété  de 

transiti vité. 

Le  coeffic ient  de  transit iv ité  C  est  la  fract ion  moyenne  de  paires  de  vo isin s  d' un  nœud  qui 

sont  auss i des  vo isin s l' un  de l' autre.  Dans un  graphe complet, où tout  le monde connaît tout 

le  monde, C  =  1.  Dans  un  graphe  aléatoire,  C  =  z 1 N, ce  qui  est  très  petit  pour  un  grand 

résea u. 

Pour  ce  qui  est  d' un  graphe  simil aire  à  la  fig ure  2.4.1 .3 ,  le  coeffic ient  de  tra nsitiv ité 
c = J(z- 2)  tend  vers l  pour des z  très grands  (Newman, 1999). 

4(z- l) 

4 

36 

D' un  autre côté,  ce  type de graphe  ne représente  pas du  tout  l'effet des  petits mondes, car  la 

distance  moyenne  séparant  deux  sommets  augmente  de  façon  linéa ire  avec  la  taill e  du 

système. 

Cependant,  (Watts  et  Strogatz,  1998  ;  Watts,  1999)  ont  proposé  des  algorithmes  pour 

construire un  graphe montrant  à la fo is 1' effet des  petits mond es et  la propriété de transiti vité. 

Le premier modèle,  le modèle  a, se  construit comme le modèle de Erdos  et Rényi, mais lors 

de  l' aj out  de  li ens au graphe,  plutôt que de choisir  deux nœud s de  faço n tout  à fa it  aléatoire, 

on les  choisit  avec  une  probabilité qui  augmente  proporti onnell ement  au nombre  de contacts 

communs que  possèdent  les  deux  noeud s  que  l' on veut  relier.  Ce la conduit  rapidement  à  la 

fo rmation  de  sous-groupes  cohés ifs  (clusters)  dans  la  structure.  Le  deuxième  modèle,  le 
modèle  f3 , part  d' une  structure  en  fo rme  de  treillis  régulier  circulaire,  mai s  y  aj oute  un 

certain  degré de  hasard.  Pour  ce  faire,  parmi  tous  les liens du  graphe de  la fi gure 2.4 .1.3, on 

choisit  quelques  li ens se lon une probabilité pet, pour  chaque  lien choisi, on dépl ace  une des 

extrémités de  ce  li en vers un  autre sommet déterminé aléatoirement.  La  fi gure 2.4 .1.4  montre 

un  exemple de graph e obtenu  par cet algorithme. 

Figure 2.4.1.4  Modèle  fJ  exposa nt l'effet des petits mondes et la  propriété de transitivité 

La  fig ure 2.4.1 .4  montre que,  pour  un e  petite  probabilité p ,  le  treillis obtenu  demeure quand 

même  assez  régulier,  mais  possède  désormais  quelques  raccourcis  qui  le  traversent  et 

provoque nt  ainsi  l'effet  des  petits  mondes.  En  effet,  Watts  et  Strogatz  ont  montré,  par 

simul ation  numérique,  que  la  distance  moyenne  entre  deux  sommets,  lorsq ue  la  probabil ité 

37 

p  =  1~,  est éga le  à 3.6.  Ce  résultat est à  peine  supérieur  à  la di stance  moyenne éga le à 3.2, 

ca lculée  pour un  graphe aléatoire. 

De  plus,  le  nombre  de  voi sins  d' un  sommet  parti culier  peut  être supérieur  ou  infé rieur  à z, 

mais en moyenne,  le nombre de coordination est toujours égal à z.  Clairement,  la va leur  du 

coeffi cient  de transitivité C,  pour  de petites  va leurs de p  et un  grand  z,  sera proche de ce lui 

calculé  pour  un  treillis  parfaitement  régulier,  comme celui  de  la fi gure  2.4.1.3.  Ce  modèle 

montre  donc  l'effet  des  petits  mondes  ainsi  que  la  propriété  de  transiti vité  observés  dans 

plusieurs systèmes soc iaux rée ls. 

Autres  modèles de petits mondes 

L'effet  des  petits  mond es,  sel on  la  vision de  Watts et Strogatz, se  produit  grâce  à  quelques 

raccourcis aléatoires,  passant  à travers le treillis.  (Dorogovtsev  et Mendes,  1999)  ont  trouvé 

une autre façon de  provoquer ce phénomène. 

Il  suffit  d'ajouter au graphe quelques  sommets 

qui  ont  un  nombre de  coordination inh abituell ement  plus élevé  que  les  autres  nœuds c'est-à(cid:173)

dire,  qui  sont  reli és  aléatoirement  à un  plus grand  nombre de vo isins que  les  autres  nœud s du 

graphe.  Ces quelques sommets parti culi ers deviennent  alors des  points de passage entre deux 

nœud s  quelconques  éloignés  l' un  de  l' autre.  Cet  arrangement  prod uit  le  phénomène  des 

petits  mondes  tout  en conservant  la  propriété  de  transitivité  qu 'offre  la  structure  en  treillis. 

La fi gure 2.4.1.5  montre à quoi ressemble un  tel graphe. 

Figure 2.4.1.5  Modèle de petits mondes de Dorogovtsev et  Mendes 

38 

Un  autre  modè le  de  petits  mondes  à été  proposé  par  (Kieinberg,  1999)  dont  l'argument  en 

défaveur  du  modèle  de  Watts  et  Strogatz  porte  sur  le  fait  qu ' un  tel  modèle,  basé  sur  des 

connexions arbitraires entre des  paires  de  sommets et se lon  une  probabilité uniforme, est  une 

piètre  représentation  des  situations  qu 'on  retrouve  dans  le  monde  rée l. 

Il  propose  alors  un 

modèle  basé  sur  un  treillis  carré  à  deux  dimension s  dans  lequel on  a  ajouté  aléatoirement 

quelques connexions entre des paires de sommets i,j, mais se lon une probab ilité non uniforme 

égale à  d,;'  su ivant  une  loi  de  puissance  où  rest le coefficient caractéristique qui  détermine 

l' allure  de  la  courbe.  Cette  probabilité  est  fonction  de  la  distance  d.  entre  i  et  j  où 
d,1  =1 x, - x, 1 + 1 y,- Y1 1 et  où  (x,, y,) et  (x,, )IJ ) sont  les  coordonnées  des sommets i  etj dans le 

treillis. 

Il  semble  possible, en effet, qu ' un  tel réseau représente mieux  les interactions soc iales  que  le 

modèle  présenté  par  Watts  et  Strogatz  même  si  les  propriétés  des  deux  modèles  sont 

similaires en ce qui  concerne l' effet des petits mondes et la tran sitivité. 

Modèle indépendant de l'éche lle (sca!e-{ree ) 

Une  autre  propriété  de  certains  réseaux  soc1aux  et  plus  particulièrement  du  WWW  a  été 

démontrée  dan s  une étude  conduite  par  (A Ibert, Jeong et  Barabas i,  1999). 

Il s ont  rem arqué 

que  la  connectivité  dans  beaucoup  de  sortes  de  réseaux  tel s  que  le  WWW,  montre  une 

distribution  des  degrés  qui  suit  une  loi  de  puissance  et  ce,  indépend amment  de  l' échelle 

considérée.  Cette  propriété  n' avait  pas  encore  été  rencontrée  dan s  les  modè les  théoriques 

ex istants  et  il s  ont  donc  proposé  le  modèle  du  résea u  indépendant  de  l'éc helle  (Barabasi, 

Albert et Jeong, 2000).  L' équipe de Barabasi  a montré que  les  modèles  de réseaux ex istants 

ne  tenaient  pas  compte  de  deux  caractéristiques  importantes  de  certains  réseaux  réels. 

Premièrement,  certains  réseaux  grandissent  continue ll ement  par  l' addition  constante  de 

nouveaux  sommets et deuxièmement, les  nouveaux sommets se  connectent  préférablement  à 

des sommets qui  ont une connectivité élevée (attachement  préférentiel).  Il s ont démontré que 

la  combina ison  de  la  constante  croissance  du  réseau  et  de  l'attachement  préférentiel  est 

directement  responsable de  la  di stribution de  la  connectivité  en loi  de  puissance.  Ce  modèle 

dynamique est défi ni  par deux règles: 

39 

1.  Croissance : en débutant avec  un  petit  nombre de  sommets m0,  à chaque  pas  de temps,  il 
ajoute  un  nouveau sommet avec  m nouveaux  liens  (où  m :::;  m .. ) qui  seront  connectés  à m 
sommets déjà présents dans le graphe. 

2.  Attachement préférentiel : Le  choix  des  m  sommets  auxquels  le nouveau sommet sera 

connecté  s' effectue  selon  une  probabilité p  qui  dépend  de  la  connectivité  du  sommet 

La  fi gure  2.4.1.6  illustre  ce  type  de  réseau.  On  y remarque  que certains  sommets  (les t ois 

sommets  noirs)  possèdent  une  connectivité  beaucoup  plus  élevée  que  les  autres  sommets  à 

cause  des  mécani smes d' attachement préférentiel. 

Figure 2.4.1.6  Modèle du réseau indépendant de l' éc helle illustrant l'attachement préférentiel. 

Partant de  ce modèle, (Albert et Barabâsi, 2000) proposent  une dynamique de  reconnexion  et 

de  suppress ion  de  liens  dan s  le  temps.  Dans  le  même  optique,  (Dorogovtsev  et  Mendes 

2000) suggèrent  un  modèle similaire mais qui  intègre l' idée que la tend ance d' un  site à attirer 

de  nouveaux  liens  diminue  se lon  son  ancienneté :  plus  un  site  est  âgé,  moins  il  attire  de 

nouveaux  liens.  Finalement,  (Amaral  et  al., 2000)  proposent  un  coCit  ou  une contrainte  de 

capacité qui  ralentit  le processus de la di stributi on des  degrés en loi de  puissance. 

40 

Un  modèle de réseau  d' amis 

(Jin,  Girvan  et  Newman,  2001)  proposent  un  modèle  représentant  l' évo luti on  d' un  réseau 

soc ial de contacts  personnels (ou d'amis).  Les  propriétés  de ce  modèle diffè rent  des  règles 

du  modèle  de  l' évolution  du  WWW  (modèle  indépendant  de  l'échelle  et  ses  descendants) 

pour plusieurs raisons. 

Tout d' abord , dans un  réseau  soc ial, il  est vrai que de nouveaux contacts et de nouveaux liens 

s' ajoutent  et  di sparaissent  continuellement  dans  le  réseau.  Des  individus  voyagent  et 

changent  de  réseau,  il s font  de nouvelles  connaissances, certains  nai ssent, d'autres  meurent, 

etc.  Étant  donné ce  va-et-vient  constant  dans  les  réseaux  sociaux,  les  auteurs  de ce  modèle 

considèrent  que  l' ajout  et  la  perte de  sommets s'éq uilibreront,  en quelque  sorte,  et qu ' il  est 

raisonn able de considérer comme  une bonne approx imation que, dans  l' ensembl e,  le nombre 

de  sommets  du  réseau  soc ial  modélisé  ne  varie  pas.  Seul s  le  nombre  et  l' arrangement  des 

li ens changent. 

Deuxièmement, la di stributi on des degrés, dans un  réseau soc ial, ne semble pas sui vre une loi 

de  puissance,  mai s  sembl e  plutôt  tourner  autour  d' un  degré  moyen.  Ce  phénomène 

s'explique  par  le fa it  que,  dans  la  plupart  des  réseaux soc iaux (certaines  exceptions  ex istent 

par  exempl e,  les  réseaux  de  contacts  sexuels),  l'entretien  d' une  amiti é  demand e  des 

ressources en temps et en efforts:  il  y a une limite au nombre de contacts qu ' un  individu  peut 

entretenir. 

Ensuite,  l' absence  d' une di stribution des  degrés  sui vant  une  loi  de  puissance  suggère  que  le 

mécani sme de  1 'attachement  préférentiel n'est pas très  important dan s les  réseaux d' ami s. 

Finalement, comme on  l' a vu précédemment,  les  réseaux  soc iaux  doivent  tenir compte de  la 

propriété de transiti vité qui, cependant, est absente du  modèle du  réseau du  Web. 

Étant  donné  ce  qu1  vient  d'être  discuté, 

les  auteurs  proposent  quatre  caractéristiques 

importantes qu ' un  modèle dynamique de  l'évolution d' un  réseau d' am is devrait considérer: 

41 

1.  Un  nombre  fixe  de  sommets:  Considération  d' une  population fermée  d' une  grandeur 

fi xe. 

2.  Un  degré  limité :  La  probabilité  qu ' un  individu  déve loppe  une  nouvelle  amiti é  doit 

diminuer fortement  lorsque le  nombre de ses amis atteint un  certain  niveau. 

Mécani sme  mis en  place pour modéliser cette propri été : 

z*  = limite sur  le  nombre z d'amis qu ' un  individu  peut  avoir.  À l' atte inte de z*  contacts, 

pour  un  individu,  la  probabilité  que  cet  indi vidu  crée  d'autres  liens  d'amitié  diminue 

rapid ement. 

3.  Transitivité:  La  probabilité  que  deux  individus  dev iennent  des  am1s  doit  être 

significativement  plus élevée s' ils ont un  ou plusieurs amis communs. 

Mécanisme  mi s en  place pour modéliser cette propriété: 

Des  paires d' individus se  rencontrent avec  une probabilité par  unité de temps qui  dépend 

du  nombre d' am is qu ' il s ont en commun . 

La  probabilité  par  unité de  temps  Pi!  que deux  personnes  données,  i etj,  se  rencontrent 

dépend  de deux facteurs  : 

a.  Le  nombre d' amis  z,  et  z,  que i etj possèdent  déjà. 

b.  Le nombre  m,,  d'ami s communs dei etj. 

Ces facteurs  sont représentés par  les fonctions f et g : 

La  fonction .f doit être assez grande et assez constante  pour de  petits z, mai s doit diminuer 
considérablement  lorsque z approche  de  la  valeur de  transition  z*.  La  fonction  de  Fermi 

présente ces caractéristiques et c' est elle que  les  auteurs ont utilisée pour leur modèle. 

42 

où le paramètre  fJ  contrôle la  préc ision de la diminution à z*. 

1 

f (z;)-
· 

- efl( =•-=* l + 1 

La fonction g(m)  représente  l'augmentation attendue  de  la chance  que deux  indi vidus se 

rencontrent  s' il s ont  un  ou plusieurs ami s communs. 

g (m ) = 1- (1 - po)e-am 

Où  po  représente  la  probabilité  d' une  rencontre  entre  deux  personnes  qui  n'ont  pas 

d'ami s commun s et où le paramètre  a  contrôle la vitesse à laquell e  g(m,,) augmente. 

4.  Bris  de  liens  d'amitié :  Étant  donné  le  nombre  fi xe  de  sommets  dans  le  réseau  et  le 
degré  limité pour chaque sommet, il  est nécessa ire que des  liens se  brisent et que d'autres 
se forment  pour que le résea u ne stagne pas. 

Mécani sme mis en pl ace  pour  modéliser cette propri été: 

Lorsque  deux  indi vidus  sont  am1 s,  ceux-ci  doivent  se  rencontrer  réguli èrement  pour 

maintenir leur amiti é.  Si tel n' est pas  le cas, il  y a cessation de cette amiti é. 

Pour  représenter la force  d' une amitié,  chaque  lien d 'amiti é possède  un  paramètres dont 

la va leur est plus ou moin s élevée se lon que les rencontres sont  plus ou moins fréquentes. 

Chaq ue fo is que deux ami s se  rencontrent,  la fo rce  s,,  est aj ustée  à  la  va leur  1.  Puis, à 

mesure  que  le  temps  passe  et  qu ' il s  ne  se  rencontrent  pas  de  nouveau,  la  fo rce  de  leur 

amitié diminue ex ponentiellement  se lon: 

s,,  = e 

- k  l1 

Où Dt représente  l' interva lle de temps  depu is la dern ière  rencontre dei etj et où  k est un 

paramètre  ajustable  du modè le.  Si i  et) se  rencontre  une autre fo is,  S;; est  remi s à  1.  Il 

43 

est ensuite  poss ibl e de  poser  une  limite  minimale à  Sii  afin  de considérer qu 'en dessous 

de cette limite, il  y a cessation de l' amitié entre i et). 

2.4.2  Modèles statistiques de réseaux sociaux 

Dans  l' approche soc iologique,  une des  perspecti ves  dominantes  de  l' analyse  de  réseaux vo it 

les  caractéristiques  du  réseau  comme  des  variabl es  pouvant  expliquer  le  comportement  de 

chaque  indi vidu  au  se in  de  l' ensemble  soc ial (les  comportements  qu ' il s  adoptent,  les 

stratég ies  qu ' il s utili sent)  et  ceci, en  regard  de  la  pos ition que  chacun  d'eux  occupe  dans  la 

structure du  réseau.  Dans ce cas,  on ne cherche pas à ex pliquer la structure même du  réseau. 

Une seconde perspective, plus récente, s' intéresse  plutôt aux relations.  Elle tente d' expliquer 

leur émergence, leur agencement, leur évolution.  De ce  point de vue, la structure des  réseaux 

doit  être ex pliquée à partir du  comportement  soc ial des acteurs qui  le constituent. 

En  compara1son  avec  les  modèles  déc rits  plus  haut,  plusieurs  soc iologues  ont  choisi  de 

construire  des  modèles  stati stiques.  Nous  all ons  nous  concentrer  ici sur  qu atre  classes  de 

modèles  importants  dans  ce  domaine  qui  ont  donné  naissa nce  à  plusieurs  descendants :  le 

modèle  de  Holland-Le inhardt  et  ses  descendants,  les  modèles  métriques,  les  modèles  de 

ferm eture  des  tri ades  et  final ement,  les  modèles  de  la  variance  du  degré.  Ceux-ci  ont  en 

commun  qu 'étant  donné  un  couple d' indi vidus et de  leurs caractéri stiques,  il s se  concentrent 

sur  la  probabilité de  l' ex istence  de  relation entre eux. 

Il  est à  remarquer que  la  maj orité de 

ces  modèles  gèrent  des  relations  ori entées  ce  qui  n'est  pas  la  tendance  observée  dans  les 

modèles théoriques précédents. 

Le  modèle de Holland-Leinhard t et ses descendants 

Le  modèle p l  (premier modèle  de  probabilité)  est un  modèle log-linéa ire qui  a été déve loppé 

par  (Ho lland  et  Le inhardt,  198 1 ).  Ce  modèle  permet  d' une  part,  de  spécifier  des  effets 

individuels en perm ettant de tenir compte, par exemple, de  la  popul arité des acteurs (nombre 

de  li ens  reçus =  demi-degré  intérieur)  et de  l'activité de  ceux-ci  (re lations émi ses  ou  demi-

44 

degré extérieur).  Cependant, ce  modèle ne permet pas  de  tenir compte de variabl es  exogènes 

telles  que  l' âge,  le  sexe,  le  statut  soc ial  qui  sont  souvent  très 

importantes  pour  le 

déve loppement  de  la  structure  d' un  réseau relationnel.  D'autre  part, ce  modèle  permet  de 

représenter  des  effets  dyadiques  (caractéristiques  des  acteurs  et  de  leurs  relati ons  deux  à 

deux)  de  réciproc ité  (probabilité  que  si  i  émet  une  relation  vers j  alors j  émet  auss i  un e 

relati on  vers  i).  Bien  qu ' étant  un  point  de  départ  important  pour  le  déve loppement  des 

modèles  stati stiques  de  réseaux  soc iaux, ce  modèle  postul e  l' ind épendance  entre  les  dyades, 

ne  permet  pas  de  représenter  les  effets  triadiques  et  en  ce  sens,  empêc he  le  traitement  au 

niveau structural. 

Le  modèle p2, développé  par (Van Duijn  et  Snijders,  1995)  est  une améliorati on du  modèle 

p l  en ce  sens qu ' il  permet le traitement de vari ables exogènes  (ca ractéri stiques des acteurs)  et 

de  variables  dyadiques 

(simil arités, 

flu x, 

fréquences,  contenu s  ou 

toutes  autres 

caractéri stiques  des  relations).  Cepend ant,  ce  modèle  ne  traite  touj ours  pas  les  effets  au 

niveau des triades. 

En plus de posséder tous les avantages du modèle p2, le modè le p *, introd uit  par (Wasserman 

et  Patti son,  1996),  propose  une  fo rmulation  très  générale  qui  permet  la  représentation  de 

n' importe quelles  di stributi ons de  probabilités  pour  un  graphe orienté.  Cec i rend  ce modèle 

très  souple  et  permet  le  traitement  des effets  triadiques  et  donc  structuraux.  Cepend ant,  la 

formulation  est tell ement  générale  qu ' i 1 faut  trouver  la  fo rmul e  spéc ifique  pour  chaque  cas 

parti culier et cec i n'est pas touj ours év id ent. 

Les modèles  métriques 

La  méthode  principa le utili sée  ici est  la construction d' un  espace  soc ial où  chaq ue agent  est 

locali sé.  C'est donc une représentation spati ale, et non purement  structurale.  Un algorithme 

stochastique  est  alors  uti 1 isé  pour  créer  les  1 iens  soc iaux  étant  donné  un e  foncti on  de 

proximité.  En  général ,  cette  fo nction  est  la  distance  eucli dienne  entre  chaque  coupl e 

d' indi vidus  sé lectionné.  Plusieurs  travaux  ex istants  retiennent  cette  so lution  soit  en  créant 

des  réseaux  soc iaux  qui  dépendent  seulement  d' une  distance  géographique  (Nowak  et 

45 

Valacher,  1998)  ou en  incluant  d'autres  attributs tels  que  des  indices  soc io-économiques  de 

chaque  individu.  Une  générali sation de la construction d' une métrique  sociale a été proposée 

par  (Banks  et  Carley,  1994). 

Il  est  à  noter  que  le  concept  répandu  parm i  plusieurs  de  ces 

modèles  est  le  concept  de  l' homophilie.  Ce  terme  réfère  à  la  tendance  de  la  similarité  sur 

plusieurs  attributs des  personnes qui  se  lient:  plus les  agents  sont  semb lables ou plus  ils sont 

près  les  uns des autres à l' intérieur d' un  espace soc ial, plus  grande  est leur tend ance  à être en 

relation.  Une  version  spatiale de la construction d' un  espace  soc ial  est  proposée  par (Epstein 

et  Axtell ,  1996)  dans  laquelle  les  agents  se  dépl acent  sur  une  ca rte  et  les  individus  qu ' il s 

rencontrent  sont  aussitôt  intégrés  à  leurs  réseaux  sociaux.  Les  liens  sont  brisés  lorsque  les 

individus deviennent trop éloi gnés  les un s des autres. 

Les modèles de fermeture des triades (completion triad) 

Ces  modèles  sont  dérivés  des  travaux  de (Heider,  1958)  sur  l'éq uilibre.  Dans  ces  modèles, 

les  indi vidus cherchent  à minimi ser le déséq uilibre perçu.  Par exemple, si Loui s se consid ère 

comme un  ami  de Lucie et que  Louis  perço it  que Lucie est une amie de  Fabien alors, si Louis 

n' est  pas  am i  avec  Fabien,  il  percevra  un  déséquilibre  et  aura  tend ance  à  voul oir  se  lier 

d'amiti é  avec  Fabien.  L'obj et  principal n' est  alors  plus se ul ement  la  dyade,  mais  la  tri ade, 

formée  par un  groupe de  trois  person nes  et des  relati ons entre ell es.  Le  but  de ce  modè le est 

d'ass igner  une  probabilité  sur  la  création  d' un  nouveau  li en à  l'intérieu r d' une  triade,  étant 

donnés  les  liens  ex istants.  Cec i a  donné  li eu à  une  série de  modè les  incluant  le  modèle  de 

« clu stering » de  (Davis, 1967), le modè le  de transiti vité de  (Holland  et  Le inhardt,  197 1) et le 

modèle de l'équilibre pos itif de Newcomb (Newcomb,  1968). 

Les  modèles de la variance du  degré (degree variance  mode l) 

Ces  modèles  dérivent  en partie  des  travaux de  (Biau ,  1967)  sur  la  théorie de  l' éc hange.  Ces 

modèles  assument que  chaque acteur  est diffé rent  dans sa  probab ilité  intrin sèque d' attirer de 

nouveaux  liens:  les  acteurs  qui  ont  un  degré  de  centralité  élevé  tendent  à  attirer  plusieurs 

liens  tandis  que  ceux  qui  ont  un  degré  de  centra lité faible  tend ent  à en attirer  moins.  On  dit 

d' un  acteur qu ' i 1 est très  central lorsqu ' i 1 est  engagé dan s beaucoup  de  re lations  (directes  ou 

46 

indi rectes).  Plus  le degré de centralité est élevé, plus  l' acteur  possède du  pouvoir, plus  il  est 

populaire et plus il attire de nouvelles  relations.  Ce  phénomène s' apparente fo rtement  à celui 

de  l' attachement  préférentiel  ex posé  dans  le  modèle  du  réseau  ind épend ant  de  l' échell e 

(Barabas i,  Albert  et  Jeong,  2000).  La  polari sation  et  la  balkan isation  sui vent  aussi  des 

concepti ons théoriques  du  pouvoi r et  peuvent  être vues  comme des  variati ons du  modèle de 

la vari ance  du  degré.  La polari sation se  produit  l_?rsque  la soc iété se  di vise  en deux groupes, 

chacun  étant  centré  autour  d' un  acteur  spécifique,  comme  il  se  produit  lorsqu ' il  y  a  des 

cliques  opposées,  chacun  avec  un  puissant  leader.  La  balkani sati on  se  prod uit  lorsque  la 

soc iété  se  divise  en  un  grand  nombre  de  petits  groupes,  chacun  étant  centré  autour  d' un 

acteur principal. 

2.4.3  Approche par modélisation ascendante 

Dans  les  approches  basées  agents,  le  réseau  peut  être  vu  comme  un  ensemble  de  relations 

générées  par  les  agents  du  système. 

Il  est  nécessa ire,  alors,  de  défini r  les  mécani smes  de 

création, d'évoluti on et de suppress ion des  relations des agents eux-mêmes. 

Cette  catégorie  de  modèles  de  réseaux  soc wux  util ise  une  approche  de  modéli sation 

ascendante.  Son  but  concerne  la  modéli sation  des  mécani smes  individuels  sociocognitifs 

utili sés  pour  bâtir,  entretenir  et  terminer des  relations.  On diffé rencie  deux  approches.  La 

première  est  issue  de  la  théori e  des  jeux  qui  est  axée  sur  les  méca ni smes  rati onnels  de 

création  de  liens.  La  second e,  fortement 

li ée  avec 

les 

théori es  soc iopsyc holog iques, 

privi légie  la  modéli sati on  des  propri étés  soc iocogniti ves  de  la  création  de  relations.  Étant 

donnés ces  mécani smes, elle a pour but  d'observer le genre de réseau qu ' ils engend re nt. 

Modè les  basés sur la théorie  des  jeux 

En  économie  et  dans  la  théori e  des  jeux  en  particu li er,  le  cad re  utili sé  est  ce lu i  de  la 

max imisation  de  la  fonctio n d' uti lité.  Chaq ue  individu  possède  la  même  fonct ion  utilita ire, 

mais  peut  posséder différentes  ressources  pour  in vestir  dans  des  re lations  ou  pour  modifier 

son  comportement.  Ces  modèles  s' intéressent  donc  à  la  création  des  relations  et  à  leur 

47 

évolution  (Myerson,  1977).  La  création  ou  l'entretien  de  chaque  relati on  a  un  coût  pour 

l'agent  et  les  possibilités  de  partage  des  ga in s dépendent  de  la  structure de son réseau soc ial 

personnel  (Siikker  et  Van  Den  Nouweland ,  200 1).  Ainsi ,  l' agent  doit  bien  choisir  ses 

relations  parce  qu 'e lles  sont  coûteuses,  mai s  nécessa ires  pour  l'acqui sition  de  ressources 

(Baia  et Goya!,  1999).  Le  but  de  ces  modèles  est d'étudi er  le  dilemme  entre  la  stabilité  et 

l' efficacité des  réseaux générés  (Jackson, 200 1 ).  Selon cette  approche basée  sur  la foncti on 

d' utilité,  (Stokman  et  Yan  Oosten,  1994 ;  Stokman et  Zeggelink,  1996)  ont  déve loppé  des 

modèles  de  la  négoc iation  politique.  Dans  ce  cas,  on étudi e  la  dynamique  des  interactions 

entre  les  agents  plutôt que  la  structure de  leurs  interactions.  Cependant,  une autre tendance 

dans  la  théorie  des jeux  est  d'appliquer  des jeux  classiques  et  de  les  tester  dans  différentes 

structures  soc iales  où  seulement  les  agents  reliés  peuvent  interagir.  Dans  ce  cas,  les 

économ istes  utilisent  souvent des modèles  théoriques de  réseaux  soc iaux  tels  que  les graphes 

aléatoires,  les  structures  régulières  ou  les  petits  mondes  comme  structure  d' interaction 

(Peyton Young,  1998). 

Simul ations soc iales basées agents 

Le  but  de  la  modéli sati on basée  agents dan s  l'étude  des  résea ux soc iaux  est  d'ex primer des 

mécani smes  soc iocognitifs  de  création,  d' entretien  et  de  finalisation  de  relati ons.  La  base 

théorique  de  ces  mécani smes  vient  surtout  des 

th éories  soc iopsycholog iques  du 

comportement  de groupe.  Ces  mod èles  initiali sent  le résea u soc ial en choisissant  parfois  un 

réseau  vide  ou  bien  en utilisant  un  réseau  choisi parmi  les  modèles  théoriques  ou encore, en 

utilisant des  données emp iriques.  Les  modèles  basés agents sont  nombreux et  plus ou moins 

complexes.  Pour  n'en  nommer  que  quelques-uns,  (Mos ler  et  Brucks,  200 1)  justifient 

1' utilisati on  de  simul ations  basées  agents  pour  ex pl orer  des  théories  soc iopsyc holog iques, 

(Flache et Macy,  1996) uti 1 isent  un e approche stoc hastique d'apprenti ssage basée agents  pour 

explorer la théorie  de  l'échange  de  Homan , (Zeggelink,  1993)  suggère  de  nouveaux modèles 

de  réseaux  d'amitié  basés  agents  et  (Snijders,  1996)  propose  des  modèles  stochast iques 

orientés acteurs pour tester la théorie de  la fraternité de Newcomb. 

48 

Dans  un  modèle  basé  agents, ce  qui  motive  un  agent  à créer et  maintenir  des  relations  peut 

être,  par exemple,  son  dés ir  d' atteindre  certain s  buts  ou d'occuper  une  pos ition  stratégiqu e 

dans  le  réseau  qui  augmentera  son  pouvoir.  Aussi,  dans  plusieurs  modèles,  la  notion  de 

confiance joue souvent  un  rôle important  dans le choix des  relations d' un  agent. 

2.5  Outils de modélisation et simulation 

Il  ex iste  une  panoplie  d' outil s,  de  logicie ls  et  de  librairies  qui  peuvent  aider  à  la 

programmation  d' un  modèle  de  réseau soci al dans  le  but  de  le  simul er.  L' obj ectif de  cette 

section  est  de  pos iti onner  NetSim  par  rapport  aux  différents  types  d' outil s  déjà  à  notre 

di sposition. 

Tout  d' abord,  on  constate  qu ' il  existe  plusieurs  langages  ou  logiciels  qui  sont  bien  adaptés 

pour  la mi se en œuvre de  simul ations d'ensembl es  soc iaux complexes.  Ces outil s permettent 

de définir fin ement  les  agents de la  simul ati on, les  méca ni smes d' interacti ons entre les  agents 

et l'environnement  dans lequel évo luent  ces agents.  Nous parl ons ici d' applicati ons capabl es 

de construire des  modèles  multi-agents très complexes.  Swarm  (http ://www.swarm .org), par 

exemple, est une des  meilleures  pl ates-form es  pour  la création de simul ations soc iales.  Elle a 

été  spéc ial ement  conçue  pour  la  simulation d'agents  multiples  dans des  systèmes  adaptatifs 

complexes. 

Ascape 

(http://www.brook.edu/es/dynamics/  models/asca pe)  et  RePas! 

(http://repast.sourceforge. net) sont  d'autres exempl es de ce genre de log iciels. 

Étant  donné  leur  puissance  et  leur  fl ex ibi 1 ité,  ces  applications  permettent  d' implémenter des 

mécani smes  soc iaux  très  sophistiqués. 

Par  contre, 

il  demande  une  longue  courbe 

d'apprenti ssage  et  beaucoup  de  programmati on.  Dans  le cas  de Swarm,  par exempl e,  il  est 

nécessa ire  d' avo ir  une  certa ine  expérience  en  Java  ou  en  Obj ective  C,  d' être  fa milier  avec 

l'orienté-obj et et d' apprendre le code Swann . 

Ces  logiciels  ne  sont  pas  comparables  à  NetS im . 

Il s  sont  destinés  à  si muler  des  modè les 

plutôt  basés  agents  qui  peuvent  modéli ser des  comportements  sociaux  très  complexes.  De 

~--

- - - - - - - - - - - · - - - - -- -------, 

49 

plus, il s vi sent  plus particulièrement  l'étude de  la dynamique des  interacti ons entre les  agents 

plutôt que de s' intéresser, comme NetSim, à la structure de ces  interacti ons. 

D' autre part, en ce  qui  concerne plus  parti culièrement  l' étude de  la structure des  réseaux, on 

peut  trouver  une  grande  variété  de  log iciels  et  librairi es  qui  permettent  la  représentati on et 

l' analyse de données de réseaux .  Ils comprennent des  méth odes  pouvant  calculer les  notions 

les plus courantes comme la densité, le coeffi cient de tran siti vité, la di stribution des degrés, la 

centralité,  l'équivalence  structurale  et  parfo is,  des  procédures  d' analyse  stati stique  plus 

sophistiquées.  Les  log iciels 

•  UCIN ET (http://www.analyti ctech.com/downl oaduc6.htm) et 

•  StOCNET (http://stat.gamma. rug.nl/stocnet), 

en sont des exemples. 

D' autres  outil s  se  spéc iali sent  dans  la  visuali sati on,  sous  forme  de  graphe,  de  données  de 

réseaux.  Il s sont souvent offerts sous fo rme de librairie comme 

• 

JUNG  (http://j ung.sourceforge.net), 

•  GINY  (http://csbi .sourceforge. net) et 

•  Prefu se (http://www.prefuse.org) 

ou sont des appt ications comme 

•  Graph viz (http://www.graphviz.org/), 

•  KrackPiot (http://www.isi.edu/- blythe/KP) ou 

•  NetDraw  (http://www.analyti ctech.com/downl oadnd.htm). 

Ces  différents  outil s  sont  très  utiles  pour  étudier  la  structure  de  réseaux  statiques,  mais  ne 

permettent  pas  de  spéc ifie r  les  règ les  d' un  modèle  dynamique  afi n  de  le  sim uler  dans  le 

temps.  En  général,  les  simulations  sont  programmées  pour  l'étude  d' un  phénomène 

' 1 
1 
L 

50 

particulier  et  ne  servent  que  pour  cette  étude.  À  notre  conn aissance,  une  pl ate-forme 

générique  comme NetSim,  permettant de  modéli ser  les  règ les  de divers  modèles  de  réseaux 

soci aux à  l'aide d' un  langage de  modéli sation spéc ifique, et ce, dans  le  but  de  les  simul er et 

de  visualiser  1 'évolution  de  leurs  structures  dans  le  temps,  n'a  pas  encore  été  déve loppée. 

Nous  voudrions  cependant  menti onn er Blanche  (Hyatt,  Contractor et Jones,  1997),  un  ou ti 1 

informatique servant à la modéli sati on et à  l' exécution de simulations numériques  basées  sur 

la  conceptuali sation  et  l' organisation  des  réseaux.  Un  peu  comme  NetSim,  il  fournit  un e 

architecture  fl ex ible  et  réutilisabl e  pour  la  spéc ificat ion  de  di vers  types  de  modèles  en 

permettant  la définiti on de diffé rentes  entités  (acteurs, personnes, noeuds), d'attributs sur  ces 

entités,  de  relations  entre  ces  entités  et  d 'équations  mathématiques  qui  expriment  les  règles 

du  modèle à simuler.  Cepend ant, contrairement  à NetSim, cette applicati on ne  permet  pas  la 

vi suai isation,  sous  forme  de  graphe,  de  1 'évo lution  structurale  du  résea u  au  cours  de  la 

simul ation.  Par contre,  elle fournit  diffé rentes  méth odes  d' analyse  du  réseau de  sortie de  la 

simulation. 

2.6  Conclusion 

Tout  d'abord , nous avons vu, dans ce  chapitre, quelques  exemples  montrant  la  pertinence  de 

l'étude  des  réseaux  soc iaux  dans  plusieurs  domaines  puis  nous  avons  expliqué  di verses 

méthodes d 'analyse  de réseaux, prove nant  de la soc iolog ie structurale,  qui  sont  très  utiles à la 

compréhension de certain s phénomènes  soc iologiques.  Nous avons vu di ffé rentes  méthodes 

de  partitionnement  de  réseaux  pour  une  étud e  de  la  structure  au  ni veau  global  et  avons 

ensuite expliqué des  procédures  de pos iti onnement  des acteurs dans  le  réseau pour  une étud e 

au ni veau local. 

Le  logiciel NetS im  n'a  pas  encore déve loppé  de  méth ode  d' analyse  des  réseaux,  mais  nous 

pensons  tout  de  même  que  la  com pré hension de  ces  concepts  t:st  pertinente  pour  effectuer 

une  première  analyse  visuelle  de  la  structure  des  réseaux  engendrés  par  simul ation.  Les 

concepts  de  centra lité,  de  prestige,  par  exemple,  bien  que  pouvant  se  ca lcul er  de  faço n 

mathématique, peuvent être facilement  repérables, dans certa in s cas, par sim ple visuali sation. 

51 

Nous avons ensuite montré que l' investigation de  certain s phénomènes  sociologiques  peut  se 

fa ire  par  modélisation  et  avons  décrit  plusieurs  modèles  provenant  de  diverses  di sc iplines. 

Premièrement, 

les  modèles 

théoriques,  provenant  surtout  de 

la  phys ique  et  des 

mathématiques,  tentent  de  représenter  des  phénomènes  observés  dans  la  réa lité  tels  que  la 

transitivité  et  l'effet  des  petits  mondes  dans  plusieurs  types  de  réseaux  soc iaux  et 

l' attachement  préférentiel,  dans 

l' évolution,  par  exemple,  de 

la  structure  du  Web. 

Deuxièmement, 

les  modèles  statistiques,  utili sés  surtout  en  soc iologie,  essa ient  de 

comprendre  et d'expliquer  la structure des  réseaux soc iaux  par  les  relations qu ' entretiennent 

les  acteurs entre eux.  Ces  modèles  étudient  la probabilité de  l' existence  d' une  relation entre 

deux  acteurs  se lon  leurs  caractéri stiques  et  leur  pos ition  dans  le  réseau.  Finalement,  nous 

avons vu  l'approche par modélisation ascendante qui  modéli se  les  mécanismes  indi viduels de 

création,  d' entretien  et  de  suppress ion  de  relations  des  agents  eux-mêmes  dans  le  but 

d'étudier le genre de  réseau qu ' il s engendrent. 

Finalement,  nous  avons  pos itionné  NetSim  par  rapport  à  di vers  types  d' outil s  de 

modélisation, de vi suali sation et de simul ation de réseaux. 

CHAPITRE  3 

Langage de modélisation NetSim 

3. 1  Introduction 

Les  chapitres  précédents  présentaient  le  contexte  théorique  et  certaines  notions de  base  qui 

ont  motivé  la  réa lisation  de  ce  projet.  Nous  avons  constaté  qu ' il  ex iste  des  modèles 

dynamiques  de  réseaux  d' information  qui  peuvent  être  étudiés  par  simul at ion.  Nou s  avon s 

vu  que  les  structures  des  réseaux  ainsi  générés  peuvent  être  exa minées  par  des  méthodes 

d' analyse,  basées  sur  la  théori e  de  graphes,  dont  les  principaux  concepts  sont  souvent 

repérabl es par simple vi sualisation  graphique. 

De  plus,  nous  avons  vu  qu ' il  ex iste  beaucoup  de  ressources  (logiciel  ,  librai ries  etc .)  qu1 

aident à la  modé lisation, la  simulation, la visuali sati on et  l'analyse des réseaux d' informati on. 

Cependant, on constate que, pour  plusieurs de ces  outi ls,  la mi se en œuvre d' une simulati on 

peut  être  assez  labori euse  et  demande  so uvent  de  bonnes  compétences  en  programmati on. 

De  plus,  chaque foi s que l'on  désire  imp lémenter un  nouveau modèle,  le trava il  est souvent  à 

recommencer.  Ces  constats  nous ont  amenés  à chercher des  so luti ons  pour fac iliter  la  mi se 

en oeuvre de simulations diverses. 

C'est  dans  cet  esprit,  donc,  que  nous  avons  développé  une  plate-forme  générique  de 

modélisation,  de  simulation  et  de  visuali sation  de  modèles  dynamiques  de  réseaux 

d' informati on. 

Dans  ce  chapitre,  nous  allons  abord er  plus  particulièrement  la  parti e  modéli sation  qu1 

consiste  en  un  langage  de  modéli sation  permettant  de  spéc ifier  les  paramètres  et  les  règles 

des modèles que l'on veut simuler.  Ce  langage est, en quelque sorte, le concept  central de ce 

53 

projet  et  a  été  élaboré  en  particulier  pour  les  modèles  de  réseaux  sociaux  et  le  Web.  Nous 

croyons cependant que  sa  flexibilité et son extensibi lité  le  rendent  capab le d' ex primer divers 

types de  réseaux d' information. 

Les  modèles  qui  nous  intéressent  plus  particulièrement  sont  les  modèles  dynamiques 

pouvant, de ce fait, être  simu lés  par ordinateur et dont  la structure d' interactions sous-j acente 

est  un  graphe .  Nous  en  avons  vu  quelques-uns  au  chapitre  précédent  et al lons  les  utili ser, 

dans  les chapitres à venir, à titre d'exemple pour la modélisation avec  le langage NetSim . 

3.2  Les entités du langage 

Le 

langage  de  modéli sation  NetSim  a  été  élaboré  en  observant  différe nts  modèles 

dynamiques  de  réseaux  d' information  (Jin,  Girvan  et  Newman,  2001  ;  Albert  et  Barabas i, 

2000).  Les  entités  manipulées  dans  ces  modèles  sont  à  peu  près  toujours  les  mêmes:  les 

acteurs  ou  agents,  les  relations  entre  les  acteurs  et  finalement,  l'ensemble  des  acteurs et de 

leurs relations qui  forment  le réseau.  Dans le langage NetSim, le réseau est représenté par  un 

graphe  dans  lequel  les  acteurs  sont  représentés  par  les  nœuds  ou sommets  du  graphe  et  les 

relation s, par les liens (arcs ou arêtes) du  graphe. 

Le  tableau  3.2. 1 donne  une  description  des  entités  du  langage  de  NetSim .  Pour  l' instant, 

notre  logici el de  simulation ne  permet de  simuler que  l' évolution d' un  seul  réseau à  la  fois, 

mai s  nous  pensons  qu 'éventuellement,  il  serait  intéressant  d' étendre  les  fonctionnalités  de 

NetSim  pour que celui-ci  puisse  exécuter plusieu rs  si mulations  différentes  en  même  temps. 

Dans  cette  optique,  nous  avons  prévu  l' entité  world  qui  représente  l' environnement  dans 

leque l évo luent  les  réseaux.  Cet environnement  pourrait  alors devenir  un  li eu d' échange  de 

données entre les différents réseaux.  Pour le  moment, puisqu ' il  n'y a qu ' un  seul  réseau, cette 

entité est pratiquement  triviale. 

54 

Tableau 3.2.1  Les entités du  langage NetSim 

Entité 

'''><!'> 

Représentatiofi'm'' " "'' 

\ yd\ 

""''*''""'''~""' 

\'1,\  Ji' 

world 

L' environnement dans lequel évo lue le réseau d' information si mulé. 

network 

Le  réseau formé  par les acteurs et les relations qu ' ils entretiennent entre eux. 

link 

node 

Une relation  entre deux acteurs. 

Un acteur 

Certaines  entités,  comme  nous  le  verrons  dans  les  sections  sui vantes,  possèdent  des 

constantes, des attributs et des fonction s prédéfini s par NetSim ou  qui  peuvent être défini s par 

l' utilisateur.  Les  constantes  sont  initiali sées  au  début  de  la  simulation  et  leur  valeur  reste 

inchangée  durant  toute  la simulation .  Les  attributs, par contre,  sont  in itia.l isés  au  début de  la . 

simulation, mai s leur  valeur peut  être modifi ée  au  cours de  celle-ci.  Les  fonctions, pour  leur 

part, sont des valeurs calculées pendant  la  simulation. 

Pour comprendre ce  langage  de  modéli sat ion, on doit  tout  d' abord  comprendre  la  hi érarchi e 

des entités qui  détermine la  visibilité d' une entité par une autre: 

1.  Les attributs et fonctions défini s sur  l' entité world  sont  visibles par toutes  les entités. 

2.  Les  attributs  et  fonction s  défini s  sur  l'entité  network  sont  vi sibl es  par  les  entités 

network, link  et node. 

3.  Les  attributs et fonctions  défi ni s sur l'entité  link  ne sont  visibles  que  par  l' entité link 

seulement. 

4.  Les  attributs  et  fonctions  défini s  sur  l'entité  node  ne  sont  visibles  que  par  l' entité 

node seu lement. 

5.  Les constantes sont visibles de partout. 

La  figure  3.2.1  illustre cette hiérarchie de façon  plus schématique. 

55 

Fig ure 3.2.1  Hiérarchie des entités de NetSim 
Chaque  entité est visible par elle-même et par les  entités  représentées  par  une teinte  de gris plus pâle 
(s ' il  y  a  lieu).  Dit  d' une autre manière, chaque  entité peut  se  voir  elle-même  et  peut  voir  des  entités 
représentées  par  une  teinte  de  gris  plus  foncée.  Par  exemple,  l'entité  world  ne  voit  qu 'elle-même, 
l'entité  network  peut  se  voir  elle-même ainsi  que  l'entité world.  L'entité  link  peut se  voir elle-même 
ainsi que l'entité network  et l'entité world  et fin alement, l'entité node peut  se voir elle-même ainsi que 
l'ent ité network et l' entité world . 

La  section  suivante  ex plique  la syntaxe du  langage NetSim  pour écrire  ce  que  nous appelons 

les défin itions  du  modèle : les constantes, les attributs et les fonctions . 

3.3  Syntaxe d'écriture des définitions du modèle 

3.3.1  Généralités 

Le  langage NetSim  permet de définir certains paramètres sur  les entités de  la  simulation.  Ces 

paramètres  (définitions) peuvent  être des constantes, des attributs ou  des fonctions. 

À l'exception des constantes qui  sont  v isibles de partout, chaque défi nition est définie su r une 

entité  spécifique  (world ,  network,  link  ou  nod e)  qui  détermine  sa  visibilité  comme  nous 

l' avons vu  à la  section  précédente. 

Les commandes servant à écrire les définitions commencent toutes par le  mot « DEFINE ». 

56 

Chaque définiti on se termine par un  point-virgule. 

3.3.2  Les constantes 

Les  constantes sont  des valeurs numériques  déterminées au début de la  simul ation et qui  sont 

utili sées  dans  la  spécification  des  règles  du  modèle.  Ce lles-ci  ne  sont  pas  modifiables 

pend ant  la  simulati on. 

La  commande pour définir  une constante est DEFI NE_ CONST  et prend  comme paramètre  le 

nom de la constante ainsi que sa va leur d' initiali sation. 

Par  exemple,  pour  définir  la  constante  dont  le  nom  est  « limite»  et  dont  la  valeur 

d' initialisation est 5, il  faut éc rire: 

DEF I NE  CONST  (limite,  5); 

3.3.3  Les attributs 

Les  attributs sont  des variabl es  défini es  sur  une entité particuli ère.  Leur  valeur est initi alisée 

au début  de la simul ation, mais peut  être modifiée  au cours de  la  simul ation.  NetSim  définit 

quelques  attributs  sur  les  entités  node  et  link  qui  caractéri sent  leur  apparence  lors  de  la 

vi suali sati on de  la  simul ation  cepend ant,  des  attributs  suppl émentaires  peuvent  être  défini s 

par l' utili sateur. 

3. 3. 3.1  Les attributs p rédéfinis par NetSim 

Les  entités  node  et  lin k  possèdent  une  série  d'attributs  de  visualisation  prédéfini s  qui  ne 

concernent  que  les  propriétés  graphiques  de  ces  enti tés.  On  parl e  ici de  grosseur  et/ou  de 

coul eur des  nœud s ou des  liens.  En effet,  il  peut  être utile,  par exemple, de  colorer certain s 

nœuds  ou  li ens  présentant  des  caractéristiques  particuli ères  que  l' on  voudrait  mettre  en 

évidence  en cours de  simulation.  Par exempl e, on pourrait voul oi r colorer en ve rt  les  nœud s 

qui  ont  un  degré  plus  élevé  que  la  moyenne  afin  de  les  rendre  plus  visibles  en  cours  de 

57 

simulation.  Les  tab leaux 3.3.3. 1.1  et 3.3.3 .1.2  montrent  la  li ste de ces  attributs pour  chaque 

entité. 

Tableau 3.3.3.1.1  Attributs prédéfinis sur l'entité nod e 

Atfrjbuts 

%\ 

Description 

·:§·@;j 

:. 

1\0.··  1) 

border  co lor 

-

fi Il  co lor 

-

highlight_co lor 

fixed  co lor 

radius 

Couleur de la bordure du  nœud  (noir par défaut). 

Couleur de remplissage du  nœud  (noir par défaut) . 

Couleur  de  rempli ssage  du  noeud  lorsque  ce lui-c i  est  m1 s  en 
évidence  par  la  souri s :  lorsq ue  la  souri s  est  pos iti onnée  sur  un 
nœud ,  ce  nœud  ai nsi que  tous  ses  vo isin s  prennent  cette  couleur 
(rouge  par défaut). 

Couleur  de  remplissage  du  nœud  lorsque  ce lui-ci est  immobile 
dan s  la  visuali sation  graphique:  il  est  poss ible d' immobiliser  un 
nœud  en cliquant dessus avec  la  souri s (rouge  par défaut). 

Grosseur des  nœud s.  Plus cette  valeur  numérique est petite, plus 
la grosseur des nœud s est petite et vi ce  versa  (égal  6 par défaut) . 

Tableau 3.3.3.1.2  Attributs prédéfinis sur l'entité link 

A~if)pts 

•  c%: 

@;  Dê'Si!iiption 

%t%Jià 

" 

i'H 

''  &~~v 

co lor 

La  couleur du  lien (noir par défaut) . 

highlight_co lor 

La  couleur du  lien lorsq ue ce lui-ci  est mis en év idence par la 
souri s : lorsque  la souri s est positionnée sur un  nœud , tous les 
liens de ce nœud  prennent celle couleur (rouge  par défa ut). 

En ce  qui  concerne les  attributs de  couleur, ce  sont  des  va leurs numériques  qui  correspond ent 

à des codes de  cou leur spéc ifiés dans un  fichi er de configuration de NetSim . 

--------------------------------, 

58 

3. 3. 3. 2  Définition d 'attributs par l 'utilisateur 

Les attributs prédéfini s par NetSim sont des  attributs de vi suai isation et ne concernent  que les 

entités  link  et  node.  Cependant,  les  attributs  servent  souvent  à  représenter  l'état de  chaque 

entité  au  cours  d' une  simulation.  Le  langage  de  modéli sation  NetS im  offre  donc  la 

poss ibilité à  l' utilisateur  de définir  des  attributs d' état  sur  toutes  les  entités  de  la simulation. 

Les attributs sont  touj ours numériques et peuvent être modifi és au cours de la  simul ation. 

La  commande de définiti on des  attributs  est DEFI NE_ ATTRIB et prend  comme  paramètres 

l'entité  sur  laquell e  on défi nit  l' attribut  (world,  network,  link  ou node),  le  nom de  l'attribut 

ainsi que sa valeur d' initiali sation . 

Par exemple,  nous  pourrions définir,  sur  l'entité  link,  l' attribut  dont  le  nom est «force» et 

dont  la  va leur d' initiali sation est  1 de cette manière: 

DEFINE  ATTRIB  (link,  force,  1); 

La  définiti on ci-dessus implique que chaque  li en nouvellement  créé  au cours de  la simulation 

possèdera alors un  attribut « force» initi ali sé  à  1 et dont  la  va leur pourra, bien entendu , être 

modifiée  par  la suite.  Selon  les  règles  de vi sibilité vues  à  la section 3.2, cet  attribut  ne sera 

visible  que  par  l'entité  link .  De  la même façon , nous pourrions définir  des  attributs sur  les 

entités  world ,  network  et node. 

3.3.4  Les fonctions 

Après  avo ir écrit  les  constantes et les  attributs du  modè le dans le langage de modéli sati on, on 

peut  alors écrire  les  fo ncti ons nécessa ires  au fonctionnement  de notre modèle.  Les  fonctions 

NetSim  sont  des  expressions  arithm étiques  ou  boo léennes  qui  ca lculent  et  retournent  une 

va leur  numérique  ou  boo léenne.  Comme  pour  les  attributs,  le  langage  fournit  déjà  certaines 

fonctions  prédéfinies sur  les entités, mais  il  est aussi  possible, pour  l' utilisateur, de  définir ses 

propres  fo nctions.  Dans  ce  derni er  cas,  nous  aurons  besoi n  de  que lques  opérateurs 

59 

arithmétiques  et  booléens.  Les  tableaux 3.3.4.1 à 3.3.4.5  montrent  la  li ste des  opérateurs de 

base dont dispose ce  langage de modélisation . 

Tableau 3.3.4.1  Opérateurs arithmétiques binaires de NetSim 

hw·€l*îlêrlttê'ûrs  arithmétique~ hill 
Signes 

Opérations 

add iti on 

,_  •. @) 

H 

"1® 

Exem~les 

5+3 =8 

+ 

-

* 

1 

** 

soustraction 

5-3 = 2 

mu !ti p 1 ication 

5*3 =  15 

divi sion (rée lle) 

513 =  1.666 .. . 

pUissance 

5 **  3 =  125 

mod 

modul o 

5 mod 3 = 2 

Tableau 3.3.4.2  Opérateurs arithmétiques un aires de NetSim 

'•  Opérnteurs arithmétiques unaires 
Signes 

Û l)érations 

Exemp les 

-

+ 

nombre négatif 

-1 

nombre positif 

+]  =  1 

fioor 

plancher 

floor 3.4 = 3 

ce il 

plafond 

ceil 3.4  = 4 

60 

Tableau 3.3.4.3  Opérateurs booléens binaires de NetSim 

OpérateuJ"S booléens binaires 
Signes 

Opérations 

Exemples 

test d'éga lité 

1 = 2 est faux  ,  2 = 2 est vrai 

test d' inéga lité 

1 /= 2 est vrai  ; 2 /= 2 est faux 

plus petit 

5 <  3 = faux  ,  5 <  5 = faux 

plus grand 

5 > 3 = vrai  ,  5 > 5 = faux 

plus petit ou égal 

5 <= 3 = faux  ,  5 <= 5 = vrai 

plus grand  ou  éga l  5 >= 3 = vrai  ,  5 >= 5 = vra i 

et 

ou 

ou exc lusif 

/= 

< 

> 

<= 

>= 

and 

or 

xor 

Tableau 3.3.4.4  Opérateur booléen  unaire de NetSim 

Opérateur booléen  unaire 
Signes 

Opérations 

Exemples 

not 

négation 

not fau x = vra i 

' 

not vrai  = fau x 

Tableau 3.3.4.5  Opérateur d ' affectation 

Opérateur d'affectation 
Opération 
Signe 

Exemp_le 

-

affectation 

force:= 5 (affecte  la va leur 5 à l' attribut fo rce) 

61 

3.3.4. 1  Les fonctions prédéfinies par NetSim 

Le  langage  de  modéli sati on NetSim  offre  une  série  de  fonctions  défini e  sur  les  différentes 

entités.  Une  fonction  se  termine  touj ours  par  une  parenthèse  ouvrante  et  fermante  pour  se 

différencier des attributs. 

Les tabl eaux 3.3.4. 1.1 à 3.3.4. 1.4  montrent  les fonctions di sponibles  pour chaque entité.  Pour 

ce  trava i 1,  nous  avons  implémenté  les  fonctions  de  base  mentionnées  dans  les  tableaux 

suivants,  mais  nous  souhaitons  éventuellement  ajouter  de  nouvelles  fonctions  pour  enrichir 

notre  langage.  NetSim  a été  conçu de  façon  à être faci lement  extensibl e et  nous verrons, au 

chapitre  suivant,  comment  implémenter  de  nouvelles  fonctions  qui  pourront  ensuite  être 

utili sées comme fonctions  prédéfinies du  langage de  modé li sation. 

Tableau 3.3.4.1.1  Fonct ions prédéfinies sur l'entité world 

.Fonctions prédéfinies sm·J'entitéwl'lHd  & 

,Il,~;' 

iif:. 

il\ 

,. 

.. ,,.,,,,""~  "';J. 

Selon  les  règles  de  visibilité  des  entités,  cette  fonction  est  visib le  par  les  entités  world , 
network, link  et node . 

Nom  de  la fonction 

Desuiption 

time  step() 

Retourn e  le  nombre de  pas  de tem ps effectués  depuis  le début de 
la simul ati on.  Le  premier  pas  de  temps  =  0  et augmente de  1 à 
chaque pas de temps supplémentaire. 

random _ nurnber() 

Foncti on  utilitaire  qui  retourne  un  nombre  aléato ire  entre  0  et  1 
inclusivement. 

Tableau 3.3.4.1.2  Fonctions prédéfinies sur l'entité network 

.Jj:oncti6ns prédéfinies sur l'entité network 

r4 

wEli 

'If 

Selon  les  règ les  de  visibi lité  des  entités,  ces  fo ncti ons  sont  donc  visibles  par  les  entités 
network, lin k et node. 

number _of_ nod es() 

1  Retourne  le nombre de nœud s contenus dans le  réseau . 

62 

number_of_ links() 

Retourn e le nombre de li ens contenus dans  le réseau. 

mean_ degree() 

max_ degree() 

min_ degree() 

Retourne  le  degré  moyen du  réseau :  la  somme  des  degrés  de 
tous  les  nœud s  du  réseau divi sée  par  le  nombre  de  nœuds  du 
réseau. 

Retourne  le  degré  d' un  nœud  du  réseau  qui  est  supérieur  ou 
égal  aux degrés de tous les autres  nœud s. 

Retourne  le  degré  d' un  nœud  du  réseau  qu1  est  inférieur  ou 
égal  aux degrés de tous les autres  nœud s. 

diameter() 

Retourne le diamètre du  réseau 

Tableau 3.3.4.1.3  Fonctions prédéfinies sur l'entité link 

Selon  les  règles  de  visibilité  des  entités,  ces  fo ncti ons  sont  donc  visibles  par  l' entité  link 
uniquement. 

start  node() 

end_node() 

Retourne  le  prem1 er  nœud  du 
lien.  Si  le  graphe  est 
ori enté,  c'est  le  nœud  qui  correspond  au  point  de  départ 
du  li en. 

Retourne  le  deuxième  nœud  du  lien_  Si  le  graphe  est 
orienté,  c'est  le  nœud  qui  correspond  au  point  d' arri vée 
du  li en. 

number_of_common_contacts()  Retourne  le  nombre  de  VO ISin s  immédiats  qu ' ont  en 
commun  le  premier  nœud  (de  départ)  et  le  second  nœud 
(d ' arri vée) du  lien. 

have_common_contacts() 

Retourne vrai si les  deux  nœuds  du  li en ont  au moins  un 
contact en  commun, retourne faux sinon . 

a_ common _contact() 

Reto urne  un  nœud  qui  est  un  contact  commun  des  de ux 
nœuds du  lien. 

Tableau 3.3.4.1.4  Fonctions prédéfinies sur l'entité node 
,.,, 

, sur t  entite· u~~XR! 

·"'' 

JW:I.·'" 

63 

''\\\ 

"  ,, 

'i''  0"'}7 

Selon  les  règles  de  visibilité  des  entités,  ces  fonctions  sont  donc  visib les  par  l' entité  node 
uniquement. 

degree() 

Retourne  le degré du  noeud. 

Pour  un  graphe  orienté, c'est  la somme du  demi-degré  extérieur 
et du  demi -degré intéri eur. 

Si  le  graphe est non ori enté,  le  degré est id entique au  demi-degré 
intérieur et au  demi-degré extérieur. 

Retourne  le  nombre  de 
extérieur) . 

liens  sortant  du  nœud  (demi -degré 

Retourne  le  nombre  de  lien s  entrant  sur  le  nœud  (demi-degré 
intérieur). 

out_ degree() 

in-'-degree() 

3.3.4.2  Définitions de fonctions par l 'utilisateur 

Outre  les  fonctions  prédéfi nies  par  le  langage  de  modélisati on  NetSim,  1 ' uti 1 isateur  peut 

définir  ses  propres  fonctions.  Une  fonct ion  défini e  par  un  utili sateur  est  une  ex press ion 

arithmétique ou boo léenne qui  retourne respectivement  une  va leur  numérique  ou  boo léenne. 

Comme  dan s  le  cas  des  attributs, une  fonction  est  touj ou rs défini e  sur  un e entité spéc ifique. 

Ell e  peut  être  construite  à  l'a ide  d'opérateurs  arithmétiques  ou  boo léens,  de  constantes, 

d' attributs et d'autres  fonctions  pourvu que  les  attributs et  les  autres  fonctions  respectent  les 

règ les de visibilité di ctées par l'entité sur  laquelle on définit  la fonction. 

La  commande  de  définition  des  fonctions  est  DEFINE_FUNCTION  et  elle  prend  comm e 

paramètres  l'entité sur  laq uell e on  veut  définir  la  fo nction  et  le nom de  la fonction .  Ensu ite, 

on  écrit l' expression de  la fo nction qui  se  termine par un  point-virgul e. 

64 

Lorsqu 'on veut  appeler une fonction, on doit  écrire  le nom de ce lle-ci sui vi d' une parenthèse 

ouvrante et fe rmante.  La fonction calcule et retourne la valeur  de son express ion au moment 

de l' appel.  Supposons les définiti ons de constantes et d'attributs sui va ntes: 

DE FI NE  CONST  (con st_ 1 ,  2.34) ; 
DEF INE  CONST  (const  2,  0. 1 ) ; 
DE FINE  CONST  (con st  3 ,  0.8); 

DEFI NE  ATTRIB  (node,  n ode_1 ,  0) ; 
DEFINE  ATTRIB 
DE FINE  ATTRI B  (network ,  net_1 ,  4); 
DEFI NE  ATTRIB  (world,  world_ 1,  30 ) ; 
DE FINE  ATTRIB  (wor l d,  wor l d_ 2,  2); 

(l ink,  li nk_ l,  0.000); 

Voici quelques exemples de définitions de fonctions: 

Exemple 1: 

La  fonction sui vante  est  défi nie  sur  l' entité  world  et  son  nom est  f  1.  C' est  une  fo nction 

boo léenne,  car  elle  teste  1 ' éga lité  entre  deux  sous-ex pressions  arithmétiques  à  1 'aid e  de 

l'opérateur «=».  L'express ion boo léenne de cette fo nction utili se  la foncti on time_ step () 

et  les attributs wor l d  1  et world  2  aussi défin is sur l'entité world .  La  visibil ité des entités 

est donc respectée. 

DEFINE  FUNCTION  (world ,  f_1) 
time_step()  **  world  2 

time_ s tep ()  **  floor  (world_1); 

Exemple 2: 

La  fo nction  suivante  est  défini e  sur  l' entité  network  et  son  nom  est  f  2.  C'est  auss i  un e 

fo nction  boo léenne,  car  ell e  uti li se  1 'opérateur  boo léen  «  >=  ».  Elle  ut i 1 ise  les  fonctio ns 

number_of  links () ,  numbe r_o f _ nodes ()  et  diameter (),  to utes  prédéfi nies  sur 

l' entité  network.  Ell e  util ise  auss i  la  fo ncti on  time_s tep ()  qui  est  prédéfi nie  sur  l' entité 

world.  Comme cette  fo nction  est défi nie sur  l' entité  network,  l' expression  respecte  bien  les 

règles de visibilité, car l'entité world  est visible par l' entité network . 

l 

65 

DE FI NE_FUNCT I ON  (network,  f  2) 

(number_ of  links()  +  n umber_ of  n a des())  / min  degre e ()  > = 
diameter()  *  ti me _ step ( ); 

Exemple 3 : 

La  fonction  sui vante  est  une  fonction  défini e  sur  l' entité  node  et  son  nom  est  f  3 .  C'est 

aussi une foncti on  boo léenne  car  elle  utilise  des  opérateurs  boo léens.  On  remarque  qu ' ell e 

fait appel aux fonctions f _1 ( )  et  f_ 2 ()  défini es  précédemment  sur  l'entité world  et l' entité 

network .  De plus,  elle utilise  les  fon ctions in_ degree ()  et o ut _ d eg re e  ()  prédéfini es sur 

l' entité node.  L'expression respecte donc les  règles  de visibilité puisque  les entités world  et 

network  sont visibles par l'entité node. 

DEFINE_FUNCTI ON  (n ode,  f_ 3 ) 

(f _1 ( )  o r  f _ 2()  and  (in  d e gree()  >  o ut _de g ree()  or 

no t 
in_ de gree ( )  / =  o ut_degree ()) ) ; 

Exemple 4: 

La  fonction  sui vante  est  définie  sur  l'entité  link  et  son  nom  est  f  4.  C'est  une  foncti on 

arithmétique  qui  retourne  une  valeur  numérique.  On  peut  remarquer  ici  comm ent  il  est 

poss ible d' appeler une foncti on défini e sur  node dans une foncti on défini e sur  link.  En effet, 

les  deux  fo nctions  s tart_ nod e  ( )  et  e nd_ n od e  (),  défini es  sur  link,  retournent  un  nœud . 

Avec  la  notation  pointée,  il  est  poss ible  d' appeler  des  fonctions  ou  d ' uti 1 iser  des  attributs 

défi nis  sur 

l' entité  node  comme  dans  les  express ions  start_node ()  . degree ()  et 

e nd_node ()  . n ode l.  Cette fonction respecte aussi les règ les de  visibili té. 

DEFINE_ FUNCTION  (link,  f_4 ) 
s t art  no d e ( ) .degree( ) 
link_1 )  *  con s t  3)  1  n e t  1; 

/  con s t  2  *  (( end_ n ode()  . n ode  1  + 

Exemple 5: 

Cet exemple montre une fonction qui  n'est pas  bien défini e.  Ell e présente  deux erreurs.  La 

première erreur  vient de 1 ' utilisation  de l' attribut  1 ink _1  dan s une fonction défini e sur  node. 

En  effet,  l' entité  lin k  n' est  pas  visible  par  l' entité  node.  La  seconde  erreur  vient  de 

66 

l' utili sation  de  la  fonction  f_1 ()  dans  l'ex press ion.  En  effet,  cette  foncti on  retourne  une 

valeur booléenne qui  ne peut pas être multipliée ainsi. 

DEFINE_FUNCTION  (node, 

f  4) 

degree() 

/  const  2  *  link  1  *  f  1 (); 

3.3.4.3  Définition de  méthodes Java dans NetSim 

NetSim est  une application basée sur le langage Java et il  est poss ible de  définir des  méthodes 

Java  qui  pourront,  par  la  suite,  être  utilisées  dans  la  spéc ifi cati on  des  règles  du  modèle  à 

si muler.  Étant  donné  qu ' il  est  imposs ible de  prévo ir  toutes  les  fonctions  qui  pourrai ent  être 

nécessa ires à la spéc ification des  règles de tous les  modèles  poss ibl es,  cette  commodité a été 

prévue  dans  le  cas  où  NetSim  n' offrirait  pas  la  fonction  prédéfi nie  nécessa ire  à  la 

modéli sat ion.  Év idemment,  1 ' utili sation  de  cette  fonctionna i ité  suppose  que  1 ' uti 1 isateur  de 

NetSim  connaît  le  langage  Java,  ce  qui  n'est  pas  toujours  le  cas.  Éventuellement,  nous 

aimerions  impl émenter  plusieurs  autres  fonctions  NetSim  pour  ainsi  minimi ser  l' utilisati on 

de méthodes Java . 

Il  y  a  cepend ant  certaines  restrictions  à  1 ' uti 1 isation  de  méthodes  Java  dans  NetS im . 

Premièrement,  la  méthode  Java  définie  doit toujours  retourner  un  nombre rée l (Double).  De 

plus,  pour  le  moment,  le  résultat  de  cette  méthode  est  touj ours  considéré  comme  une 

probabilité  (un  nombre entre  0  et  1 inclusivement) .  S' il  advi ent  que  le  résultat  retourné  est 

plus petit  que  zéro,  il  sera considéré  comme  éga l à zéro.  Si  le  résultat  est  plus grand  que  le 

nombre un , il  sera  consid éré comme éga l à un . 

Pour  pouvoir  impl émenter  une  méthode  Java,  il  faut  d'abord  l' indiquer dans  les  définitions 

du  modè le  avec  la  commande  DEFINE  JAVA  METHOD.  Cette  command e  prend  deux 

paramètres :  1 'entité  sur  laquelle  est  défi nie  cette  méthode  et  le  nom  de  la  méthode.  Par 

exemp le,  pour  définir  la  méthode  probabiliteAjouterCeLien sur  l'entité  lin k,  on 

écrit : 

DEFINE  JAVA  METHOD  (link,  probabiliteAjouterCeLien  ) ; 

67 

Ensuite, 

il  faut  écrire  le  code  Java  de  la  méthode  dan s  un  espace  réservé  à  cet  effet  dans 

l' interface  graphique de NetSim.  L' entête  de  la  méthode  Java  correspondant  à  la définition 

ci-dessus doit  être absolument : 

public  Double  probabil it eAj outerCeLien  (Li nk  link); 

Il  faut  mentionner  ici  que  la  classe  dans  laquelle  est  définie  cette  méthode  conti ent  déjà  les 

obj ets  nécessa ires  à  la  consu ltation  ou  la  modification  des  attributs  de  chaque  entité  de  la 

simul ation.  Nous avons  donc  la variable  wor ld qui  représente  l'entité world  et  la  variab le 

network,  qui  représente  l'entité  network.  Dans  le  cas  des  entités  link  et  node,  lors  de 

l' appel  de cette méthod e au  cours de  la  simu lation, l' instance de Node ou de Link qui  est en 

train  d'être  traitée  est  passée  en  paramètre  se lon  que  la  méthode  est  définie  sur  l' une  ou 

l'autre de ces entités. 

De  plus,  cette  classe  contient  l' attribut  s i mContro ll e r  qui  est  une  in stance  de  la  classe 

SimulationControll er que  nous  verrons  plus en détail  au chapitre suivant.  Il  suffit de 

savo ir, pour  le moment, que toutes les  méthodes servant à la consultation ou à la modificati on 

des  attributs  défini s  sur  chaque  entité  du  langage  sont  des  méthodes  définies  sur  cet  obj et. 

Par  exempl e,  pour  modifi er  la  va leur  de  l'attribut  toto qui  aurait  préa lab lement  été  défini 

sur  l' entité world,  nous écrivon s : 

s imControl l er.se tAttribute(world,  «  toto»,  valeur); 

où  le  paramètre  valeur  est  un  une  variable  de  type  double.  Pour  obtenir  la  valeur  de 

l' attribut force qui  aurait  préalablement été défi ni  sur  l'entité link, nou s écrivons: 

Double  valeur  =  simControl l er.getAttribute  (link,  «  force  »); 

Le  SimulationController  contient  auss i  l'équivalent  Java  de  toutes  les  fonctions 

prédéfini es  du  langage  de  NetSim .  Par  exempl e,  pour obtenir  le  pas  de  temps  courant  de  la 

si mulation,  le  langage  de  modéli sation  NetSim  offre  la  fonct ion  ti me_ step () .  Pour 

obtenir cette valeur dans  une  méthode Java, il  faut appeler la  méthode getTimeStep ()  sur 

l' obj et simController: 

68 

int 

t  =  s i mContro ll er.getTimeStep(); 

Finalement,  le  Simu l at i onController  contient  évidemment  d'autres  méthodes  de 

consultati on  et  de  gestion  du  graphe  représentant  le  réseau  simulé.  Ces  méthodes  ont 

l' avantage,  par rapport  aux fonctions prédéfini es du  langage de NetSim, de  pouvoir  retourner 

un  résultat autre  que  numérique  ou  boo léen.  Nous  ne  ferons  pas  ici  la  liste  exhausti ve  des 

méthodes  di sponibl es  dans  le  SimulationContro ll er,  mais  voyons  tout  de  même 

quelques  exemples : 

la  méthode  getAllPotent i a lL inks () 

retourne  une 

li ste 

(A rrayLi st)  de  tous  les 

liens  qui  pourraient  être  aj outés  au  résea u  et  la  méthode 

commonNeighbours 

(Node  nodel ,  Node  node2)  retourne  une  liste  de  tous  les 

voisins qu ' ont en commun  les paramètres nodel et node2 . 

Nous n'aborderons pas  cette fonctionnalité  plus en détail ,  mais nous présentons un  exemple 

simpl e de l' utili sation d' une méth ode Java dans l'éc riture d' un  modèle de l'évoluti on du  Web 

au chapitre 5. 

3.3.5  Exemple d'écriture des définitions du modèle d'amitié de Jin, Girvan et 
Newman 

Pour  donner une  idée  plus concrète de  l'écriture des  définiti ons d' un  modèle avec  le langage 

de modéli sation NetSim, nous all ons traduire  le modèle dynamique du  résea u d'ami s de (Jin , 

Girvan  et Newman, 2001 ) présenté à la secti on 2.4. 1. 

Définiti ons des constantes du  modèle 

Dans  l' exemple  du  modèle  d' amitié,  il  y  a  plusieurs  constantes que  nous  pourrions  définir 

comme suit : 

• 

z*  est  le  nombre  d'ami s  après  lequel  la  proba bili té  de  créer  d'autres  amitiés  diminue 
rap idement.  Nous appe lons cette constante  z _limite et l' initi ali sons à 5 par exemple. 

DEFINE  CONST  (z  limite,  5); 

- - - -- - - - -

69 

• 

j3 contrôle  la  précision  de  la  diminution  à  z*.  Nou s  appelons  cette  constante  b  et 
l' initialisons à 5 par exemple. 

DEFINE_CONST  (b,  5); 

•  a contrô le  la  vitesse  de  l'augmentation  de  la  chance  que  deux  individus  se  rencontrent 
s'i ls ont des amis communs.  Nous appelons cette constante a  et lui  donnons la va leur 0.5 
par exemple. 

• 

• 

DEFINE  CONST  (a,  0.5); 

po est  la  probabilité  que  deux  individu s  se  rencontrent  s' il s  n'ont  aucun  ami  commun . 
Nous appelons cette constante pO  et lui  donnons la va leur de  0.006  par exemple. 

DEFINE  CONST 

(pO,  0.006); 

k est  un  paramètre ajustable du  modèle qui  influence  le ca lcu l de la  force de l' amitié entre 
deux  contacts  qui  diminue  au  co urs  du  temps  si ceux-ci  ne  se  rencontrent  pas.  Nous 
appe lons cette constante k  et l' initialisons  à 0.01  par exemple. 

DEFINE_CONST  (k,  0 . 01); 

•  Un  paramètre qui  spéc ifi e  la  limite  minimum  de  la  force  de  l'amitié entre deux contacts. 
Sous  cette  limite,  le  lien  d'amitié  n'existe  plus.  Nous  appe lons  cette  constante 
limit_min_for_friendship et l' initi ali sons à 0.5  par exemple. 

DEFINE  CONST  (limit  mi n_for_friendship ,  0 . 5) ; 

•  Une approximation du  nombre naturel e. 

DEFINE  CONST  (e ,  2.718); 

Définitions d'attributs 

Ensuite,  touj ours en  prenant  l'exemple  du  modèle  d'amitié,  nous  pourrions  définir  les  deux 

attributs sui vants sur l'entité link: 

70 

• 

S  est  la force  de  l' amiti é entre  deux  contacts.  Au début  d' un e nouvell e amiti é (création 
d' un  nouveau  li en),  la  force  est  éga le  à  l  mais  diminue  au  cours  du  temps  si  les  deux 
ami s ne se rencontrent  pas.  Nous appelons cet attribut strength et l' initialisons à  1. 

DE FINE  ATTRIB 

(l ink,  strength,  1 ) ; 

•  nt est  l' interva ll e de temps entre deux  rencontres success ives  de deux ami s.  Au début 
d' une  amitié  (à  la  création  d' un 
lien),  la  va leur  de  cet  attribut  est  égale  à  0,  mai s 
augmente  de  1 à  chaque  pas  de  temps jusqu 'à  ce  que  les  deux  ami s  se  rencontrent  de 
nouveau 
attribut 
ti me_since_ l ast_mee ti ng et l' initiali sons à O. 

que  Dt 

rem1 s 

à  O. 

Nous 

appelons 

cet 

et 

so it 

DEFINE  ATTR I B  (l i nk,  time  since_last_meeting,  0); 

Définiti ons de fonctions 

Fin alement, le modèle d'amitié définit  les fonctions sui vantes : 

•  La fonction  g (m) ==  1- (1- po)e~am  qui  représente l'a ugmentati on attendue de la chance  qu e 
deux  indi vidus se  rencontre nt  s' il s  ont  un  ou plu sieurs ami s commun s.  Le  nombre  m,; 
est le nombre d' ami s commun s dei et)  où i et j  représentent deux ami s. 

DEFINE_FUNCTION  (l ink,  g) 

1- (1- pO)  *  e  **  (-a*  number_of  common_contacts()) ; 

• 

La  fo nction  f(z,) =  fJ(· - -*l 

e  -'  - + 1 

qui  ajuste  la probabilité pour  un  contact id e se  fa ire de 

nouveaux  ami s.  Nous  aurons  beso in  de  deux  fo nctions:  Une  fo nct ion  pour  le  premier 
nœud  du  lien i et une fo nction pour le deuxième nœud  du  li en). 

DEFINE_ FUNCTION  (link ,  fi) 

1  /(e  ** 

(b  *  (start  n od e() .degree()  -

z  limite))  +  1 ); 

DEFINE_FUNCTION  (l ink,  fj) 

1  /(e  ** 

(b  *  (end_node()  .degree()  -

z  limit e))  +  1); 

71 

•  La  fonction  pu= f (zi )f (z,)g(mu)  qui  permet  de  ca lcul er  la  probabilité  d'aj outer  un 
lien d'amitié entre  les contacts i etj.  Cette foncti on utili se  les  tro is fonctions défini es ci(cid:173)
dessus. 

DEFINE  FUNCTION  (l i nk ,  pij} 

g(}*f i

(} *f j(} ; 

•  La  fonction  su= e-kl t qui  diminue  la  force  du  lien  d' amiti é  à  chaque  pas  de  temps  où 

deux ami s ne  se  rencontrent  pas. 

DEFINE  FUNCT ION 

(l ink,  s} 

e  **  (- k  *  t i me  since  last_meeting}} ; 

La prochaine section explique comment  écrire les  règles  du  modèle à simul er dans le langage 

de modéli sation NetSim.  Nous pourrons alors fin ali ser la traduction de ce  modèle. 

3.4  Syntaxe d'écriture des règles du modèle 

3.4.1  Les actions 

Les règles  du  modèl e sont  des acti ons à exécuter sur  le  résea u, à chaque  pas  de  temps.  Ces 

règ les sont  habituellement exéc utées se lon certaines  probabilités et/ou conditi ons qui  peuvent 

dépendre de  l'état (l 'ensemble des  va leurs des  attributs)  des  ent ités  du  réseau.  Les  règles  du 

modèle sont donc  spécifiées  par le langage de modéli sation via les acti ons. 

Les  acti ons  du  langage  de  modéli sation  sont  en  somme  les  acti ons  de  manipul ation  d' un 

graphe.  Ils se  résument  à aj outer, modifi er ou supprimer des  li ens ou des  nœud s et à modifier 

les  attributs du  réseau ou du  mond e. 

Chaque action concerne  une entité  spéc ifique de  la simulati on.  Cette entité est spécifiée  par 

le  deuxième  terme  de  la  commande  d'action .  Par  exemple,  la  commande  PICK  WORLD 

concerne  1 'entité  world  tandis  que  la commande ADD _NOD ES  concerne  1 ' entité  node.  Cette 

constatati on est  importante  car  les  paramètres  des  actions  doivent  respecter  la  visibilité  des 

72 

entités  les  unes  par  rapport  aux  autres.  Le  tableau suivant  présente  la  liste  des  neuf actions 

disponibles dans le langage NetSim. 

Tablea u 3.4.1.1  Les actions d u langage NetSim 

Action.s  ll.~jl.  .,î: .•. ~lM:w. 0n  J_).éfjpiti~D ~Wi~Jfliii•Y ~,k. qp"'". 

ij;  "-'Ë  1h' _iii 

~t~i· 

PICK  WORLD 

-

( ... ) 

Cette  action  permet  de 
modifier les attributs. 

choisir  l'ent ité  world  dans  le  but  d' en 

PICK  NETWORK 

-

( ... ) 

Cette  action  permet  de  choisir  l'ent ité  network  dans  le  but  d'en 
modifier les attributs. 

PI CK  LINKS 

-

( ... ) 

Cette  action  permet de  choisir  des  liens dans  le  but  d'en  modifier 
les attributs. 

ADD  LINKS 

-

( ... ) 

CUT  LINKS 

-

( ... ) 

Cette action  permet d'aj outer des  liens. 

Cette action  permet de supprimer des  li ens. 

REW IRE  LINKS 

-

( ... ) 

Cette act ion permet de changer le deuxième nœud  de certains liens 
par un autre nœud  choisi au hasa rd . 

PI CK  NODES 

-

( ... ) 

Cette action  permet de cho isir des  noeud s dan s le but d'en modifier 
les  attributs. 

ADD  NODES 

-

( ... ) 

CUT  NODES 

-

( ... ) 

Cette action permet d'ajouter des nœuds. 

Cette action permet de  supprim er des  noeud s. 

Chaque acti on  peut contenir une séquence de  paramètres, chacun  étant  séparé  par  une virgule. 

Chaque  paramètre  peut  être  soit  une  expression  arithmétique,  so it  une  expression 

booléenne ou so it une affectation. 

•  Une expression  arithmétique est : 

•  Une fonc tion numérique 

•  Un attribut 

73 

•  Une constante 

•  Une  express ion  mathématique  construite  à  l'a ide  d' opérateurs  arithmétiques,  des 

fo ncti ons et/ou des constantes et/ou des attributs. 

•  Une express ion boo léenne est : 

•  Une fonction  booléenne 

• 

une ex press ion boo léenne construite à l' aide des  opérateurs boo léens et des fonction s 

et/o u des constantes et/ou des attributs. 

•  Une  affectati on  est une  ex pressiOn  qui  modifie  un  attribut  par  une  express1on 

arithmétique  à  1 ' aide  de  1 ' opérateur  d'affectation.  Seul s  les  attributs  peuvent  être 

modifiés (peuvent  se  situer à gauche de l' opérateur d' affectation). 

Les  paramètres  des  action s sont  donc  so it  des  va leurs numériques, so it  des  conditi ons ou so it 

des affectati ons. 

En ce qui  concern e une valeur numérique : 

•  Si elle est entre 0 et 1 inclusivement, ell e est considérée comme une probabi lité. 

•  Si elle est plus petite que 0, elle est consid érée comme éta nt éga le à 0 et donc  comme 

une probabilité. 

•  Si elle est plus grande  que  1, ell e est consid érée  comme un  nombre enti er (s' il  y a des 

déc imal es, elles seront tronquées). 

Il  est  important  de  respecter  la  visibilité  des  entités  les  unes  par  rapport  aux  autres  (voir 

fi gure 3 .2. 1 ).  Par exemple,  pour  une action concernant  1 'entité world , il  est interdit d' utili ser, 

dans  les  expressions  définissant  les  paramètres  de  l'action,  les  fo nctions  ou  les  attributs  qui 

sont définies sur les entités network, link et node car l'entité world  ne  voit qu 'e lle-même.  Par 

contre,  une action  qui  concerne  l'entité  link  peut  contenir des  paramètres  définis  à  l'a ide  de 

fonctions ou d ' attributs défini s sur  1 'entité  1 ink,  1 'entité  network  et  1 'entité world  car  1 'ent ité 

link  se voit ell e-même, voit  l' entité network et l'entité world. 

Les  paramètres  des  actions  sont  en  quelque  sorte  une  manière  de  choisir  les  entités  sur 

lesquell es  l' action  sera  effec tuée. 

Il s  peuvent  être  vus comme  une  série d'épreuves  que  les 

entités  concernées  par  l' action doivent  gagner afin  que  l' action puisse  y  être appliquée.  Ces 

épreuves sont  appliquées séquentiellement dans l'ordre où elles sont écrites  et auss itôt qu ' une 

épreuve  est  échouée,  1 ' action  n'est  pas  appliquée  sur  1 'entité  courante.  Supposons  les 

définiti ons sui vantes et examinons quelques exemples  : 

DEFINE  CONST  (pl,  0. 3) ; 
DEFINE  CONST  (nb,  3)  ; 

DEFINE  ATTRIB 
(wor ld,  flag,  0) ; 
DE FI NE  ATTRI B  (ne t work,  ok,  0)  ; 
DEFI NE  ATTRI B  (link,  for ce ,  1)  ; 

DEFINE_ FUNCTION 

(n etwork,  probl) 

number_of  l inks()  / 
1 ))  1  2); 

((number_of  nades()  *  (number_of  nades()  -

DEFINE  FUNCTI ON  (link,  prob2) 

number_of  common_contacts  ()  1  (start  node()  .degree()  + 
end_node()  .degree()); 

DEFINE_ FUNCTI ON  (node,  condl) 

degree()  >  mean_degree() ; 

Les  actions PICK 

Ce type  d' action sert à choisir des enti tés afi n d' en modifier les attributs. 

Exemple 1 

Consid érons les actions suivantes: 

PICK_WORLD(); 
PICK_NETWORK  (); 
PICK_LINKS(); 
PICK_NODES(); 
PICK  WORLD 

(flag  .- 1); 

75 

PICK_NETWORK  (pl ,  number_of_nodes()  > =  100,  ok  :=  1); 

Les  quatre  premières actions  n'exécuteront ri en, car bien qu 'e ll es  choisissent respectivement 

l'entité  world,  l'entité  network,  les  liens  (links)  et  les  nœuds  (nodes)  du  réseau,  elles  n'ont 

aucun  paramètre qui  pourrait modifier les attributs de ces entités. 

La  cinquième action, par contre,  aura pour effet de chois ir  l'entité world , sans condition, et de 

modifier sont attribut flag en lui  ass ignant  la va leur  1. 

La  dernière  action  cho isira  l'entité  network  si,  tout  d'abord,  l' épreuve  probabiliste  indiquée 

par  la constante pl est  réuss ie et si ensuite,  la condition booléenne qui  stipule que  le nombre 

de  nœuds dans  le  réseau doit  être  plus grand  ou éga l à  100  est  respectée.  Si et seulement  si 

ces  deux  tests  sont  réuss is,  l'attribut  ok  sera  modifié  par  la  va leur  1 sinon,  l'action  n' aura 

aucun effet. 

Exemple 2 

Considéron s maintenant  les act ions suivantes : 

PICK  LINKS  (probl(),  force  :=  1,  flag  :=  f l ag  +  1 ); 

PICK  LINKS  (20,  prob2(),  forc e 

. -force +  1,  color  :=  8 , 

2 ,  co l or  :=  5) ; 

PICK  NODES  (condl(),  fill  co l or  :=  6,  nb,  radius  :=  10); 

La  première action sera interprétée comme suit :  tout d'abord, chacun  des  li ens ex istants dans 

le réseau passera  le test  probabiliste donné par la fonction  probl ()  .  Ensuite,  seul  l' attribut 

force  des  liens  choisis  prendra  la  va leur  1.  Le  dernier  paramètre  qui  mod ifie  l' attribut 

flag ,  défini  sur  l'entité  world,  pourrait  agir  ici comme  un  compteur  des  liens  sé lectionnés, 

car à chaque  li en cho isi, la valeur de  flag augmente de  1.  Il  faudrait  s'assurer,  dans ce  cas, 

que  l' attribut  flag  soit  bien  initial isé  à  zéro  en  éc ri vant  l'action  PICK_WORLD  (flag  : = 

O); juste avant cette action  PICK_LINKS. 

76 

La  deuxième  action  commence  tout  d' abord  par  sélecti onner  20  liens  au  hasard  dans  le 

réseau .  Ensuite,  chacun  de  ces  20 liens devra passer le test probabiliste donné par la fonction 

prob2 ().  Supposons  que  nous  obtenons  12  liens  gagnants.  L'attribut  force  des  ces  12 

liens sera alors incrémenté de  1 et l' attribut color dev iendra éga l à 8.  Finalement, parmi  ces 

12  liens,  2 liens seront  choisis au hasard  et la va leur  de leur attribut co l or dev iendra éga le à 

S. 

La dernière action débute en sélectionnant, parmi  tous les  noeud s ex istants dans le réseau, les 

noeuds  qui  répondent  à  la  conditi on  donnée  par  la  foncti on  co nd 1 ().  Ensuite,  1 'attribut 

fi li_ col or de tous  les  nœuds choisis dev iendra  éga le  à  6.  Enfin ,  parmi  tous  les  nœud s déj à 

sélectionnés,  on en choisira  n b (=  3) au hasard  qui  verront  la va leur de  leur  attribut  radius 

être remplacée  par la valeur  1 O. 

Les acti ons ADD 

Ces  acti ons  servent  à  aj outer  des  nœud s  ou  des  1 iens  dans  le  résea u  se lon  certaines 

probabi 1 ités et/o u conditions. 

Exemple 1 

ADD_NODES(); 
ADD_LINKS (); 

Par  convention,  pour  une  acti on  ADD _ NODES ( )  sans  paramètres,  on  ajoute  un  nombre  de 

noeud s éga l  au nombre de nœuds déj à présents dans le résea u au moment de  l'exéc ution de 

l'action.  Si cette  action,  san s  paramètre,  est  exécutée  dans  un  réseau  vid e,  ell e  n'a  donc 

aucu n effet.  C' est  pourq uoi,  lors  de  l'in itia lisation  d'un  réseau,  nous  uti li sons  souvent  cette 

action  avec  un  nombre  comme  paramètre .  Par exemple, ADD_ NODES 

(100 )  ajoutera  100 

nœud s au réseau.  Considérons maintenant  les deux actions suivantes: 

ADD  NODES 
ADD  NODES  (); 

(1 00); 

Après  l'exéc ution de ces deux actions, il  y aura 200 nœud s dans le réseau. 

77 

L'action ADD _ LINKS()  ,  sans  paramètre,  aj outera tous  les  liens  potenti els  possibl es dans  le 

réseau  c'est-à-dire,  tous ceux qui  peuvent  être aj outés dans le réseau jusqu 'à ce  que le graph e 

soit complet. 

Exemple 2 

ADD  NODES  (300,  number_ of  nodes()  <  500); 
ADD  NODES  (p l ,  1 00); 
ADD  NODES 

(1 00,  pl,  border  col or  :=  4); 

La  première  action  crée  d'abord  300  nouveaux  nœuds  et,  se lon  le  deuxième  paramètre,  les 

aj outera  au réseau tant que le nombre total de nœud s dans le réseau est plus petit que 500. 

La deuxième action a comme premi er  paramètre  une proba bilité.  Premi èrement, ell e crée  un 

nombre de nouveaux nœuds éga l au nombre de nœuds  déj à présents  dans le réseau  et chac un 

de  ces  nouveaux  nœuds  doit  ensuite  passer  le  test  probabiliste  donné  par  pl.  Parmi  les 

nœuds gagnants,  ell e en sélectionne aléatoirement  100 qui  sont fi nalement aj outés au réseau. 

La  dernière  action  aj oute  d'abord  100  nouvea ux  nœud s  au  réseau.  Ensuite,  l' attribut 

border_co l or des  nœuds ayant  passé  le test probabiliste donné par pl prend  la va leur  4 et 

ces nouveaux nœuds sont finalement ajoutés au résea u. 

Exemple 3 

ADD  LI NKS 

(200); 

ADD  LINKS 

(200,  ok  :=  1); 

ADD  LINKS  (prob2(),  force  :=force+  1,  10, 

end  node()  .condl(),  force  . -force+  1); 

La  première acti on crée 200  liens potentiels et les aj oute au réseau. 

La  deuxième  action  crée  d'abord  tous  les  liens  potentiels  du  réseau.  Ensuite,  chaque  lien 

potentiel qui  passe  l'épreuve  probabiliste donnée  par la fo ncti on prob2 ()  verra son attribut 

force  augmenter  de  1.  Puis,  parmi  les  liens  précédemment  sé lectionnés,  10  liens  sont 

78 

choisis.  Ces  10  li ens  sont  ensuite  testés  sur  leur  nœud  d'arrivée  (end_node ())  se lon  la 

condition  condl  ()  et les  liens  qui  répondent à cette condition  verront  leur  force augmenter 

encore de 1. 

Les actions  CUT 

Les  actions  de  ce  type  servent  à supprimer des  nœuds  ou  des  liens du  réseau se lon certaines 

probabi 1 ités  et/  ou conditions.  Les  actions  CUT _NOD ES ()  et  CUT _LINKS ()  sans  paramètre 

suppriment respectivement tous  les  nœuds et les liens  du  réseau.  Lorsque ces  actions ont  des 

paramètres,  elles  agissent  comme 

les  actions  PICK _NOD ES ()  et  P I CK_ LINKS ()  à 

1 'exception  que  les  nœuds  ou  les  liens  gagnants  de  toutes  les  épreuves  données  par  les 

paramètres de l' action sont alors supprimés du  réseau. 

L' action  REWIRE  LINKS 

Cette action  consiste à changer le nœud  d'arrivée d' un  li en (end_no de ()) par un  autre  nœud 

du  réseau  choisi  au  hasard.  L' action  REWIRE_LINKS () ,  sa ns  paramètre,  a  pour  effet  de 

changer  le  nœud  d' arrivée  de  tous  les  liens du  réseau.  Sinon,  lorsqu ' elle  a des  paramètres, 

cette  action fonctionne  de  la  même  manière  que  l' action  CUT_LINKS  ( ... )  à  l' excepti on  que 

tous  les  liens  ayant  gagné  toutes  les  épreuves  données  par  les  paramètres  de  l' action  sont 

reconnectés au  1 ieu  d'être supprimés. 

3.4.2  Commandes d'exécution de  la  simulation 

Arrêt de la  simulation 

Le  langage  de  modélisation  NetSim  offre  aussi  une  in struction  qui  permet  de  spéc ifier  le 

moment  d'arrêt de  la simulation.  Le  nom  de cette comm ande est  SIMUL  S TOP  CONDITION 

et  elle  prend  une  expression  booléenne  comme  seul  paramètre.  Cette  expression  peut  donc 

être  form ée  d'opérateurs  bool éens  et/ou  de  constantes  et/ou  d' attributs  et/ou  de  fonctions 

pourvu que ceux-ci respectent  les  règles  de visibilité.  À cet effet, nous devons considérer  la 

79 

commande  d'arrêt  comme  si  elle  était  définie  sur  1 ' entité  network.  Ce lle-ci  peut  donc 

contenir, dan s  l' expression  de  son paramètre,  des attributs  et/ou  des  foncti ons défi nis sur  les 

entités network et world. 

La  simulation se  termine aussitôt  que  l'ex press ion bool éenne devient  vraie.  Dit  d' une autre 

façon,  la  simulation s' exécutera tant  que  la condition  n' est  pas  vraie.  Si  aucune command e 

d' arrêt  de  la  simulation  n' est  donnée,  la  simulation  ne  s'arrêtera  pas  automatiquement. 

Certaines  fonctionnalité s du  logicie l NetSim  permettent  cependant de  terminer  la simulation 

manuellement, via  l'interface graphique. 

Par exemple,  pour que la  simulation s' arrête au  pas de temps  1000, nous pourri ons écrire : 

S I MUL_ STOP_ CONDITI ON  (time_step()  >  1000); 

Pour que  la  simulation  se  termine  aussitôt  que  le degré  moyen  de  tous  les  nœuds du  résea u 

dépasse  la va leur  5, par exemp le, nous pourrions écrire  : 

SIMUL  STOP  CONDI TI ON  (mean_degree()  >  5); 

Phases d' exéc ution 

Une  phase,  dans  le  langage  NetSim,  est  un  groupe de  règles  (d ' actions)  qui  sont  exécutées 

ensemble  à  chaque  pas  de  temps. 

Il  est  poss ible  de  définir  plusieurs  phases  dan s  un e 

simul at ion.  Par  exemple,  nous  pourrions  tout  d' abord  construire  un  réseau  initi al avec  un 

ensembl e  particulier  de  règles  et,  à  un  moment  spéc ifié,  continuer  la  simul ation  avec  un 

groupe de  règ les  différentes.  Nous  pourrions auss i définir  différentes  phases  et  les  exécuter 

se lon certaines  probabilités à chaque pas de temps. 

Il  faut  donc  spécifier une condition qui  détermine  si une  phase  s'exécutera ou  non, à  un  pas 

de  temps  donné.  L' instruct ion  PHASE_ EXEC _ CONDITION  prend  une  express ion  booléenne 

comme  seul  paramètre.  La  phase  ne  s' exécutera  que  si  le  résultat  de  l' éva luat ion  de  son 

expression  booléenne est vrai. 

80 

Il  est  à  noter que  seule  la  première  phase  ne  nécessite  pas  la  spéc ification  d' une  condition 

d'exécution .  Si  la commande  PHAS E_EXE C_CONDITI ON est absente,  pour  la première phase, 

la  phase  sera exécutée sans conditi on.  Pour  la  définit ion de toutes  les  phases subséquentes, la 

condition  d'exécution  est  requise,  car  cette  commande  détermine  le  début  d' une  nouve ll e 

phase.  La  fi gure  3.4.2 .1  montre  un  fi chier  d'actions  contenant  trois  phases  d' exécution 

différentes  et  une  commande  d' arrêt  automatique  de  la  simulation.  Selon  cet  exempl e,  la 

simulation  s' arrêtera  au  pas  de  temps  100.  La  première  phase  regroupe  trois  actions  et 

s' exécute  sans condition.  La deuxième phase  contient  deux actions et s'exécute si le  pas  de 

temps  est  plus  grand  que  zéro  et  fin alement,  la  troisième  phase,  qui  définit  deux  acti ons, 

s' exécute se lon une probabi lité de 0.7. 

SIMUL_STOP _CONDITION  (time _step()  >  100) ; 

ADD_NODES (50); 
ADD_LINKS (100) ; 
REWIRE_LINKS (30) ; 

PHASE_EXEC_COND ITION  (time_step ()  > 0); 
CUT_LINKS (0 .3); 
PICK_ NODES (fill _color :=  4); 

-
--

-

PHASE_EXEC_COND ITION  (random_number()  < 0.7); 
CUT_NODES (0.4, degree()< 2); 
ADD_NODES (1 0,  number_of_nodes ()  < 500); 

Condition d'arrêt 
de la simulation 

Phase  1, sans 
condition  d'ex éc ution 

Phase 2 

Phase 3 

-

-

Figure 3.4.2.1  Phases d ' exécution et commande d ' arrêt automatique de la  simulation 

Ceci  nous amène à parl er des  deux modes  d' exécution de  ph ases  que gère NetSim  : le mode 

séquentiel et le mode para llèle. 

Selon le mode séquentiel, les  phases  s'exécutent, une après  l' autre, dans  l'ordre où  ell es sont 

écrites.  Pour qu ' une ph ase  pui sse  être exécutée,  il  fa ut  absolument  que  la  phase  précédente 

ait d' abord été exécutée.  Au premier pas de temps, la simulation tente d' exécuter la première 

phase.  Si celle-ci  n' a pas  de conditi on d' exécution, elle s' exécute jusqu ' à ce que la  condition 

d' exécution de  la  seconde  phase  soit  vraie.  Ensuite,  la  seconde  phase  s'exécute jusqu ' à  ce 

81 

que  la  conditi on d'exécution  de  la  troi sième  phase  soit vraie  et ainsi  de  suite.  Si  la  première 

phase  définit  une  condition  d'exécution,  le  programme  évalue  la  condition  et  exécute  la 

première  phase  seulement  si  le  résultat  de  l'évaluation  est vrai.  Si  la  condition  n'est j amais 

vraie,  la simul ation ne fait  rien, car elle  reste bloquée sur cette phase. 

Le  pseudo-code  suivant  décrit  l'a lgorithme  de  la  simulation  des  trois  phases  décrites  à  la 

figure 3.4.2.1  en  mode séquentiel. 

Comp teurDePhases  =  0 
pasDeTemps  =  0 

TANT  QUE  pasDeTemps  <=  1 00  FAIRE 

#  condition  d'exécu t i o n  d e 
SI  nombreAléatoire  <  0.7  et  compteurDePhases 

l a  phase  3 

2  ALORS 

compteurDe Phases  =  3 
exécuter  phase  3 

#  condition  d'exécution  de  la  phase  2 
SINON  SI  le  pasDeTemps  >  0  et  compteurDePha ses 

compt eurDe Phase s  =  2 
exécuter  phase  2 

1  ALORS 

#  exécuti on  de  l a  phase  1 
S INON  SI  compteurDePha ses 
compteurDePhase s  =  1 
exécuter  phase  1 

FIN  SI 

pasDeTemps 

pasDeTemps  +  1 

0  ALORS 

FIN  TANT  QUE 

Le  mode  d'exéc uti on en parallèle fonctionne  de  faço n tout à fait  différente.  À chaque  pas de 

temps, chaq ue  phase  s'effectue  si  le  résultat  de  1 'évaluation  de  sa  condition d'exécuti on est 

vrai.  Le  pseudo-code  suivant  décrit  l'a lgorithme de  la  simulation  des  trois phases  décrites à 

la fi gure 3.4.2. 1  en mode  parallèle. 

82 

pasDeTemps  =  0 

TANT  QUE  pasDeTemps  <=  1 00  FAIRE 

Exécut er  phase  1 

SI  pasDeTemps  >  0  ALORS 

Exécuter  phase  2 

FIN  SI 

SI  nombreAléatoire()  <  0.7  ALORS 

Exécuter  phase  3 

FIN  S I 

pasDeTemp s 

pasDeTemps  +  1 

FIN  TANT  QUE 

Le  choix  du  mode d'exécution des  phases dépend  du  ge nre de  modè le que  l' on veut  simuler. 

La  spéc ification du  mode se fait via  l'interface graphique du  logic iel NetSim au moment de la 

création d' une simul ation. 

3.4.3  Exemple d'écriture des règles  du  modèle d'amitié de Jin, Girvan et 
Newman 

Nous  allons reprendre  1 ' exemple  du  modè le d' amiti é et all ons maintenant écrire  les  règles  de 

ce modèle en  lan gage de modéli sation  NetSim. 

Une  des  règles  du  modèle  cons id ère  un  nombre  fi xe  de  noeud s.  Cette  règle  indique 

simpl ement  qu ' il  n'y aura pas d' ajout  ni  de suppress ion de nœud s au  cours de la simu lation  et 

donc, pas d' actions ADD_NODES ou CUT_NODES. 

Une  autre  règle  concerne  la  formation  de  nouveaux  li ens  d'am itié.  D' un  côté,  le  nombre 

d' amis  qu ' un  individu  peut  posséder  doit  diminuer  rapidement  lorsque  son  nombre  de 

relations  atteint  la constante z*  (degré  1 imité).  Ce  facteur  est  représenté par  la fonction j(ZJ. 

De  l'autre  côté, la probabilité que  deux  individus créent un  lien  d' amitié doit être  plus élevée 

s' il s  ont  un  ou  plusieurs  amis  communs  (transit ivité).  Ce  facteur  est  représenté  par  la 

fonction  g(m) .  L' ajout  de  liens,  dans  le  réseau,  doit  donc  se  faire  se lon  une  certaine 

,-

- - -

-----------------------------------------------, 

83 

probabilité qui  tient  compte de ces  deux facteurs et qui  est représentée  par  la fon cti on p" que 

nous avons déjà défini e.  Nous pourri ons donc définir cette règle comme suit  : 

ADD_LINKS(p ij ()) ; 

Selon cette acti on, chaque lien potentiel du  réseau doit  passer le test probabiliste donné par la 

foncti on pij () .  Chaque lien qui  passe  l'épreuve  sera aj outé au  réseau. 

Les  derni ères  règles  du  modèle  d' amiti é  concernent  la  suppression de  li ens  d' amiti é  qui  ne 

sont  pas  entretenus  au  cour  du  temps.  ( 1)  À  chaque  pas  de  temps,  deux  ami s  qui  ne  se 

rencontrent  pas  voient  la  force  de  leur  amitié diminuer exponentiellement  selon 

s,,  =e 

- k il 

Nous  avons  déjà écrit  cette  fonction  s ()  dans  les  définiti ons.  (2)  À chaque  pas  de  temps, 

deux ami s qui  se  rencontrent  de  nouveau renforcent  leur  amit ié  (force :=  1 ).  (3)  Lorsque  la 

force 

d' une 

amiti é 

dev ient 

trop 

petite 

(plus 

petite 

que 

la 

constante 

li mit_ min_ f o r_fri e nd s hip),  le lien d' amiti é di sparaît. 

Nous pourri ons écrire ces  règles comme suit  : 

(1 )  PICK_ LINKS (time  s ince  la s t  me e ting 

. -

time  s lnc e 

l as t  meet lng  + 

1,  s tre ng th  :=  s() ); 

(2)  PICK_LINKS (pij () , 

t ime _ s inc e_l ast_mee ting  . - 0 

, 

st reng t h 

. - 1 ) ; 

(3)  CUT  LI NKS  (stre ng t h  < =  limit  mln  f o r_f r i e n d s h i p ) ; 

L' action 

(1 ) 

sélecti onne 

tous 

les 

li ens  du 

réseau  pour 

ajuster 

les  attributs 

t i me_s i n ce_l a st_ mee ting  et  s t ren g th  de  chaque  lien.  En  effet,  à  chaque  pas  de 

temps,  la  force de la relation entre  chaque coupl e d'ami s diminue si ceux-c i ne se  rencontrent 

pas  de  nouveau.  L'attribut 

time_s inc e_l as t _ mee ting  comptabilise,  pour  chaque 

re lation,  le nombre  de pas de temps  qui  se  sont écoulés  depuis  la dern ière rencontre de  deux 

amt s. 

84 

L'action  (2)  modéli se  la  rencontre  de  certains  coupl es  d'amis  qui  se  conn aissent  déj à  et 

renforcent  ainsi  leur  amiti é.  Elle choisit,  parmi  tous  les  liens du  réseau, ceux qui  passent  le 

test  probabiliste  donné  par  la  fonction  pij ().  Ensuite,  pour  chaque  lien  sé lectionné,  ell e 

remet  l'attribut  time _ since_ last_meeting à 0 et  l'attribut  strength  à  1 pour  indiquer 

que cette relation a été renouvelée. 

L'action (3) sert à décrire la règ le qui  stipule qu ' une  relation d'amitié tend  à di sparaître si ell e 

n'est  pas  entretenue.  Dans  le  modèle, 

la  constante  l i  mit  min_for_fri e ndship 

représente  la 1 imite  inférieure  perm ise  sur  la force  d' une relation avant  que ce lle-ci  ne cesse 

d'ex ister.  Cette  action  supprime  donc  tous  les  liens  d' amiti é  dont  la force  (strength)  est 

plus petite ou éga le à li mi t_min_ for_friendship. 

3.5  Conclusion 

Le  langage  de  modéli sation  NetSim,  bi en  qu ' il  demande  un  certain  apprentissage,  est  un 

langage  très  simple en  comparaison au langage de programmati on usuel.  Dans cette optique, 

nous croyons qu ' il  est assez abord abl e pour des  utili sateurs variés. 

De plus, comme on a pu  le constater en traduisant  le modèle du  résea u d'ami s, la description 

d' un  modèle en  langage  NetSim  ne  demande  pas  beaucoup  de  lignes  de  command es  et ces 

commandes  se  modifient  très  fac ilement  lorsque  l'on dés ire expérimenter di vers  paramètres 

ou  diffé rentes  règles  lors  de  nos  simul ati ons.  Cec i  n'est  pas  à  nég li ger  sac hant  qu' il  fa ut 

souvent  plusieurs  essais  avant  de  trouver  les  bonnes  règ les  et  les  bonnes  va leurs  de 

paramètres  lors de la construction de modèles dynamiques. 

Bien  que  le  langage  de  modéli sati on  NetSim  ait  été  conçu  plus  particulièrement  pour  la 

modélisation de réseaux soc iaux et  du  Web, nous croyons en son potentiel de  déve loppement 

quant  à la modélisat ion d'u ne grande  va riété de  réseaux d' info rmation. 

CHAPITRE 4 

NetSim  : une plate-forme de modélisation et 

simulation de Réseaux d'information 

4. 1  Introduction 

NetSim  est  une  plate-forme  de  simu lation  capable  d' interpréter  le  langage  de  modélisation 

NetSim.  Étant  donné  la  fl ex ibilité de ce  langage,  il  est possib le de simuler fac ilement  divers 

types  de  modèles  de  réseaux d' informati on.  Dans ce  chapitre,  nous  présentons tout  d' abord 

une  vue  générale  du  fonctionn ement  de  NetSim  pour  ensuite  ex pliquer  certains  détail s 

d' implémentation que nous considérons comme les  plus importants. 

4.2  Fonctionnement général de NetSim 

NetSim  est  une  app li cation  qui  sert  à  interpréter  le  langage  de  modéli sati on  NetSim. 

Cependant, ce  logiciel n'est  pas  un  interpréteur  en so i. 

Il est  basé  sur  le  langage  Java et se 

sert  de  la  machine  virtuelle  Java  pour  interpréter  le  langage  de  modéli sati on,  préa lablement 

traduit  en  code  Java.  La  fi gure  4.2. 1  illu stre  les  grandes  étapes  du  fo nct ionnement  de 

NetSim. 

La  première  étape  de  la  constructi on  d' une  simulation  dans  NetS im  consiste  à  écrire  les 

définiti ons  et  les  règ les  du  modèle  à  simuler  en  langage  de  modéli sati on  NetSim,  comme 

nous  l' avons fa it  au chapitre 3.  Deuxièmement,  l' application véri fie  la syntaxe de  ces  règ les 

et définiti ons et, lorsqu ' il  n'y a pas  d'erreur, le programme lit  le modèle NetSim  en mémoire. 

Ensuite,  l' application  traduit  le  modèle NetSim  en  modè le Java  et  d'après  ce  modèle  Java, 

elle  écrit en  mémoire  les  classes  d'exécution  de  la  simulation.  Finalement,  ces  classes  sont 

86 

compil ées  en  in structions  (bytecodes)  compréhensibles  pour  la  machine  virtuelle  Java  de 

sorte que cell e-ci puisse  interpréter la simulation. 

Définitions 

et 

règles 

Vérification  syntaxique 

Modèle NetSim 

en mémoire 

Modèle Java 
en mémoire 

~,--------------------E~.c-ri-tu-re_d_e_c-od_e_j-av-a--------------------------f] 

Classes java en 

mémoire 

Compilation  et  interprétation 

Simulation 

Figure 4.2.1  Fonctionnement gén éral de NetSim 

La  fi gure 4.2 .2  illu stre  un  diagramme de classes  UML qui  montre  les  classes  et assoc iati ons 

principales 

nécessa ires 

à 

la 

construction 

d' une 

simul ati on. 

L'obj et 

ApplicationController est  le  premi er  à  être  créé.  C'est  en quelque  sorte  ce lui  qui 

orchestre la mi se  en œuvre de la simul ati on. 

Premièrement,  I'ApplicationController  lit  les  définiti ons  et  les  règ les  du  modèle 

écrit 

en 

langage 

de  modéli sation 

NetSim. 

Ensuite, 

la  méthode 

verifyDefinitionsSyntax ()  de  l'obj et  ApplicationController construit  le 

SyntaxVerificator  de  l'obj et  SimulationData  en  lu i  passa nt  en  paramètre  les 

définiti ons  et  les  règles  du  modèle.  Elle  appell e  ensuite  la  méthode  verifyDefs ()  sur 

l'obj et SyntaxVerif ica tor qui  vérifie si la syntaxe des défi niti ons du  modè le est va li de. 

Si  ell e  est  va lide,  le  SyntaxVerificator  crée  l' obj et  ModelDefinitions  et  y 

entrepose  les  définiti ons  NetSim  va lides.  Si  la  syntaxe  n'est  pas  respectée,  1 'attri but 

errorMsgDefs  du  SyntaxeVerificator cont iendra  un  message  d' erreur  significa tif 

généré par la  méthode verifyDefs () . 

-

87 

Ensuite, 

SI 

les 

définitions 

NetSim 

sont 

syntaxiquement 

correctes, 

I'Appli c ationContro ller appelle sa  méthode  verifyRulesSyntax ()  qui  appell e 

à  son  tour  la  méthode  v erify Rul es ()  du  SyntaxVerifi ca t o r .  La  syntaxe  des 

règles NetSim est alors  vérifiée en considérant les définitions  préalablement  entreposées dans 

le  Mo d e lDe finiti o ns.  S' il  y  a  erreur  de  syntaxe,  l' attribut  erro rM sgRul es  du 

SyntaxVerif ica tor contiendra  un  message  d'erreur sign ificatif  généré  par  la  méthode 

verifyRules ( ) . 

ApplicationController 

+loadModel() 
+ initJavaSimulationModel () 
+ ve rifyDefinitionsSyntax {) 
+veril yR ulesSyntax() 
+compileSimulation (} 
+executeSimulation () 

__ j  

1 

1 

1 

1 

1 SimulationControll~-~ 

-"-
1 

1 

11  

1 

] ApplicationDataRegiste 

/ 

1 

J Simulatio nOataRegiste~ 

1 
1 

1 

1 

1 

1 

1 
1 

1 1 

J DegreeDistributionOat~ 
...._ 
1  0 .. 1 

1 

1 

1 1 

SimulationData] 

1 

1 

1 

1 

1 

1 

\ Il 

Syn taxVerifica to r 
-errorMsgDets: String 
-errorMsgRules : String 
+verif yDefs() 
+vernyRules{) 

1 

1 

NetSimAction 

·name : Str ing 
·params : Arr aylisl 

1.. ' 

\ 

1  1  ModeiRuleSet 

1 
· execCondition  :String  1 

1 

1 

-compiledSimContextCiass  : Glass 
-simContext : Object 

1 

ModeiOefinitions 

,r  1 

1 

1 1 

SimulationModel 

1 
1 
l·simS1opCondition : String  1 

JavaSimu lationModel 

1 
l·simulationStopCondition  :String  1 

1 

1 

1 

1 

1 

1 

1'1 

JavaRuleSet 

1 
1-execCondilion : String 

1 

1 

1  1 

JavaAction 

-name : String 
-entity · String 

1 

\/ 

JavaParam 

·expression  : String 
·type : String 

Figure 4.2.2  Diagram me de classes UML des classes principales  nécessaires à  la  construction 
d'un mod èle da ns  NetSim 

88 

Les  définiti ons  NetSim  sont  entreposées  dans  le  Mode lDe f in i t  ions  sous  forme  de 

dicti onnaires  (HashMap).  Par exempl e,  les  définiti ons du  modèle d'amitié, que  nous avons 

écrites  en  langage  NetSim  au  chapitre  précédent,  ressembl erai ent  à  cec i  une  fois  en 

mémoire: 

Définiti ons des constantes  : 

z  l imite 
k 
a 
pO 
limit  min  for - friends h ip  - -- >  0.5 
b 
--- >  5.0 
e 
-- - >  2.718 

- -- >  5.0 
-- - >  0.0 1 
--- >  0 . 5 
--->  0.006 

Définiti ons des attributs  sur  l'entité lin k: 

--->  1.0 
strength 
time  s i nce  l ast_meeting  --->  0.0 

Définiti ons des fonctions sur  l'entité link : 

pij  - - - >  g()*fi()*fj() 

f i

--->  1  /(e  ** 

(b  *  (start_node().degree()- z  limite)) +  1) 

fj  --->  1  / (e  ** 

(b  *  (end_node() . degree()- z  limite))+  1) 

g  --->  1  -

(1  -pO)  *  e  **  (-a  *  number_ of  common_ contacts()) 

s  --->  e  **  (-k  *  time  slnce  last_meeting) 

Si 

la 

syntaxe 

des 

règles 

est 

valide, 

avec 

sa  méthode 

loadModel (), 

l'ApplicationController  lit en mémoire toutes  les  règles  (actions) écrites en langage 

NetSim  et  construit  le  modèle  NetSim.  Ce  modèle  est  composé  de  tro is  classes  : 

SimulationModel ,  ModelRuleSet 

et  Net SimAction. 

La 

classe 

SimulationModel  contient  un  attribut  de  type  Stri ng  qui  contient  l'expression,  en 

langage NetSim,  de  la  condition  d'arrêt  de  la simu lation  (qu i peut être  nulle).  Ell e conti ent 

89 

auss i une liste de toutes  les  ph ases du  modèle  où chacune comprend  une ou plusieurs actions 

NetSim  et  une  condition  d'exécution  (qui  peut  être  nulle  pour  la  première  phase).  C' est 

l'objet ModeRuleSet  qui  sert  à stocker les  informations  d' une  phase.  Ce  dernier  possède 

comme  attribut  l'express ion, en  langage  NetSim,  de  la  condition d'exécuti on de  la  phase  et 

une  li ste de  toutes  les  actions NetSim  contenues dans cette  phase.  Chaque act ion NetSim  est 

ensuite  décomposée en  deux  objets : une chaîne de caractère qui  est  le nom  de l'action  et un e 

li ste  de  chaînes  de  caractères  qui  contient  tous  les  paramètres  de  l' acti on  écrits  en  langage 

NetSim . 

Pour  donner  un  exempl e  plus  concret  de  la  création  du  SimulationModel ,  nous  all ons 

nous in spirer du  modèle de réseau d'ami s écrit au  chapitre précédent.  Supposons d'abord  que 

nous  voulons  que  la  simulation  s'arrête  au temps  t =  1000.  Ensuite,  nous  voulons,  dans  un 

premier temps,  construire  un  réseau initial  de 250  nœud s, de  faço n aléatoire,  en ajoutant  des 

liens jusqu 'à  ce  que  le degré  moyen  du  réseau  soit  éga l à  z_limit e.  Pour  ce  faire,  nous 

écrivons  une  première  phase,  sans spécifier de  condition  d'exécuti on, qui  ajoute 250  nœud s 

au temps t = O.  La  deuxième  phase  a comme  condition  d'exécuti on que  le  pas de temps so it 

supérieur  à  0  et  entre  donc  en  action  au  temps  t  =  1.  Cette  deuxième  phase  ne  contient 

qu ' une seule action qui  ajoute  10  liens,  au hasard , à chaq ue pas de  temps.  La  troi sième phase 

est  déc lenchée  au  moment  où  le  degré  moyen  du  réseau  est  plus  grand  que  z  limi te et 

contient  les  règ les  (actions)  du  ~ odèl e  telles  qu 'écrites  au  chapitre  précédent.  Voici  les 

actions  NetSim  qui  modélisent  ce  qui  vient  d' être  di scuté  (nous  supposons  un  mode 

d'exécution  séquentiel)  : 

#condition  d'arrêt  de  la  s imul ation 
S IMUL_STOP_CONDITI ON  (t ime_step  ()  >=  1000); 

#première  phase,  sans  condition  d'exécution 
ADD  NODES  (250); 

#deuxième  phase 
PHASE  EXEC  CONDITION  (time  step()  >  0); 

ADD_LINKS 

(1 0); ' 

#troi s ième  pha s e 
PHASE  EXEC  COND ITI ON  (mean_degree()  >  z  limite); 

90 

PICK_LINKS(time_since_last_meeting 

time_since_last_meeting  +  1 , 

strength 

s  ()  ) 

PICK_LINKS(pij  (),  time_since_last_meeting 

0 

s tre ngth  :=  1) 

CUT  LINKS  (strength  < =  limit  min  f or  fr i endship) 

ADD_LINKS(pi j  ()) 

La  figure  4.2.3  illustre les  objets en mémoire qui  contiennent  les  informat ions de ce  modè le 

écrit  en  langage de  modélisation NetSim . 

: SimulationModel 

1 
1 
simStopCondhion  = "time_step() >= 1 000"  1 
ruleSetlist 

· MoQetB~teSet  1 
execCondition  = nulle  1 
a dions 

· MoQeiA1.!teSet 

1 
1 
~ ~x~cCondition = "time_step() > 0"  1 
act1ons 

· MQdeiRIIIeSel 

1 
~ ~xec:Condition- "mean_degree() > z_timite " 
actions 

· ~e:tSim8~ioo 

1 
1 
~~ame - ''ADD_ NODES'' / 
params 

--

-

-

· ~ e1Sim8ctioo 

1 
name = "ADD_ LINKS"  1 
params 

-
'"250"  1  -

1 

"10" 

1 

-
-

· ~etSiro8ctioo 

1 
1 
~~ame= "PICK_LINKS"  1 
params ~ 

· ~etSim8ctioo 

1 
1 
~~ame= "PICK_ LINKS"  1 
params 

· ~e1Sim8ctioo 

1 
1 
~~ame = "CUT_ LINKS"  1 
pa r am s ~ 

1 

\ 

· ~e!Sim8c:!ioo 

1 
1 
~~ame= "ADD_ LINKS"  1 
params  ~ 

-

-

1 

1 
1 

1 
1 

1 
• 

·· time_since_ Jast _meeting := 
time_ since_ last_ meeting + 1" 

']:lij()" 

l "strength <= 

limit _ min_ for_ friendship'' 

"strength := s()'" 

'lime _since_ last_meeting := 0" 

1 
1 

1 
1 

1 
1 

"strength :=  , ~ 

1 
1 

1 
1 

Figure 4.2.3  Représentation en  mémoi)'e d'un modèle NetSim du  réseau d'amis 

Après  avoi r créé  le modèle NetSi m en mémoire,  I'App li cationController appelle sa 

méthode  initJavaSimulat ionModel ()  qui  traduit  toutes  les  expressions  du  modèle 

NetSim 

en 

expression 

Java  dans 

un  modèle 

composé  de 

quatre 

classes  : 

JavaS i mulationMode l ,  JavaRu l eSet,  JavaAction  et  JavaParam. 

Le 

JavaSimu l ationModel  est  simil aire  au  SimulationModel  à  l'exception  que  toutes 

les express ions NetSim  sont traduites en express ions Java. 

Toutes  les  fonctions  prédéfinies  du  langage  de  modéli sati on NetS im  sont  traduites  par des 

méthodes  Java défini es  dans la classe  Simu l ationController.  Prenons, par exemple, 

la premi ère action de la troisième phase du  modèle NetSim  : 

PHASE  #  3 

condition  exécution:  "mean_ degree()  > 

z  l imite" 

ACTION  #1 

:  "pick  links" 

Name 
Params 

: 

"time_s i nce_last_meeting  .- time  s ince  last_meeting  +  l" 
"strength  : =  s()" 

Supposons 

que 

l'obj et 

simCon trol l er 

est 

une 

in stance 

de 

la 

classe 

SimulationContro l ler. 

Traduction de la conditi on d'exécution : 

La  méthode  NetS im  «mean  degree ()  »  est  trad uite  par  un  appe l  de  la  méthode 

getMeanDegree ()  sur l'objet simController. 

simController . getMeanDegree()  >  5 . 0 

Traduction du  premier paramètre de 1 'action #  1 

L'opérateur d' affectation NetSim  «:=»d' un  attribut défi ni sur l' entité  link est trad uit par  la 

méthode: 

92 

setAtt ri bute( Link  link,  String  nomAttrib,  doubl e  va l eurAttrib). 

Pour  obtenir  la  val eur  d' un  attribut  défini  sur  l'entité  link,  il  faut  appeler,  sur  l' obj et 

simControl l er,  la  méthode : 

getAttribute  (Link  link,  Stri ng  nomAttrib) 

Ainsi , la  traduction  complète est: 

simControll er . se tAttribute(link,  "time  s ince 

l ast_meet ing", 

simContro ll er.getAttribut e( link,  "time_since_last_meeting " )  + 
1. 0) 

Traduction du  deuxième  paramètre de  l' action#  1 

On  remarque que  la  fonction  s  ()  a été  remplacée  par  son  express ion  correspondante  avant 

d'être traduite en code Java. 

s imContro ll er. se tAttribute ( link ,  " st r ength", 

(  Math.pow(2.7 18,  - 0 . 01  *  s imCont roller.g e tAttribute(link, 
" time  since  l as t_mee ting"))  ) ) 

Nous  ne détaillerons  pas  ici  la  procédure  complète de traduction  des  expressions NetSim  en 

expressions Java, mais nous en  reparlerons à la  section 4.3 .2. 

Une  fois  le  modèle  NetSim  traduit  en  Java,  se lon que  le  mode d'exécution de  la  simulati on 

choisi  est  séquentiel  ou  parallèle,  NetSim  écrit  le  code  Java  des  classes  nécessa ires  à 

l' exécution  de la  simulati on.  Nous verrons cette partie plus en déta il  à la  section 4.3.3 . 

Le  Simul ationControl l er est  l'objet qui  contrôle  la  simulation .  Il  contient  toutes  les 

méthodes qui  sont  appelées  par  les  classes  respon sables de  l' exécution  de  la simul at ion:  les 

méthodes  d' ajout  et  de  suppress ion  de  nœud s  ou  de  liens  du  réseau,  les  méthodes  de 

consultation  et de  modification  des  attributs de  toutes  les  entités du  modèle  simulé ain si  que 

des  méth odes  d' arrêt, de  mi se  en marche, d'arrêt  temporaire, et  de  reprise  de  la  si mulation. 

De  plus,  c' est  lui  qui  est  responsable  de  la  coordination  de  l' état  du  graphe  représentant  le 

93 

réseau simulé et la visualisation de l'évolution de  ce réseau à 1 'écran.  La figure 4.2.4 montre 

les classes principales qui contrôlent et implémentent la simulation. 

SimulationController 

prefuseNodesToNetSimNodes : HashMap  ----------

-netSîmNodesToPrefuseNodes : HashMap 
+initDisplayQ 

--- -- -- -- -. 
' 

1  +startSimulationO 

+stopSimulationQ 
+pauseSimulationQ 
+resumeSimulationQ 

1 

r-

1 

DlsplayController 
-graph : DefauttGraph 
-oriented : boolean 

r-1  ,:, 

edu.berkeley .guir. prefuse 

1 

]; 

1 NetworkController 
1 
1 

11 

World 

-attributes : HashMap 
-timeStep : int 

· ~ 

Network  J 
1 
l·•ttnbutes  HashMap 1 
l 
J 
1 
1 j; 

1 

Graph 

-directed  boolean 
1 

1 

1  1 

Node 

1 

1 
~attributes : HashMap  1 
1 

1 

r 
1L 

' 
- -- ----- -attrîbutes : HashMapjE-

Link 

1 

1 

l 

1 

Figure 4.2.4  Diagramme de classes UML des principales classes de contrôle de la simulation 

Dans la classe  Simulatio nCo nt ro ller, la méthode  ini tDisplay  ()  est responsable 

de 

1 'initialisation 

de 

la 

fenêtre 

de 

visualisation 

du 

réseau, 

la  méthode 

startSimulati o n  ( )  démarre la simulation et la méthode st opSimul a t ion  ()  arrête 

la simulation. 

La  classe  Simulati on Contro ll e r  contient deux  attributs  très  importants.  Le  premier 

est  une  instance  de  la  classe  NetworkContro l ler  qui  contient  et  gère  le  graphe 

représentant  le réseau  qui  évolue  dans  le  temps,  selon  les  règles  du  modèle.  Le  deuxième 

- ~- - - - - -- - -- - - - - - ,  

94 

attribut  est  une  in stance  de  la  classe  DisplayController  qut  est  responsable  de 

l' affichage du  réseau à l'écran. 

Pour  ce  qui  est  de  la  visualisation  du  réseau,  nous  avons  utili sé  la  librairie  Prefuse 

(http://www .prefuse.org/).  Cette  librairie  offre  des  classes  servant  à  la  manipul ation  d' un 

graphe  et  à  sa  visualisation  à  l' écran. 

Il  faut  construire  le  graphe  avec  les  classes 

Defaul tGraph,  De faul tNode  et  De faul tLink  fournies  dans 

le  paquetage 

edu .berkeley.guir.prefuse, afin  qu ' il  pui sse être visualisé à l'écran.  Comme nous ne voulions 

pas  que  notre  application  dépende  du  graphe  d' une  librairie  particulière,  au  cas  où  nous 

voudrions  éventuellement  utiliser  une  autre  librairie,  nous  avons  construit  notre  propre 

graphe.  La  figure  4.2.5  illustre  la  structu re  de  données  que  nous  avons  utili sée  pour 

construire notre graphe. 

Ltste des liens 

1 
t 

Dictionnaire des noeuds 

0 

1  ~ 1 
node 1  :::--t-
node2  o..  1--f-..J 

.:..i'lll<lo 

1 

1 1  1 

1 

1 

1 

1 

0 

1 

2 

3 

- · 

- · 

Liens  nants 

l iens 

tran ts 

.:J'Io<lo 

1 

1 

.. 

~1 

1 

0  1  2 

1 

_J 
1 

.:J'Io<lo  1 
1 

! 

! 

1 

ol 
11  \  1 

0\ 1  2 

Liens 

rtants 

Lions( nlmnls 

llE!nS 

ri ants 

L10ns 

\ranis 

-· 

1 

1 

3 

1 

1 

1 

1 

3 

Figure 4.2.5  Struct ure de données  représentant le  graphe de NetSim  en  mémoire 
Cette figure montre la liste de  liens et le dictionnaire des nœuds du  graphe.  On  remarque  qu ' un  même 
lien (pour  un  graphe orienté) sera présent  dans la liste des  liens sortants d' un  nœud  ainsi que  dans la 
liste  des  liens entrants d"un  autre  nœud  pui squ 'un  lien est  formé d'un  nœud  de départ  et d'un  nœud 
d'arrivée. 

95 

Le  graphe  de NetSim  est  composé  d' une  liste de  nœud s  et d' une  liste de  li ens.  La  liste  de 

noeuds est plus particul ièrement un  dictionnaire (java. utii.HashMap) dans lequel les clés sont 

les  nœuds  et  les  valeurs  correspondantes  sont  des  tabl eaux  de  longueur  deux.  La  premi ère 

case du  tabl eau contient  la  li ste  des  liens  sortants du  nœud  clé.  La  deuxième case du  tableau 

contient  la  li ste  des  liens  entrants  sur  le  nœud  clé.  Si  le  graphe  n'est  pas  dirigé,  seule  la 

première  case  du  tableau est  utilisée  et contient  une  li ste  des  liens  (sortants  ou entrants)  du 

nœud  clé. 

C'est  le  Simulat ionController qui  gère  la  correspondance  entre les  nœud s du  graphe 

de NetSim  et les  nœuds du  graphe de ?refuse et entre  les  1 iens du  graphe de NetSim  et ceux 

de ?refuse.  Pour ce faire,  il  gère  deux  attributs de type  di ctionnaire (Java.utii.HashMap) dans 

lesquels  il  conserve et  maintient  la  correspondance des  nœud s et des  li ens.  Par  exempl e, en 

cours  de ·  simulati on,  pour  ajouter  un  nœud  au  graphe,  on  appelle 

la  méthode 

addNode (Node  n)  du  SimulationController.  Ce lui-ci  se  charge  d' ajouter  le 

nœud  dans  le  graphe  NetSim,  via  le  NetworkContro ller et  puis  il  crée  le  nœud  de 

Prefuse  (De f aul tNode)  et  se  charge  de  l'aj outer  dans  le  graphe  à  visualiser  via  le 

DisplayCo ntroll e r .  Ensuite, il  ajoute  la correspondance  entre le nœud  de NetSim et le 

nœud  de  Prefuse  dans  le dictionnaire  des  nœud s  (nœud  NetSim  --->  nœud  Prefuse).  De  la 

même  mani ère,  lors de  la  suppress ion d' un  nœud ,  on appelle  la  méthode  cutLink (Node 

n)  du  SimulationControl l er qui  trouve, dans  le  dictionnaire des  nœud s,  le  nœud  de 

Prefuse  correspondant  au  nœud  à  retirer  du  graphe.  La  méthode  ret ire  ensuite  le  nœud  du 

graphe de  NetSim  via  le NetworkCo ntro ller et  supprime le nœud  du  graphe de  Prefuse 

via  le  DisplayController.  Finalement,  le  dicti onnaire  des  nœuds  est  mi s  à jour.  Le 

même principe s' applique pour les  liens. 

Lorsque  le  simu l ationController ajoute  un  nœud  ou  un  lien  au  réseau,  il  va  tout 

d' abord  chercher  les  attributs  de  ce  nœud  ou  de  ce 

lien  qui  sont  stockés  dans  le 

Mo delDef initions  sous  forme  de  dictionnaire  et  les  copie  ensuite  dans  l' attribut 

a t  tribut es du  nœud  ou  du  lien  à ajouter.  Pour consu lter la va leur d' un  attribut, au cours 

de  la  simul at ion, c' est  la méthode getAttribute  (Node  n,  String  nomAttrib) 

ou  getAttribut e  (Link  1,  String  nomAttrib )  qui  est  appelée  sur 

le 

96 

SimulationController.  Ces  méthodes  retournent  la  valeur de  l'attribut  nomAttrib 

du  nœud  n  ou  du 

lien  l.  Pour  modifier  la  valeur  d' un  attribut,  c'est  la  méthode 

setAttribute (Node  n,  String  nomAttrib,  double  nouvelleValeur) 

ou  setAttribute(Link  l,String  nomAttrib,  double  nouvelleValeur) 

qui  est  appelée.  Ces  méthodes  affectent  nouvelleValeur à  l'attribut  nomAt trib du 

nœud n  ou  du  li en  l. 

Les  entités  world  et  network  du  langage  de  modéli sation  NetSim  sont  représentées  par  les 

classes  World  et  la  classe  Network.  Chacune  de  ces  deux  classes  contient  aussi  un 

dictionnaire (nomAttrib ---> valeur)  pour gérer les  valeurs de  leurs  attributs  respectifs.  De  la 

même façon  que  pour les  nœuds et  les  liens, la consultation et la modification  de ces attributs 

se 

font 

VJa 

les  méthodes  getAttribute ( ... ) 

et  setAttribut e  ( ... ) 

du 

SimulationController. 

Nous allons maintenant voir certains aspects de  l' implémentation  de NetSim  plus en détail. 

4.3  Détail d'implémentation de NetSim 

4.3.1  Initialisation du  logiciel 

NetSim  possède  plusieurs  fichiers  de  configurat ion  qui  sont 

lus  en  mémoire 

lors  de 

l'i nitialisation  du  logiciel.  À  l'excepti on  du  fichier  XML  de  configurations  initi ales  du 

réseau  offertes  par NetSim,  les  données  de  ces fichi ers sont  représentées  en mémoire sous  la 

forme  d' un  dictionnaire (HashMap) dans  l'objet ApplicationData.  Nous  présentons  ici 

les fichiers  principaux. 

Configuration  initiale du  réseau de la  simulati on 

Avant  de  commencer une  simulation, NetSim  offre  la  possibilité à l' utili sateur de choisir une 

configuration  initiale  du  réseau  dans  le  cas  où  celui-ci  ne  voudrait  pas  que  la  sim ulation 

débute à  partir d' un  réseau  vide.  Les  différentes  configurations  initiales  offertes  sont  li stées 

97 

dan s  le  fi chier  de  configuration  XML « degreeDi stributi on.xml  ».  Lors  de  l' ouverture  du 

logiciel,  les  configurations décrites  sont  montées  en  mémoire.  La  fig ure  4.3. 1.1 montre  ce 

fi chi er. 

c?xml  v er s ion • "l.O"  encoding="UTF-8"  ? > 
c!DOCTYPE  DEGREE_DISTRIBUTIONS  SYSTEM  "DegreeDistributi o n s .dtd" > 

cDEGREE  DISTRIBUTIONS > 

<DISTRIBUTION > 

c NAME >Explicit  degree  distributi o nc/NAME > 
c iMPLEMENTATION_CLASS >ExplicitDegre eDistrib c/ IMPLEMENTATI ON_ CLASS > 
c PARAM>Maximum  Degree c/ PARAM > 
c PARAM >Degree  1  Number  of  n a de s 

t a bl ec/ PARAM > 

</DISTRIBUTION> 

<DI STRIBUTION > 

cNAME >Random  link  di s tributi o n c/ NAME > 
c iMPLEMENTATION_ CLASS >LinksPro p o rti o nDi st rib c/ IMPLEMENTATI ON_CLASS> 
c PARAM >Number  of  nodes c/ PARAM > 
c PARAM >percentage  of  links c /PARAM > 

</DISTRIBUTION > 

<DISTRIBUTION > 

c NAME >Normal  distributi o n c/ NAME > 
c iMPLEMENTATI ON_CLASS>No rmalDe greeDi s t r i bc/I MPLEMENTAT I ON_CLASS> 
c PARAM >Number  of  n o d e s c/ PARAM > 
c PARAM >Mean c/ PARAM > 
c PARAM >Standard  dev iati o n c/ PARAM> 

</ DISTRIBUTION > 

<DI STRIBUT I ON > 

law  di s t r ibuti o n c/ NAME > 

c NAME >Powe r 
c iMPLEMENTATION_CLASS> Po we rL a wDeg r eeD1 s tr1b c/ IMPLEMENTATI ON  CLASS> 
c PARAM >Number  of  nod e s c/ PARAM > 
c PARAM >i c/ PARAM > 

</DI STRIBUTION > 

c / DEGREE_ DISTRIBUTIONS > 

Figure 4.3.1.1  Fichier de configuration XML des distributions initia les  du  résea u offertes  pa r 
NetSim 

Dans  le  fichier  de  configuration  XML  chaque  configurati on  est  décrite  par  les  bali ses 

<NAME >,  < IMPLEMENTATION_CLASS>  et  < PARAM>  contenues  à  l' intérieur  de  chaq ue 

balise  <DISTRIBUTION >.  Le tab leau 4.3 .1.1 déc rit chacune de ces ba lises. 

98 

Ta blea u 4.3. 1.1  Description des ba lises d u fic hier XML de configuration des d istributions 
in itia les d u réseau offerte par NetSim 

Etiquette 

<NAM E> 

Descriptjon 

Spéc ifie  le  nom  de  la  di stribut ion.  Ce  nom est  ce lui 
qui  apparaîtra  dans  la  li ste  des  di stributi ons  offertes 
dans l' interface  graphique de NetSim . 

<IMPLEMENTATION  CLASS>  Spécifie la  classe d' imp lémentation de la di stribution. 

<PARAM> 

Spéc ifi e  le  nom des  paramètres  que  l' utili sateur  devra 
sa1s1r,  dans  1' interface  graphiqu e,  s' il  choisit  cette 
di stribution initiale. 

Dans  le fichier  de  la fi gure 4.3.1.1,  quatre distributions  initi ales  sont  défi ni es.  La  première 

di stribution est un e di stributi on explicite pour  laquell e l' utili sateur doit  tout  d' abord  spéc ifier 

le degré maximum  du  réseau à générer et  ensuite, doit  donner le nombre de nœud s, dans  le 

réseau,  pour  chaque  degré  allant  de  zéro  au  degré  max imum.  Par  exemp le,  s' il  choisit  un 

degré  maximum  égal à 4,  il  devra  ensuite spéc ifi er  le nombre de  nœud s de degré éga l à 0,  le 

nombre de  nœud s de  degré éga l à  1,  le nombre  de nœud s de  degré éga l à 2  et ainsi  de suite 

jusqu'à 4.  Le  réseau initial de la simulation sera donc  initialisé avec ces  paramètres. 

La  seconde distribution est une  di stributi on aléatoire  pour  laquelle  l' utili sateur  doit  spéc ifier 

le  nombre  de  nœud s  du  réseau  initia l  et  le  pourcentage  de  li ens  dans  le  réseau.  Cette 

configuration est construite en ajoutant d' abord  les  nœuds,  puis les  liens, de faço n aléatoire. 

La  troisième  distribution  décrite  est  une  distribution  (des  degrés)  normale  pour  laq uell e 

l' utilisateur doit fournir le nombre de nœud s, la moyenne et l' écart-type. 

La  dernière  distribution  est  une  di stribution  (des  degrés)  en  loi de  puissance  pour  laquelle 

l' utili sateur  doit  spéc ifi er  le  nom bre  de  nœud s  et  le  paramètre  ide  la  formule  de  la  loi de 

puissance p(degré)  = degré_, _ 

Le  fichier  XML  des  configurations  initiales  est  automatiquement 

lu  en  mémoire  à 

l' initi ali sati on  du  logicie l.  Le  nom  de  chaq ue  configu rati on  initiale,  spécifié  par  la  balise 

r - - - - -

1 

99 

<NAME >,  est affiché  dans  1' interface  graphique et  lorsque  1 ' uti 1 isateur  en choisit  une,  i 1 doit 

fournir  une  valeur  pour  chacun  des  paramètres  spécifiés  par  les  balises  <PARAM>.  La 

configuration choisie,  les  val eurs  des  paramètres  fournies  par  l' utili sateur  ain si que  la  classe 

d' implémentation de cette  di stributi on, donnée  par la  balise < I MPLEMENTA T ION_ CLASS>, 

sont  alors  stockées  en  mémoire  dans  l'obj et  Di st ribu t i onData.  La  fi gure  4.3 .1.2 

détaille cette classe. 

implementationCiass 

Le  nom de  la classe,  dans  le  paquetage 
org.netsim .application,  qui  impl émente 
la  construction de cette di stribution. 

Distribution Data 

-implementationCiass  : String 
-name: String 
-numOfNodes: lnteger 
-paramN ames: Arraylist 
-paramValues : Arraylist 

Na me 

Le nom de cette distributi on 

numOfN odes 

nombre  de  nœud s  de 

Le 
distribution  (s' il  y a li eu) 

cette 

paramNames 

La li ste des  noms des  paramètres 

paramYalues 

li ste  des  valeurs  des  paramètres 
La 
(dans  le  même  ordre  que  les  noms  des 
paramètres 
dans 
paramNames). 

correspondants 

Figure 4.3.1.2  Les attributs de la  classe Distribution Data 
La  classe  Distribu t i onData  contient  les 
configuration initiale du  réseau choisie par l'utilisateur. 

inform ati ons  nécessa ires  à  la  construction  de  la 

Toutes 

les 

classes 

d' implémentation  doivent 

hériter  de 

la 

classe 

abstraite 

DegreeD i stribConfig  qui  contient  la  méthode  abstraite  createDistrib () .  Les 

classes  d' implémentati on doivent  al ors  implémenter  la  méthode  createDistrib ()  dont 

le  travail  est de construire  la  configuration initi ale.  Ain si, lorsqu e vient  le moment de  générer 

le 

réseau 

initial, 

le  programme  construit  d' abord  un  obj et  du 

type  de 

la  classe 

d' imp lémentation.  Le  constructeur  de  chaque  classe  d' implémentation  doit  recevo ir  en 

argument  la  li ste  des  valeurs  des  paramètres  de  la  configuration  initiale  (paramVa lues) 

obtenue  de  l'obj et  Distribut i onData.  Le  programme  invoque  ensuite  la  méth ode 

100 

createDistrib ()  sur  cet  objet.  La  figure  4.3 .1.3  montre  un  diagramme  UML  des 

classes qui  viennent d'être discutées. 

org.netsim.applicatio n 

1 

DegreeDistribConfig 

+abstract createDist rib() 

1 

1 

1 

1 

LinksProportionDistri t 

ExplicitDegreeDistrib 

PowerLawDegreeDistrib 

NorrnaiDegreeDistrib 

+createDistrib() 

+createDistrib() 

+createDistrib() 

+createDistrib() 

Figure 4.3.1.3  Diagramme UML représentant les classes d'implémentation des configurations 
initiales du  réseau . 
Les classes  d' implémentation se  trouvent  dans  le  paquetage  org.netsim.application  et doivent  toutes 
hériter  de 
la  méthode  abstraite 
createDistrib () .  Par  conséquent,  les  classes  d' implémentation  doivent  aussi  implémenter  la 
méthode createDistrib () . 

la  classe  abstraite  DegreeDistribConfig  qui  contient 

Maintenant, en  regardant  le  fichier XML des configurations  initial es,  on  constate qu ' il  y en a 

quatre  cependant, NetSim  a  été  conçu  de  te ll e  sorte  que  l' on  puisse  aisément  en  ajo uter  de 

nouvelles.  Supposons,  par  exemple,  que  l'on  veuil le  ajo uter  le  choix  d' une  distribution 

suivant  une  loi de  Poisson.  La  Première  étape  est  d' ajouter  les  informations  nécessa ires  au 

fichier XML des configurations in itiales.  Par exemp le : 

<DI STRIBUTION > 

<NAME>Poisson  distribution </ NAME > 
<IMPLEMENTATION_CLASS>PoissonDegreeDistrib</ IMPLEMENTATION_CLASS> 
<PARAM>Number  of  nodes</PARAM > 
<PARAM>mean</PARAM> 

</ DISTRIBUTION> 

La 

seconde 

étape 

est 

de 

créer 

la 

classe 

d ' implémentation 

org .netsim .appli cation.PoissonDegreeDistrib.java  qUI  hérite  de 

la 

c l asse  DegreeD ist r ibConfig . 

Notre  classe  d' implémentation  doit  ensuite 

101 

implémenter  la  méthode  createDistrib ()  dans  laquell e  on écrit  le  code  qui  génère  la 

di stributi on  suivant  une  loi  de  Poisson.  Le  constructeur  de  notre  classe  d' impl émentation 

reçoit  en argument  une  liste des  valeurs des  paramètres  nécessa ires  à  la constructi on de cette 

configuration,  préalablement 

sa1s1es  par 

l' utili sateur  et  se 

trouvant  dans 

l'objet 

DistributionData.  Le code simplifié de la classe d' implémentation pourrait  ressembler 

à cec i : 

pub li c  class  Poi sson DegreeDi strib  extends  DegreeDistribConfig  { 

ArrayList  distribParams; 

//constructeur 
public  Poi ssonDegreeDistrib(ArrayList  params)  { 

this.d i str ibParams  =  params ; 

public  void  generateDistrib  (int  numOfNodes,  double  mean)  { 

//À  FAIRE 

//méthode  qui  genere  l a  distribution 
public  void  createDistrib  () 

try  { 

//recueillir  les  paramètres 
i nt  n umOfNodes  = 

(int)  ((Double)distribParams.get(O)). 
doubleValue(); 

doub l e  mean  =  ( (Double)d i stribParams . 

get(l)) .doubleVa l ue(); 

//gé nérer  la  distribution 
generateDistrib  (numOfNodes,  mean); 

catch  (C l assCastException  e)  { 

System. out .println ("A  parameter  is  wrong. " ); 

//Fin  classe 

Pour générer  les  distributions  des  degrés  su ivant différentes  lois  comme  la  loi  norma le et  la 

loi  de  puissance,  nous  avons  utilisé  des  méthodes  de  génération  de  nombres  provenant  de 

classes  Java  contenues  dans  les  paq uetages  cern.colt. *  ,  cern .jet. *,  cern .clhep du  proj et  Co lt 

(http:/ /dsd .1 bl .gov/-hoschek/co lt). 

Ce  projet  fo urnit  un  ensemble  de 

li brairies  Java 

------1 

102 

permettant  d'effectuer  une  grande  vari été  d'opérations  et  de  ca lcu ls  scientifiques  et 

techniques.  Nous reproduisons ic i les permi ss ions et les droits d'auteurs. 

(c)  1999  CERN 

- European  Organization  for  Nuclear  Research. 
Copyright 
Permission  to  use,  copy,  modify,  distribute  and  sell  this  software  and 
i ts  documentation  for  any  purpose  is  hereby  granted  without  fee,  provided 
that  the  above  copyright  notice  a ppear  in  all  copies  and  tha t  both  that 
copyright  notice 
supporting 
documen tation .  CERN  makes  no  representat i ons  about  the  su i tabi l ity  o f 
thi s 
i s  provided  " as  is "  wi t h o u t 
exp resse d  or  impli e d  war ran ty. 

this  permission  noti ce 

a ppear 

so ftw are 

f or  a n y  p urpose . 

I t 

a nd 

in 

lmpl émentation des opérateurs de NetSi m 

Tout  d' abord,  un  opérateur  est soit  unaire,  so it  binaire.  NetSim  n' implémente  pas,  pour  le 

moment,  d'opérateurs  terti aires. 

Ensuite, 

i 1  peut  être  un  opérateur  de  comparaison, 

arithmétique,  boo léen  ou  d' affectation.  Le  fi chi er  « operatorsDefinit ions.txt »  contient  le 

classement  de  tous  les  opérateurs  de  NetSim .  La  fi gure  4.3. 1.4  montre  ce  fi chier.  La 

première  ligne du  fi chier sert  à  définir tous les  symboles  atomiques  ut ili sés  (en combinaison 

ou non)  pour  représenter les  opérateurs symboliques  (qui  ne sont  pas  des  mots).  Les  lignes 

suivantes  classent  les opérateurs dans  leurs catégories.  Par exemple, l'opérateur « :=  »est un 

opérateur binaire d'affectation tandi s que l'opérateur « fl oor »est unaire et arithmétique. 

symbol s 
unary 
binary 
assignment 
comparison 
ar i t h metic 
bool e an 

- > 
-> 
- > 
-> 
- > 
-> 
-> 

+, -,*, / ,=, : , < , > , \ 
not , floor, - ,+ 
:=,=,> , < , >= , < =, /= ,+, -, *, /, **,mod, and , or,xo r 

=, > , <,>=,<=,/= 
+,- , * , /,** , f l oor,mod 
and,or , not , xor 

Figure 4.3.1.4  Fichier de classement des opérateurs de  NetSim 

Comme  nous  l' avons  exp liqué  à  la  section  4.2,  les  déclarations  en  langages  NetSim  sont 

d' abord  traduites  en  langage  Java  avant  d'être  compilées  et  exécutées.  Nous  avons  donc 

deux  autres  fic hiers  qu i  indiquent  la  correspondance  entre  les  opérateurs  de  NetSim  et  les 

,---

----- ~- --

103 

opérateurs  Java.  La  figure  4.3. 1.5  illustre  ces  deux  fichiers.  Le  fi chier  de  gauche  fa it 

correspondre  les  opérateurs de NetSim  avec  les  opérateurs de  Java  tandi s que ce lui  de droite 

fait  correspondre  les  opérateurs de  NetSim  avec  des  méthodes Java contenues  dans  la classe 

java.lang.Math. 

not 
and 
o r 
x or 
mod 
--

1= 

- > 
- > 
- > 
- > 
- > 
- > 
- > 
- > 

&& 
Il 

% 

! = 

** 
floor  - >  Math.floor 

- >  Math.pow 

Figure 4.3.1.5  Fichiers de correspondance des  opérateurs de  NetSim  avec les opérateurs ou  les 
méthodes Java 
Le  fichier  de  gauche  contient  les  correspondances  des  opérateurs  de  NetSim  avec  les  opérateurs  de 
Java.  Le  fi chier de droite  contient  les  correspondances  des  opérateurs  de  NetS im  avec  les  méth odes 
Java de  la classe java. lang.Math. 

Ces  fichiers serviront à  la trad uction des  express ions arithmétiques  ou boo léennes  de  NetSim 

en  express ion Java.  Cette opération est expliquée  plus en détai l à la section 4.3.2. 

Maintenant,  il  est  poss ible  d' inventer ou d'aj outer d' autres  opérate urs NetS im  en  modifiant 

ces troi s fichi ers de configuration.  Les deux exemples sui vants montrent comment faire . 

Exemple 1 

Supposons que  l' on veuille  aj outer  l' opérateur  de  comparaison «>>» qu i signifie« plus de 
deux foi s plus grand  ». 

Par exemple, x  >>  y  signifie la même chose que x  >  2  *  y. 

Dans  le fichier de  classement des opérateurs : 

104 

Vérifier  que  le  symbole  atomique  « > »  utili sé  pour  former  notre  nouvel  opérateur 

« >>» est présent  dans la première ligne.  Dans cet exemple,  il  y est, mais dans le cas 

où  il  n'y serait  pas,  il  faudrait  l'aj outer à  la fin  de  la  première  ligne du  fi chi er en  le 

séparant des autres symboles  par une virgul e. 

Ensuite,  puisque  notre  nouvel opérateur  est  un  opérateur  de  comparaison  binaire,  i 1 

faut  l' aj outer à la  fin  des lignes suivantes  en le séparant des autres opérateurs par une 

virgule: 

binary 
comparison 

- > 
- > 

: = , = , > , < , >=,<= , /= ,+, ,* , /~ **,mod,and,or,xor ,>> 

=,>,<,>=,<=,/=,>> 

Dans le fi chier de correspondance des opérateurs de NetSim  avec  les opérateurs Java: 

Aj outer  une  ligne  au  fichi er  de  gauche,  dans  la  fi gure  4.3. 1.5,  en  indiquant  la 

traducti on de l'opérateur comme cec i : 

>> 

- > 

>  2  * 

A in si,  lors  de 

la  traducti on,  l'opérateur  NetSim  « >>  »  sera  transformé  par 

l' express ion Java« 2  *  > ». 

Puisque  l' express ion Java  ne  fait  pas  appel à  une  méthode de  la classe j ava. lang. Math,  nous 

ne modifi ons pas  le fi chi er de droite de la fi gure 4.3. 1.5. 

Exemple 2: 

Supposons que l'on dés ire ajouter  la fo nction sqrt qui  calcule la rac ine carrée d' un  nombre de 

tell e sorte que l' ex press ion « sqrt  4  »  éga le 2. 

Dans le fic hier de classement des opérateurs  : 

105 

Étant  donné  que  notre  nouvel  opérateur  « sqrt »  n'est  pas  formé  de  symboles 

atomiques (c 'est un  mot), on  ne  vérifie pas  la  première  ligne du  fichier. 

Notre  nouvel opérateur est un  opérateur unaire  arithmétique.  JI  faut  donc  ajouter cet 

opérateur  à  la  fin  des  lignes  qui  comptabilisent  ces  types  d' opérateurs,  de  cette 

façon: 

unary 
arithmetic 

- > 
- > 

n o t,fl oor,-,+ , sqrt 
+,-,*,/,**,f l oor,mod, sqrt 

Dans  le  fichier  de  correspondance  des  opérateurs  de  NetSim  avec  les  méthodes  Java  de  la 

classe java.lang.Math  : 

Ajouter la  ligne  suivante : 

s qrt  - >  Math .sqr t 

Avec  ces  simples  modification des fichi ers  de  configuration  des  opérateurs, il  est maintenant 

possible  d' utiliser l' opérateur« >>» et l' opérateur « sqrt » dans la  définiti on des fonctions 

ou  des  paramètres  des  actions  lors  de  l'écriture  du  modè le  en  langage  de  modéli sation 

NetSim. 

Implémentation  des fon ctions prédéfinies sur chaque  entité 

Comme  nous  l' avons  vu  au  chapitre  3  sur  le  langage  de  modéli sation NetS im,  il  ex iste des 

fonctions  prédéfi nies  sur chaque entité.  Ces fonctions correspondent à des  méthodes  Java qui 

sont  implémentées  dan s  la  classe  Simul a tionContro ll e r.  Par  exemple,  la  foncti on 

nurnber_of_no d e s  ( ),  définie 

sur 

l'entité  network,  correspond  à 

la  méthode 

g e tNurnberOfN o des ()  de  la classe Simul a tionCo ntroller.  NetSim  possède un  tel 

fic hier 

de 

correspondance 

par 

entité. 

Par 

exemple, 

le 

fichier 

« networkFun ctions.properties  »,  illustré  à  la figure  4.3 . 1.6  contient  la  correspondance  entre 

les fo ncti ons NetSim  défini es sur l'entité network  et  les  méthodes Java qu i les  impl émentent. 

106 

number_of_nodes : getNumberOfNodes() 
number  o f  links:getNumberOfLinks() 
mean_degree:getMeanDegree() 
max_degree:getMaxDegree() 
min_degree:getMinDegree() 
di ameter:getDiameter() 

Figure 4.3.1.6  Fichier de correspondance entre les fonctions  NetSim définies su r  l'entité 
network et les méthodes Java qui les implémentent 

À l' initialisation  du  logiciel, ces  fichiers sont  lu s en  mémoire  et serviront à  la  traduction  des 

express ions NetSim  en expression Java. 

Pour  ajouter  une  nouvelle  fonction  prédéfini e  sur  une  entité  particulière,  il  suffit  donc 

d' implémenter  la  méthode Java  correspondante  dans  la  classe  S imulat ionControll er 

et d' ajouter la correspondance dans le fichier de  l' entité concerné. 

Il  existe  cependant  certaines  restrictions  aux  foncti ons  qui  peuvent  être  ajoutées  au  logiciel. 

Pour  le  moment,  i 1 n'est  pas  possible  d' implémenter  des  fonction s  avec  paramètres,  mais 

nous comptons éventuellement remédier à cette limitation. 

Les codes de couleur 

Dans  le  langage  de  modélisation NetS im , nous avons  vu  qu ' il  ex iste des attributs de couleur 

prédéfini s  sur  les  entités  node  et  link .  Ces  attributs  permettent  de  modifier  la  couleur  des 

nœud s et des  liens du  réseau en  cours de simulati on.  Il  faut  pour  cela affecter à  l' attribut de 

couleur  un  code  numérique  correspondant  à  un e  couleur  défi nie  dans  le  fichi er  de 
configuration  « co lorCodes. properti es ».  Chaque  ligne  de  ce  fichi er  contient  la  définition 

d' une  couleur en  précisant  le code  NetSim  de  la couleur,  son encodage  RVB  et  finalement, 

son nom .  Par exemple, pour définir  la  couleu r rouge, nous pouvons écrire,  dans le fichier, la 

li gne suivante : 

7:255,0,0;light  red 

107 

La  ligne précédente définit  la  couleur  rouge dont  le  code NetSim  est  7,  l'encodage  RVB  est 

2 5 5 1 

0 1  0  et  le  nom  est  l  ight  red. 

Il  faut  bien  entendu  que  les  codes  de  coul eur 

NetSim  soient  uniques, dans le fi chier. 

On  peut  ainsi aj outer toutes  les  couleurs  voulues  au fichi er de  confi guration des  couleurs et 

ces codes seront di sponibles  pour  modifi er les  attributs de couleur défini s sur  les  entités  node 

et link. 

4.3.2  Traduction du modèle NetSim en  modèle Java 

À 

l' aide  des  données  provenant  des  fi chiers  d' initiali sation  de  l'application  et  du 

Model Def i n i tions  qui  contient  les  définiti ons  du  modèle  défini es  par  l' utili sateur, 

NetSim  peut  traduire les  règles du  modèle. 

Après  que  I'Applica t ionController  ait  appelé  sa  méthode  l oadModel ()  pour 

construire 

le 

S i mulat i o n Mode l , 

il 

appell e 

sa 

méthode 

initJavaSimulationModel ()  pour  construi re  le  modèle  Java  en  mémoire.  Pour  ce 

fa ire,  il  traduit  chaque  ex press ion NetSim  du  SimulationMode l

:  la condition d'arrêt de 

la simulation, les  conditi ons d' exécution de chaque phase  et  les  règles  (actions)  faisant  parti e 

de chaque phase.  Pour chaque ex press ion, il  construit  un  obj et NetS i mExpress i on en lui 

passant en paramètre l'express ion NetSim  à traduire. 

C'est  la  méthode  netSimToJava () ,  appelée  sur  l' obj et  NetSi mExpress i o n  qui  est 

responsabl e de  la  traducti on des  express ions NetSim  en express ions Java.  Tout  d' abord , ell e 

traduit  les  fonctions,  ensuite,  les  nombres,  les  constantes,  les  attributs,  les  opérateurs  et 

fin alement, 

les  affectations  (qui  sont  auss i  des  opérateurs,  mais  qui  sont 

traitées 

diffé remment). 

Prenons,  par exempl e,  l' expression  su ivante  qui  est  ce ll e  de  la  fonct ion g  de  notre  modè le 

d'amis: 

108 

1  -

(  1  -pO  )  *  e  ** 

(  - a  *  number  o f  common_contacts () 

La  première étape de la  méthode netSimToJava ()  consiste à traduire  les fo nctions.  Pour 

ce  faire,  l'application  peut  vérifier  quelles  sont  les  fonctions  prédéfi nies  de  NetSim,  dans 

I'ApplicationDataRegister  et  quell es  sont  les  fonctions  défi ni es  par  l' utili sateur 

dans  le ModelDefinitions.  Après  la traducti on des  fonctions,  l'ex press ion ressem ble à 

cec1: 

(  1  - pO 

1  -
(link)  ) 

)  *  e  ** 

(  - a  *  simController . getNumOfCornmonNeighbours 

La  deuxième  étape  consiste  à  traduire  tous  les  nombres  en  nombres  réels  pour  év iter  les 

divi sions entières.  Après  la  traduction des nombres, l'ex pression ressemble à cec i : 

1.0  -
simControl ler.getNumOfCommonNeighbours  (link) 

(  1.0  - pO 

)  *  e  ** 

(  - a  * 

) 

La  troisième  étape  consiste à traduire  les  constantes  dont  les  va leurs peuvent être  récupérées 

dans le  ModelDefinitions.  Après  la traduction des constantes, l'express ion ressemb le à 

cec1 : 

(  1.0  - 0.0060  )  *  2.718  ** 

1.0  -
simController.getNumOfCommonNeighbours  (link) 

(  - 0.5  * 

La  quatrième  étape  consiste  à 

remplacer 

le  nom  des  attributs  par 

la  méthode 

getAttribute 

(Entité , 

nomAttrib)  du  Simulati o n Controller  qu1 

récupère  la  va leur courante de  cet  attribut  au  moment  de  l'appel.  Dans  cet  exempl e,  il  n'y  a 

aucun  attribut donc  l'ex press ion reste  inchangée. 

La  cinquième éta pe est  la traduction  des opérateurs,  à l'exception  de l' opérateur d'affectation 

qui  sera  traduit  à  l'étape  suivante.  Toutes  les  indicat ions  nécessaires  à  la  traduction  des 

opérateurs  proviennent  des  fichiers  d' initialisations  des  opérateurs  lus  en  mémoire  dans 

l' objet ApplicationDataRegister.  Après  la  traduction  des  opérateurs,  l'express ion 

ressemble à ceci ; 

~-~---~-------------------------; 

109 

(  1. 0  - 0 . 0 0 6 0  )  *  Ma t h . pow  ( 2 . 7 1 8 , 

1. 0  -
s imContro ll er . ge tNumOfCommonNeighbou rs  ( li nk)) 

- 0 . S  * 

La  sixième et dernière  étape est  la traduction  des  opérateurs d'affectati on.  Cet opérateur  est 

traduit 

par 

la 

méthode 

setAtt r ibute 

(en t i té, 

nomAttr i b , 

n ouve l leValeu r)  du  S i mul at i onControl l e r.  Dans cette express ion,  il n'y a  pas 

d'opérateur d' affectation alors l' expression reste inchangée. 

L'express ion fina le, complètement traduite en code Java,  est la sui vante : 

1. 0- (  1.0- 0.0060)  *  Mat h .pow  (2 . 7 1 8, 
s i mController.getNumOfCommonNeighbours  (link)) 

- 0.5  * 

Comme  exemple  de  traduction  de  1 ' opérateur  d' affectation  et  des  attributs,  prenons 

l' express ion suivante, auss i tirée du  modèle d' amis: 

strengt h 

: =  s  () 

Après  la traduction des fo nctions: 

strength  . -

(  e  **  ( 

- k  *  ti me  s i n ee  last _meeting  ) 

) 

Après  la traduct ion des  nombres  : 

stren gt h 

. -

(  e  **  (  - k  *  ti me  s i n ee  last _ mee ting  ) 

) 

A près  la traduct ion des constantes  : 

strength  := 

(  2 . 718  **  (  - 0.01  *  time  s1 n ce  l ast  meet ing 

Après  la traducti on des attributs : 

strength  := 
" ti me_s ince  l ast_meet i ng " ) 

)  ) 

(  2 .718  **  (  - 0.01  *  simController.getAttribute(link, 

Après  la traduction des opérateurs : 

strength  := 
( link,  " t ime_si nc e_l as t_me eting " )) 

(  Math.pow(2.718, 

) 

- 0 . 01  *  simControl le r.getAttr ibu te 

Après  la traduction de  l' affectation  : 

s imContro ll er . setAttribute  (link,  " strength", 
0.01  *  s imContro ll er.getAttr ibute  (link,  "time  s inc e 
)  ) 

110 

-

(  Mat h.p ow  (2.718, 

l ast_meeting")) 

Maintenant  que  toutes  les  expressions  sont  tradu ites  en  expression  Java,  l' application  peut 

écrire  les  classes  d' exécution  de  la  simu lation .  C'est  ce  que  nous  ex pl iquons  à  l'artic le 

suivant. 

4.3.3  Écriture des classes Java d'exécution de la simulation 

La  classe principale d' exécution de  la simu lation  est  la classe  SimulationContext.  Elle 

contient  la  méthode  run ()  dans  laquelle  se  trouve  la  boucle  principale  d'exéc ution  de  la 

simu lation .  Un  tour  de  boucle  correspond  à  un  pas  de  temps  et  à  chaque  pas  de  temps 

s'exécutent  une  ou  plusieurs  phases  selon  le  mode  d'exécution  (séquentiel  ou  parallèle) 

cho isi par  l' uti lisateur.  La  fi gure 4.3.3. 1 montre  les  classes  nécessa ires  à  l' exécution  d' une 

simulation. 

SimulationContex 

+run() 

1 

1 

Mode1Ph ase1 

...... 
/ 

1 

Mode/Phases 

+abstract simule() 

T 

1 

ModeiPhasE2 

1 

Mo de1Phasé3 

+Simule() 

+simule() 

+simule() 

Figu re 4.3.3.1  Diagramme de classes  UML  représentant les classes  d 'exécution de la simulation 

1 11 

Premièrement,  il  y  la  classe  SimulationContext dont  nous venons  de  parler.  Ensu ite, 

chaque phase  du  modèle correspond  à une classe ModelPhase# (où# représente  le numéro 

de la phase).  Chaque classe Mode lPhase# hérite de la  classe abstraite Mode lPhases qui 

conti ent  la  méthode  abstra ite  simule ().  Toutes  les  classes  ModelPhas e# doivent  donc 

implémenter cette méthode. 

~a  méthode  simul e  ()  de  chaq ue  ModelPhase#  est  responsable  de  l'exécution  des 

actions  contenues  dans  cette  Phase.  Voici,  comme  exemple,  une  représentation  générale 

simplifiée  de  la  classe  ModelPhasel qui  conti ent,  di sons,  une  action  ADD_NODES ,  une 

action  PI CK_ LINKS  ,une action ADD  LINKS et une autre action ADD _NOD ES 

public  class  ModelPhasel  extends  ModelPhases  { 

public  void  addNodesO  (SimulationCon troll er  simController) 

//code  de  la  première  action  add  nodes 

}  //end  method 

public  void  pickLinksl  (Simulation Controller  simController) 

//code  de  la  deuxième  action  pick  links 

}  //end  method 

-

public  void  addLinks2  (S imulati onContro ll er  simController) 

//code  de  la  troisième  action  add  links 

}  //end  method 

public  void  addNodes3  (SimulationController  simController) 

//code  de  la  dernière  action  add  n odes 

}  //end  method 

//implémentation  de  la  méthode  simule 
public  void  simule ()  { 

SimulationController  simController 

SimulationControll er.getContro ll er(); 

addNodesO 
pickLinksl 
addLinks2 
addNodes3 

( simControl l er) ; 
( simControl l er) ; 
( simControl ler ) ; 
( simController); 

}  // end  metho d 

//end  class 

11 2 

Dans chaque classe Model Phase#, une action est implémentée  par une méthode du  nom de 

cette  acti on qui  prend  en  paramètre  une  instance de  la  classe  Simu lationController. 

En  effet,  lors  de  la  traducti on  des  expressions  NetSim  en  Java,  toutes  les  méthodes  sont 

appelées sur cet obj et. 

Évidemment,  le  code  de  chaque  méthode  qui  implémente  une  action  particulière  sera 

di fférent  se lon  les  paramètres  que  l' utili sateur  a  fournis  à  cette  action  lors  de  l' écritu re  du 

modèle en  langage  de  modéli sati on NetSim .  Ce  sont  ces  méth odes  qui  modifient  le  graphe 

représentant  le  réseau  simulé.  Nous  ne  verrons  pas  le  code  de  ces  méthodes  en  détai 1 

cependant,  l' annexe  A  fournit  le  code  complet  des  cl asses  Simu l at i onContext  et  des 

classes  Mode l Phase#  écrites  dynamiquement  lors  de  la  constructi on  de  la  simul ation du 

modèle de résea ux d'ami s. 

Comme nous l' avons vu  à  la section 3.5.2, le code de la classe  SimulationContext sera 

différent  se lon que  le mode d 'exécuti on choisi par l' utili sateur est séquentiel ou parallèle. 

Revoyons le  pseud o-code général de  la méth ode run ()  se lon ces deux modes  (en supposant 

qu ' il  y  a  trois  phases  dans  le  modèle  et  que  la  première  phase  n'a  pas  de  conditi on 

d'exécution): 

Mode d'exécuti on séquentiel 

compteurDePhases  =  0 
pasDeTemps  =  0 
ModelPhases  p  =  null 

TANT  QUE  NOT  <condition  d'arrêt  de  l a  simulation>  FAIRE 

#  phase  3 
SI  <condit i on  d ' exécution  p h ase  3>  et  compteurDePhases 
ALORS 

compteurDePhases  =  3 
p  .- nouvelle  instance  de  la  c las se  Mode1Phase3 

2 

#  phase  2 
SINON  SI  <conditi on  d'exécution  phase  2>  et 
compteurDePh ases  =  1  ALORS 
compteurDePhases  =  2 

113 

p  .- nouvelle  instance  de  l a  c la sse  Mode1Phase2 

#  phase  1 
SINON  SI  compteurDePhases  =  0  ALORS 

compteurDePhases  =  1 
p 

. - nouvelle  instance  de  la  classe  ModelPhasel 

FIN  SI 

p. simule() 

pasDeTemps 

pasDeTemps  +  1 

FIN  TANT  QUE 

Mode d' exécution parallèle 

pasDeTemps  =  0 

TANT  QUE  NOT  <cond it ion  d'arrêt  de  la  s imulati on >  FAIRE 

:=  nouve l le  instanc e  de  l a  c l a ss e  Mode lPha se l 

p 
p. simule () 

SI  <condition  d 'exécuti o n  phase  2>  ALORS 

:=  nouv e lle  instanc e  de  l a  clas s e  Mode1Phas e2 

p 
p. simule () 

FIN  SI 

SI  <condition  d'exécution  pha s e  3>  ALORS 

:=  nouve ll e  in s tan c e  de  la  cla s s e  Mode1Phas e3 

p 
p. simule() 

FIN  SI 

pasDeTemps 

pasDeTemps  +  1 

FIN  TANT  QUE 

Dans  les  deux  cas,  si une  phase doit être exécutée,  une  instance de  la  classe Mo del Phase# 

correspondante est créée et  la méthode s imule ()est appe lée sur cette  instance. 

Les classes qui  sont écrites en mémo ire sont donc  la classe SimulationContext et toutes 

les classes ModelPhase# .  La c lasse Model Phases n'est  pas  écrite dynamiquement  étant 

donné qu 'e lle  ne change pas se lon  les modè les simulés. 

114 

Les  chaînes  de  caractères  qui  représentent  la  définition  de  chacune  de  ces  classes  sont 

entreposées dans le Mo d e lDef initions . 

4.3.4  Compilation de la  simulation 

Le  choix  de  conception  que  nous  avons  fait  d' utiliser  la  machine  virtuell e  Java  comme 

interpréteur  de  notre  langage  de  modéli sation NetSim  préa labl ement  traduit  en Java suppose 

la  compi lation  dynamique  des  classes  di scutées  à  l' artic le  précédent.  Nous  nous  sommes 

interrogés à savoir  si la compi lation  de  classes  ne prendrait  pas trop  de temps  lors de  la mi se 

en  œuvre  d' une  simulation,  mais  étant  donné  que  le  nombre  de  classes  à  compil er  est 

proportionnel  au  nombre de  phases du  modèle simul é, qui  est  rarement  plus grand  que  trois, 

la compi lation  s'exécute très rapidement. 

Lorsque  les  classes  d'exécution  de  la  simulati on ont  été écrites  en  mémoire et stockées  dans 

le Mode l Defin i tions , nous pouvon s  les  compiler.  Pour  ce  faire,  nous avo ns  utili sé  le 

paquetage 

uk. ac .dcs.stand .dcs.javacompil er 

créé 

par  Graham  Kirby 

(http://www(cid:173)

systems.cs.st-andrews.ac.uk!w iki/Dynamic _Java_ Compiler),  contenant  une  librairie  pour  la 

compilation dynamique. 

C'est  la  méthode  compil eS imulation ()  de  la  classe  ApplicationController 

qui  s'occupe de  la  compilation  des classes  d'exécut ion de  la simulation .  Il  suffit  de fournir 

au  compi lateur  dynamique  le  nom  de  la  classe  que  l' on  veut  compiler  ainsi qu ' un  tabl eau 

contenant  les  définition s  de  cette  classe  et  de  toutes  les  autres  classes  dépend antes.  Le 

compilateur  retou rne  une  instance de  la Classe  Class  de  la classe  compil ée.  Dans  notre cas, 

nous fourni ssons  le nom de  la  classe  « SimulationContext »et  un  tableau des définitions des 

classes SimulationContext et toutes  les classes ModelPha se#.  Le  code Java sui vant, 

tiré  de  la  méthode  compileSimulation ()  de  I'App lic ationController montre 

les étapes principales de  la comp ilation. 

115 

// Definitions  de  variables 
String  prefix=  SimulationCons t. SIMULATION_PACK_PREFIX; 
ModelDefinitions  mode lDe fs  =  simRegister.getModelDefinitions(); 
St ring  [)  defns  =  mode lDefs.getClas sesDefinitions( ); 
Clas s  simul ContextClass  =  null; 
Dyn amicCompi l e r  comp il er  =  nul l ; 

//c r ée r  le  compilat e ur  dy namique 
compiler  =  n ew  DynamicCompiler(); 

//compilation  d es  c l asses 
si mulContext Clas s  =  compiler. compileCl ass  (def n s,  prefix  + 

"SimulationContext"); 

//stoc k age  d e 
mod e lDef s.se tCompiledS imCont ext Cl ass(simul Cont extC l ass); 

l a  c l asse  compilée  dans 

l e  Mode lDef initi ons 

//Créa ti on  d'une  ins tanc e  de  la  classe  comp ilée  et  stockage  de  ce tt e 
// i nstance  d a ns  le  Mo delDefiniti on s 
mod e l Defs.setSimContext(simu l ContextClass.newinstance{)); 

La  variable  pre fix  contient  le  nom  du  paq uetage  dans  lequel  se  trouve 

la  classe 

Simulat ionCont ext .  Le  tableau  defns  est  un  tab leau  de  chaînes  de  caractères 

contenant 

les  définition s  des  classes  à  compiler,  préa lab lement  stockées  dan s 

le 

ModelDefi niti o ns. 

La  méthode  compi l e  ()  de  l'objet  compiler  retourne  l'obj et  simulContextCl ass 

(une  in stance  de  la  classe  Cl ass)  qui  est alors stocké dans  le Mode lDefi niti ons .  Cet 

obj et contient le code octet de  la  classe SimulationContext. 

Fin alement, en  appelant  la méthode n ewinstanc e  ()  sur  l'obj et simul ContextClass, 

nous  construi sons  une  in stance  de  la  classe  S imulati o n Context  et  cette  in stance  est 

auss i stockée dans le Model Def ini tions. 

4.3.5  Exécution de la simulation 

Comme  nous  l' avons  déjà  dit,  c'est  le  Simul a ti o nContro ll e r  qui  est  responsable  du 

contrô le  de  l'exécuti on  de  la  si mulation .  Sa  méthode  startSimul ation ()  démarre  la 

116 

simul ation 

en 

invoquant 

la  méthode 

run () 

sur 

l' instance 

de 

la 

classe 

Simu l ationContext  que  nous  avons  préalablement  compil ée  et  stockée  dans 

le 

ModelDefinitions. 

Le  SimulationControl l er  contient  aussi  la  méthode  st o pSimulation ()  qu1 

termine  la  simu lation,  la méthode pauseSimulation ()  qui  permet  l'arrêt tempora ire de 

la  simul ation  ainsi  que  la  méthode  resumeSimulation ()  qui  permet  la  reprise  de 

l'exécution  de  la  simulati on après  un  arrêt  temporaire.  La  classe  SimulationContext 

est en  fait une tâche (thread) qui  peut donc être suspendue et redémarrée  à vo lonté. 

4.3.6  Données de  réseaux externes 

À la section 4.3.1,  nous avons  introduit  la notion de configuration  initi ale en ex pliquant  que 

NetSim  offre  différentes  façons  de  créer  le  réseau  in itia l de  la  simul ati on  se lon  différen tes 

di stributi ons.  Cette  fonctionna lité  permet  à  l' utili sateur  de  ne  pas  amorcer sa  si mulation  à 

partir d'un  réseau  vide. 

Cependant,  il  peut  arriver  que  l' on  possède  déjà  des  données  de  réseau  que  l' on  voudrait 

utili ser pour construire  le réseau qui  servira de point  de départ  à notre simulati on.  Dans cette 

optique,  nous avons  créé  un  format  de fichier  XML  permettant  la  représentation de données 

de résea ux  externes  et que  NetSim  peut  alors  interpréter pour créer  le réseau initial. 

Il  suffit 

d'écrire  nos données sous ce format et de charger le fichier XML dans NetSim. 

Aussi , NetSim  permet d'enregistrer dans ce  format  les  réseaux générés  par simulat ion.  Ce la 

peut être utile dans le cas où nous voudrions récupérer nos  données dans  le but de  les  utili ser 

dans un  autre logiciel, d'analyse  par exemple ou  simp lement pour les  réutiliser comme réseau 

initial dans une autre simu lation de NetSim. 

Le  format XML de NetSi m (NetS im XML) est divisé en  deux  parties.  La  première, délimitée 

par  la  bali se  <ENTITY  ATTR I BUTE >  sert  à définir  le  nom des  attributs des  nœuds  et  des 

liens.  S' il  n'y a pas d'attributs, cette section  reste vide.  La  seconde  partie,  délimitée  par  la 

117 

balise  <GRAPH >  sert  à décrire tous  les nœud s et  les  liens du graphe  avec les  valeurs de leurs 

attributs respectifs s' i 1 y a 1 ieu.  La  figure 4.3 .6.1 montre un  exemple d'un  tel fichier. 

c?xml  version= " l.O"  encoding= "UTF-8 "  ?> 
c!DOCTYPE  NETWORK  SYSTEM  "externalData . dtd " > 

c NETWORK > 

cENTITY  ATTRIBUTES> 

c ENTITY  ATTRIBUTES> 

c NODE  ATTRIB> 

cNAME >attribl c /NAME> 
cNAME >attrib2c/NAME> 

c/NODE_ATTRIB> 

c LINK  ATTRIB> 

cNAME>attrib3c/NAME> 
cNAME>attrib4c/NAME> 

c /LINK_ATTRIB> 

c/ ENTITY_ATTRIBUTES > 

c GRAPH  oriented="true" > 

cNODES > 

' 

c NODE  id= 11 n1 11 
c NODE  id= 11 n2 1
<NODE  id= 11 n3 11 
c NODE  id="n4 11 
c NODE  id= 11 n5 '' 
e N ODE 
id== •• n6 '' 
c NODE  id= 11 n7 11 
cNODE 
id;:: 11 fl8 11 
<NODE  id= 11 n9 11 
cNODE  id= 11 n10 11 
cNODE 
id=="nll 11 
cNODE  id="n12" 
eN ODE  id="nl3 11 

label= "Banane "  attrib_values= " 2.3  3"  /> 

label= "Maison "  attrib_values="0.345  3" 
/ > 
label="Citron"  attrib_values="2.5  3.2"  / > 
label="Café "  attrib_values="2.6  3.5"  / > 
label="Taxi"  attrib_values="O  0" 
label= "Voiture "  attrib  values= " 2.6  3.5"  /> 
label="Soleil"  attrib_values="2.6  3.5"  / > 
label="Visage "  attrib_values="2.6  3.5"  /> 
label="Beau"  attrib_values="2.5  3.2"  / > 
label= "Travail "  attrib  values= " O  0 "  /> 
labe l = "École"  attrib_va-lues="2.5  3.2"  / > 
label= "Moustache"  attrib  values= " 2 . 5  3.2"  /> 
label="Lunette "  attrib  values= " 2.5  3.2"  / > 

/ > 

c/NODES > 

cLINKS> 

node2= "nl2"  attrib_values="O  1"/ > 
c LINK  nodel="nl" 
c LINK  nodel="n3 " 
node2="n7 "  attrib  values= "2  0 "  /> 
c LINK  nodel= "n6" 
node2="n7"  attrib  values="3  l"  / > 
c LINK  nodel="n12"  node2="n3  attrib  values="O  2"  /> 
node2="n4  attrib  values="l  3 "  /> 
c LINK  nodel="nl" 
/ > 
node2="n3  attrib  values="O  3" 
c LINK  node l ="nB " 
c LINK  nodel= "n9 " 
node2= "n6  attrib  values= " 2  0" 
/ > 
c LINK  nodel= "n6" 
node2="n2  attrib  values="O  l"  / > 
c LINK  nodel="n9" 
node2="nl  attrib  values="O  l "  /> 
c LINK  n o del="n12"  node2="n6 
/ > 
c LINK  nodel= "nl2"  node2="n5  attrib  values= " O  0 "  /> 
c LINK  nodel="n4" 

node2="n12"  attrib_values="2  0" 

a ttrib  values="O  2" 

/ > 

c/ LINKS> 

c/ GRAPH > 

c/NETWORK > 

Figure 4.3.6.1  Données de réseaux externes dans le  format NetSimXML 

~~-~-----------------

118 

On  remarque que  le  format NetSimXML permet aussi de  spécifier une étiquette  pour chaque 

nœud  du  graphe,  mais  ce lle-ci  n'est  pas  obli gatoire.  Si  on  mentionne  une  étiquette  dan s  la 

définition  des  noeud s,  ell es  seront  affichées  dans  chaque  nœud  lors  de  la  visuali sation  du 

graphe. 

Dans  1 'exemple  de  la  fi gure 4.3 .6. 1, on a défini  deux  attributs  pour  les  nœuds (at t  ribl et 

attrib2) ain si que deux  attributs  pour  les  li ens (attrib3 et attrib4).  Les  valeurs  de 

ces  attributs  sont  spéc ifi ées  dans  la  définiti on de chaque  nœud  et  de  chaque  lien.  Ainsi ,  la 

ligne 

<NODE  id="nl" 

labe l="Banane"  attrib_values =" 2 . 3  3"  /> 

définit un  nœud  dont  le  numéro unique d' identification  est « n 1 »,  l'étiquette est « Banane », 

la  valeur de l' attribut  attribl est 2.3  et la valeur de  l'attribut  attrib2  est 3, les  valeurs 

de  chaque  attribut  étant  séparées  par  un  espace. 

Il  est  important  que  les  numéros 

d' identificati on des  nœud s soient tous uniques  puisqu ' il s serviront à identifier les deux  nœud s 

qui  composent  un  lien dans la définition des  li ens.  Ainsi , la  ligne 

<LINK  nodel= "nl"  node2="nl2 "  attrib_ values ="O  1" /> 

défi nit  un  1 ien dont  le  premier  nœud  est celui  qui  a  le  numéro  d' id entification « n 1 » et dont 

le deuxième nœud  est ce lui  qui  a  le  numéro d' identification « n 12 ».  La  va leur de  l'attribut 

attrib3  est  éga le  à  0  et  la  valeur  de  l' attribut  attr ib4  est  égale  à  1,  les  va leurs  de 

chaque attribut étant séparées par un  espace. 

La  figure  4.3.6.2  montre  le  graphe  obtenu  une  fois  que  le  fichier  NetSimXML  de  la  figure 

4.3.6.1  a été chargé dans NetSim comme configuration de départ. 

11 9 

Taxi 

Maison J-- - - - - --i 

Figure 4.3.6.2  Visualisation de donn ées de  résea u externes dans NetSim 

Nous pouvons maintenant  exécuter une simul ati on à partir de ce  résea u initial.  Cependant, si 

des  nœud s  sont  ajoutés  en  cours  de  simul ation,  ceux-ci  sont  anonymes  et  ne  seront 

év id em ment  pas étiquetés. 

Même si NetSim  a été conçu spéc ialement  pour simuler des  modèles  dynamiques de  réseaux 

d'information ,  on  peut  auss i  1 ' utiliser  pour  la  visualisation  statique  de  données  de  réseaux 

représentées sous  le format NetSimXml.  On charge  d' abord  ce  fichi er dans NetSim, on crée 

ensuite  une  simulat ion  vide  (sans  aucune  définition  ni  règle)  et  on  choisit  le  fichier 

NetSimXML  comme  configuration  de  départ  de  notre  simu lation.  Lors de  l' initialisation de 

la simu lation, le réseau initial  est affiché. 

-

-

-

-

- - - - - - - - - - ,  

120 

Éventuellement,  nous  voudrions  rendre  NetSim  capab le  de  lire  d' autres  formats  de 

représentation  de  données  de  réseaux.  Par  exemple,  il  serait  utile  de  pouvoir  fournir,  en 

format  texte  ou  Exce l, des  données de réseaux qui  représentent  simplement  les  nœud s et  les 

liens  sous forme  de matrice.  Plusieurs applications d' analyse ou de  visua li sation de  réseaux, 

comme Pajek  ou  KrackPi ot, fournissent  leur  propre  format  de  données,  mais  il  ex iste  aussi 

des  formats connus et assez génériques, dont GraphXML, qu ' il  serait  intéressant  d' intégrer à 

NetSim. 

4.4  Conclusion 

Dans  ce  chap itre,  nous  avons  exp liqué  le  fonctionnement  général  de  NetSim  pour  ensuite 

détailler  certains  aspects  de  son  implémentati on.  Nous  avons  pointé,  ici  et  là,  certaines 

limitation s  actue lles  quant  à  son  utili sation,  mai s avons  tenté  de  montrer  que  sa  conception 

est  assez  souple  pour  permettre,  éventuell ement,  l' extension  ou  l' amé li oration  de  ses 

fonct ionn ai ités. 

Le  chapitre sui vant  propose  deux  exempl es  de simul ations de modèles  de  réseaux tirés  de  la 

littérature qui  nous ont permi s de tester notre pl ate-forme. 

CHAPITRE  5 

Résultats de simulation avec NetSim 

5. 1  Introduction 

Lorsque nous étudions certains  phénomènes  par modélisation,  la simul ation de  nos  modèles 

est une étape essenti elle.  En effet, ce ll e-ci permet de tester nos  hypothèses  sous diffé rentes 

contraintes.  Les  modèles  incluent  souvent  des  paramètres  ajustables  qu ' on  doit  tester avec 

différentes  va leurs avant  de trouver  la  va leur  ou l' interva ll e  de  va leurs qui  produit  les  effets 

recherchés.  De  plus,  en jouant  avec  ces  paramètres, on  peut  découvrir  des  comportements 

qui  n'étaient  pas  prévus  à  l' origin e.  Les  simulations  permettent  ai nsi  d'ex pli citer  nos 

modèles. 

Dans  ce  chapitre,  nous exposons  nos  résultats  de  simul ati on avec NetSim  de deux  modèles 

tirés  de la littérature : le modèle du  réseau d'ami s que nous conn aissons déj à et un  modèle de 

l' évo lution de  la  structure du  Web.  Nous comparons ensuite  nos  résultats  avec  les  résultats 

de simulation obtenus par les auteurs de chaque modèle. 

5.2  Simulation d'un modèle de l'évolution d'un réseau d'amis 

5.2.1  Le  modèle théorique 

Nous  allons  reprendre  ici  le  modèle  de  l' évolution  du  réseau  d' ami s  de  (Jin,  Girvan  et 

Newman,  2001 )  que  nous  avons  déjà  écrit  au  chapitre  3  et  allons  le  simuler  à  l' aide  de 

NetS im . 

Nous en rappe lons brièvement ici  les principales  règ les  : 

--- ----

--- -

- - - - -------------~ 

122 

1.  Un  nombre  fixe  de  sommets:  Considération  d' une  popul at ion  fermée  d' une 

grandeur fixe . 

2.  Un degré limité:  Lorsqu ' un  individu  atteint z* contacts, la proba bilité que celui(cid:173)

ci  déve loppe  de  nouvelles amitiés  diminue radica lement.  Ce  mécani sme est mis 

en  place  pour  modéli ser  le fait  qu 'entretenir  une amitié demande des  ressources 

et que, pour cette rai son, un  individu  ne peut  pas  avoi r un  nom bre illimité d'ami s. 

3.  Transitivité :  La  probabilité  que  deux  indi vidu s  devienn ent  am1 s  doit  être 

significativement plus élevée s' ils ont  un  ou plusieurs amis commun s. 

La  probabilité  par  unité  de  temps  p,,  que  deux  personnes  donn ées,  i  et  j ,  se 

rencontre dépend  de deux facteurs : 

1.  Le nombre d'amis  z; et  z, que i elj possèdent déj à. 

11.  Le nombre  mu d'ami s commun s de i elj. 

Ces facteurs sont  représentés  par  les fonctionsfet g : 

La  fonction f doit être assez grande et  assez constante  pour de  petits z,  mais doit 
diminuer  considérab lement  lorsque  z  approche  la  va leur  de  transiti on  z*  La 

fonction de  Fermi , qui  est un e sigmoïde, présente ces caractéri stiques et c'est ell e 

que les auteurs ont utili sée pour leur modè le. 

Où  le paramètre  f3  contrôle  la  précis ion de  la diminution  à z*. 

- -- - - - -

123 

La  foncti on  g(m)  représente  l' augmentation  attendue  de  la  chance  que  deux 

individus se rencontrent  s' il s ont  un  ou plu sieurs amis  communs. 

g (m) = 1- (1- p o)e-am 

Où  p o  représente  la  probabilité  d' une  rencontre  entre  deux  personnes  qui 

n' ont  pas  d'amis  communs  et  où  le  paramètre  a  contrôle  la  vitesse  à 

laquelle  g (m;;) augmente. 

4.  Bris  de  liens  d'amitié :  Lorsque  deux  indi vidus  sont  am1 s,  ceux-c i  doivent  se 

rencontrer  régulièrement  pour  mainteni r  leur  amiti é.  Si  tel  n' est  pas  le  cas,  il y  a 

cessation de cette amitié.  Pour  représenter la fo rce d' une amitié, chaque  1 ien d' amitié 

possède  un  paramètre  s  dont  la  va leur  est  plu s  ou  moins  élevée  selon  que  les 

rencontres  sont  plus ou moin s fréquentes.  Chaque fo is que deux ami s se rencontrent, 

la fo rce  s;;  est ajustée à la va leur  1.  Pui s, à mesure que  le temps passe et qu ' il s ne se 

rencontrent  pas  de nouveau, la force de  leur amiti é diminue ex ponentiell ement  se lon : 

s,,  = e 

- k  lt 

Où Dt représente l' interva lle de temps depuis la derni ère rencontre  de i etj  et où k est 

un  paramètre  ajustabl e du  modèle. 

Si i etj se  rencontre une autre fo is,  s,, est remi s à  1. 

Il  est ensui te  poss ible de poser une  limite minimale à  s,, permetta nt  de considérer une 

amitié  active  et  ne  tenir  compte  que  de  ces  li ens  lors  des  ca lcul s,  par  exemple,  du 

nombre d' amis communs et du  coeffi cient  de transiti vité. 

124 

5.2.2  Le  modèle traduit en  langage NetSim 

Nous avon s déjà écrit ce modèle en  langage NetSim au  chap itre précédent  : 

Les définitions du  modèle en  langage NetSim 

( z_limite,  5); 
(b,  5) ; 

DEFINE  CONST 
DEFINE  CONST 
DEFINE  CONST  (a ,  0.5); 
DEFINE  CONST  (pO ,  0.006); 
DEFINE  CONST  (k,  0.01); 
DEFINE  CONST 
DEFINE  CONST  (e,  2.718); 

(limit_min_for_friendship,  0.5); 

DEFINE  ATTRIB  (link ,  strength,  1); 
DEFINE  ATTRIB  (l ink,  time  s ince  l ast_meeting,  0); 

DEFINE  FUNCTI ON  (l ink,  g) 
1 - (1- pO )  *  e  **  {-a*  number_of  common_contacts()) ; 

DEFINE  FUNCTION  (link,  fi) 
1  /(e  ** 

(b  *  (sta rt_node()  .degree()  - z  limi te))  +  1); 

DEFINE  FUNCTION  (link,  fj) 
1  /  (e  ** 

(b  *  (e nd_node () . degree()  - z  limit e))  +  1); 

DEFINE  FUNCTION  (link,  pij) 
g() *fi()*fj( ); 
DEFINE  FUNCTION 
e  **  {-k  *  time_since_last_meeting); 

(link ,  s) 

Les  règ les du  modè le en langage NetSim 

SIMUL_STOP_CONDITION  (time_step  ()  >=  1000); 

PICK_L I NKS(time  since  l ast_meeting  __  time_since_last_meeting  +  1 , 

strength 

:=  s()); 

PICK  LINKS(pij  (),  time  since  last  meeting  __  0 

, 

strength  :=  1); 

CUT  LINKS  (strength  <=  limit  min  for_friendship); 

ADD_LINKS(pij  ()); 

Maintenant que  nous avons traduit  le modèle en  langage NetS im, nous  pouvons  le simuler. 

125 

5.2.3  Résultats de simulation 

Pour  construire  le  réseau  initial  de  notre  simulation,  nous  avons  fait  comme  les  auteurs  du 

modèle.  Nous  avons  commencé  avec  250  nœuds  et,  en  simulant  le  modèle,  nous  avons 

ajouté  des  liens  au  réseau jusqu'à  ce  que  le  degré  moyen  des  nœuds  du  réseau  atteigne  la 

valeur de la constante  z  li mi te.  Pour ce faire, nous avons mis la valeur de la constante k  à 

0 afin d'empêcher la suppression de  liens  durant cette étape.  La figure  5.2.3.1 montre  l'état 

du réseau à la fin de cette étape. 

Figure 5.2.3.1  Réseau initial de la simulation du réseau d'amis à t = 0 (625 liens) 

Une  fois  notre  configuration  initiale  construite,  nous  avons  amorcé  la  simulation  de  notre 

modèle en  spécifiant des  valeurs de  paramètres  très  similaires  à ceux  utilisés par les  auteurs 

du modèle.  Certains paramètres n'étaient pas spécifiés explicitement dans 1 'article alors nous 

avons  expérimenté  avec  différentes  valeurs  pour  trouver  celles  qui  semblaient  donner  de 

meilleurs  résultats.  Le  tableau  5 .2.3 .1 montre  la  comparaison  des  valeurs  des  paramètres 

utilisées  par les  auteurs  du modèle  avec  les  valeurs  des  constantes  utilisées pour exécuter la 

simulation  dans  NetSim.  On  remarque  qu 'à l'exception  des  valeurs  non  spécifiées  par  les 

auteurs, les valeurs utilisées pour la simulation  avec NetSim sont toutes identiques sauf dans 

le  cas  de la force  minimale limite  d'une amitié  (limit_min_for_friendship).  En  effet, 

126 

nous  avons  réalisé  qu ' en  augmentant  légèrement  cette  valeur,  nous  obtenions  de  mei lleurs 

résu ltats  quant  à  la  démonstration  de  l'effet  de  transitivité  et  de  la  formation  de  petites 

communautés  à  l' intérieur  du  réseau  qui  sont  des  propriétés  de  plusieurs  types  de  réseaux 

soc 1aux. 

Tableau 5.2.3.1  Comparaison des valeurs des  paramètres utilisées dans la simulation de NetSim 
avec celles utilisées dan s la sim ulation des a uteurs du  modèle 

k 

fJ 

z* 

Po 

a 

k 

b 

z  limite 

pO 

a 

0.0 1 

5 

5 

Non spéc ifi ée 
exactement  mais 
dite très  petite 

Non  spéc ifié 

Force minimale 
limite d' une 
amiti é 

Limit_ min _for _fr iend ship  0.3 

0.01 

5 

5 

0.006 

0.5 

0.5 

La  figure  5.2.3.2  montre  l'évo lution du  réseau à différents  moments dans  le temps.  Comm e 

l'expliquent  les  auteurs  du  modèle,  on  peut  observer  la  formation  de  commun autés  bien 

déterminées  à  l' intérieur  du  réseau.  La  plupart  des  groupements  observés  sont  restés  reliés 

entre eux, mai s certa ins se  sont  déconnectés de  la composante principale du  graphe, au cours 

de  la  simul ation.  Cette  propriété  (qui  n' était  pas,  à  1 'origine,  une  des  caractérist iques  du 

modèle)  est  évidemment  observab le  dans  le  mond e  rée l.  L' émergence  de  ce  phénomène 

s' explique  par  le fait  que  si, durant  l' évo luti on du  résea u, une région du  graphe commence  à 

montrer une  plus  grande  densité  de  connexions  que  la  moyenne  alors, dans cette  région, on 

observe  conséq uemment  un  nombre  plus  élevé  de  paires  de  sommets  qui  ont  des  liens 

communs.  Ainsi,  de  nouvell es  amitiés  vont  préférab lement  se  former  entre  ces  paires  de 

- - -- - - - - - -- - -- - - - - - - - -- - -- - -- -- - -- - -- - - - - - - - - - - - - -- - - -

127 

sommets  en fa vorisant, à  leur  tour,  la  densité  de  connex ions  à  l' intérieur  de  cette  région et 

ain si  de  suite. 

Il  apparaît  donc  qu ' une  toute  petite  fluctuati on  init ial e  dans  la  densité  du 

réseau peut provoquer l'évolution de communautés cohésives à l' intérieur du  système. 

De plus,  on remarque que ces  communautés  sembl ent  autosuffi santes.  En effet, à  l' intérieur 

de  ce lles-ci,  plusieurs  paires  d' individus  ont  nécessa irement  des  amis  commun s  ce  qu1 

produ it  la  formation  de  plusieurs  « triangles»  d' amiti é.  Un  tri angle  est  une  structure 

autosuffi sante  dans  ce  modèle.  Chaque  paire  de  sommets,  dans  un  triangle,  a  un  vo isin 

commun  qui  est  le troisième sommet du  tri angle.  Donc,  parce  qu ' il s ont  un  ami  commun  et 

qu ' ainsi la rencontre entre chaque paire de sommets a plus de chances de se  produire souvent, 

la  force  de  connexion  entre  ces  paires  de  sommets  est  continuell ement  renouve lée.  Ce la 

signifie qu 'à l' intérieur d' une communauté,  les  liens perdurent  plus  longtemps,  en moyenne, 

que  ceux  qui  relient  les  communautés  entre  elles.  Ce  sont  donc  les  ami s  commun s  qui 

forment et maintienn ent  les communautés. 

128 

Etat du réseau à t =  200 (619 liens) 

Etat du réseau à t = 400 (624 liens) 

Etat du réseau à t = 700 (622 liens) 

Etat du réseau à t = 1000 (626 liens) 

Figure 5.2.3.2  Évolution du réseau d'amis au cours de la simulation dans NetSim 

Nous  avons  ensuite  calculé  les  coefficients  de  transitivité  à  chacune  des  étapes  de  la 

simulation  montrées  à  la  figure  5.2.3.1  (réseau  initial)  et  à  la  figure  5.2.3.2  (réseaux 
subséquents) à l'aide  du logiciel d'analyse de réseaux sociaux« Ucinet » (Borgatti, Everett et 

Freemanm, 2002).  Le coefficient de transitivité est la mesure de la densité des triangles dans 

le réseau.  C'est le rapport entre le nombre de structures triangulaires (triangles fermés)  et le 

129 

nombre  de  tripl ets  (triangles  ouverts  et  ferm és)  dans  le  réseau.  Le  tabl eau  suivant  montre 

1 'évo lution  du  coefficient de transitivité au  cours de  la simul ation. 

Tableau 5.2.3.2  Évolution du coefficient de transitivité au cours de la sim ulation du  réseau 
d 'am is 

Réseau in itial à t = 0 

Réseau à t = 200 

Réseau à t = 400 

Réseau à t = 700 

Réseau à t = 1 000 

0.309 

0.440 

0.473 

0.516 

0.544 

Les  auteurs  du  modèle obtiennent  un  coeffic ient  de  transiti vité  éga le à 0.45.  Nous  obtenons 
donc  des  résultats  similaires  si  l'on considère  notre simulation entre  les  temps  t =  200  et  t = 
400.  Comme  il s  le  fo nt  remarq uer,  ce  coefficient  de  transitivité  est  très  élevé  si  on  le 

compare  à un  graphe aléatoire de  même  dimension et  possédant  environ le  même  nombre de 
liens qui  présente un  coeffic ient  de transitivité tournant autour  de  z * 1 N  = 5 1 250 =  0.02.  N 
étant  le  nombre  (constant)  de  nœuds  dans  le  réseau  et  z*,  le  nombre  d'amis  (liens)  après 

leq uel  la  poss ibilité  de  créer  d'autres  amitiés  diminue  radical ement.  Ce  modèle  montre 

clairement  la propriété de transitivité propre aux réseaux soc iaux. 

De  plus, si l'on  observe  le tableau 5.2.3.2, on remarque  que  le coeffic ient  de  tran sitivité tend 

à  augmenter  avec  le  temps.  Nous  pourrions  donc  fai re  l' hypothèse  que  la  formation  de 

communautés  se  poursuit et s' intensifi e avec  le tem ps.  On pourrait, éventuell ement, observer 

l' évo lution de  la  structure de  ce  réseau  sur  une  ~lu s grande  période  de  temps  pour  éva luer 

cette hypothèse. 

Il  nous  apparaît  donc  que  notre  simulation du  modèle  avec  NetSim  produit des  résultats  très 

similaires aux simulations effectuées  par les auteurs du  modèl e. 

130 

5.3  Simulation d'un modèle de l'évolution du  Web 

5.3.1  Le  modèle théorique 

Comme modèle de  l'évo lution du  Web, nous avons choisi de simuler  le  modèle  proposé  par 

(Albert  et  Barabasi,  2000)  qui  est  une  extension  du  modèle  indépendant  de  l' échelle 

précédemment  introduit  par (Barabas i, Albert  et  Jeong,  1999).  Ce  modèle  ti ent  compte  du 

phénomène  de  l'attachement  préférentiel  qui  veut  que  les  nœuds  de  degré  élevé  (nœud s 

popul aires)  tendent à attirer plus de liens que les  nœuds de degré faibl e.  Cette propriété a été 

observée dans certains réseaux tels que le WWW.  De plus,  contrairement au modè le d' amitié 

vu à  la section  précédente,  ce  modèle  tient  compte de  la croissance  constante du  nombre de 

nœud s et  de  liens  qu 'on observe  dans  le  WWW.  En conséquence  de cette  croissance  et  du 

mécani sme d'attachement  préférentiel,  il  a été  montré (A lbert, Jeong et Barabas i,  1999)  que 

la di stribution des degrés  du  réseau engendré par l' évo lution du  Web semble sui vre une loi de 

puissance.  Nous  tenterons donc  de vérifier  cette  propriété  sur  le  réseau engendré  par notre 

simul ation. 

Ce  modèle  débute  avec  m0  nœud s  et  à  chaque  pas  de  temps,  les  trois  règles  sui vantes  sont 
effectuées se lon certaines probabilités. 

1.  Ajout  de  nouveaux  liens : avec  une  probabilité p , aj outer m  <  m0  liens  au  réseau. 
Pour  ce  fa ire, on choisit  au hasard  le nœud de départ  de chaque  nouveau  lien.  Cec i 

décrit, par exempl e,  un  déve loppeur  Web  qu i déc ide  d'ajouter un  nouve l hyperli en à 

sa  page  Web.  Le  nœud  d'arrivée  du 

lien,  par  contre,  est  sé lection né  avec  la 

probabilité 

D (k) = 

k, + 1 
I<k, + 1) 

où  k représente la connecti vité du  nœud  (son degré). 

131 

Cette  probabilité 

ti ent  compte  du 

fait  que 

les  nouveaux 

liens  s'attachent 

préférentiellement  à  des  nœuds  populaires  ayant  déj à  beaucoup  de  connexions.  La 

fi gure 5.3.1 .1 et le tableau 5.3 .1.1 explicitent  le calcul de cette probabilité. 

2.  Reconnexion  de  liens : avec  une probabilité q,  reconnecter m  li ens du  réseau.  Pour 

ce  faire,  on sé lectionne  au  hasard  un  nœud  i  et  un  lien !if  partant  de  i  et  all ant  à  un 

autre  noeud j.  Ensuite, on supprime ce  lien et on le remplace  par  un  nouveau lien /if (cid:173)
choisi  se lon la  même  probabilité n qu 'à  la  règle  1.  Cette règ le décrit, par exemple, 
la  modification d' une URL sur une page  Web vers une autre  page  Web. 

3.  Ajout  de  nouveaux  nœuds:  avec  une  probabilité  1 - p  - q,  ajouter  un  nouveau 

nœud  au  réseau.  Ce  nouveau nœud  possède m nouveaux liens qui  sont connectés à m 
nœud s existants dan s le  graphe et  choisis se lon la même  probabilité n qu ' à la règ le 
1.  Cette  règle  représente  l'ajout  de  nouvelles  pages  Web  contenant  un  certa in 

nombre d' hyperliens. 

Figure 5.3.1.1  Attachement préférentiel dan s le réseau du  W eb 
Il  s' agit de  choisir un  lien  parmi  tous  les  liens potenti els pouvant  être ajouté au  réseau et  ayant  comme 
premier  nœud  le  n~ud n.  Le  choix  du  second  nœud  se  fait  en  tenant  compte  de sa  connectivité (son 
degré).  Plus un  nœud a un  degré élevé, plus il  a de  chances d'être choisi. 

132 

En se  rapportant  à  la  figure  5.3 .1. 1,  le  tableau  5.3. 1.1  montre  les  ca lcul s des  probabi 1 ités  11 

de  choisir  les  nœuds  i, j ,  k,  lou m  comme  nœud  d'arrivée  du  lien  à  ajouter.  On  remarque 

effectivement  que  cette  probabilité  ti ent  compte  de  l'attachement  préférentie l,  car  plus  la 

connectivité d' un  nœud est élevée, plus sa  probabil ité  d'être choisi est élevée. 

Tableau 5.3.1.1  Calcul de  la  probabilité  11, pour l'ajout de nouveaux liens, qui tient compte de 
l'attachement préférentiel dan s le  mod èle du Web 

J 
k 

m 

5 
2 
4 
3 

5 1 15 = 0.333 
2 /  15 = 0.133 
4 1 15 = 0.267 
3 1 15  = 0.200 
1 1 15 = 0.067 

Il  est à noter que  la  probabilité  11(k) est  proportion nelle à  k, + 1 de  telle  sorte  que  les  nœud s 

de  degré zéro n' aient pas  une  probabilité nulle de  recevoir de  nouveaux  liens. 

Dans  ce  modèle,  les  probabilités p  et  q  peuvent  se  situer  dans  les  interva ll es  0 ::::;  p < 1  et 

o ::::; q < l - p. 

5.3.2  Le modèle traduit en langage NetSim 

Les définitions du  modèle 

Les constantes 

• 

• 

La  constante  rn  représente  le  nombre  de  liens  à ajouter  ou  à  reconnecter  se lon  la  ou  les 
règles exécutées à chaque pas de temps.  Après avo ir effectué certa ins tests de simulati on, 
nous avon s fixé cette va leur à 4. 

DEF I NE  CONST 

(rn ,  4); 

La  constante  p  est  la  probabilité  d'exécuter  la  règ le  1.  Selon  nos  différents  tests  de 
simu lation, nous avons trouvé que  la va leur 0.4  produisait de  bons résultats. 

133 

DEFINE  CONST  (p ,  0.4); 

• 

La  constante  q  est  la  probabilité  d'exécuter  la  règ le  2.  Après  avoir  testé  plusieurs 
valeurs lors de simulati ons diverses, nous avons fi xé cette valeur à 0.3. 

DEFINE  CONST  (q,  0.3); 

Les attributs 

•  Bien qu ' il  n'y ait  pas d'attributs défini s par ce  modèle, nous aurons besoin  d' une variable 

témoin  qui  marque  les  nœud s  traités.  Nous  allons  donc  définir  cet  attribut  que  nous 

initialisons à zéro. 

DEFINE  ATTRIB  (node,  mark,  0); 

Les fonctions 

•  Nous  aurons  besoin  d' une fonction  pour calc uler  la  probab ilité  TI .  Pour ce  faire,  nous 

avons 

recours  à  la  définition  d' une  méthode  Java  définie  sur  l' entité  link  que  nous 

appellerons  probToAddThi sLink.  Nous  devons  tout  d' abord 

la  déclarer  avec 

la 

commande DEFINE  JAVA  METHOD  comme suit: 

DEFINE  JAVA  METHOD 

(link,  probToAddThisLink); 

Nous  allons  ensuite  écrire  le  code java  de  cette  méthode  dans  l'éditeur  de  code j ava  du 

logiciel NetSim.  Voici  le code : 

134 

public  Double  probtoaddthis li nk( Li nk  l i nk )  { 

Double  value; 
double  sumDegree 

0· ' 

//Va leur  à  retourner 
// somme  des  degrés  de  tous  les  liens 
//potentiels 

Il  obtenir  tous  les  liens  potentiels  qui  ont  comme  noeud  de  départ 
/1  le  nœud  de  départ  du  lien  reçu  en  paramètre. 

ArrayList  links  =  simController. 

getPotentialNodeOutLinks(link.getStartNode()); 

Il  Calculer  la  somme  des  degrés  (+ll  des  noeuds  d ' arrivée  de  tous 
Il  les  liens  potentiels  obtenus  à  l'étape  précédente. 

for  (inti=  0 

; 

i  <  links.size()  ; 

i  ++) 

s umDegree  =  sumDegree  + 

simController . getDegree(((Link)l inks.get(i)) . getEndNode())  +  l; 

/1  Calculer  le  rapport  entre  le  degré  (+l)  du  nœud  d'arrivée  du  lien 
Il  passé  en  paramètre  et  la  somme  des  degrés  calculée  à  l'étape 
Il  précédente . 

value =  new  Double  ( (simCont r o lle r.getDegree(l i nk.get EndNode())  +  l)  / 

sumDegree)  ; 

//Le  résultat  retourné  est  la  probabilité  de  la  création  de  ce  lien 
//potentiel  (passé  en  paramètre)  qui  tient  compte  de  l'attachement 
//préférentiel. 

return  value; 

Les règles du modèle 

Comme  les  règles  du  modèle  s'effectuent selon  une probabilité, il  n'est pas certain  qu'elles 

s'effectueront  toutes  dans  un  même  pas  de  temps.  Nous  allons  donc  créer  une  phase 

différente  pour  chaque  règle.  La  condition  d'exécution  de  chaque  phase  dépend  de  la 

probabilité d'effectuer la règle concernée  : la règle  1 s'exécute selon la probabilité p, la règle 

2, selon la probabilité q  et la règle 3 selon la probabilité 1  - p  - q . 

Phase 1 

La phase  1 contient 1 'action  qui  modélise  la règle  1 concernant l'ajout de m liens au  réseau. 

Pour  fabriquer  la  condition  d'exécution  de  la  phase  1,  nous  appelons  la  méthode 

135 

random _ number ()  qui  retourne  un  nombre  aléatoire  entre  0  et  1  inclusivement.  Si ce 

nombre est plus petit ou éga l à la probabilité p,  la conditi on est vraie et la phase  1 s'exécute, 

sinon, la  phase  1 ne s'exécute pas. 

L'action  ADD  LINKS  sélectionne  tous  les  liens  potenti els  qui  passent  le  test  probabiliste 

donné  par  la  méthode probToAddTh isL i nk et  parmi  tous ces  liens  sé lectionnés, ell e  en 

choisit rn  à aj outer au réseau. 

phase  exec  condit i on  (random_number()  < =  p); 

ADD  LI NKS 

(probToAddThisLink(),  m) ; 

Phase 2 

La  phase  2 conti ent toutes  les  actions qui  modéli sent  la règle 2 concern ant  la reconnex ion de 

m li ens  dans  le  résea u.  La  conditi on  d' exécution de  cette  phase  suit  le  même  principe  que 

ce lle de la ph ase  1. 

L'action  CUT_L INKS  sé lectionne  rn  liens  du  réseau  (ceux  que  l'on  dés ire  reconnecter)  et, 

avant  de  les  supprimer,  marque  le  nœud  de  départ  de  chacun  de  ces  liens  en  affectant  la 

va leur  1 à leur attribut mark. 

Ensuite,  l'action  ADD _ L I NKS  sé lectionne  tous  les  liens  potentiels  dont  le  premier  nœud  a 

son attribut mark éga l à  1 (nœud  marqué  à  l' act ion précédente).  Tous  les  liens ain si choisis 

passent  l'épreuve  pro babiliste  donnée  par  la  méthode  probToAddThisLink.  Tous  les 

liens qui  réuss issent  le  test sont  ajoutés  au  réseau et  l'attribut  mark de  leur  nœud  de départ 

est  remi s  à  0  pour  qu ' un  autre  li en,  avec  ce  même  nœud  de  départ,  ne  so it  pas  choisi de 

nouveau. 

L' action  PICK_LINKS  a  pour  but  de  s'assurer  que  l'attribut  mark  de  tous  les  nœuds  du 

réseau est rem is à 0 pour la prochaine phase ou  le prochain  pas de  temps. 

phase_exec  condition  (random_ number()  <  q); 

- - - - - - - - - - - -- - - - - - -- - - - - -- - - - - - - - - - - - - - - - - - - - - - --

-

136 

CUT  LINKS 

(m,  start  node()  .mark  :=  1); 

ADD  LINKS  (start  n o de()  .mark=  1,  probToAddThisLink(), 

start  node()  .mark  .- 0); 

PICK  LINKS(st a rt_node()  .mark  .- 0); 

Phase 3 

La  phase 3 contient toutes  les actions qui  modélisent  la règle 3 concernant  l' ajout, au  résea u, 

d' un  nœud  avec  m liens.  La  cond ition  d'exéc ution de cette  phase  suit  le même principe que 

pour la  phase  1 . 

L' action ADD _NOD ES aj oute  un  nœud  au réseau et marque ce  nœud  en affectant  la va leur  1 à 

son attribut mark .  On  remarque  ici  que pour  ajouter un  seul  nœud ,  il  faut  que  la valeur soit 

légèrement  plus grande que  1 car la  va leur exacte de  1 est traitée, par convention, comm e une 

probabilité  (valeur  entre  0  et  1 inclusivement)  et  non  comme  un  nombre.  Par  convention, 

toute valeur  plus grande que  1 est traitée com me un  nombre entier et sa partie déc imale, s' il  y 

a  li eu, sera  tronquée.  Comme  nous  l' avons déjà exp liqué au chapitre 3,  lorsqu 'on traite  une 

probabi lité comme  premier paramètre d' une acti on ADD,  par convention, le  système crée  tout 

d' abord  un  nombre  de  nouveaux  nœud s  éga l  au  nombre  de  nœud s  déjà  présents  dans  le 

réseau.  Ensuite, chaque nouveau nœud  doit passer le test probabili ste donné par ce  paramètre 

probabi 1 iste.  Dans  le  cas  d' une  pro ba bi 1 ité  éga le  à  1,  tous  les  nouveaux  nœud s  passeront 

l' épreuve.  Ains i, dans  le  cas  de notre acti on ADD_NODES, ce la  aurait  pour  effet d' ajouter 

au réseau un  nombre de nœuds éga l au nombre de  nœuds déjà  présents dans  le graphe, ce  qui 

ne correspond  pas  à  ce  que  nous vou lons fa ire.  Puisque  la va leur  1.1 est traitée  comme  un 

nombre  (par  convention),  sa  partie  déc imal e  sera  tronquée  et  un  seul  nœud  sera  aj outé  au 

réseau (la  valeur  de  l' attribut  mark de  ce  nœud  ayant  préalablement  été  aj ustée à  1).  C' est 

exactement ce que  nous voulons faire  ici . 

L' action  ADD _ LINKS  débute  en  sé lectionnant  tous  les  liens  potentiels  dont  le  nœud  de 

départ  est marqué.  Ensuite, les  liens choisis passent  le test probabiliste donné par la  méthode 

- - - - - -- - --- -- -

·--·-

137 

probToAddTh is L i n k  et  parmi  les  gagnants,  on sé lectionne  final ement  m  liens  à  aj outer 

au  réseau . 

L'action  PI CK_L INKS  a  pour  but  de  s' assurer  que  l'attribut  mark  de  tous  les  nœuds  du 

réseau est remi s à O. 

p h ase_exec_condition  (random_number()  <  1  - p  - q) ; 

ADD  NODES 

(1 .1,  mark  : =  1 ); 

ADD  LINKS  (start  n ode()  .mark=  1,  probToAddThi sLink(),  m) ; 

PI CK  LI NKS  (start  node()  . mark  .- 0); 

Maintenant  que  nous  avons  écrit  le  modèle  du  Web  en  langage  NetSim,  nous  pouvons  le 

simu ler dans NetSim.  La section suivante commente nos  résultats obtenus par simulati on. 

5.3.3  Résultats de simulation 

Tout  d' abord ,  nous  avons  construit  notre  résea u  initial avec  m0  =  6  nœud s  initiaux.  Nous 

avons  alors  démarré  la  simu lati on  et  la  fi gure  5.3 .3. 1 montre  l'évo luti on de  la  structure  du 

réseau à différents  moments dans  le  temps.  Dans  l' image  du  résea u au temps t =  600, nous 

avons  coloré  certains  nœud s  de  degré  élevé  en  séparant  la  valeur  des  degrés  se lon  des 

tranches  de cinq .  Étant donné que  le degré  maximum  du  réseau fin al est de 43,  le code des 

couleurs des  nœud s est le suivant  : 

Tranche des de  rés  Nombre de noeuds 
43 - 39 
38 - 34 
33 - 29 
28 - 24 
23- 19 

1 
2 
2 
6 
17 

Couleur des noeud s 
rouge 
orange 
Jaune 
vert 
bleu 

Nous  remarq uons déjà qu ' il y a très  peu  de  nœuds avec  un degré très élevé  se  situant  dans les 

trois  premières tranches des degrés.  Nous  remarquons auss i que  le nombre de  nœuds  semble 

138 

augmenter  fortement  à  mesure  que  le  degré  diminue  doucement.  Ceci  est  une  première 

indication de la possibilité d' une distribution exponentielle des degrés. 

1 

du réseau  à t =  100 ( 44 nœuds,  157  liens) 

Etat du réseau  à t =  200 (69  nœuds,  157  liens) 

Etat du réseau à t =  300 (98  nœuds, 449  liens) 

Etat du  réseau à t =  400 ( 126  nœ uds, 566  liens) 

Etat du  réseau à t =  600 (194 nœuds,  868  liens) 
Figure 5.3.3.1  Évolution du  réseau  du Web au cours de la simulation 

~~~~--~~~~~~~~~~----~- ----

139 

Cependant,  nous  voudrions  vo ir  si  la  distribution  des  degrés  de  notre  réseau  généré  par 

si mul ation  suit bien  une loi  de puissance  de la  forme  p(d) =d-a  où p(d) est  la probabilité du 

degré  d et  a, un  paramètre  variab le.  Nous  avons  donc  tracé  graphiquement  la  distributi on 

des  degrés  en  omettant  les  degrés  de  va leur éga le  à  0  et  les  probabilités  éga les  à  zéro.  La 

figure  5.3.3.2  montre  ce  graphique dan s  lequel l' axe  des x correspond  aux  degrés  des  nœud s 

tandis  que  l' axe  des  y  représente  la  probabilité  de  chaque  degré  dans  le  résea u.  Nous 

constatons que les  points du  graphique semb lent dess iner une courbe à l'a llure exponenti ell e. 

Si la courbe de  la figure  5.3.3 .2  suit  une loi  de puissance,  nous devrions obtenir  une droite en 

prenant  le  logarithme des val eurs  en  x  et  en y.  La  figure  5.3.3.3  illustre ce  graphique.  En 

utilisant  une  technique  de  régress ion  linéa ire, nou s obtenon s une  pente de  régress ion dont  le 

coefficient  de  corré lation  est  éga l à  -0.879. 

Il  semble  que  le  modèle  simul é  avec  NetSim 

produise  effectivement une structure  de  résea u dont  la di stributi on des  degrés  suit  assez  bien 

une  loi  de puissance . 

Distribution des degrés 

• 

•• 
• 

• 

• 

• 
• 
• 
•••  •  ••• 
• 

• 

• 
• 
• 
• 
• ••••• 

0,14 

0, 12 

0,10 

• (Il 

~  0,08 
::0 
ID 
.0 
0  0,06 
tl: 

0,04 

0,02 

0,00 

•• 

• 

• 

0 

10 

2.0 

(}egré 

30 

40 

Figure 5.3.3.2  Distribution des degrés du  réseau  généré par simulation  au temps t  =  600 
L'axe  des x représente les  degrés des  nœuds du  réseau  et l'axe  des  y, les probabilités d'occurrence  de 
ces degrés dans le réseau.  Les  points du  graph ique semblent dessiner une courbe de type exponentiel. 

140 

Distribution logarithmique des degrés 

-0,5 

-1,0 

..... 
0 .... 
01 
0 
:;:.. 
-;v  -1,5 
':!: 
:ë 
til . 
.a 
0 
li. 

-2,0 

0,0 

0,2 

0,6 

0,8 

1, 0 
Degré {loglO) 

1,2 

1,6 

F igure 5.3.3.3  Distrib ution  loga rit hm iq ue des d egrés d u  résea u gé néré par simulat ion au temps t 
= 600 
Ce  graphique  illustre  la  distribution  logarithmique  du  graph ique  de  la  figure  5.3 .3.2.  L'axe  de  x 
représente le logarithme  des  degrÙ  des nœuds du  réseau et l'axe des  y,  le  logarithme  des  probabi lités 
d' occurrence de ces degrés dans le réseau.  Les  points du  graphique semblent  dessiner un e ligne  dro ite 
qui  ind ique que  la distribution  des degrés suit une  loi  de puissance.  Le coefficient de  corrélation  de  la 
pente de  régression  est  assez significatif avec  une  va leur de  -0.879.  La  va leur négative  du  coefficient 
de  corrélation  signifie  que  les  données  sont  corrélées  négativement : plus  la  valeur  des  degrés 
augmente, plus la va leur des probabilités diminue. 

141 

5.4  Conclusion 

Dans ce  chapitre, nous  avons traduit en langage NetS im  et simulé deux  modè les  typ iques  de 

la  littérature.  Bien  que  notre  analyse  des  résultats  obtenus  reste  assez  sommaire,  nous 

voulions  d' abord  montrer  qu ' une  première  analyse  visuelle  est  souvent  révé latrice  des 

résultats que nous sommes susceptibles d'obtenir, par la  suite, avec une analyse  plus poussée. 

Dans  le  cas  du  modèle  d' amitié,  nou s  avons  obtenu  des  résu ltats  très  simil aires  à  ceux 

obtenus  par  les  auteurs du  modèle.  Le  réseau  généré  par  NetSim  montrait  effecti vement  la 

propri été  de  transitivité ainsi  que  la  formation  de  petites  communautés très cohés ives  au se in 

de  la structure.  Ces  phénomènes sont aussi  des  phénomènes observés dans plusieurs  réseaux 

soc iaux  rée ls. 

En  ce  qui  concerne  le  modèle  de  l' évolution  de  la  structure  du  Web,  nous  avons  obtenu , 

comme  mentionné  dan s  la  littérature,  un  réseau  dont  la  di stribution  des  degrés  sembl e 

effect ivement su ivre une loi de puissance. 

CHAPITRE  6 

Conclusion et perspective 

6. 1  Contributions 

Dans  ce  mémoire,  nous  avons  montré  que  1 'étude  des  réseaux  par  lesquels  circulent 

information et connaissances est pertinente dans  notre  société moderne et que  l'investigation 

de  ces réseaux par modélisation et simulation est, dans certains cas, une solution appropriée : 

elle  permet  de  tester  diverses  hypothèses  ou  d'aider  à  en  formuler  d'autres  quant  aux 

phénomènes observés dans le monde réel. 

Étant  donné  que  l'échange  d'informations  se  fait,  le  plus  souvent, dans  le  cadre  de  réseaux 

sociaux,  nous  avons  vu  différents  modèles  de  ce  type  de  réseaux,  tirés  de  la  littérature  et 

provenant  de  plusieurs  domaines  tels  que  la  physique,  les  mathématique,  la  psychologie,  la 

sociologie  et  l'économie.  Parmi  ces  divers  types  de  modèles,  nous  avons  choisi  de  nous 

intéresser plus particulièrement à ceux qui  tentent de comprendre la structure des  interactions 

entre les acteurs du réseau plutôt qu'à ceux qui  étudient la dynamique de ces  interactions. 

Cette « structure » peut dès  lors  être représentée sous  forme  de  graphe et de  ce  fait, peut être 

examinée  de  façon  quantitative  par  des  méthodes  d'analyse  se  basant  sur  la  théorie  des 

graphes.  Nous en avons vu quelques-unes provenant de la sociologie structurale. 

De  plus,  cette  «structure»,  lorsque  visualisée  sous  forme  de  graphe,  peut  déjà  révéler 

plusieurs  informations  lorsqu'elle  montre  certains  motifs  spécifiques  dans  1 'arrangement  de 

ces nœuds et de ces liens. 

143 

Cependant, la mi se en œuvre de simulations de modèles de réseaux d' information est souvent 

lente et  laborieuse, car celles-ci  sont  souvent  programmées  à  partir  de zéro  et  ne  répondent 

aux  beso in s que  d' un  seul  modèle :  1' impl émentati on  est  à  recommencer  lorsqu ' i 1 s'agit  de 

simuler des  modèles  di fférents.  C'est  pourquoi nous avons  proposé,  dans ce  mémoire,  une 

plate-forme générique de modéli sation de réseaux d' information et plus  particulièrement, de 

réseaux soc iaux. 

En  nous  in spirant  de  modèles  ex istants,  nous  avons  tout  d'abord  élaboré  un  langage  de 

modéli sati on qui  est assez simple pour être access ible à des  utili sateurs vari és  et assez concis 

pour  être capable de spéc ifi er un  modèle en peu de commandes.  Un modèle exprimé dans ce 

langage  est  fac ilement  modifiable  et  permet  de  tester  rapidement  différentes  règles  ou 

différentes  va leurs de paramètres de modèles di vers. 

Nous avons ensuite implémenté NetSim, un  logiciel de simulation capable d' interpréter notre 

langage  de  modéli sation et de simuler des  modèles  variés  tout  en visuali sant  leur  évo luti on, 

au  cours  de  la  simul ation,  sous  fo rme  de  graphe.  Étant  donné  l'as pect  structural  de  ces 

modèles,  la  visuali sation  est  importante,  car  outre  le  fa it  qu ' ell e  nous  permet  de  déce ler 

di vers  motifs  ou  régul arités  structurales  significati ves,  ell e  permet  auss i de  nous apercevo ir 

rapidement  si le modèle simulé sembl e tendre ou non vers la structure recherchée. 

Finalement,  nous  avons  testé  notre  plate-forme  de  simulation  sur  di fférents  modèles 

class iques  de  la  littérature.  Les  résultats de  simulations que  nous avons obtenus sont  plutôt 

conva incants,  car  il s  sont  signifi cati vement  confo rmes  aux  résultats obtenus  par  les  auteurs 

des diffé rents modèles simulés. 

La  pl upart  des  travaux  techn iques  actuels  ne  ti ennent  pas  suffi samment  compte des  as pects 

sociaux de  la communication et restent  ainsi en deçà  de  leur  potentiel d'utilisation. Cet outil 

de modéli sati on nous donne  la possibilité de  modéliser fi nement  des  réseaux pertinents pour 

la  circulation  de 

l'information  entre  individus.  Cela  nous  semble  très  uti le  pour  le 

développement, par exemple, de  nouve lles  app lications de  communication électronique ou  de 

trava i 1 co ll aboratif par ordinateur. 

144 

6.2  Travaux futurs 

Pour  la suite de ce proj et, nous voudrion s étendre  les fonctionnalités  de NetSim  en y aj outant 

un  module  d'analyse  de  réseaux.  En  effet,  bien  que  la  vi suali sation  des  réseaux  so it 

révélatri ce  en so i, elle n'est pas suffi sante pour  bien comprendre et caractéri ser les  structures 

générées  par  simulation.  Nous  pourrions  commencer  par  implémenter  les  méthodes 

présentées au chapitre 2.  Par exemple, pour  une étude plus approfondie au niveau structural, 

il  serait 

intéressant  de  pouvoir  partiti onner  le  réseau  en  sous-groupes  cohés ifs  se lon 

différentes  méthodes  comme  les  méthodes  basées  sur  l'accessibilité  et  le  diamètre,  sur  la 

réc iproc ité complète ou sur  l'équivalence structurale et de pouvoir  vi suali ser ces  partitions à 

l'écran.  Pour  une  analyse  au  ni veau  local,  nous  pourrions  implémenter  les  méth odes  de 

calcul  des  différents  pointages  de centralité et de prestige, etc.  Il  ex iste aussi des  méthodes 

stati stiques  plus  compl exes  d' analyse  de  réseau  (Wassermann  et  Faust,  1994)  que  nous 

voudrions éventuell ement  impl émenter. 

De plus,  le  langage  de  modéli sation NetSim  est, pour  le  moment, à  un  état embryonnaire  et 

nous voudri ons  le  déve lopper pour  qu ' il  puisse  modéli ser une plus grande variété de réseaux 

d' information.  Pour  ce  faire,  nous  voudrions d' abord  améliorer  les  mécanismes  de création 

de fonctions.  Comm e nous l'avons déj à menti onné, pour  le moment, les fonctions se  limitent 

à retourner un  résultat numérique ou boo léen.  De plus,  les  fonctions ne peuvent  pas  recevo ir 

de  paramètres.  Éventuellement,  il  serait  intéressant  de  pouvoir  créer  des  librairies  de 

fonctions  défini es  en  langage  NetSim. 

Chaque  librairie  pourrait  fourni r  des  méthodes 

spéc iali sées  dans  1 ' étude  de  phénomènes  spécifiques  ou  de  types  particuliers  de  réseaux 

d' info rmation.  Ell es  pourraient  être déve loppées  séparément  par certains et se  charger dans 

NetSim  pour  pouvo ir être utili sées par d' autres.  Le code NetSim  pourrait ainsi être réutili sé. 

Nous  espérons  que  l' ébauche  d' un  tel  langage  de  modéli sation  ouvrira  la  porte  à  d'autres 

propos iti ons.  Beaucoup  de  concepts  de  programmati on  sont  déjà  passés  dans  la  prat ique 

courante  de 

l' info rmatiq ue  (langages  numériques,  langages  de  manipu lation  de 

li stes, 

langages  orientés  obj ets ... )  et  nous  croyons  qu ' il  est  temps,  maintenant,  de  se  do nner  des 

outil s pour modé liser les réseaux d' information. 

------------------------------------------------------------------------------ - - ----

ANNEXE A 

Code généré dynamiquement des classes 
d'exécution de la simulation du  modèle du 
réseau d'amis de Jin, Girvan et Newman 

Classe SimulationContext 

package  org .netsim.simulation ; 
import  org.netsim.network.*; 
import  org.netsim .utils.*; 

public  class  SimulationContext  extends  Thread  { 

private  int  phaseCounter  =  0 ; 
private  ModelPhases  phase  =  null; 
private  boolean  suspend  =  true; 
private  SimulationController  simController 

SimulationController.getController(); 

public  SimulationContext  ()  { 

super() ; 
phase  =  null; 
phaseCounter  =  0 ; 

public  void  resetPhaseCounter  ()  { 

phaseCounter  =  0; 
phase  =  null; 

public  int  getPhaseCounter  ()  { 

return  phaseCounter; 

public  synchronized  void  pauseThread  ()  { 

suspend  =  true; 

public  synchronized  void  resumeThread  ()  { 

suspend  =  false; 
notifyAll () ; 

- - - - - - - - - - - - - - - - -

146 

notifyAll ()  ; 

public  void  run  ()  { 

while  (!  (simControl l er.getTimeStep()  >=  1000.0)) 

synchronized  (this)  { 

try  { 

Thread.sleep((int)  Math.random()  *  1000000); 
while  (suspend)  { 

wait(); 

catch  (InterruptedException  e) 
System.out.println("Interrupted  exception"); 

//phase  1  exec  condition 
if  (phase  ==  null  &&  true) 

phaseCounter  =  1; 
phase=  new  ModelPhase1(); 

if  (phase  !=  null) 
phase. simule(); 

//update  time  step 
simController.incrementTimeStep(); 

//refreshing  the  graph  display 
simController.refreshDisplayedGraph(); 

//end  synchro 

//end  while 

suspend  =  true; 
NetSimUtils.po pinfoMsg(null,  "Normal  end  of  this  simulation!"); 

//  end  method 

//e nd  class 

147 

Classe ModelPhasel 

package  org . netsim.simulation; 

import  java.util.HashMap; 
import  java.util.ArrayList; 
import  org.netsim.network.* ; 
import  org.netsim.utils .*; 

public  class  ModelPhase1  extends  ModelPhases  { 

public  void  pickLinksO(SimulationController  s imContro ll er) 

{ } ; 

initPi ckLinks(); 
new  ArrayList(); 
new  HashMap(); 

double  []  numValues  = 
ArrayList  processList 
ArrayList  chosenLinks 
HashMap  link sToRewire 
boolean  fail 
false; 
boolean  stop  =  false; 
int  i  =  0; 
ILink  link; 
boolean  boolValue; 
double  doubleValue; 
int  counter  =  -1 ; 
int  number; 

while  (!stop  &&  processList.size()  >  0) 

i  =  MathUtils.randomNumber(O,  processLi s t.size()  - 1); 
link  =  (ILink)processLis t.get(i); 
//ASSIGNMENT 
if  (!fail)  { 

simController.setAttribute(link,  "time  since  last_meeting " , 

simController.getAttribute(link, 
"time  since  l ast_meeting " )  +  1.0); 

} 
//ASSIGNMENT 
if  ( !fail)  { 

simController. setAt tribu te ( link,  " stre ngth", 

(  Math.pow(2.718, 
simControl l er . getAttribut e (link, 
" time  since  last_meetlng"))  ))  ; 

- 0 . 01  * 

fail  =  false; 
proce s sList . remove(i); 
count e r  =  -1; 

//end  whil e 
//end  me thod 

148 

public  void  pi c kLinks 1(SimulationControll er  s imCont ro ll er) 

initPickLinks ()  ; 
new  ArrayLi st(); 
new  HashMap(); 

double  (]  numValue s  =  {}; 

Ar ray List  processList 
ArrayList  c h osenLinks 
Ha shMap  link s ToRewire 
boolean  f ai l 
f a l se ; 
b oo lean  stop  =  false; 
int  i  =  0; 
ILink  link; 
boolean  boolVa l ue; 
double  d oubl eVa lue ; 
i n t  counter  =  - 1 ; 
int  numb e r; 

while  (!stop  &&  processList.size()  >  0) 

i  =  MathUtils.randomNumber(O,  processList . size()  - 1); 
link  =  ( ILink )processLi s t .ge t (i); 

doubleValue  = 

( 

(  1.0  -

(  1.0  - 0.0060  )  * 

- 0.5  * 

(  Mat h.pow(2.7 1 8 ,  5 . 0  * 

Math.pow(2.718, 
s imCon troll er.getNumOfCommonNeighbours(link)) 
(  1.0  / 
(  s imControl l er.getDegree(s imControl l er . 
getStartNode(link))  - 5.0  ))  +  1 . 0)  )  * 
Math.pow(2.718,  5.0  * 
s imCon t r o ll e r. ge tDegree(simContro ll er . 
getEndNode(l ink ))  - 5 . 0  ))  +  1.0)  ) 

) ; 

( 

)  * 

(  1.0  / 

( 

//PROBABILITY 
if  (!fail)  { 

if  (!Mat hUtil s . isARandomWinningNumber(doubleVal u e)) 

fail  =  true; 

} 
//ASSIGNMENT 
if  (!fail)  { 

s imContro ller . setAttribut e(li n k, 

" time_since_last_mee ting",  0.0); 

} 
//ASS IGNMENT 
if  (!fa il )  { 

simControl l er. setAt tribu te ( link,  "strength ",  1. 0)  ; 

fail  =  false; 
processList.remove(i); 
counter  =  -1; 

}  //end  while 

//end  method 

149 

p u bl i c  void  c u t Links2(S imu la ti on Contro ll e r  s imCont ro l ler) 

{ } ; 

init CutL i nk s  (); 
n ew  Ar r ayList(); 
n ew  HashMap(); 

[)  numValues  = 
d o u b l e 
Arr a yLi s t  processLi st 
ArrayLi s t  c h osenLinks 
Has hMa p  link s ToRewi r e 
boo l ean  fa i l 
fa l se; 
boo l ean  s t op  =  f alse; 
i n t 
ILink  l i nk ; 
b oo l ean  b ool Va lue ; 
d ou b l e  d ou b l eVa lue ; 
int  count er  =  -1; 
int  numbe r ; 

i  =  0 ; 

whil e 

( ! stop  &&  p r ocessLi s t .s iz e()  >  0)  { 

i  =  Mat hUtil s.randomNumbe r (O ,  p rocess Li s t .si ze()  - 1); 
link  =  (ILink ) processLi st . ge t (i ) ; 

//BOOLEAN 
( ! fa il ) 
i f 

boolVa lue  =  si mContro ll er . ge t Attribute(l i nk,  " s t rength " ) 

<=  0.5 ; 

fail  = 

!bool Va lue ; 

} 
// ENDI NG 
fa i l  =  fa l se ; 
p r ocessLi st.remove( i ); 
counter  =  -1 ; 

}//end  whil e 
//end  met h od 

150 

public  vo id  addLinks3(SimulationController  simController) 

initAddL i nks(); 
new  ArrayList(); 
new  HashMap(); 

double  []  numValues  =  {}; 
ArrayList  processList 
ArrayList  chosenLinks 
HashMap  linksTo Rewire 
boolean  fail 
fa l se; 
boolean  stop  =  false; 
int  i  =  0; 
ILink  link; 
boolean  boolValue; 
double  doubleValue; 
int  counter  =  - 1; 
int  number; 

while  (!s t op  &&  processList.siz e()  >  0)  { 

i  =  MathUtils.randomNumber(O,  proc essList.size()  - 1); 
link  =  (ILink)processList.get(i); 

//add  the  link  to  the  net wo rk 
simController.addLink(link); 

doubleValue  = 

( 

(  1.0  -

(  1.0  - 0.0060  )  * 

- 0 . 5  * 

(  Math.pow(2 . 718,  5.0  * 

Math.pow(2.718, 
s i mContro l ler.getNumOfCommonNeighbours( link))  )  * 
(  1.0  / 
(  s imControll e r.getDegre e(s imController . 
getStartNode(link))  - 5.0  ) )  +  1.0  ) 
Math.pow(2.718,  5.0  * 
(  s imController.getDegree(simController. 
getEndNode(link)) 

)  *  (  1.0  / 

- 5.0  ) )  +  1.0  )  ) 

) ; 

( 

//PROBABILITY 
if  ( !fail)  { 

if  ( !MathUtils . isARandomWinningNumbe r(doubleValue)) 

fail  =  true; 

} 
//ENDING 
if  (fail) 

simController.cutLink(link); 

fail  =  false; 
processList.remove(i) ; 
counter  =  -1; 
//end  while 

//end  method 

151 

public  void  simul e() 

Simulat ionController  simController  = 

Simu l ationControl l er.getController(); 

pickLinksO(simController); 

pickLinksl(simControl ler ); 

cutLinks2(simController); 

addLinks3(simController); 

//end  c l ass 

ANNEXE  B 

Interface graphique de NetSim 

~;,~ 
Proj;"i:tl  Help 
New 

Open 

s~"' 

S~.JS. 

...... A...Ili: 

Figure B.l  Création d'un  nouveau projet 
Avant  de  créer  une  simulation  dans  NetSim,  il  faut  tout  d'abord  créer  un  projet.  Le  même  projet 
pourra, par la suite, contenir une ou plusieurs simulations. 

153 

.:. 

t 

·

, : 

. ' 
Project  Help 

Enreg!strer dans :  [t:J Mes documents 

.. Il ~ [!] [Q] fil~ 

d  SnagH Catalog 
LI Symantec 

û  Axialis Librarian  LlMvAibums 
E:l Cyberlink 
L]MyShapes 
Ll Ma musique 
d  My Skype Content 
Ll Mes eBooks 
c::l My Skype Pi ct ures 
LI My Web Sites 
d  Mes images 
d  Mes notes 
Ll Norton_2004 (F .J 
LI Mes vidéos 
d  Pinnacle Studio 

!:l_om de fichier : 

Fich,iers du !)lpe : 

r 

jproModeleAmiti e 

-

-

1 

~1 

Ir  Enregistrer  111  Annuler 

1 

Figure B.2  Enregistrement du nouveau projet sur le disque 
Lors de la création d'un nouveau projet, NetSim demande de lui fournir un nom pour ce projet et de lui 
donner l'emplacement où l'enregistrer. 

154 

.. 

Project  Help 

Select a simulation 

Simulations: 

ll~""""""""""""""""""""""""""""""""""""""""""""" ... "'~lllrr 

[

Projectnoles----------------------~----------, 

'New 

1 

Les  simulations  de  ce  projet  sont  des  tests  de  simulation  du  modèle 
de  réseaux  d 1 ami s  de  Jin,  Girvan  et  Ne~an . 

Changed 

Figure B.3  Écriture de notes de projet et création d ' une nouvelle simulation 
À la création d'un projet, un espace est réservé pour 1 'écriture de  notes  à propos de  ce projet.  Ensuite, 
pour créer une  nouvelle simulation,  il  faut  sélectionner 1 'option « New » dans  la liste  des  simulations. 
S'il  y  avait  déjà  des  simulations  d'enregistrées  dans  ce  projet,  elles  apparaîtraient  dans  la  liste  des 
simulations et il serait possible de les sélectionner pour les ouvrir. 

155 

Simulation  Help 

~~~ork---------------------------------------------------------------, 

bJ: Orier\ted 

star't configuration: 

j Ex~i~~ degree distribution 

,..  1 

Edit 

Simulalioni--------------------------------1 

Rule sé( execution: 

_Networok updàte: 

Z! J Se;quenfial 
.® immediate 

Degree maK: ~ Refresh 

1 

Display 

Nodesize  le 

Node border color 

! _BLACK 

Node fdl color  1 LIGHT  BLUE 

Highlighted node colo'r 

[ RED 

Fixed node color  1 RED 

" 

. 

Degree 

Number of no des 

0 

10 
20 

... J 

... 1 

... 1 
~] 
... 1 

Figure B.4  Choix d'une configuration initiale dans les paramètres généraux de la simulation 
On  peut  choisir  une  configuration  pour  le  réseau  initial  de  la  simulation  en  choisissant  une 
configuration  dans  la  liste  des  « start  configuration ».  Dans  cet  exemple,  on  a  sélectionné  la 
configuration « Explicit Degree Distribution » et une  autre  fenêtre  s'est ouverte, dans  laquelle  on doit 
entrer les  valeurs  des  paramètres pour cette  configuration.  Dans  ce  cas, il  faut  tout  d'abord donner  le 
degré maximum de notre réseau et ensuite fournir  le  nombre de  nœuds pour chaque degré  allant de  0 à 
degré maximum. 

-- -- - - - - - -- -

-- - - -- -- -- -- ---- ------ -------- -, 

156 

.. 

'  Simulation  Help 

.. 

.. .. - - · 

.. 

. . 

(  Getting. storted)!î'Mj@MIEBJft!rv.jiîtrW!WlDI 

1 

1 

1 

1 

Nelwork 

0  Oriented 
start configuration: 

1 Explicit degree distribution 

Number of nades: 

Edit 

1 

1 

... 1 

250 

Simulation 

Rule set execution: 

Network update: 

®  Sequ enti al 

®immediate 

0  Parall él 
0  Differe d 

Display 

Node slze  h~ -

·············-··-·····-

Node border color 

l sLACK 

Node fdl color  1 LIGHT  BLUE 

Highllghted node color 

r RED 
Fixed node col or·  1 RED 

- ~JI; 
... 1, 

... 1 

... 1 

... 1 

U nk width  11 
link color  lsLACK 

Highlighted link color  1 RED 

... 11 

... 1 

... 1 

~ Constrained display 
~ High quality display 

Save 

1 

1 

Figure B.S  Choix des autres paramètres généraux de la simulation 
Dans  l'onglet  des  paramètres  généraux  (getting  started)  de  la  simulation,  on  doit  mentimmer  si  le 
graphe  est  orienté  ou  non,  le  mode  d'exécution  des  phases,  le  mode  de  mise  à  jour  du  réseau  (pas 
encore  implanté)  les  différents  attributs  visuels  des  nœuds  et  des  liens,  etc.  Lorsqu'on  appuie  sur  le 
bouton  « Save», l'onglet suivant (Definitions)  est activé  et  l'on peut écrire  les  définitions  du  modèle 
(voir figure suivante). 

~  .. 

Simulation  Help 

I!OijjLiiiisterted .J  Definitions  ~~-

.. 

.. .... . 

-· 

DEFINE_CONST  (z_1irnite,  5); 
DEFINE_C ONST  (b,  5); 
DEFINE_ CONST  (a ,  o. 5); 
DEFIIJE_CONST  (pO,  0.006); 
DEFINE_CONST  (k) ; 
DEFINE_CONST  (1imit_min_fo~_f~iendship,  0 . 6); 
DEFINE_CONST  (e,  2 . 718) ; 

DEFINE_ATIRIB  (1ink,  st~ength,  1); 
DEFINE_ATIRI B  (link,  time_since_last_meeting,  0); 

DEFINE_FUNCTION  (1ink,  g) 
1  -

(1  - pO) 

.,.  e  11'1r  (- a~ numbe~_o f_cornmon_contacts()) ; 

DEFINE_FUNCTION  (1ink ,  fi ) 
1  / (e  ~~  (b  ~  (sta~t_node().deg~ee()  - z_limite))  +  1); 

DEFINE_FUNCTION  (1ink ,  fj ) 
1  /(e  ~~  (b  ~  (end_node().deg~ee()  - z_1imite) )  +  1); 

DEFI NE  FUNCTION  (link,  pij) 

Syntax  error  at  l ine  S. 

DEFIIUTION  :  DEFINE_CONST  (k) 

ERROR  MESSAGE 
Ba<i  number  of  a r gum ents~ 

: 

1  1Veril)l Syntaxl  Il  Save 

1 

157 

... 

~~ 

'! 

1-; 

~ 
~: 
1 

... 

Figure B.6  Écriture des définitions du  modèle et vérification syntaxique (avec erreurs) 
C'est  dans  l'onglet  « Définitions » que  l'on écrit  les  définitions  du  modèle.  Lorsqu'on  clique  sur  le 
bouton  « Verify  Syntax »,  si  nos  définitions  contiennent  des  erreurs  de  syntaxe, un  message  d'erreur 
(en rouge)  est affiché dans l'aire de texte du bas. 

158 

Simulation  Help 

Getf  atarted 

Definitions  ~ll!iC!i\l~~~;:j!j!!i@Mtl!l!ll• 

~~#!\!•! .. "!---~--------~--

DEFINE_CO!VST  (z  1l!Jate,  5); 
DEFINE_CO!VST  (b,  5) ; 
DEFINE_CO!VST  (a,  0.5); 
DEFINE_CO!VST  (pO ,  0.006); 
DEFINE_CO!VST  (k,  0. 01); 
DEFINE_CO!VST  (1imit_min_for_friendship,  0.6); 
DEFINE_CO!VST  (e,  2.718); 

DEFINE_ATTRIB  (1ink,  strength,  1)  ; 
DEFINE_ATTRIB  (1ink,  time_since_1ast_meeting,  0); 

DEFINE_FUNCTIO!V  (1ink,  g) 
1- (1- pO)  •  e  ••  (-a  •  numbe r_of_common_contacts() ) ; 

DEFINE_FUNCTIO!V  (1ink,  fi) 
1  / (e  ••  (b  •  (start_node( ) . degree()  - z_1imite))  +  1); 

DEFINE_FUNCTIO!V  (1ink,  fj ) 
1  /(e  ••  (b  •  (end_node().de gree( )  - z  11m1te))  +  1); 

DE FINE  FUNCTIO!V  ( link,  pij) 

Syn tax  OK! 

jverify Syntaxf  Il  Save 

Figure B.7  Vérification syntaxique des définitions du  modèle (sans erreurs) 
Lorsque la syntaxe de  nos définitions est correcte,  le bouton « Save» devient actif et si l'on clique sur 
ce bouton, l'onglet suivant (Rules), dans lequel on peut écrire les règles du modèle, devient actif. 

159 

Simulation  Help 

Gîîtti 

Rulell 

SIHUL_STOP_CONDITION  (time_step ()  > 1000); 

PICK_LINKS( time_since_1ast_meeting  .- t i me_since_1as t _meeti ng  +  1, 

strength  :=  s()); 

PICK_LINKS(pij(),  t ime_since_1 ast_meeting  :=  0  , 

str ength  : =  1 ); 

CUT_LINKS  (s trength  <=  limit_min_fo r _fr i endship); 

ADD_LINKS(pij()); 

Syntax  OK! 

jverify Syntaxj  Il  Save 

Figure B.8  Écriture des règles du  modèles et vérification syntaxique (sans erreurs) 
Lorsque  la  syntaxe  de  nos  règles  est correcte,  le  bouton « Save » s'active.  Lorsque  l'on clique sur ce 
bouton, si  nous  avons  défini  une  méthode  Java  dans  les définitions, l'onglet  suivant  (Java Methods), 
dans  lequel  on peut écrire notre  méthode en Java,  deviendra  actif.  S'il n'y a pas  de  méthode  Java,  le 
bouton « Start » apparaît (voir figure  suivante). 

L_ ____ _____ ___ _____________ __ _________ _________________ _ ____  _ 

160 

Simulation  Help 

SIMUL_STOP_CONDITION  (time_step()  >  1000); 

PICK_LINKS(time_since_1ast_me etinq  .- time_since_1ast_meetinq  +  1, 

strenqth  :=  s()); 

PICK_LINKS(pij(),  time_since_1 ast_meetinq  .- 0, 

strenqth  :=  1); 

CUT_LINKS  (strenqth  <= 1imit_min_for_friendship); 

ADD_L I NKS(pij()); 

Synt.ax  OK! 

VeriiY Syntax  Il  :S<111e1 

41FifiM 

Figure B.9  Initialisation de la simulation (bouton « start ») 
Le bouton « Start » sert à initialiser la simulation. 

161 

Figure B.lO  Visualisation de la  configuration initiale du réseau 
À l'initialisation de la  simulation, la configuration initiale du réseau,  s'il y a lieu, est affichée à l'écran. 
Pour démarrer la  simulation, il  suffit de cliquer sur le bouton « Resume ».  Pour arrêter la simulation, il 
faut  cliquer sur le  bouton « Stop ».  En tout temps au  cours  de  la  simulation, on peut sauvegarder une 
image  du  réseau  en cliquant sur le  bouton  « Save  Image »  ou  sauvegarder  la  configuration du réseau 
sous le  format NetSimXML et cliquant sur le bouton « Save graph ». 

RÉFÉRENCES 

Albert, R.H.  et Barabasi A.-L.  (2000), Topology of evolving  networks  : local  events 
and universality, Physical Review Letters,  vol.  85 , 5234. 

Albert  R. ,  Jeong  H.  et  Barabasi  A. -L.  (1999),  Diameter  of the  World-Wide  Web, 
Nature,  vol. 401 , 130-131. 

Amaral, L. A. N. , Scala A., Barth~lémy M.  et Stanley H.  E. (2000), Classes  of small(cid:173)
world networks, Proceedings  of National Academy  of Sciences  USA , vol.  97,  11149-
11152. 

Amb1ard  F.  (2002),  Which  ties  to  choose?  A  survey  of social  networks  models  for 
agent-based  social  simulations,  Proceedings  of  the  2002  SCS  International 
Conference  On  Artificial  Intelligence,  Simulation  and Planning  in  High  Autonomy 
Systems, Portugal, Lisbon, avril, 253-258 . 

Auer K . et Norris  T.  (2001),  "Arrieros Alife", a multi-agent approach  simulating the 
evolution  of a  social  system  :  modeling  the  emergence  of social  networks  with 
Ascape, Journal of Artificial Societies and Social Simulation , vol. 4, no  1. 
URL : http://www.soc.surrey.ac.uk/JASSS/4/116.html. 

Baker G.  L.  et  Gollub  J.  P.  (1990),  Chaotic  dynamics  : an  introduction,  Cambridge 
University Press, Cambridge. 

Baia  V.  et  Gayal  S.  (1999),  A  non-cooperative  model  of  network  fom1ation, 
Econometrica, vol.  68, 1181-1230. 

Banks D.  L.  et Carley K.  M. (1994), Metric inference for social networks, Journal of 
Classification, vol.  11 , 121-149. 

Barabasi A. -L., Albert R. et Jeong H.  (1999), Mean-field theory for scale-free random 
networks, Physica A, vol.  272, 173-187. 
Borgatti  S.  P.,  Everett  M.  G.  et  Freeman  L.  C.  (2002),  UCINET  6 for  Windows, 
Software f or Social Network Analysis, Harvard, Analytic Technologies. 

163 

Borgatti  S.  P .,  Everett  M.  G .  et  Freeman  L.  C.  (2002),  UCJNET  6 fo r  Windows, 
Software fo r Social Network A nalysis, Harvard, Analytic Technologies. 

Blau P. M.  (1967), Exchange and power in social/ife, J. Wiley, New York. 

Brin  S.  et  Page  L.  (1 998),  The  anatomy  of a  large-scale  hypertextual  Web  search 
engine, Proceedings  of the  7'h  International  World  Wide  Web  Conference, Brisbane, 
Australie, avril,  1 07-117. 

Broder A.,  Kumar  R. , Maghoul  F.,  Raghavan P .,  Rajagopalan  S.,  Stata  R. ,  Tomkins 
A.  et Wiener J.  (2000) Compuler Networks, vol.  33, 309-320. 

Davis  J.  A.  (1967),  Clustering  and  structural  balance  in  graphs,  Human  Relations , 
vol. 20,  181-187. 

Donald  M.  (1993),  Cognitive  evolution  and 
Philosophy  of Science lecture Series. 

the  definition  of  human  nature, 

Dorogovtsev S.  N.  et Mendes J.F. F. (1999) Exactly solvabl e analogy of small-world 
networks, submitted to Physical Review Lellers. 

Dorogovtsev  S.  N.  et  Mendes  J.  F.  F.  (2000),  Evolution  of reference  networks  with 
aging, Physical Review E, vol.  62,  1842. 

Ellis  C.  A. ,  Gibbs  S.  J.  et  Rein  G.  L.  (1 99 1 ),  Groupware 
experiences, Communicalions ofLhe ACM, vo l.  34, no  1, 38-58. 

sorne  Issues  and 

Epstein  J.  M.  et  Axtell  R.  (1996),  Growing  arLijicial societies,  social  sciences fi'om 
Lhe  bollom up, MIT Press, Cambridge. 

Erdos P.  et Rényi A.  (1960), On the evolution  of random  graphs, Publications of the 
Mathematics Jnstilute of Hungarian Academy of Science , vol.  5, 17-6 1. 

Flache  A.  et  Hegselmann R.  (2001 ), Do  irregular grids  make  a  difference? Relaxing 
the  spatial  regularity  assumption  in  cellular  models  of social  dynamics,  Journal  of 
Artificial Socielies and Social Simulalion, vol.  4, no 4. 
URL : http://www. soc.suney.ac.uk/JASSS/4/4/6.html. 

Flache A. et Macy M.  W.  ( 1996), The weakness of strong ti es : collective action 
failure in a  highly cohesive group, Journal of Mathemalical Sociology, vol.  21 , 3-28. 

164 

Guare J.  (1990), Six Degrees ofSeparation: a play, Vintage, New York. 

Heider F.  (1958), The Psycho/ogy of lnterpersonal Relations, J.  Wiley, New York. 

Bolland  P.  W.  et  Leinhardt  S.  (1981 ),  An  exponential  family  of  probability 
distributions for directed graphs, Journal of the American Statistical Association, vol. 
76, 33-65. 

Hyatt A. , Contractor N.  et Jones P . M.  ( 1997), Computational organizational  network 
strategies  and  an  example,  Computational  and  Mathematical 
modeling 
Organizational Theory, vol.  4, 285-300. 

: 

Jackson M.  O.  (200 1 ), The  stability and  efficiency  of economie and  social networks, 
in  Models  of the  Formation  of Networks  and Groups, B.  Dutta  and  M.  O.  Jackson 
( eds. ), Springer-Verlag, Heidelberg. 

Jin  E.  M. ,  Girvan  M .,  Newman  M.  E.  J.  (2001 ),  The  structure  of growing  social 
networks, Working Papers 01-06-032, Santa Fe Institute. 

Jordan  K. ,  Hauser  J.  et  Poster  S.  (2003),  The  augmented  social  network:  Building 
identity and trust into the next-generation Internet, in First Monday , vol.  8, no 8. 
URL:  http://firstmonday.org/issues/issue8  8/ jordan/index.html. 

Kautz  H.,  Selman  B.  et  Shah  M.  (1997),  Referral  Web:  combining  social  networks 
and collaborative filtering, Communications of the ACM 40 (3). 

Kleinberg  J.  (1999),  The  small-world  phenomenon  :  an  algorithmic  perspective , 
Corne!!  University,  Computer  Science  Department,  Technical  Report  99-1776. 
http://www.cs.cornell.edu/home/kleinber/swn.ps. 

Kirsch  S.,  Gnasa  M .  et  Cremers  A.  (2006),  Beyond  the  Web:  retrieval  in  social 
information spaces, Proc.  28'11  European Conference on Information Retrieval. 

Korte  C.  et  Milgram  S.  (1970),  Acquaintance  linking  between  white  and  negro 
populations  :  application  of the  small  world  problem,  Journal  of Personality  and 
Social Psycho/ogy, vol.  15,  101 - 118. 

Lamy  C.  (2004 ), Les  logiciels  sociaux  : des  outils  qui  placent 1 ' individu  au  premier 
plan, Bulletin SJSTech.  URL : http://www. info metre.cefrio.qc.ca/loupe/sistech/0204.asp 

165 

Lazega E.  (1998), Réseaux sociaux et structures relationnelles, Paris, Que sais-je? No 
3399, PUF. 

Memmi  D.  et  Nérot  O.  (2003),  Building  virtual  commumt1es  for  information 
retrieval,  in  Groupware:  Design,  Implementation  and  Use,  Favela  et  Decouchant 
( eds ), Springer, Berlin. 

Milgram s. -(1967), The small world problem, Psycho/ogy Today, vol.  2, 60- 67. 

Mosler  H.-J.  et  Brucks  W.  (2001),  Social  influence  among  agents,  in  Cooperative 
Agents, Application  in  the  Social  Sciences, N.  J.  Saam  et B.  Schmidt  (eds), Kluwer, 
Amsterdam,  125-147. 

Mutton  P.  (2004),  Inferring  and  visualizing  social  networks  on  Internet  relay  chat, 
Proc Information  Visualization, IEEE Computer Society, London, UK. 

Myerson R.  B.  (1977), Graphs and  cooperation in  games, Mathematics of Operations 
Research, vol.  2, 225-229. 

Newcomb T. M. (1968), Interpersonal  balance, in  Theories of Cognitive Consistency: 
A Sourcebook, R.  P.  Abelson et al.  (eds.), Rand-McNally, Chicago, 28-51. 

Newman  M.  E.  J.  (1999),  Srnall  worlds:  the structure  of social  networks,  Working 
Papers 99-12-080, Santa Fe Institute. 

Newman  M.  E.  J.  (2001),  Clustering  and  preferential  attachment  m  growmg 
networks, Physical Review E. 

Nonaka  l.  (1991),  The  knowledge-creating  company,  Harvard  business  review, 
November-December. 

Nowak A.  et Vallacher R.  R.  (1998), Dynarnical social psycho/ogy,  Gui ldford Press, 
New York. 

Peyton  Young H.  ( 1998), lndividual  strate gy and social structure  :  an  evolutionary 
theory of institutions, Princeton University Press, Princeton. 

Poulin  I.  (2004),  Combiner  technologies  de  l' information  et  innovation  d' affaires 
pour augmenter la productivité, Bulletin SISTech, 13  février 2004. 
URL: http://www.infometre.cefrio.gc.ca/loupe/s istech/0204.asp#bas 

166 

Slikker M.  et  Van  Den Nouweland  A.  (2001),  A  one-stage  mode]  of link  formation 
and payoff division, Games and Economie Behavior, vol. 34, 153-175 . 

Snijders  T.  A.  B.  (1996),  Stochastic  actor-oriented  models  for  network  change, 
Journal of Mathematical Sociology, vol 21, 57-76. 

Stokman  F.  N.  et  Van  Oosten  R.  (1994),  The  exchange  of voting  positions  :  an 
object-oriented  model  for  policy  networks,  in  European  Community  Decision 
Making.  Models,  applications,  and  comparisons,  B.  Bueno  de  Megsuita  et  F.  N. 
Stokman (eds.), Yale University Press, New Haven, 105-127. 

Stokman  F.  N.  et  Zeggelink  E.  (1996),  Is  politics  power  or  policy  oriented?  A 
comparative  analysis  of  dynamics  access  models  in  policy  networks,  Journal  of 
Mathematical Sociology, vol. 21, 77-111 . 

Van Duijn M.  et Snijders T.  A.  B.  (1995), The  P2  Mode!, Internai  publication, VSM, 
University of Groningen. 

Viegas  F.,  Boyd  D.,  Nguyen  D.,  Potter  J.  et  Donath  J.  (2004),  Digital  artifacts  for 
remembering  and  storytelling 
fragments , 
Proceedings  of the  37th  Hawaii  International  Conference  on  System  Sciences, 
janvier, 401 09a. 

:  posthi story  and 

social  network 

Wasserman  S.  et  Pattison  P.  (1996),  Logistic  models  and  logistic  regressions  for 
social  networks  : An  introduction  to  Markov  graphs  and  p* , Psychometrika, vol.  61 , 
401-425 . 

Wassermann  S.  et  Faust  K.  (1994 ),  Social  Network  Analysis:  Methods  and 
Applications, Cambridge University Press, Cambridge. 

Watts  D.  et  Strogatz  S.  H.  (1998),  Collective  Dynamics  of small  world  networks, 
Nature, vol.  393, 440. 

Watts D.  J.  (1999) Small Worlds, Princeton University Press, Princeton, NJ. 

Wolfram  S.  (1986),  The ory and Applications of Cellular A ut amata, World  Scientist, 
Singapore. 

Zeggelink  E.  (1993),  Strangers  into  Friends,  The  evolution  of friendship  networks 
using an  individual oriented modeling approach,  Thesis Pub1ishers, Amsterdam. 

