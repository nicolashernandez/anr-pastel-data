https://www.theses.fr/2017CERG0842.pdf

T H È S E

pour obtenir le titre de

Docteur de

de l'Université de Cergy Pontoise

Spécialité : Sciences et Technologies de l'Information

et de la Communication STIC

présentée et soutenue par

Jean-Philippe ATTAL

Nouveaux algorithmes pour la détection de

communautés disjointes et chevauchantes

basés sur la propagation de labels et adaptés

aux grands graphes

date de soutenance 19 janvier 2017

Le jury est composé de :

Rapporteur M. Arnaud MARTIN
Rapporteur M. Guy MELANÇON
Examinateur M. Henry SOLDANO
Directeur
Examinateur Mme. Maria MALEK
Examinateur M. Dominique Laurent

M. Marc ZOLGHADRI

1 Résumé

Les graphes sont des structures mathématiques capables de modéliser certains systèmes com-
plexes. Une des nombreuses problématiques liées aux graphes concerne la détection de communau-
tés qui vise à trouver une partition en sommet d'un graphe en vue d'en comprendre la structure.
A titre d'exemple, en représentant des contrats d'assurances par des n÷uds et leurs degrés de
similarité par une arête, détecter des groupes de n÷uds fortement connectés conduit à détecter
des prols similaires, et donc à voir des prols à risques. De nombreux algorithmes ont essayé
de répondre à ce problème. Une des méthodes est la propagation de labels qui consiste à ce que
chaque n÷ud puisse recevoir un label par un vote majoritaire de ses voisins. Bien que cette mé-
thode soit simple à mettre en ÷uvre, elle présente une grande instabilité due au non déterminisme
de l'algorithme et peut dans certains cas ne pas détecter de structures communautaires.

La première contribution de cette thèse sera de i) proposer une méthode de stabilisation
de la propagation de labels tout en appliquant des barrages articiels pour limiter les possibles
mauvaises propagations. Les réseaux complexes ont également comme caractéristique que certains
n÷uds puissent appartenir à plusieurs communautés, on parle alors de recouvrements. C'est en ce
sens que la seconde contribution de cette thèse portera sur ii) la création d'un algorithme auquel
seront adjointes des fonctions d'appartenances pour détecter de possibles recouvrements via des
n÷uds candidats au chevauchement. La taille des graphes est également une notion à considérer
dans la mesure où certains réseaux peuvent contenir plusieurs millions de n÷uds et d'arêtes. Nous
proposons iii) une version parallèle et distribuée de la détection de communautés en utilisant la
propagation de labels par c÷ur. Une étude comparative sera eectuée pour observer la qualité de
partitionnement et de recouvrement des algorithmes proposés.

Table des mati`eres

Introduction g´en´erale

0.1 Des r´eseaux complexes aux structures communautaires . . . . . .
0.2 Objectif de la th`ese et plan du manuscrit
. . . . . . . . . . . . .
0.3 Graphes utilis´es . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1 Etat de l’art

disjointes

1.1
1.2 Notions et notations relatives `a la th´eorie des graphes

Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . .
1.2.1 Repr´esentation d’un graphe . . . . . . . . . . . . . . . . .
1.2.2 Centralit´e dans un graphe . . . . . . . . . . . . . . . . . .
1.2.3 Analyse des r´eseaux sociaux et graphes de terrains . . . .
1.3 D´etection de communaut´es disjointes . . . . . . . . . . . . . . . .
1.3.1 Formulation du probl`eme de d´etections de communaut´es
. . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3.2 Approches divisives
. . . . . . . . . . . . . . . . . . . . .
1.3.3 Approches agglom´eratives et multi-niveaux . . . . . . . .
1.3.4 Approches fond´ees sur la d´etection de leaders . . . . . . .
1.3.5 Approches fond´ees sur la perturbation du r´eseau . . . . .
1.3.6 Approche par propagation de labels
. . . . . . . . . . . .
1.3.7 Autres m´ethodes . . . . . . . . . . . . . . . . . . . . . . .
1.3.8 Tableau r´ecapitulatif des m´ethodes disjointes . . . . . . .
1.3.9 Mesures supervis´ees et non supervis´ees pour la d´etection
. . . . . . . . . . . . . . . . .
1.3.10 Synth`ese et discussion . . . . . . . . . . . . . . . . . . . .
1.4 D´etection de communaut´es chevauchantes . . . . . . . . . . . . .
1.4.1 Formulation du probl`eme de d´etection de communaut´es
chevauchantes . . . . . . . . . . . . . . . . . . . . . . . . .
1.4.2 D´etection de communaut´es chevauchantes `a base de pro-
. . . . . . . . . . . . . . . . . . . . . .
1.4.3 Autres m´ethodes pour la d´etection de communaut´es che-
. . . . . . . . . . . . . . . . . . . . . . . . . .
1.4.4 Tableau r´ecapitulatif des m´ethodes chevauchantes
. . . .
1.4.5 Mesures supervis´ees et non supervis´ees pour la d´etection
de communaut´es chevauchantes . . . . . . . . . . . . . . .

de communaut´es disjointes

pagation de labels

vauchantes

1

7
8
11
12

15
16
16
18
18
20
23

24
26
30
33
34
36
43
46

49
56
58

58

59

61
64

65

2

TABLE DES MATI `ERES

1.4.6

Synth`ese et discussion . . . . . . . . . . . . . . . . . . . .

70

2 Parall´elisme et distribution

graphes

2.2 Plateformes parall`eles et distribu´ees

2.1 Probl´ematique de la d´etection de communaut´es dans de grands
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . .
2.2.1 Hadoop . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2.2 Apache Spark . . . . . . . . . . . . . . . . . . . . . . . . .
2.2.3
Syst`eme de traitement de graphes parall`eles . . . . . . . .
2.3 D´etection de communaut´es dans un environnement parall`ele et
distribu´e . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4 Tableau r´ecapitulatif des m´ethodes parall`eles et distribu´ees
. . .
2.5 Synth`ese et discussion . . . . . . . . . . . . . . . . . . . . . . . .

3 Propositions algorithmiques

3.1 LPA avec barrages et dendrogrammes

. . . . . . . . . . . . . . .
3.1.1 Propagation de labels asynchrone avec barrages . . . . . .
3.1.2 Propagation de labels asynchrone avec barrages et d´etection
. . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.3 Exp´erimentations portant sur les propositions algorith-
miques pour la d´etection de communaut´es disjointes . . .
3.1.4 Conclusion sur les algorithmes de propagation de labels

de cœurs

73

73
74
74
75
77

80
85
86

87
88
89

91

98

. . . . . . . . . . . . 121
3.2 LPA avec coloration . . . . . . . . . . . . . . . . . . . . . . . . . 123

avec barrages et d´etection de cœurs

3.2.1 Propagation de labels asynchrone avec d´etection de cœurs

et coloration . . . . . . . . . . . . . . . . . . . . . . . . . 123
3.2.2 Exp´erimentation sur R-POP, POP-UP et POP-DOWN . 125
3.2.3 Conclusion sur les propositions algorithmiques `a base de

3.3 Analyse comparative des m´ethodes disjointes
3.4 Propositions sur le chevauchement

coloration . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
. . . . . . . . . . . 137
. . . . . . . . . . . . . . . . . 141

3.4.1 De la propagation de labels avec d´etection de cœurs au

chevauchement . . . . . . . . . . . . . . . . . . . . . . . . 141
3.4.2 Fonction d’appartenance . . . . . . . . . . . . . . . . . . . 142
3.4.3 Propositions algorithmiques . . . . . . . . . . . . . . . . . 145
3.4.4 Exp´erimentations sur CDLPOV . . . . . . . . . . . . . . . 147
3.4.5 Etude portant sur le temps d’ex´ecution . . . . . . . . . . 155
3.4.6 Analyse comparative . . . . . . . . . . . . . . . . . . . . . 156
3.4.7 Conclusion sur les propositions algorithmiques chevau-

chantes

. . . . . . . . . . . . . . . . . . . . . . . . . . . . 158

4 Propositions sur le parall´elisme et la distribution

159
4.1 Propagation de labels avec d´etection de cœurs avec Apache Hadoop160

4.1.1 Proposition algorithmique pour la propagation de labels

parall`ele et distribu´ee avec d´etection de cœurs . . . . . . . 161
4.1.2 Mod´elisation MapReduce de PAR-CDLP . . . . . . . . . 161

TABLE DES MATI `ERES

3

4.1.3 Cr´eation d’un dendrogramme . . . . . . . . . . . . . . . . 171
4.2 Exp´erimentations . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
4.2.1 Etude de la stabilisation . . . . . . . . . . . . . . . . . . . 173
4.2.2 Etude sur de grands graphes de terrains . . . . . . . . . . 174
4.2.3 Etude volum´etrique trait´ee par le HDFS . . . . . . . . . . 183

4.3 Conclusion portant sur les propositions li´ees au parall´elisme et la

distribution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186

5 Conclusion

187
5.1 Contributions algorithmiques . . . . . . . . . . . . . . . . . . . . 188
5.2 Perspectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189

6 Glossaire

6.1 D´eﬁnitions relatives aux graphes

191
. . . . . . . . . . . . . . . . . . 191

Bibliographie

195

Remerciements

Cette th`ese m’a permis d’acqu´erir une tr`es grande ouverture d’esprit dans

le monde de la recherche.

Je remercie Madame Maria Malek, qui m’a toujours soutenu, aid´e, conseill´e
et prot´eg´e au cours de cette th`ese. Madame Maria Malek m’a transmis son sa-
voir et m’a initi´e `a la recherche scientiﬁque. Madame Maria Malek a toujours
fait preuve d’une grande gentillesse `a mon ´egard. Je n’aurais jamais pu r´eussir
cette th`ese sans elle.

Je remercie Monsieur Dominique Laurent, qui a toujours ´et´e `a mon ´ecoute et
m’a soutenu. Ses conseils et sa tr`es grande gentillesse m’ont permis d’accomplir
ce travail de doctorat.

Je remercie Monsieur Marc Zolghadri pour avoir accept´e de diriger cette
th`ese. Par ses conseils, sa grande gentillesse, et son enthousiasme, Monsieur
Marc Zolghadri m’a aid´e `a toujours am´eliorer mon travail scientiﬁque.

Je remercie Monsieur Arnaud Martin d’avoir accept´e d’ˆetre rapporteur de
cette th`ese. Monsieur Arnaud Martin m’a beaucoup aid´e `a am´eliorer mon travail
scientiﬁque au cours des diﬀ´erentes conf´erences auxquelles nous avons assist´e en-
semble. Ses remarques et observations sur le manuscrit m’ont beaucoup aid´e.

Je remercie Monsieur Guy Melan¸con d’avoir accept´e d’ˆetre rapporteur de
cette th`ese. Ses analyses critiques et son exp´erience m’ont permis d’am´eliorer
ce travail doctoral.

Je remercie Monsieur Henry Soldano d’avoir accept´e d’ˆetre examinateur de
cette th`ese. Les questions que Monsieur Henry Soldano a pos´ees durant les
diﬀ´erentes conf´erences auxquelles nous assistions m’ont permis de faire ´evoluer
mon travail, de l’am´eliorer, et d’ouvrir de nouvelles perspectives scientiﬁques.

Je remercie Monsieur Chrysostome Baskiotis qui m’a enseign´e, lorsque j’´etais
´etudiant, le langage Python qui me fut tr`es utile dans la r´ealisation du travail
doctoral.

5

6

TABLE DES MATI `ERES

Je remercie Monsieur Nesim Fintz pour m’avoir aid´e ﬁnanci`erement durant

cette th`ese et de sa grande gentillesse.

Je remercie tous mes coll`egues de l’EISTI qui m’ont toujours aid´e et soutenu

durant mon travail doctoral.

Je remercie tous mes amis de m’avoir aid´e et soutenu.

Je remercie ma famille et mes parents, qui m’ont toujours soutenu et aid´e au
cours de ma vie et durant ce travail doctoral. C’est `a eux que je d´edie ma th`ese.
Je n’aurais jamais r´eussi sans leur soutien. J’ai une pens´ee pour mes grands-
parents, qui ont contribu´e `a mon ´education et qui m’ont guid´e dans ma vie.

Introduction

De nombreux syst`emes r´eels sont repr´esent´es `a l’aide de graphes. Des entit´es
peuvent ˆetre mod´elis´ees par des sommets et leurs relations par des arˆetes. Il
existe de nombreux domaines et champs d’application utilisant la structure de
graphe (graphes sociologiques, graphes de collaborations, r´eseaux biologiques
(interactions prot´eine-prot´eine, r´eseaux de neurones, r´eseaux de g`enes), r´eseaux
sportifs, r´eseaux du web (graphes de pages web connect´ees), r´eseaux de trans-
ports, r´eseaux de co-achats,etc). Ces graphes portent le nom de graphes de
terrains ou de r´eseaux complexes.

L’´etude et l’analyse de ce genre de graphes r´ev´elent des informations sur les
acteurs et expliquent la structure mˆeme du r´eseau. Parmi les nombreuses appli-
cations li´ees aux graphes, on peut citer la d´etection de communaut´es qui vise `a
trouver au sein d’un graphe des groupes de noeuds fortement connect´es entre
eux et faiblement avec le reste du graphe. La d´etection de communaut´es per-
met de trouver les individus d’une population les plus similaires en fonction
de leurs relations. Par exemple, dans le domaine des assurances, consid´erer les
contrats d’assurances comme des noeuds et leurs relations comme leurs degr´es
de similarit´e permet de trouver des groupes de contrats similaires, d’oﬀrir des
communaut´es `a ´etudier pour en comprendre les relations, et de cr´eer un mod`ele
de score pour les nouveaux clients. Dans le r´eseau web, o`u les sommets sont
des pages web et les arˆetes des hyperliens, des groupes de pages ou de sites
fortement connect´es traitent souvent de th`emes apparent´es et la d´etection de
communaut´es permet l’am´elioration des moteurs de recherche. En consid´erant
le r´eseau de neurones du ver Caenorhabditis elegans, ´etudier l’organisation des
liaisons et l’existence de structures communautaires peut permettre de com-
prendre si la formation des synapses entre neurones se fait de mani`ere al´eatoire
ou non, ce qui peut avoir en biologie et en m´edecine de grandes r´epercussions,
notamment en neurochirurgie. En marketing, grˆace `a un graphe de co-achats o`u
les sommets repr´esentent les produits et les arˆetes le fait que les produits ont
´et´e achet´es ensemble, un algorithme de d´etection de communaut´es permettra
de trouver les proﬁls des produits les plus co-achet´es pour les analyser, en vue
de proposer un syst`eme de recommandation (utilis´e par exemple par la soci´et´e
Amazon).

La d´etection de communaut´es pr´esente trois challenges :

7

8

INTRODUCTION

Le premier est que les tailles des communaut´es peuvent ˆetre diﬀ´erentes au sein
d’un mˆeme graphe selon la nature des objets ´etudi´es. Par exemple, dans la sec-
tion livres d’Amazon, les tailles des communaut´es seront plus grandes pour les
livres dont le th`eme est fantastique que pour ceux dont le th`eme est historique.
On peut observer ce ph´enom`ene en utilisant le site http : //www.yasiv.com/.
Le second est que certains nœuds du graphe peuvent appartenir `a plusieurs com-
munaut´es. Par exemple, dans un r´eseau de collaboration scientiﬁque, un auteur
peut publier dans diﬀ´erents domaines et champs scientiﬁques.
Le troisi`eme challenge concerne la taille des graphes. Si l’on consid`ere de nou-
veau le graphe Amazon, qui poss`ede plusieurs millions de nœuds et plusieurs
centaines de millions d’arˆetes, appliquer un algorithme de d´etection de commu-
naut´es sur une seule machine peut dans le meilleur des cas prendre plusieurs
heures, au pire, une erreur m´emoire peut survenir due `a la quantit´e de donn´ees
traˆıt´ees.

0.1 Des r´eseaux complexes aux structures com-

munautaires

Un graphe de terrain (ou r´eseau complexe) est un r´eseau constitu´e de donn´ees
collect´ees correspondant `a une v´erit´e de terrain. Il est r´ealis´e par des experts.
Un graphe de terrain a des caract´eristiques topologiques non triviales. Ces
caract´eristiques, qui n’apparaissent pas dans les graphes simples ou graphes
al´eatoires, ´emergent lors de la mod´elisation de syst`emes r´eels. Ces r´eseaux
mettent en exergue un ensemble d’individus, d’organisations ou d’objets reli´es
par des interactions sociales r´eguli`eres ou incontestables. L’un des premiers ayant
travaill´e sur les relations humaines `a travers les graphes fut Moreno (1934) qui
publia ”Who shall survive ?”. Il ´etudie les aﬃnit´es entre ´el`eves de classes de
divers degr´es, repr´esent´es sous forme de sociogramme, posant ainsi les bases de
la sociom´etrie. L’auteur explique par la suite l’importance de l’utilisation des
graphes comme outils d’analyse sociologique, Moreno (1951).

C’est `a Barnes (1954) que l’on doit le terme analyse des r´eseaux sociaux.
Il porta son analyse sur un cas particulier de r´eseaux de terrains, les r´eseaux
sociologiques. Wasserman et Faust (1994) ´ecrivirent un livre sur les m´ethodes
appliqu´ees aux r´eseaux sociaux qui allaient ouvrir de tr`es nombreuses portes
comme celles du partitionnement de graphe et plus tard, la d´etection de com-
munaut´es. Wasserman d´ecrit un r´eseau social comme ´etant un ensemble ﬁni
d’acteurs avec des relations d´eﬁnies entre eux. La notion de graphes de terrains
s’est construite au fur et `a mesure d’analyses concernant des syst`emes r´eels, en
liaison avec les r´eseaux sociaux.

Les premi`eres ´etudes utilisant les r´eseaux sociaux port`erent sur l’aspect relation-
nel entre personnes, Murdock (1949) et Lowie (1950). A travers un graphe social,
l’objectif ´etait d’expliquer les relations entre individus et comment les liens pou-

0.1. DES R ´ESEAUX COMPLEXES AUX STRUCTURES COMMUNAUTAIRES9

vaient se former. Elles suivent les ´etudes de Davis et al. (2009) sur l’aspect com-
portemental et relationnel entre individus en fonction de certains ´ev`enements.
Les ´etudes portaient sur le fait de savoir si des personnes de mˆeme cat´egorie
sociale allaient entrer en relation ou non. C’est en 1950 que les premi`eres ´etudes
portant sur les questions de groupes d’individus furent lanc´ees par Homans
(1950). Il exposa des exemples de groupes au sein de graphes sociaux. Ses tra-
vaux furent continu´es par Nadel (1957) qui montra l’existence de structures
sociales intrins`eques aux r´eseaux r´eels. Les premi`eres ´etudes des structures de
groupes au sein du graphe furent propos´ees par Glanzer et Glaser (1961). Les
m´ethodes ´etaient bas´ees sur des graphes de communication. Les premiers tra-
vaux concernant la possibilit´e qu’un noeud d’un graphe social puisse apparte-
nir `a plusieurs groupes de noeuds furent introduits par Bonacich (1972) qui
utilisa la topologique des graphes pour en exposer l’existence. Breiger (1974)
proposa de dissocier les arˆetes dans un groupe de noeuds tr`es connect´es de
celles sortant de ces structures. L’id´ee fut d’expliquer les groupes de noeuds
`a travers les arˆetes et de mettre une voix `a la d´etection de telles structures.
L’existence de structures de noeuds dens´ement connect´es entre eux et faible-
ment avec le reste du graphe fut expos´ee par Newman, qui employa le terme de
communaut´es pour d´eﬁnir ces groupes de noeuds. Il montra que la pr´esence de
structures communautaires ´etait une caract´eristique des r´eseaux complexes. Des
´etudes men´ees notamment par Barab´asi et Bonabeau (2003), Newman (2003)
et Clauset et al. (2009a) ont essay´e de recenser les caract´eristiques communes
des r´eseaux complexes. Les caract´eristiques portent sur l’eﬀet ”petit monde” (le
fait que chaque individu puisse ˆetre reli´e `a n’importe quel autre par une courte
chaˆıne de relations sociales), un fort nombre de triangles entre groupes de noeuds
fortement connect´es et une distribution des degr´es suivant une loi faible. Une
´etude portant sur les m´ethodes de d´etections de communaut´es fut propos´ee par
Fortunato (2010). Il y r´ef´erence plus d’une cinquantaine de m´ethodes (la liste
n’est pas exhaustive) qu’il classiﬁe selon leurs techniques de partitionnement.
Ainsi, l’auteur montre les algorithmes spectraux, les m´ethodes hi´erarchiques, les
m´ethodes d’optimisation d’une fonction de qualit´e appel´ee la modularit´e et les
autres m´ethodes, notamment celles concernant le recouvrement, o`u un noeud
peut appartenir `a plusieurs communaut´es. Le choix de cette classiﬁcation n’est
pas absolu. L’´etude nous oﬀre plusieurs conclusions `a retenir. Tout d’abord,
beaucoup de m´ethodes issues du partitionnement de graphes (d´ecoupage du
graphe en groupes de noeuds de mˆeme taille dont le nombre est donn´e par l’utili-
sateur, chaque noeud appartenant `a un et un seul groupe) avaient ´et´e appliqu´ees
ou transform´ees pour la d´etection de communaut´es. Parmi ces m´ethodes, citons
celles portant sur l’optimisation d’une mesure de qualit´e qui est la modularit´e.
Une ´etude men´ee par Brandes et al. (2008) montre que l’optimisation de la
modularit´e est NP-diﬃcile. D`es lors, les m´ethodes d’optimisation de la modu-
larit´e ne peuvent s’eﬀectuer qu’`a une ´echelle locale si l’on veut pouvoir traiter
des graphes de plusieurs millions de noeuds et d’arˆetes. L’´etude de Fortunato
montre bien que les heuristiques les plus utilis´ees reposent sur les principes de
classiﬁcation hi´erarchique, qui est subdivis´ee en deux cat´egories :

— les m´ethodes ascendantes (agglom´eratives) : partant des noeuds du graphe

10

INTRODUCTION

(ensembles de singletons), o`u les algorithmes fusionnent deux classes `a
chaque it´eration en optimisant une certaine fonction de qualit´e.

— les m´ethodes descendantes (de subdivision), dans lesquelles on consid`ere
la topologie du graphe dans son entier pour y appliquer une coupe. A
chaque it´eration, le graphe est scind´e en deux, donnant deux sous-classes
disjointes dont la coupe donne le score le plus ´elev´e `a une certaine fonction
de qualit´e.

Ces deux familles de m´ethodes produisent une hi´erarchie de communaut´es,
que l’on appelle dendrogramme 6.1. Cependant, Fortunato (2010) a montr´e que
ces m´ethodes n’avaient pas le mˆeme ordre de grandeur en termes de complexit´e.
Les m´ethodes descendantes ont une complexit´e bien plus ´elev´ee que les m´ethodes
ascendantes car elles consid`erent le graphe dans son entier pour faire la coupe.
La coupe optimale n´ecessite de tester plusieurs possibilit´es, parfois de migrer
certains noeuds dans d’autres communaut´es comme le fait le recuit-simul´e (Gui-
mera et Amaral (2005)) maximisant la modularit´e, mais ne permettant l’appli-
cation qu’`a des graphes de quelques dizaines de milliers de noeuds en un temps
raisonnable. Ces m´ethodes sont d´eterministes.

Les m´ethodes ascendantes, dont les calculs sont bas´es sur le voisinage des
noeuds, demandent beaucoup moins de calculs, et permettent de traiter des
graphes de plus grandes tailles. Les m´ethodes ascendantes sont non-d´eterministes
alors que les m´ethodes descendantes le sont. Ces conclusions se retrouvent dans
d’autres ´etudes comparatives telles que Planti´e et Crampes (2013), Papado-
poulos et al. (2012) ou Yang et Leskovec (2012). Les m´ethodes pr´ec´edemment
cit´ees oﬀrent la possibilit´e de partitionner un graphe en sous-groupes de noeuds
disjoints, cependant, elles ne permettent pas de cr´eer de recouvrements, o`u
des noeuds peuvent appartenir `a plusieurs communaut´es. C’est pourtant une
caract´eristique qui fut remarqu´ee pour les graphes de terrain. Par exemple,
en biologie, des recherches actuelles s’eﬀectuent sur des r´eseaux d’interactions
prot´eine-prot´eine pour permettre, entre autres, de pr´edire leurs fonctions. Ce-
pendant, des prot´eines peuvent poss´eder plusieurs fonctions, il est ainsi utile de
construire des recouvrements, c’est `a dire un syst`eme de classes chevauchantes,
pour connaˆıtre les fonctions des prot´eines suivant les diﬀ´erents tissus.

Parmi les nombreuses m´ethodes de d´etection de communaut´es, la propaga-
tion de labels (Raghavan et al. (2007)) est celle qui est la plus rapide et celle
permettant de traiter les plus grands graphes. Elle pr´esente cependant certains
inconv´enients. C’est une m´ethode bas´ee sur le vote majoritaire des voisins d’un
noeud pour la propagation de labels, ainsi, en cas d’´equidistribution des labels
majoritaires, la m´ethode est sujette au non d´eterminisme. Il a ´et´e ´egalement
not´e que certaines mauvaises propagations pouvaient donner des communaut´es
ayant le mˆeme label. Enﬁn, l’aspect asynchrone de la m´ethode, c’est `a dire le
fait que chaque noeud du graphe doive connaˆıtre le label courant de ses voisins
en fait une m´ethode diﬃcile `a parall´eliser. La propagation de labels constituera
le socle algorithmique de nos contributions scientiﬁques.

0.2. OBJECTIF DE LA TH `ESE ET PLAN DU MANUSCRIT

11

0.2 Objectif de la th`ese et plan du manuscrit

Les ´etudes comparatives men´ees par Fortunato ont montr´e l’existence de
nombreuses m´ethodes dont les principales sont soit divisives, soit agglom´eratives.
Il a ´et´e observ´e que les m´ethodes locales, c’est-`a-dire dont le point de d´epart
est atomique (par le noeud), permettaient de traˆıter de plus grands graphes que
les m´ethodes divisives. La propagation de labels est une m´ethode locale, qui
pr´esente l’avantage d’ˆetre rapide et applicable `a des graphes de plusieurs mil-
lions de noeuds et d’arˆetes mais elle a certains inconv´enients. C’est en ce sens
que notre premi`ere contribution sera i) de proposer une version am´elior´ee de la
propagation de labels en y incluant une stabilisation par recherche de coeurs et
mise en place de barrages artiﬁciels pour ´eviter de mauvaises propagations. La
seconde contribution ii) sera d’am´eliorer la m´ethode pr´ec´edente pour le chevau-
chement en y incluant une fonction d’appartenance permettant de d´etecter des
noeuds pouvant appartenir `a plusieurs communaut´es. Plusieurs fonctions d’ap-
partenance bas´ees sur la densit´e et le coeﬃcient de clustering seront propos´ees en
vue d’une ´etude comparative. Enﬁn, nous proposerons iii) une impl´ementation
MapReduce de notre propagation de labels pour travailler sur de plus grands
graphes ayant au moins plusieurs millions de noeuds et d’arˆetes. La propagation
de labels dans sa forme asynchrone pr´esente une diﬃcult´e pour le parall´elisme
`a laquelle nous r´epondrons.

Dans la suite du manuscrit, nous pr´esenterons au chapitre 1 la probl´ematique
de la d´etection de communaut´es disjointes et chevauchantes, les m´ethodes exis-
tantes pour la r´esolution de ces probl`emes et les mesures sur la qualit´e de parti-
tionnement qui y sont associ´ees. Le chapitre 2 traitera des m´ethodes parall`eles
et distribu´ees de la litt´erature avec les plateformes destin´ees au traitement de
grands graphes. Le chapitre 3 pr´esentera notre contribution `a la d´etection de
communaut´es disjointes et chevauchantes.
Le chapitre 4 donnera une impl´ementation Hadoop parall`ele et distribu´ee d’un
de nos algorithmes pour la d´etection de communaut´es disjointes, ouvrant la
voie `a l’´elaboration d’une impl´ementation pour le chevauchement. Enﬁn, nous
pr´esenterons nos conclusions au chapitre 5, nos travaux de recherches actuels et
nos perspectives.

12

INTRODUCTION

0.3 Graphes utilis´es

Pour tester la qualit´e de nos algorithmes, et dans la mesure o`u nous voulons
que nos algorithmes soient ´echelonnables selon l’ordre et la taille du graphe, le
tout en r´epondant aux probl´ematiques des grands graphes, nous proposons de
travailler sur les r´eseaux r´eels, plus exactement sociaux.

Nous utilisons des graphes issus de la litt´erature dont nous connaissons par
avance les communaut´es pour tester nos propositions algorithmiques et ´etudier
leur comportement. Nous pouvons les retrouver sur le site
https : //snap.stanf ord.edu/snap/. Une ´etude comparative pourra ensuite ˆetre
propos´ee avec les algorithmes les plus connus de la litt´erature. Les r´eseaux pour
notre ´etude concernent :

Le club de karat´e de Zachary, Zachary (1977) (Zac) : un r´eseau de membres
d’un club chez lesquels une dispute entraine la formation de deux communaut´es
autour du manager et de l’entraˆıneur.
Un r´eseau de dauphins, Lusseau et al. (2003) (Dol) : un graphe de dauphins
´etudi´e `a Doubtful Sound, en Nouvelle Z´elande. Le graphe comprend 62 dauphins
repr´esent´es en deux communaut´es, mˆales et femelles.
Un r´eseau footballistique, Girvan et Newman (2002a) (Foot) un graphe ex-
posant 11 diﬀ´erentes comp´etitions entre clubs de football am´ericain.
Un r´eseau de livres politiques am´ericains, Krebs (2004) (pol) un graphe de
co-achat exposant les livres politiques ´edit´es en 2004 et vendus sur Amazon.com.
Le graphe comprend 3 communaut´es, les D´emocrates, les R´epublicains et les
neutres.
Un r´eseau de musiciens de jazz, Gleiser et Danon (2003), o`u chaque noeud
repr´esente un musicien, une arˆete d´enotant que deux musiciens ont jou´e en-
semble dans un groupe.
Le r´eseau a´eroportuaire am´ericain de 1997, Batagelj et Mrvar (2006), o`u
les noeuds sont des a´eroports et les liens sont des lignes directes .
Le r´eseau d’Amazon, Yang et Leskovec (2015), qui est un graphe de co-achat
o`u les noeuds sont des produits (livres, vid´eos, CD de musique,etc). Un lien est
mis entre le produit i et le produit j si les deux produits sont fr´equemment
achet´es ensemble.
Le r´eseau de collaborations scientiﬁques DBLP, Yang et Leskovec (2015),
o`u les auteurs de publications scientiﬁques sont li´es s’ils sont co-auteurs.
Le r´eseau de vid´eos You tube, Yang et Leskovec (2015), o`u les noeuds
sont des utilisateurs qui peuvent former des groupes auxquels s’agglom`erent de
nouveaux utilisateurs. Les groupes de noeuds sont caract´eris´es par des th`emes
sociaux.
Le r´eseau social LiveJournal, Yang et Leskovec (2015) est une communaut´e
de blogs en ligne gratuite, o`u les utilisateurs se d´eclarent leur amiti´e, formant
ainsi des liens. Les utilisateurs penvent ´egalement former des groupes sur des
th`emes auxquels d’autres utilisateurs peuvent se joindre.
Les caract´eristiques des graphes sont expos´ees sur le tableau 1.

0.3. GRAPHES UTILIS ´ES

13

Caract´eristiques de certains r´eseaux r´eels

densit´e
0,139
0,0938
0,0841
0,0808
0,281
0.038
0,0021
1,65e − 05
2,08e − 05
4,3e − 06
4,3e − 06

diam`etre

5
4
8
7
6
6
17
44
21
20
17

AT

0,2557
0,4072
0,3088
0,3484
0,52
0.0

0,6934
0,3967
0,6324
0,0808
0,2843

r´eseaux
Zachary
Football
Dauphins
Politique
Jazz
US-Air 97
Netscience
Amazon
DBLP
You tube
LiveJournal

|V | et |E|
34 \ 78
115 \ 615
62 \ 159
105 \ 441
198 \ 5 484
332 \ 2126
1 589 \ 2 742

334 863 \ 925 872
317 080 \ 1 049 866
1 134 890 \ 2 987 624
3 997 962 \ 34 681 189

Tableau 1 – Caract´eristiques des r´eseaux utilis´es fr´equemment pour les ´etudes algo-
rithmiques avec AT, pour la transitivit´e moyenne. |V | est le nombre de noeuds du
graphe et |E|, le nombre d’arˆetes.

14

INTRODUCTION

Chapitre 1

Etat de l’art

Introduction . . . . . . . . . . . . . . . . . . . . . .

Sommaire
16
1.1
1.2 Notions et notations relatives `a la th´eorie des graphes 16
18
18
20
23

1.2.1 Repr´esentation d’un graphe . . . . . . . . . . . . . .
1.2.2 Centralit´e dans un graphe . . . . . . . . . . . . . . .
1.2.3 Analyse des r´eseaux sociaux et graphes de terrains .

1.3 D´etection de communaut´es disjointes . . . . . . .
1.3.1 Formulation du probl`eme de d´etections de commu-

naut´es disjointes . . . . . . . . . . . . . . . . . . . .
1.3.2 Approches divisives
. . . . . . . . . . . . . . . . . .
1.3.3 Approches agglom´eratives et multi-niveaux . . . . .
1.3.4 Approches fond´ees sur la d´etection de leaders . . . .
1.3.5 Approches fond´ees sur la perturbation du r´eseau . .
1.3.6 Approche par propagation de labels
. . . . . . . . .
1.3.7 Autres m´ethodes . . . . . . . . . . . . . . . . . . . .
1.3.8 Tableau r´ecapitulatif des m´ethodes disjointes . . . .
1.3.9 Mesures supervis´ees et non supervis´ees pour la d´etection

24
26
30
33
34
36
43
46

de communaut´es disjointes

. . . . . . . . . . . . . .
1.3.10 Synth`ese et discussion . . . . . . . . . . . . . . . . .

1.4 D´etection de communaut´es chevauchantes

. . . .
1.4.1 Formulation du probl`eme de d´etection de commu-

49
56
58

naut´es chevauchantes

. . . . . . . . . . . . . . . . .

58

1.4.2 D´etection de communaut´es chevauchantes `a base de

propagation de labels

. . . . . . . . . . . . . . . . .

59

1.4.3 Autres m´ethodes pour la d´etection de communaut´es

chevauchantes . . . . . . . . . . . . . . . . . . . . . .
.

1.4.4 Tableau r´ecapitulatif des m´ethodes chevauchantes
1.4.5 Mesures supervis´ees et non supervis´ees pour la d´etection

61
64

de communaut´es chevauchantes . . . . . . . . . . . .
Synth`ese et discussion . . . . . . . . . . . . . . . . .

65
70

1.4.6

15

16

CHAPITRE 1. ETAT DE L’ART

1.1

Introduction

La d´etection de communaut´es est un domaine de recherche actif depuis
ces vingt derni`eres ann´ees. De tr`es nombreuses approches ont ´et´e mises en
œuvre pour la d´etection de structures communautaires. Certaines m´ethodes
consid`erent le graphe dans son ensemble et eﬀectuent une coupe pour trouver
des communaut´es alors que d’autres privil´egieront une approche nodale (c’est-
`a-dire, un partitionnement fond´e sur les propri´et´es de nœuds voisins). L’`ere du
traitement de donn´ees massives, a ´egalement vu la naissance d’architectures pa-
rall`eles et distribu´ees sur lesquelles se sont agr´eg´es de nombreux algorithmes et
des solutions `a des probl`emes multidisciplinaires.

Ce chapitre vise `a pr´esenter les principales m´ethodes de d´etection de commu-
naut´es disjointes et chevauchantes. Nous pr´esenterons dans un premier temps la
notion de r´eseaux complexes avec les caract´eristiques communes qui leur sont
associ´ees. Nous donnerons une formulation `a la d´etection de communaut´es dis-
jointes et chevauchantes, ainsi que les m´ethodes respectives pour r´esoudre ces
probl`emes. A la ﬁn de chaque section d´ecrivant les m´ethodes pour un probl`eme
donn´e, un tableau r´ecapitulatif suivi d’une discussion sera pr´esent´e pour expli-
quer les choix et les d´ecisions que nous avons pris au cours de cette th`ese. Nous
exposerons les mesures supervis´ees et non supervis´ees relatives `a chaque type
de probl`eme avec des tableaux r´ecapitulatifs et une discussion sur le choix des
mesures que nous avons s´electionn´ees. A partir de l’´etat de l’art que nous aurons
pr´esent´e, nous tirerons les conclusions n´ecessaires pour le d´eveloppement de nos
solutions de d´etection de communaut´es disjointes, chevauchantes, parall`eles et
distribu´ees.

1.2 Notions et notations relatives `a la th´eorie

des graphes

Nous utilisons dans la suite de ce manuscrit de nombreuses notations qui

illustreront l’´etat de l’art, nos propositions algorithmiques et nos exp´erimentations.
Nous proposons dans cette section de donner les d´eﬁnitions g´en´erales relatives
aux graphes.

Un graphe G est une structure math´ematique, plus exactement un couple
(V, E), o`u V = {v1, ..., vn} est l’ensemble des sommets (ou nœuds) et E est l’en-
semble des arˆetes (ou liens) E = {e1, ..., em}. Une arˆete ek ∈ E est un couple de
sommets (vi, vj) reliant les sommets vi `a vj. La notation usuelle pour d´eﬁnir un
graphe G est G = (V, E). Nous notons |V | = n l’ordre du graphe, c’est-`a-dire le
nombre de sommets du graphe et |E| = m le nombre d’arˆetes. Deux sommets
u, v ∈ V sont dit voisins (ou adjacents) si une arˆete les relie, c’est-`a-dire s’il
existe une arˆete e ∈ E telle que e = {u, v}. On dit ´egalement qu’une paire de
sommets est adjacente si les deux sommets qui la composent sont adjacents.

1.2. NOTIONS ET NOTATIONS RELATIVES `A LA TH ´EORIE DES GRAPHES17

Il existe des graphes orient´es (ou dirig´es) et non orient´es (non dirig´es). Un
graphe orient´e est un graphe pour lequel les arˆetes sont orient´ees, ce qui n’est
pas le cas pour un graphe non orient´e. Un graphe peut ´egalement ˆetre pond´er´e
ou valu´e, c’est-`a-dire lorsqu’il existe une fonction W : e ∈ E → R qui `a chaque
lien associe une valeur r´eelle. On note G = (V, E, W ) un graphe pond´er´e.

Un graphe a certaines caract´eristiques propres. Nous donnons les principales

d´eﬁnitions.

On note N (u) le voisinage du nœud u , o`u N (u) = {u ∈ V, (u, v) ∈ E}. Le
cardinal du voisinage d’un sommet est son degr´e (ou degr´e d’incidence) que l’on
note d(u) o`u ku (Freeman (1978)) qui est le nombre de liens qui lui sont incidents.

(cid:80)

Le degr´e moyen d’un graphe not´e λG pour un graphe G est la moyenne des

degr´es des nœuds du graphe : λG = 1
n

u∈V d(u).

Un graphe G(cid:48) = (V (cid:48), E(cid:48)) est un sous-graphe de G = (V, E) si V (cid:48) ⊆ V
et E(cid:48) ⊆ E, et toute arˆete de E(cid:48) a ses extr´emit´es dans V (cid:48). Etant donn´e un
ensemble V (cid:48) ⊆ V , le sous-graphe de G engendr´e (ou induit) par S(cid:48) est le graphe
G(cid:48) = (V (cid:48), E(cid:48)), o`u E(cid:48) = {(u, v) ∈ E : u, v ∈ S(cid:48)}

Un graphe partiel de G est un graphe G(cid:48) = (V (cid:48), E(cid:48)) qui a le mˆeme nombre de
sommets mais pour lequel certains arcs ou arˆetes ont ´et´e ´elimin´es, c’est-`a-dire
avec V (cid:48) = V et E(cid:48) ⊂ E.

On appelle graphe complet, un graphe o`u tous les sommets sont adjacents,
c’est-`a-dire si tout couple de sommets distincts est li´e par une arˆete. Pour tout
entier naturel n, on note Kn le graphe complet d’ordre n. Le nombre d’arˆetes du
graphe complet Kn est ´egal `a n(n−1)
. On appelle clique un sous-graphe complet
de G.

2

Un chemin du sommet s vers le sommet t dans un graphe orient´e est une
suite v0, v1, ..., vk de sommets telle que v0 = s, vk = t, (vi−1, vi) ∈ E, pour tout
1 ≤ i ≤ k. Le terme k est appel´e la longueur du chemin, et on dit que le sommet
t est joignable `a partir du sommet s. Le chemin est dit simple (ou ´el´ementaire)
si les vi sont distinctes deux-`a-deux (arˆetes incidentes deux-`a-deux). La notion
correspondante dans les graphes non orient´es est celle de chaˆıne. Dans un graphe
non orient´e, un cycle est une suite d’arˆetes cons´ecutives (chaine) dont les deux
sommets extr´emit´es sont identiques, c’est-`a-dire tel que v0 = vk.

La distance g´eod´esique entre deux sommets dans un graphe est d´eﬁnie par

la longueur d’un plus court chemin entre ces deux sommets.

Un graphe est dit connexe si deux sommets quelconques peuvent ˆetre reli´es

par un chemin.

18

CHAPITRE 1. ETAT DE L’ART

La densit´e d’un graphe, not´e ρG, est le rapport entre le nombre d’arˆetes (ou
d’arcs) et le nombre d’arˆetes (ou d’arcs) possibles. ρG = 2m
n(n−1) . Un graphe
dont la densit´e est de 1 est un graphe complet, c’est-`a-dire o`u chaque sommet
est reli´e `a tout autre sommet par une arˆete. Un graphe avec une densit´e nulle
signiﬁe qu’aucun sommet n’est connect´e `a un autre.

L’excentricit´e d’un sommet est sa distance maximale `a tous les autres som-
mets. Le diam`etre d’un graphe est la plus longue des distances entre deux som-
mets du graphe consid´er´e. C’est l’excentricit´e maximale.

Il existe de tr`es nombreux types de graphes dans la litt´erature. Nous nous
focaliserons dans notre ´etude sur des graphes simples, c’est-`a-dire ne contenant
ni boucle (un lien reliant un sommet `a lui mˆeme) et ni plus d’un lien entre deux
mˆemes sommets. Nous porterons notre attention aux r´eseaux complexes dont
nous donnerons les caract´eristiques g´en´erales dans cette section.

1.2.1 Repr´esentation d’un graphe

Il existe plusieurs structures permettant de repr´esenter un graphe. L’une des
structures les plus intuitives concerne la repr´esentation matricielle. Un graphe
peut ˆetre repr´esent´e par une matrice d’adjacence de taille |V |×|V | dont l’´el´ement
non-diagonal not´e Aij repr´esente le nombre d’arˆetes liant le nœud i au nœud
j. La matrice d’adjacence est not´ee A. Dans un graphe simple (sans boucle), la
diagonale de la matrice ne comprend que des z´eros. Cette repr´esentation per-
met d’avoir des informations sur la topologie du graphe et sur les relations entre
paires de sommets. On peut par exemple, connaˆıtre le nombre de chemins de
longueur k entre deux nœuds i et j en ´elevant la matrice `a la puissance k et
en observant les ´el´ements de la ieme ligne et de la jeme colonne de la matrice
r´esultante.

Bien que la structure de matrice soit s´eduisante `a utiliser, elle n’est pas pra-
tique en programmation dans la mesure o`u elle demande un espace m´emoire
important mˆeme pour des machines modernes. Une repr´esentation moins gour-
mande consiste `a consid´erer une liste de voisins, nomm´ee liste d’adjacence, not´ee
LA = (lvi)n

i=1 o`u l’´el´ement lvi est la liste des voisins du sommet vi.

1.2.2 Centralit´e dans un graphe

Il existe plusieurs mesures pour `a la fois caract´eriser la topologie d’un graphe
et r´ev´eler l’importance d’un nœud au sein du r´eseau. Nous proposons d’exposer
les mesures les plus utilis´ees en analyse des r´eseaux sociaux.

Nous avons vu que le degr´e d’un nœud ´etait le nombre de liens qui lui ´etait
incident. Cependant, cela ne donne aucune information sur son importance au

1.2. NOTIONS ET NOTATIONS RELATIVES `A LA TH ´EORIE DES GRAPHES19

sein du graphe. L’une des premi`eres mesures pour connaˆıtre l’importance d’un
nœud dans un r´eseau est sa centralit´e de degr´e normalis´ee. Pour un nœud u,
la centralit´e de degr´e normalis´ee consiste en ¯du = d(u)
n−1 . Un nœud peut ˆetre
connect´e au plus `a tous les autres nœuds du graphe, soit aux n − 1 autres
nœuds constituant le graphe. Ainsi, eﬀectuer le rapport du degr´e du nœud u sur
les n − 1 autres nœuds permet de voir l’importance qu’a le nœud u vis-`a-vis de
son degr´e au sein du graphe. L’objectif ´egalement est de ramener la centralit´e
dans l’intervalle [0, 1]. Pour un nœud u, plus sa centralit´e de degr´e normalis´ee
est proche de 1, plus ce nœud sera connect´e aux autres nœuds du graphes.

(cid:80)n
i=1[d(u∗)−d(i)]
[(n−1)(n−2)]

Cependant, il est int´eressant d’examiner la variation de la centralit´e de
degr´e des nœuds du graphe pour en ´etudier la distribution. En 1978, Free-
man (1978) a ainsi propos´e le degr´e de centralisation du graphe G comme ´etant
o`u d(u∗) est le degr´e du nœud maximal du r´eseau. Ce
CD =
nombre varie entre 0 et 1. La valeur 1 est atteinte pour le graphe en forme
d’´etoile, c’est-`a-dire un nœud connect´e `a tous les autres, tous de degr´e 1. La
valeur 0 est atteinte avec une clique.

Il est ´egalement int´eressant de comprendre l’organisation topologique du
graphe et comment sont li´es certains nœuds. Le cœﬃcient de clustering (CC)
est une mesure d’analyse des r´eseaux sociaux et de regroupement des nœuds
dans un r´eseau. Il mesure `a quel point le voisinage d’un sommet est connect´e,
et calcule plus exactement la probabilit´e que deux nœuds li´es `a un autre nœud
soient ´egalement li´es. Le CC a une forme globale et une forme locale. La premi`ere
(globale) concerne le graphe dans son ensemble alors que la seconde (locale) ne
concerne que le nœud. Pour un nœud u ∈ G, le CC est d´eﬁni par :

CCu =

nombre de triangles contenant le nœud u
nombre de triplets contenant le nœud u

(1.1)

o`u le triplet contenant le nœud u correspond au nombre de paires de voisins
du sommet u. Par d´efaut, si le degr´e du nœud u est de 1 ou de 0, nous posons
CCu = 0. Le cœﬃcient de clustering global pour le graphe G est calcul´e en
utilisant la valeur locale CCu,∀u ∈ G

(cid:88)

u∈G

CC(G) =

1
n

CCu

(1.2)

Par d´eﬁnition, nous avons 0 ≤ CCu ≤ 1,∀u ∈ G et 0 ≤ CC(G) ≤ 1. Pour un
nœud u, plus grand est son coeﬃcient de clustering, plus la probabilit´e que ses
voisins soient li´es est forte.

Il existe ´egalement des mesures pour connaˆıtre le degr´e avec lequel un nœud
est directement connect´e aux autres nœuds qui ne sont pas n´ecessairement di-
rectement connect´es les uns avec les autres. La centralit´e d’interm´ediarit´e (node
betweenness centrality) correspond au nombre de plus courts chemins du graphe

20

CHAPITRE 1. ETAT DE L’ART

passant par chaque sommet. Pour toutes paires de nœuds s et t d’un graphe G,
la centralit´e d’interm´ediarit´e est d´eﬁnie par :

CI(v) =

s(cid:54)=v,t(cid:54)=v,s(cid:54)=t

σst(v)

σst

(1.3)

(cid:88)

(cid:88)

avec σst le nombre de plus courts chemins entre s et t et σst(v) le nombre de
plus courts chemins entre s et t passant par v. Un niveau ´elev´e de centralit´e
d’interm´ediarit´e n’est pas toujours corr´el´e avec un degr´e important du sommet.
En eﬀet, un nœud avec un faible degr´e faisant le lien entre deux groupes de som-
mets aura une centralit´e d’interm´ediarit´e ´elev´ee. Dans sa conception, les nœuds
qui ont une forte probabilit´e d’apparaˆıtre sur un court chemin choisi au hasard
entre deux nœuds choisis ´egalement au hasard ont une haute interm´ediarit´e.

Il existe ´egalement une centralit´e d’interm´ediarit´e pour les arˆetes. Soit w :
E (cid:55)−→ R la fonction de pond´eration sur les arˆetes de G, avec E, ensemble
d’arˆetes du graphe G. Pour un graphe non pond´er´e, nous avons w(e) = 1 ∀e ∈ E.
Soit un chemin entre deux sommets commen¸cant en s ∈ V et se terminant `a
t ∈ V . Notons σst le nombre de plus courts chemins entre les sommets s et t. La
notion d’interm´ediarit´e d’une arˆete repose sur le nombre de plus courts chemins
qui passent `a travers une certaine arˆete. La centralit´e d’interm´ediarit´e pour les
arˆetes, que l’on note CI(e) pour un lien e est donn´ee par :

CI(e) =

s,t∈V,s(cid:54)=t

σst(e)

σst

(1.4)

σst(e) repr´esentant le nombre de plus courts chemins allant de s `a t passant
par e. La complexit´e pour calculer la centralit´e d’interm´ediarit´e est en O(n3)
(Brandes (2001)). Cependant, des recherches Brandes (2001), Bader et al. (2007)
et Geisberger et al. (2008) portant sur l’approximation de cette mesure ont pu
r´eduire la complexit´e en O(nm) sur des graphes complexes.

Il existe d’autres centralit´es en analyse des r´eseaux sociaux, nous invitons le

lecteur `a se reporter au glossaire du manuscrit.

1.2.3 Analyse des r´eseaux sociaux et graphes de terrains

La topologie des graphes d´epend des syst`emes complexes ´etudi´es. Un r´eseau
de collaboration scientiﬁque n’aura pas exactement les mˆemes caract´eristiques
qu’un r´eseau social li´e `a la musique ou au cin´ema. Cependant, les graphes
sociologiques ont des caract´eristiques communes que nous allons d´evelopper.
Dans notre ´etude, nous nous focaliserons sur des r´eseaux complexes (qualiﬁ´es
de graphes de terrain). De nombreuses ´etudes, notamment celles de Barab´asi
et Albert (1999), de Newman (2003) et de Clauset et al. (2009a) ont essay´e de
trouver toutes les caract´eristiques li´ees aux r´eseaux complexes. Elles ont montr´e
des caract´eristiques communes concernant la distribution des degr´es des nœuds,

1.2. NOTIONS ET NOTATIONS RELATIVES `A LA TH ´EORIE DES GRAPHES21

un faible nombre de nœuds ayant une forte centralit´e (les hubs), un nombre
de triangles important, une distance moyenne entre chaque paire de sommets
assez faible et l’existence de groupes de nœuds fortement connect´es ensemble
et faiblement avec le reste du graphe, les communaut´es. Nous d´eveloppons cha-
cune des caract´eristiques des r´eseaux complexes pour en venir aux structures
communautaires et `a la probl´ematique de leur d´etection.

Distribution des degr´es

De nombreuses ´etudes telles que Barab´asi et Albert (1999); Albert et al.
(1999) et Clauset et al. (2009b) ont constat´e que la majorit´e des graphes de
terrain poss`edent une distribution des degr´es non uniforme, qui est approxim´ee
par une distribution en loi de puissance de type P (k) = Ck−γ, avec P (k) la
proportion de nœuds de degr´e k et γ, appel´e exposant d’invariance d’´echelle,
un r´eel strictement positif. Nous avons de mani`ere g´en´erale 2 ≤ γ ≤ 3. Ce type
de graphe est qualiﬁ´e de r´eseau invariant d’´echelle (scale-free network). Lors
de la cr´eation d’un graphe de terrain, les nœuds se connectent de mani`ere non
uniforme. Certains nœuds attirent les nouveaux nœuds en formant de nouvelles
connexions. Ces nœuds que l’on pourrait qualiﬁer d’attracteurs, caract´eris´es par
une forte centralit´e, sont appel´es hubs et sont typiques des graphes de terrains.

Eﬀet petit-monde

L’eﬀet du petit monde est une exp´erience men´ee en 1967 par les psychologues
Travers et Milgram (1969) qui met en exergue l’hypoth`ese que la longueur de la
chaˆıne des connaissances sociales requise pour lier une personne arbitrairement
choisie `a n’importe quelle autre sur terre est g´en´eralement courte. Le concept
a engendr´e l’expression c´el`ebre ”le monde est petit (It’s a small world )”. Dans
cette exp´erience, Stanley Milgram a mis en ´evidence des chaˆınes tr`es courtes
reliant deux citoyens al´eatoirement choisis aux ´Etats-Unis (les chaˆınes obte-
nues avaient une longueur moyenne de six personnes, d’o`u l’expression qui
en a d´ecoul´e). En 2011, le site social Facebook publie une analyse de sa to-
pologie et indique qu’il y a en moyenne cinq degr´es de s´eparation entre ses
membres (quatre, si l’on se r´ef`ere uniquement aux ´Etats-Unis). Ces exp´eriences
conﬁrment qu’un petit nombre d’interm´ediaires est suﬃsant pour connecter
n’importe quelle personne `a une autre en ce qui concerne les graphes socio-
logiques.

Variations de densit´e et de taille des structures communautaires et
fort cœﬃcient de clustering

Dans un r´eseau social, chaque nœud est connect´e `a un certain nombre de
sommets mais rarement `a tous les sommets. Le degr´e moyen des graphes de
terrains est tr`es faible et ind´ependant du nombre de sommets du graphe (Al-
bert et al. (1999)). Les graphes de terrain ont un cœﬃcient de clustering ´elev´e.

22

CHAPITRE 1. ETAT DE L’ART

C’est-`a-dire que deux sommets voisins d’un nœud auront tendance `a se connaˆıtre
et donc `a ˆetre li´es. Ainsi, des nœuds dans certaines r´egions denses du graphe
seront connect´es `a de nombreux triangles. On peut citer comme exemples des
r´eseaux de collaborations avec un fort coeﬃcient de clustering (Newman (2006)).
Pour ´etudier les graphes de terrains, il faut donc consid´erer deux niveaux, celui
concernant le nœud avec une densit´e ´elev´ee et celui de la topologie du graphe, de
densit´e faible. Cependant, Melancon (2006) montre que la densit´e d’un graphe
varie en fonction du domaine d’application en donnant des exemples r´eels. Ainsi,
il n’existe pas de seuil universel permettant de dire si nous avons un graphe de
terrain connaissant sa densit´e.

Structures communautaires

En 2002, Girvan et Newman (2002b) ont montr´e que la pr´esence au sein de
graphes sociaux de groupes de nœuds fortement connect´es entre eux et faible-
ment avec le reste du graphe est une caract´erisque des r´eseaux complexes, ils
donnent le nom de communaut´es `a ces groupes de nœuds fortement connect´es.
La diﬃcult´e de trouver des communaut´es est qu’elles peuvent avoir des ordres
et des tailles diﬀ´erents au sein d’un mˆeme graphe. C’est en ce sens que nous
allons dans la prochaine section formuler le probl`eme g´en´eral de d´etection de
communaut´es et voir les diﬀ´erentes d´eﬁnitions des communaut´es (il n’existe pas
de d´eﬁnition exacte).

Figure 1.1 – Exemple d’un graphe avec quatre communaut´es

La modularit´e

La modularit´e est une mesure de qualit´e de partitionnement pour la d´etection
de communaut´e cr´e´ee par Newman et Girvan (2004). En consid´erant une par-
tition P de l’ensemble des nœuds d’un graphe G = (V, E), la modularit´e est
une fonction prenant une partition P = {c1, ..., ck} de communaut´es, Q : P →

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

23

(cid:80)

i(Aij− kikj

2m

2m et la proportion de liens (soit ( kikj

[−1, 1], d´eﬁnie par Q(P ) = 1
2m )δ(li, lj), avec Aij la matrice d’adja-
cence, ki le degr´e du nœud i, m le nombre de liens dans le graphe, li l’identidiant
de la communaut´es auquel appartient le nœud i, lj l’identidiant de la commu-
naut´es auquel appartient le nœud j, et δ(li, lj) = 1 si les nœuds i et j sont
dans la mˆeme communaut´e, 0 sinon. Cette mesure est la somme, sur toutes les
communaut´es des diﬀ´erences entre la proportion de liens `a l’int´erieur d’une com-
munaut´e (ce qui ´equivaut `a Aij
2m ) que devrait
avoir une communaut´e dans un graphe al´eatoire dont la distribution de degr´es
est la mˆeme que celui du graphe originel. Un tel graphe al´eatoire est nomm´e
le mod`ele nul (cf. glossaire 6.1). Une partition sera jug´ee correcte s’il y a plus
de liens `a l’int´erieur de la communaut´e que ce `a quoi l’on pourrait s’attendre.
La modularit´e prend une valeur entre 1 et −1. Une valeur ´egale `a −1 signiﬁe
qu’il n’existe aucun lien entre les nœuds d’une mˆeme communaut´e avec tous
les liens pointant vers d’autres communaut´es. Une valeur de 1 signiﬁe un grand
nombre de liens dans les structures de communaut´es d´etect´ees. La valeur 0 de la
modularit´e signiﬁe la partition triviale consid´erant le graphe comme une grande
communaut´e. L’inconv´enient de la modularit´e est sa limite de r´esolution. En
eﬀet, si l’on est confront´e `a des communaut´es de tailles diﬀ´erentes `a l’int´erieur
d’un mˆeme graphe, certaines communaut´es, mˆeme bien d´eﬁnies, pourront ne
pas ˆetre distingu´ees dans la partition de modularit´e optimale. On ne pourra
m, m ´etant le nombre
d´etecter des communaut´es ayant une taille inf´erieure `a
d’arˆetes.

√

De nombreux algorithmes de d´etection de communaut´es que nous expose-

rons dans ce chapitre visent `a maximiser cette m´etrique.

Notations scientiﬁques

Dans le cadre de ce travail doctoral, nous allons utiliser des notations scien-
tiﬁques pour mieux expliquer certains algorithmes ou certaines mesures. C’est
en ce sens que nous proposons le Tableau 1.1 de notation suivant :

1.3 D´etection de communaut´es disjointes

Bien que la notion de communaut´e ne soit pas un objet math´ematique en-
core d´eﬁni, de nombreuses recherches ont essay´e de trouver une formulation
pour la d´eﬁnir. Nous allons voir que les d´eﬁnitions propos´ees par la litt´erature
concernent des graphes sp´eciﬁques. Cette section vise `a retracer les principales
d´eﬁnitions de ce que l’on nomme communaut´e.

24

CHAPITRE 1. ETAT DE L’ART

Sigle
G = (V, E)
|V | = n
|E| = m
kS
in

kS
out

N (u)
P = {C1, ..., Cr}
(u, v) ∈ E
A

Signiﬁcation

Un graphe not´e G, constitu´e d’un ensemble

de sommets V et un ensemble d’arˆetes E

Nombre de sommets

Nombre d’arˆetes
Nombre de liens `a

l’int´erieur du sous-graphe S
Nombre de liens sortant de S
(liant les nœuds de S `a V − S),

c’est-`a-dire ayant le nombre de liens qui ont

une extr´emit´e `a l’int´erieur de S
`a l’ext´erieur de S (soit V − S)

et leurs autres extr´emit´es

Le voisinage d’un nœud u

Une partition en r parties de sommets

Un lien liant u et v
Matrice d’adjacence

Tableau 1.1 – Notations scientiﬁques

1.3.1 Formulation du probl`eme de d´etections de commu-

naut´es disjointes

Consid´erons un r´eseau social repr´esent´e par un graphe G = (V, E). Le
probl`eme de d´etection de communaut´e dans sa forme g´en´erale consiste `a trou-
ver une partition P = {C1, ..., Cr} de l’ensemble des sommets V en r classes,

(cid:84) Cl = ∅, r ≥ k ≥ 1 et Ck (cid:54)= ∅,∀k ∈ {1, ..., r}, de

avec(cid:83)

k∈{1,...,r} Ck = V , Ck

telle sorte que les sommets dans une communaut´e soient fortement connect´es et
faiblement avec le reste du graphe.

Dans son livre sur la d´etection de communaut´es, Fortunato (2010) donne
une formulation de la probl´ematique de la d´etection de communaut´es fond´ee
sur la mesure de Mancoridis et al. (1998), c’est-`a-dire sur la densit´e intra-classe
et inter-classe. C’est-`a-dire qu’une communaut´e doit ˆetre caract´eris´ee par une
densit´e forte et un nombre de liens liant les communaut´es (inter-classe) faible.
Ainsi, la probl´ematique de la d´etection de communaut´es peut ˆetre vue comme
une fonction `a optimiser. En consid´erant un partition C = {C1, ..., Ck} en k
parties de sommets disjoints, la mesure de Mancoridis se d´eﬁnit comme suit :

M Q =

s(Ci, Ci) −

k(k − 1)(cid:80)

1
i,j(cid:54)=i s(Ci, Cj)

(cid:88)

1
k

i
|E(Ci,Cj )|
|Ci||Cj|

avec s(Ci, Cj) =
dans la communaut´e Ci et Cj. En d´eﬁnissant par ∆Int(C) = 1
k
et ∆Ext(C) =
Dans cette derni`ere ´equation, ∆Int(C) repr´esente la coh´esion interne des groupes

avec E(Ci, Cj) l’ensemble des liens ´etant `a la fois
i s(Ci, Ci)
i,j(cid:54)=i s(Ci,Cj ) , nous obtenons M Q = ∆Int(C) − ∆Ext(C).

k(k−1)(cid:80)

1

(1.5)

(cid:80)

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

25

C1, ..., Ck (ou intra-classe) alors que ∆Ext(C) repr´esente la coh´esion externe des
groupes (ou inter-classe). Il s’agit de maximiser la somme de ratios sur l’en-
semble des classes.

x (G(cid:48)) + kout

Le fait que les densit´es soient diﬀ´erentes d’un type de graphes `a l’autre
rend diﬃcile la formulation d’une d´eﬁnition rigoureuse. En 2004, Radicchi et al.
(2004) proposent de consid´erer deux types de communaut´es, les communaut´es
au sens faible et les communaut´es au sens fort. En consid´erant un sous graphe G(cid:48),
auquel le nœud x appartient, le degr´e d’un nœud peut ˆetre coup´e en deux parties,
kx(G(cid:48)) = kin
x (G(cid:48)) repr´esente le nombre d’arˆetes reliant le
x (G(cid:48)) , o`u kin
nœud x `a ses voisins dans G(cid:48), et kout
x (G(cid:48)) repr´esente le nombre d’arˆetes sortant
de G(cid:48). Ainsi, un sous-graphe G(cid:48) sera consid´er´e comme une communaut´e au sens
x (G(cid:48)),∀x ∈ G(cid:48). Dans cette d´eﬁnition, chaque nœud a plus de
fort si kin
connexions `a l’int´erieur de sa communaut´e qu’`a l’ext´erieur. Une communaut´e au
x (G(cid:48)).
Dans cette derni`ere d´eﬁnition, la somme de tous les degr´es `a l’int´erieur de G(cid:48)
est plus grande que la somme de tous les degr´es vers le reste du r´eseau.

sens faible doit v´eriﬁer la condition suivante :(cid:80)

x (G(cid:48)) >(cid:80)

x (G(cid:48)) > kout

x∈G(cid:48) kin

x∈G(cid:48) kout

Les crit`eres dans l’article de Fortunato (2010) `a la recherche de bonnes com-

munaut´es s’articule autour de cinq grands axes :

— la r´eciprocit´e compl`ete (les voisins de deux nœuds au sein d’une mˆeme

communaut´e sont sensiblement les mˆemes ((Luce et Perry (1949)))

— la joignabilit´e (deux nœuds d’une mˆeme communaut´e doivent pouvoir

ˆetre proches topologiquement l’un de l’autre)

— le degr´e de sommet (les communaut´es doivent contenir des nœuds ayant

un degr´e moyen important)

— un fort coeﬃcient de clustering au sein des communaut´es (une commu-

naut´e doit contenir des triangles et des triades)

— la comparaison de la coh´esion interne et externe (nombre d’acteurs mi-

nimal qui pourrait rendre un graphe non connexe si on les retirait)

Le nombre de partitions possibles en k groupes de nœuds d’un graphe com-
prenant n sommets est le nombre de Sterling de seconde esp`ece S(n, k) (An-
drews (1976)). Le nombre total de partitions possibles est le nieme nombre de
k=0 S(n, k) (Andrews (1976)). Lov´asz (1993) montre que pour n

Bell, Bn =(cid:80)n

tendant vers l’inﬁni, Bn a une forme asymptotique.

Bn ∼ 1√
n

[λ(n)]n+1/2eλ(n)−n−1

(1.6)

o`u λ(n) = eW (n) = n/W (n), W (n) ´etant la fonction de Lambert (P´olya et
Szeg¨o (1997)). Le probl`eme de d´etection de communaut´es est donc un probl`eme
d’analyse combinatoire discret, o`u l’objectif est de trouver une partition avec
des structures fortement denses et faiblement connect´ees avec le reste du graphe.

26

CHAPITRE 1. ETAT DE L’ART

1.3.2 Approches divisives

Les approches divisives consistent `a consid´erer la topologie enti`ere du graphe
et `a eﬀectuer une coupe pour obtenir un partitionnement. Une coupe d’un
graphe est une partition des sommets en deux sous-ensembles. Les coupes ont
lieu sur des liens connectant des r´egions denses du graphe. La m´ethode la plus
connue est celle de la bissection (Fiedler (1973) et Pothen et al. (1990)) qui
coupe le graphe en deux, puis op`ere de mani`ere it´erative sur les sous-graphes
r´esultants. Il existe cependant d’autres m´ethodes que nous allons d´etailler dans
cette section.

Approche spectrale

La m´ethode spectrale, issue de l’alg`ebre lin´eaire, ´etablit notamment l’exis-
tence d’une base orthonormale de vecteurs propres pour tout endomorphisme
sym´etrique sur un espace vectoriel complexe de dimension ﬁnie. Elle consiste en
l’´etude de matrices particuli`eres, portant notamment sur les vecteurs propres de
(cid:80)n
matrices d´eﬁnies positives. Une matrice d´eﬁnie positive est une matrice positive
inversible et telle que pour tout vecteur f ∈ R, avec f(cid:48) la transpos´ee de f , nous
i,j wij(fi − fj)2. Cela induit certaines propri´et´es comme la
avons f(cid:48)Lf = 1
positivit´e des valeurs propres, que l’on peut ordonner de la mani`ere suivante
λ1 = 0 ≤ λ2 ≤ ... ≤ λn. On peut ´egalement par des m´ethodes alg´ebriques
ou num´eriques, calculer les valeurs et les vecteurs propres (Lanczos (1950)).
Une ´etude th´eorique de la m´ethode spectrale a ´et´e trait´ee par Chung (1996) et
Von Luxburg (2007).

2

Dans l’analyse spectrale des r´eseaux, la matrice Laplacienne a une place

centrale :

L = D − A

(1.7)

o`u D est la matrice diagonale des degr´es et A est la matrice d’adjacence.

Consid´erons la matrice Laplacienne L, les propri´et´es suivantes ont ´et´e ´etablies

(Von Luxburg (2007)) :

— L est une matrice sym´etrique et d´eﬁnie positive
— La plus petite valeur propre de L est 0, avec comme ´el´ement propre 1
— Les ´el´ements propos´es de L sont r´eels et non n´egatifs 0 = λ1 ≤ λ2 ≤ ... ≤

(soit le graphe comme ´etant une communaut´e)

λn

La matrice Laplacienne permet ´egalement l’obtention d’information sur la
topologie du graphe. Par exemple, l’ordre de multiplicit´e de la valeur propre 0
est ´egale au nombre de composantes connexes du graphe. Si G est un graphe
connexe, la seconde plus petite valeur propre λ2 est positive. Le vecteur propre
associ´e `a λ2, appel´ee vecteur de Fiedler, fut ´etudi´e par Fiedler (1973) et Fiedler
(1975). Une des applications est d’ordonner les sommets de G sur la droite des
r´eels en associant chaque sommet vi une composante xi correspondante `a sa

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

27

iieme composante du vecteur de Fiedler. En 1970, Hall (1970) a montr´e que si
deux sommets vi et vj sont connect´es, alors la distance |xi − xj| dans le vecteur
de Fiedler est petite. Ainsi, les sommets fortement connect´es sont donc proches
dans l’ordonnancement des sommets du vecteur de Fiedler. Il est ainsi possible
d’eﬀectuer une partition P = {P1, P2} du graphe G en choisissant un r´eel r en
posant P1 = {vi|xi ≤ r} et P2 = {vi|xi > r}. L’une des premi`eres m´ethodes
exploitant ce champ fut la m´ethode de Barnes et Hoﬀman (1981), dans laquelle
la recherche consid´era le vecteur de Fiedler et eﬀectua une bissection entre
les ´el´ements positifs et n´egatifs du vecteur. Cette m´ethode permit de couper le
graphe en deux. En 1990, Pothen et al. (1990) utilis`erent la m´ediane des ´el´ements
du vecteur de Fiedler pour la valeur de r pour eﬀectuer une bissection r´ecursive
du graphe. De 1993 `a 1995, Barnard et Simon (1994) propos`erent la bissection
spectrale r´ecursive et multi-niveaux. Cela consiste `a eﬀectuer une bissection en
se fondant sur le vecteur de Fiedler et `a r´eduire ce vecteur en minimisant la
distance entre certains points. Le processus ´etant it´eratif, la m´ethode permit de
couper le graphe de mani`ere r´ecursive. Une version parall`ele fut d´evelopp´ee par
Barnard (1995). Mais ces deux m´ethodes n’utilisent qu’un seul vecteur propre,
et donc une seule source d’information.
Shi et Malik (2000), ainsi Ng et al. (2001) eurent l’id´ee d’utiliser l’information
stock´ee dans d’autres vecteurs propres pour am´eliorer la qualit´e de partitionne-
ment. L’id´ee consistait `a utiliser l’algorithme k-means dans l’espace propre aﬁn
de trouver k clusters et par transposition sur le graphe, k communaut´es. Les
auteurs l’ont appliqu´e `a diﬀ´erentes matrices Laplaciennes normalis´ees :

LN = I − D

1

2 AD− 1

2

et

LN = I − A−1D− 1

2

(1.8)

(1.9)

o`u I est la matrice d’identit´e de la matrice d’adjacence A. Les r´esultats en termes
de qualit´e de partitionnement sont meilleurs que ceux de la matrice Laplacienne
non normalis´ee. Malheureusement cette m´ethode n´ecessite de connaˆıtre la va-
leur k. Aﬁn de rem´edier `a ce probl`eme, certaines recherches ont privil´egi´e le
nombre de vecteurs propres qui optimise le mieux une fonction de qualit´e de
partitionnement pour la d´etection de communaut´es, comme la modularit´e.

Donetti et Mu˜noz (2004) propos`erent d’utiliser les vecteurs propres associ´es
aux K plus petites valeurs propres non-nulles (au lieu simplement du vecteur
de Fiedler), K ´etant un entier ne pouvant exc´eder le nombre de valeurs propres.
L’id´ee est qu’un sommet est repr´esent´e dans un espace de dimension K constitu´e
des composantes qui lui correspondent dans les K vecteurs propres. A chaque
it´eration de l’algorithme, K est incr´ement´e de un et un algorithime de clustering
hi´erarchique est appliqu´e comme le single-linkage clustering ou complete-linkage
clustering, fond´e sur la distance angulaire entre les nœuds dans cet espace. Le
meilleur partitionnement du dendrogramme est celui qui a la plus grande mo-
dularit´e. La conﬁguration donnant la modularit´e maximale est alors conserv´ee

28

CHAPITRE 1. ETAT DE L’ART

pour retourner la partition en question parmi tous les dendrogrammes. La Fi-
gure 1.2 montre les r´esultats de l’algorithme appliqu´e `a un graphe synth´etique
(Girvan et Newman (2002a)) de 128 nœuds, constitu´e de 4 communaut´es de 32
nœuds chacune, bien visibles.

Figure 1.2 – a) Composante du premier vecteur propre non trivial (deux communaut´es
sont clairement identiﬁ´ees) b) Toutes les communaut´es peuvent ˆetre clairement iden-
tiﬁ´ees lorsque les composantes du deuxi`eme vecteur propre sont trac´ees par rapport `a
celles du premier (Extrait de Donetti et Mu˜noz (2004)).

Newman (2006) et Newman (2013) ont pouss´e l’´etude en consid´erant la ma-
trice de modularit´e pour y appliquer la m´ethode spectrale, tout en eﬀectuant
des m´ethodes de raﬃnage (o`u des nœuds changent dynamiquement de commu-
naut´es).

Les m´ethodes pour calculer les vecteurs propres comme la m´ethode QR
(Horn et Johnson (1985)) ou la m´ethode de Golub (1996) ont une tr`es forte com-
plexit´e, de l’ordre de O(n3). Cela a pour cons´equence que la m´ethode spectrale
ne peut pas ˆetre appliqu´ee `a de grands graphes, tout au plus `a des graphes de
quelques milliers de nœuds. Des m´ethodes d’approximations existent cependant
comme Koren et al. (2002) pour le calcul sur des matrices de taille relativement
grande (leur plus grand graphe comprenant 7 533 224 sommets et 14 991 280
arˆetes). La m´ethode spectrale est sujette `a la propagation d’erreurs qui d´erivent
du calcul des composantes propres. A chaque calcul d’une composante propre,

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

29

une erreur de troncature est prise en compte pour le calcul du prochain vec-
teur propre. Parmi les matrices utilis´ees dans le domaine de la th´eorie spectrale,
Newman (2006) a d´emontr´e que la modularit´e peut ˆetre exprim´ee en termes de
valeurs propres et de vecteurs propres d’une matrice appel´ee matrice de mo-
dularit´e. En 2010, Shen et Cheng (2010) a eﬀectu´e une ´etude comparative en
utilisant diﬀ´erentes matrices utilis´ees en th´eorie spectrale.

La centralit´e d’interm´ediarit´e

L’un des premiers algorithmes modernes pour la d´etection de communaut´es
fut propos´e par Girvan et Newman (2002b) avec la cr´eation d’une mesure d’im-
portance fond´ee sur les arˆetes, la centralit´e d’interm´ediarit´e.

Girvan et Newman ´etendent le calcul de la centralit´e (pond´er´e) aux arˆetes
d’un graphe. Leur heuristique repose ensuite sur l’hypoth`ese que la suppression
d’une arˆete de plus forte centralit´e est susceptible de rompre la connexit´e du
graphe (ou plus exactement de la composante dans laquelle elle se trouve). On
obtient une m´ethode hi´erarchique divisive de clustering du graphe en supprimant
tour `a tour les arˆetes de plus forte centralit´e (en prenant soin de mettre `a jour la
centralit´e apr`es chaque suppression). Cependant, des recherches Brandes (2001);
Bader et al. (2007); Geisberger et al. (2008) portant sur l’approximation de cette
mesure ont pu r´eduire la complexit´e en O(n2) sur des graphes complexes. Bien
que ne pouvant pas ˆetre appliqu´ee `a de grands graphes, la m´ethode permet de
classer les arˆetes selon leur capacit´e `a relier des communaut´es, ce qui a donn´e `a
cette m´ethode une forte notori´et´e.

Optimisation extr´emale de la modularit´e

En 2005, Duch et Arenas (2005) proposent l’optimisation extr´emale li´ee `a
la modularit´e. L’algorithme fonctionne `a une ´echelle locale pour chaque nœud
en optimisant la modularit´e. Initialement, une partition en deux groupes de
nœuds est eﬀectu´ee al´eatoirement. Pour chaque nœud, une optimisation de la
modularit´e est calcul´ee en d´epla¸cant le nœud consid´er´e dans un des deux sous-
groupes. Le d´eplacement d’un sommet d’un groupe `a un autre a une incidence
sur la modularit´e. On d´eplace, de mani`ere r´ep´et´ee, les sommets entre les deux
groupes jusqu’`a trouver un d´ecoupage dont la modularit´e approche un maxi-
mum. Lorsqu’un ´etat stable est ´etabli, les arˆetes liant les deux communaut´es
sont retir´ees et le processus est r´ep´et´e de mani`ere r´ecursive jusqu’`a ce que la
modularit´e n’augmente plus.
La m´ethode pr´esente une complexit´e algorithmique en O(n2log(n)). Elle
est cependant sujette au probl`eme de r´esolution de limite (elle ne peut trou-
m (m ´etant le nombre de
ver de communaut´es dont la taille est inf´erieure `a
liens dans le graphe)). Les r´esultats sont encourageants mais le fait d’eﬀectuer
une bissection r´ecursive ne permet pas de trouver toutes les structures com-
munautaires. En 2006, Massen et Doye (2006) proposent deux modiﬁcations
de la version du recuit-simul´e pr´ec´edent. La premi`ere modiﬁcation consiste `a

√

30

CHAPITRE 1. ETAT DE L’ART

stopper l’algorithme de mani`ere p´eriodique, `a essayer toutes les combinaisons
de mouvements possibles et `a prendre celle optimisant le plus la modularit´e.
La deuxi`eme am´elioration consiste en l’utilisation de l’approche d’optimisation
globale de Basin-Hopping (Wales et Doye (1997)) qui d´eplace des groupes de
nœuds d’une communaut´e `a une autre en optimisant toujours la modularit´e. Les
r´esultats en termes de qualit´e sont meilleurs que ceux de Guimera et al. (2004),
mais l’algorithme est plus lent. Ces algorithmes, utilisant toutes les combinai-
sons possibles, ne permettent pas de travailler sur de grands graphes.

1.3.3 Approches agglom´eratives et multi-niveaux

Une m´ethode h´erit´ee de celle du partitionnement est la m´ethode multi-
niveau. Elle consiste `a fusionner des nœuds pour produire de super-nœuds. A
la ﬁn du processus, les super-nœuds (qui agglom`erent des groupes de nœuds
connect´es) r´epr´esentent les communaut´es.

En 2004, Clauset et al. (2004) ont propos´e une m´ethode multi-niveau dont
le processus de fusion se fait sur une optimisation globale de la modularit´e.
C’est-`a-dire que pour chaque paire de nœuds, toutes les fusions possibles entre
nœuds voisins sont eﬀectu´ees et l’on consid`ere la fusion donnant la modula-
rit´e maximale `a travers tout le graphe pour une paire de nœuds voisins. Cette
m´ethode donne des r´esultats en termes de qualit´e similaire `a la m´ethode New-
man et Girvan (2004). Les auteurs ont cr´ee une structure de donn´ees adapt´ee
aﬁn d’am´eliorer la complexit´e de la m´ethode de Newman. Les auteurs ont en ef-
fet appliqu´ees leurs m´ethodes sur un graphe de co-achat, celui d’Amazon, ayant
409 687 nœuds (repr´esentant les items) et 2 464 630 arˆetes. La m´ethode retourne
de bons r´esultats en termes de partitionnement, avec une modularit´e de 0.745,
qui r´ev`ele l’existence de structures communautaires.

En 2008, Blondel et al. (2008) fusionnent localement un nœud avec le voi-
sin dont le r´esultat augmentera le plus une fonction de qualit´e, en l’occurence
la modularit´e. Le processus (cf Algorithme 1) se poursuit de mani`ere r´ecursive
sur le graphe r´esultant `a chaque nouvelle fusion jusqu’`a ce qu’il n’y ait plus
d’augmentation de la modularit´e. Il s’agit de la version locale de la m´ethode de
Clauset et al. (2004).

La m´ethode permet de produire des communaut´es de bonne qualit´e sur de
petits r´eseaux et l’obtention de dendrogrammes. Elle ne souﬀre pas du probl`eme
fr´equent que l’on peut trouver dans certains algorithmes optimisant la modu-
larit´e, la r´esolution de limite. Cependant, pour de grands graphes (de plusieurs
millions de nœuds et d’arˆetes), l’optimisation d’une mesure globale conduit `a
une propagation d’erreur apr`es la virgule. De ce fait, la qualit´e risque de se
d´et´eriorer en fonction de la taille des r´eseaux. L’algorithme agissant localement,
la m´ethode est instable, ne produisant jamais le mˆeme r´esultat d’un lancement

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

31

Algorithme 1 L’algorithme de Louvain
Entr´ee : Un graphe G = (V, E)

1: A r´ep´eter jusqu’`a l’obtention d’un score local optimal
2: Phase 1 : partitionner le r´eseau de mani`ere gloutonne utilisant la modula-

rit´e

3: 1) Assigner `a chaque nœud une communaut´e sp´eciﬁque
4: 2) Pour chaque nœud i du r´eseau

— Pour chaque voisin j de i, choisir le voisin pour lequel l’assignation du

nœud i dans une communaut´e augmenterait le plus la modularit´e

— R´ep´eter le processus jusqu’`a ce qu’il n’y ait plus de changement

5: Phase 2 : Agglom´erer les sous-graphes en nouveaux nœuds
6: 1) Laissons chaque communaut´e Ci former un nouveau nœud i
7: 2) Laissons les arˆetes entre les nouveaux nœuds i et j comme ´etant la
r´eunion des arˆetes entre les nœuds qui ´etaient dans Ci et Cj au sein du
graphe pr´ec´edent

`a l’autre. Il a ´et´e montr´e que l’ordre jouait un rˆole important sur la qualit´e des
communaut´es d´etect´ees. La ﬁgure 1.3 montre un exemple de fonctionnement de
la m´ethode de Louvain.

Figure 1.3 – Exemple d’application de la m´ethode de Louvain sur un graphe `a 16
sommets (Extrait de Blondel et al. (2008))

La m´ethode de Louvain ´etant instable, une des pistes de recherche fut de la
stabiliser. Une m´ethode propos´ee par Seiﬁ et al. (2013) consiste `a lancer plusieurs
fois l’algorithme non d´eterministe et `a consid´erer les nœuds qui apparaissent le
plus souvent ensemble dans une mˆeme communaut´e. On appelle ces nœuds dont
la fr´equence d’apparition est tr`es forte, des cœurs.

32

CHAPITRE 1. ETAT DE L’ART

D´eﬁnition Un cœur de communaut´e est l’ensemble des nœuds se trouvant
fr´equemment ensemble dans une mˆeme communaut´e apr`es plusieurs lancements
d’un algorithme non d´eterministe (exemple de Louvain avec Seiﬁ et al. (2013)).

ij = [pij]N

Cette m´ethode consiste `a utiliser une matrice de fr´equence, sp´eciﬁant le
nombre de fois que chaque paire de nœuds apparaˆıt dans les mˆemes commu-
naut´es. Les auteurs de cette m´ethode l’ont appliqu´ee en utilisant la m´ethode
de Louvain (Blondel et al. (2008)). Soit N le nombre de fois que l’algorithme
non d´eterministe est lanc´e. A chaque essai, nous notons chaque paire de nœuds
qui apparait dans une mˆeme communaut´e. Il est ainsi possible de d´eﬁnir une
matrice P N
n×n telle que pij repr´esente la fr´equence d’appartenance
des nœuds i et j `a une mˆeme communaut´e apr`es les N essais. pij, ´etant une
probabilit´e,∀(i, j) ∈ V × V a une valeur comprise entre 0 et 1. Un nombre
proche de 1 signiﬁe que les nœuds i etj sont souvent ensemble durant les N
essais. Pour trouver les cœurs, on cr´ee un nouveau graphe G(cid:48) = (V, E(cid:48)) o`u E(cid:48)
repr´esente l’ensemble des arˆetes cr´e´ees `a partir de la matrice de fr´equence en
utilisant un seuil α ∈ [0, 1] permettant de faire apparaˆıtre des composantes
connexes. Le seuil α est un entier positif que l’on utilise pour cr´eer le nouveau
graphe `a partir de la matrice de co-fr´equence. Pour toutes paires de sommets du
graphe, si la fr´equence d’apparition dans la matrice est sup´erieure `a la valeur
α, on ajoute une arˆete au nouveau graphe G(cid:48) reliant les nœuds en question.
Par construction, les composantes connexes dans le graphe G(cid:48) apparaissent.
Les composantes connexes sont ici les cœurs, qui correspondent `a nos commu-
naut´es. G(cid:48) est appel´e le graphe α-seuill´e. α est un param`etre qui inﬂuence des
connexions dans le nouveau graphe G(cid:48), et par cons´equence, le nombre de com-
posantes connexes. D’apr`es les ´etudes men´ees par Seiﬁ et al. (2013), de faibles
valeurs de α conduisent `a peu de composantes connexes alors que de fortes va-
leurs de α m`enent `a beaucoup de composantes connexes. Les auteurs ont montr´e
qu’ils avaient r´eussi `a stabiliser la m´ethode de Louvain, et `a trouver des cœurs
stables. La m´ethode pr´esente l’avantage de pouvoir cr´eer un dendrogramme en
faisant varier α sur un intervalle.

Pons et Latapy (2006) ont propos´e WalkTrap , un algorithme se fondant sur
le fait qu’un marcheur al´eatoire se promenant sur le graphe aura tendance `a
circuler dans des zones denses (ou `a y rester plus longtemps) plutˆot que dans
des r´egions faiblement denses. Il s’agit d’un algorithme agglom´eratif permet-
tant l’´elaboration d’un dendrogramme. Consid´erons un nœud u et son voisinage
N (u). La probabilit´e que le marcheur al´eatoire aille du nœud u vers un de ses
deg(u) . C’est ainsi que l’on peut calculer la probabilit´e que le
voisins est de
marcheur al´eatoire puisse, `a partir de k pas, aller du nœud u `a un autre nœud
v du graphe. Les probabilit´es calcul´ees entre chaque paire de nœuds vont ˆetre
utilis´ees pour calculer les similarit´es entre chaque paire de sommets du graphe.
WalkTrap d´emarre en consid´erant chaque nœud comme une communaut´e. L’al-
gorithme calcule pour chaque nœud dans le graphe un vecteur qui donne la
probabilit´e qu’un marcheur al´eatoire arrive aux autres nœuds du r´eseau en k
pas de temps. Ainsi, deux sommets u et v sont proches si leur vecteurs de proba-

1

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

33

bilit´e d’atteindre les autres sommets sont similaires. Les paires de nœuds ayant
la plus grande similarit´e entre eux fusionnent pour former une nouvelle com-
munaut´e. Un nouveau graphe est ainsi construit o`u les nœuds repr´esentent des
communaut´es. La m´ethode continue de mani`ere r´ecursive jusqu’`a obtenir une
communaut´e. A chaque d´ecoupage interm´ediaire, un calcul de la modularit´e
est eﬀectu´e qui permettra de retourner la partition optimisant ce score. L’algo-
rithme donne des r´esultats satisfaisants mais ne permet pas d’ˆetre appliqu´e `a
de tr`es grands graphes dans la mesure o`u il faut calculer pour toutes paires de
nœuds les distances. La complexit´e de l’algorithme est en O(n × m × H) o`u H
est la hauteur du dendrogramme.

1.3.4 Approches fond´ees sur la d´etection de leaders

Dans un r´eseau, certains nœuds peuvent ˆetre plus importants que d’autres.
Cela peut se traduire par une centralit´e ou un cœﬃcient de clustering plus
fort pour certains nœuds du graphe par rapport `a d’autres. C’est une des ca-
ract´eristiques des graphes de terrains avec des nœuds situ´es au centre de struc-
tures communautaires et d’autres nœuds qui leur sont li´es. Un graphe de terrain
poss`ede la caract´eristique d’avoir une distribution des degr´es des nœuds suivant
une loi faible (Loi de Zipf) (Newman (2005)). Des algorithmes, ces derni`eres
ann´ees, ont propos´e de d´etecter les nœuds les plus importants que l’on peut
qualiﬁer de leaders et d’attribuer les autres nœuds `a ces derniers pour former
des communaut´es.

Shah et Zaman (2010) ont propos´e l’algorithme ”Leaders-Suiveurs”. Les au-
teurs d´eﬁnissent deux types de nœuds, les leaders (nœuds qui connectent plu-
sieurs communaut´es) et les suiveurs loyaux (nœuds dont le voisinage se situe
dans une structure communautaire et poss`ede un lien avec un leader). L’algo-
rithme se d´ecompose en deux ´etapes. La premi`ere ´etape consiste `a rechercher
les leaders. Les auteurs d´eﬁnissent une mesure de centralit´e, pour un nœud u,
comme la somme des plus courtes distances de ce nœud `a tous les autres nœuds
du graphe. Un tri est alors eﬀectu´e sur les nœuds, fond´e sur cette mesure. L’en-
semble des leaders est ainsi constitu´e de telle sorte qu’il ne puisse pas y avoir
deux leaders voisins. La seconde ´etape consiste `a assigner les autres nœuds qua-
liﬁ´es de suiveurs aux leaders. Les voisins directs des leaders leur sont assign´es,
permettant la cr´eation des communaut´es. L’algorithme est en O(n × m). L’al-
gorithme admet de meilleurs r´esultats en termes de qualit´e que les m´ethodes
spectrales. Cependant, la m´ethode ne peut pas ˆetre appliqu´ee `a de tr`es grands
graphes dans la mesure o`u le calcul des plus courtes distances entre sommets
n´ecessite un temps important. De plus, dans des zones fortement denses, l’algo-
rithme peut d´etecter plusieurs leaders alors que cela ne devrait pas ˆetre le cas.
La cons´equence est la cr´eation de petites communaut´es qui auraient dˆu ˆetre
fusionn´ees.

34

CHAPITRE 1. ETAT DE L’ART

Kanawati (2011) a propos´e LICOD (pour ”Leader−driven algorithm for com-
munity detection in complex networks”). Il s’agit d’une version enrichie de la
m´ethode pr´esent´ee pr´ec´edemment par Shah et Zaman. Les auteurs proposent
diﬀ´erentes mesures pour le calcul des leaders, `a savoir la centralit´e de degr´e
(mesure locale) et la centralit´e d’interm´ediarit´e des nœuds (mesure globale).
Un nœud sera consid´er´e comme leader si sa centralit´e est sup´erieure ou ´egale
`a σ ∈ [0, 1] pourcentage de voisins. Deux leaders sont consid´er´es comme ´etant
dans une mˆeme communaut´e si leur nombre de voisins communs est sup´erieur `a
un seuil δ ∈ [0, 1]. Concernant les nœuds suiveurs, les auteurs proposent d’utili-
ser l’inverse du plus court chemin vis-`a-vis des communaut´es qui se constituent.
Les r´esultats en termes de qualit´e sont corrects et surpassent les autres algo-
rithmes sur des r´eseaux dont la densit´e est ´elev´ee. L’algorithme est cependant
sujet au choix de la param´etrisation de σ et δ qui ont une inﬂuence sur le nombre
de communaut´es trouv´ees. Comme pour la m´ethode de Shah et Zaman, l’algo-
rithme est sujet au calcul des plus courts chemins dont le coˆut computationnel
peut se r´ev´eler important pour de grands graphes. On notera que des travaux
de recherches portant sur la centralit´e d’interm´ediarit´e pour traiter des graphes
relativement grands ont ´et´e eﬀectu´es en utilisant le parall´elisme par Kermarrec
et al. (2011).

1.3.5 Approches fond´ees sur la perturbation du r´eseau

Les m´ethodes de perturbation des r´eseaux ont ´et´e cr´e´ees pour l’am´elioration
d’algorithmes d´eterministes. L’id´ee est qu’en eﬀectuant une modiﬁcation to-
pologique du graphe, certaines structures communautaires puissent ˆetre plus
facilement d´etect´ees.

Gfeller et al. (2005) proposent de construire une suite de graphes G1,G2,...,Gn
en modiﬁant la pond´eration des arˆetes pour chaque couple de nœuds (x, y) via
une loi de distribution uniforme. L’id´ee est que si des communaut´es existent au
sein d’un graphe, une faible modiﬁcation topologique du graphe en utilisant une
nouvelle pond´eration des arˆetes ne devrait pas modiﬁer la structure des commu-
naut´es d´etect´ees. Les auteurs d´eﬁnissent la probabilit´e intra-cluster pij comme
´etant le nombre de fois que les nœuds i et j se sont trouv´es dans les mˆemes
communaut´es. Les liens ayant une pond´eration pij ≤ θ sont retir´es du graphe.
Les composantes connexes r´esultantes forment ainsi les communaut´es. Bien que
l’id´ee de perturbation des arˆetes semble ˆetre un axe prometteur, l’´evaluation
des param`etres θ et σ handicape la m´ethode fortement. L’algorithme n´ecessite
plusieurs tests avant de retourner sa meilleure partition.

Karrer et al. (2008) ont propos´e un algorithme perturbatif qui enl`eve une
certaine portion d’arˆetes α et qui la remet entre certaines paires de sommets
(x, y) avec une probabilit´e d(x)d(y)
2m , que l’on retrouve dans le mod`ele nul. L’ob-
jectif est de conserver la distribution des degr´es des nœuds au sein du r´eseau.

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

35

L’id´ee de cette m´ethode est d’ajouter des liens dans des zones fortement denses
et d’en retirer des zones faiblement denses. L’algorithme n´ecessite de tester
cependant plusieurs valeurs de α avant l’obtention d’une partition de qualit´e.
Cette m´ethode d´epend ´egalement du mod`ele nul, qui parfois, ne met pas en
´evidence de structures communautaires ostensibles. L’algorithme pr´esente ce-
pendant l’avantage de d´etecter des structures communautaires au sens fort et
faible de Radicchi et al. (2004) et de tailles diﬀ´erentes.

Rosvall et Bergstrom (2007b) ont propos´e Infomod. Il s’agit d’une m´ethode
fond´ee sur la th´eorie de l’information, plus exactement sur la quantit´e d’informa-
tion qu’une partition a vis-`a-vis du graphe originel. L’id´ee consiste `a partir d’une
partition Y de sommets d’un graphe qu’un ´emetteur envoie `a un receveur, de
deviner la structure topologique du graphe X. La meilleure partition du signal Y
contenant le plus d’information au sujet de X sera consid´er´ee. Chaque ´el´ement
de Y repr´esente une structure communautaire. L’information entre les deux par-
titions peut-ˆetre quantiﬁ´ee par la minimisation de l’information conditionnelle

de l’entropie H(X|Y ) de X sachant Y . H(X|Y ) = log[(cid:81)q

lij
o`u q est le nombre initialement choisi de communaut´es par l’utilisateur, ni le
nombre de sommets dans la communaut´e i et lij le nombre de liens entre les
communaut´es i et j. A chaque calcul de la quantit´e d’information entre les
deux partitions, des migrations de sommets s’eﬀectuent entre communaut´es.
La m´ethode donne des r´esultats en termes de qualit´e de partitionnement en-
courageants sur des graphes faiblement et fortement denses. Cependant, cette
m´ethode ne peut pas ˆetre appliqu´ee `a des graphes de plus de 105 nœuds. La
m´ethode n´ecessite ´egalement de donner un nombre de communaut´es initial. La
ﬁgure 1.4 donne une explication du fonctionnement de la m´ethode Infomod.

(cid:0) ni(ni−1)

(cid:1)(cid:81)

i>j

(cid:0)ninj

(cid:1)]

i=1

2
lii

Figure 1.4 – Principe de base de la m´ethode Infomod. Un codeur envoie `a un d´ecodeur
une information compress´ee sur la topologie du graphe `a gauche. L’information donne
une description grossi`ere du graphe, qui est utilis´ee par le d´ecodeur pour d´eduire la
structure topologique originale. Extrait d’origine de Rosvall et Bergstrom (2007b)

Rosvall et Bergstrom (2010) ont propos´e Infomap. Il s’agit d’une m´ethode
fond´ee sur la th´eorie de l’information, un processus d’encodage et sur la marche
al´eatoire. Le proc´ed´e d’Infomap consiste `a trouver des structures communau-
taires en ´etudiant la marche al´eatoire et la ressemblance de motifs. Pour situer
le marcheur al´eatoire dans le graphe, on attribue aux sommets un identiﬁant

36

CHAPITRE 1. ETAT DE L’ART

unique ainsi qu’un identiﬁant `a la communaut´e `a laquelle ils appartiennent.
Pour d´ecrire le d´eplacement du marcheur al´eatoire, on commence par donner
l’identiﬁant de la communaut´e, puis le label du nœud sur lequel il se trouve.
D`es que le marcheur al´eatoire sort de la communaut´e il faut lui attribuer l’iden-
tiﬁant de la nouvelle communaut´e et le label du nouveau nœud. L’id´ee est qu’il
peut y avoir des structures ressemblantes dans chacune des communaut´es. Il y a
par exemple, plusieurs ”rue des Abeilles” en France, notamment `a Montpellier,
Mulhouse, Marseille, Toulouse ou `a L`ege-Cap-Ferret, dans des villes diﬀ´erentes.
Les chemins qu’emprunte le marcheur al´eatoire sont ainsi encod´es et l’encodage
minimum permet de trouver les structures communautaires.
Cette m´ethode fut test´ee sur les graphes al´eatoires g´en´er´es par les benchmarks
de Lancichinetti et al. (2008) et surpassa les autres m´ethodes en termes de
qualit´e de partitionnement, ce qui fonda sa notori´et´e. L’algorithme pr´esente
l’avantage de pouvoir traiter de tr`es grands graphes. Il constitue `a ce jour l’une
des meilleures m´ethodes de partitionnement pour la d´etection de communaut´es
disjointes.

De Meo et al. (2013) ont propos´e CONCLUDE (pour Complex Network
Cluster Detection). L’algorithme utilise `a la fois l’importance des arˆetes du
graphe et un algorithme de clustering qui fait suite `a une projection des nœuds
dans un espace euclidien pour trouver les communaut´es. L’algorithme fonctionne
en deux ´etapes. La premi`ere ´etape consiste en l’utilisation d’un mod`ele de pro-
pagation de l’information au sein du r´eseau, fond´e sur une marche al´eatoire avec
non retour et de longueur ﬁxe. Cela permet d’attribuer un score `a l’importance
des arˆetes maintenant le graphe connect´e. Les auteurs nomment cette mesure la
centralit´e d’arˆete (Meo et al. (2011)). La centralit´e d’arˆete est ensuite utilis´ee
pour projeter les sommets du r´eseau en points dans un espace euclidien et un
calcul de distance entre chaque paire de nœuds est eﬀectu´e. Un nouveau graphe
est cr´e´e et la m´ethode de Louvain est appliqu´ee.
Cette m´ethode n´ecessite cependant de param´etrer la longueur des marches
al´eatoires k qui est un param`etre global. Les graphes de terrain peuvent conte-
nir des tailles de communaut´es diﬀ´erentes, ce qui pose un probl`eme `a la pa-
ram´etrisation de k. L’algorithme a cependant une complexit´e proche de la
lin´earit´e en termes d’arˆetes et produit, sous condition d’une bonne param´etrisation,
de meilleurs r´esultats que la m´ethode de Louvain sur des graphes sociaux.

1.3.6 Approche par propagation de labels

La m´ethode de propagation de labels (Raghavan et al. (2007)), not´ee LPA,
est fond´ee sur la transmission d’un label d’un nœud `a ses voisins. Un ´etat
d’´equilibre est atteint lorsque chaque nœud a son label ´egal `a celui de la majo-
rit´e de ses voisins. Soit un graphe G = (V, E), avec V l’ensemble des sommets
(|V | = n) et E l’ensemble des arˆetes (|E| = m).

A chaque ´etape, chaque nœud met `a jour son label selon les labels de ses

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

37

voisins, en utilisant un vote. Le label du nœud u prendra le label majoritaire
de ses voisins. En notant cu le label du nœud u, et par N l(u) l’ensemble du
voisinage du nœud u avec le label l, l’aﬀectation d’un label au nœud u est
donn´ee par la formule suivante :

cu = arg max

l

|N l(u)|

(1.10)

A la ﬁn du processus, les nœuds ayant le mˆeme label repr´esentent une com-
munaut´e. Cette m´ethode peut ˆetre eﬀectu´ee de mani`ere synchrone ou asyn-
chrone. La m´ethode asynchrone signiﬁe que la mise `a jour d’un label d’un nœud
est connue par tous les autres nœuds du graphe imm´ediatement. Son label est
transmis pour la mise `a jour des labels des autres nœuds. Ce n’est pas le cas
du mode synchrone, o`u la mise `a jour des labels utilise les labels des nœuds
`a la pr´ec´edente propagation. La complexit´e de cet algorithme que cela soit en
mode synchrone ou asynchrone est en O(k × (n + m)), o`u k ∈ N repr´esente le
nombre d’it´erations de l’algorithme, sp´eciﬁ´e par l’utilisateur. D’apr`es les ´etudes
men´ees par Raghavan et al. (2007), sur des graphes sociaux ayant moins de
1000 nœuds, 5 it´erations suﬃsent pour obtenir une bonne classiﬁcation. Pour
des graphes ayant plus de nœuds, les recherches men´ees par l’auteur ne purent
´etablir le nombre exact d’it´erations. L’auteur pr´econise de mettre un nombre
assez important d’it´erations et d’observer it´eration apr`es it´eration si le nombre
de communaut´es ´evolue. Cet algorithme pr´esente l’avantage d’avoir une com-
plexit´e permettant de travailler sur de grands graphes.
Cependant, l’algorithme de propagation de labels pr´esente l’inconv´enient d’ˆetre
instable, ne donnant que rarement le mˆeme r´esultat apr`es plusieurs lancements.
Il est aussi caract´eris´e par un probl`eme intrins`eque conduisant dans certains
cas `a de tr`es grandes communaut´es (monstres). Ce probl`eme peut s’expliquer
par deux raisons. La premi`ere est le choix parfois al´eatoire du label que doit
prendre un nœud lorsqu’il y a plusieurs labels majoritaires dans son voisinage.
La seconde porte sur les tailles des structures. En eﬀet, la propagation de labels
prendra moins de temps `a couvrir de petits r´eseaux que de gros r´eseaux. Pour
pallier ces deux derniers probl`emes, de nombreuses propositions algorithmiques
ont ´et´e publi´ees depuis ces derni`eres ann´ees, que nous allons exposer.

Figure 1.5 – Exemple de propagation de labels

38

CHAPITRE 1. ETAT DE L’ART

Sur la Figure 1.5, nous consid´erons un graphe G avec V = A, B, C, D, F .
Chaque nœud a initialement son propre label que nous avons mod´elis´e par une
couleur. Ainsi, le nœud A a la couleur rose, le nœud B a la couleur orange, le
nœud C a la couleur bleue, le nœud D a la couleur violette et le nœud E a la
couleur beige. Un ordre σ est donn´e sur les nœuds et est suivi pour proc´eder
`a la propagation de labels. Le nœud A a le choix entre les couleurs de B,C,
D et E (cas de l’´equidistribution des labels majoritaires), au hasard, le nœud
A prend le label du nœud B, soit la couleur du nœud B, l’orange. La couleur
majoritaire dans le voisinage du nœud D est orange, le nœud D prend la couleur
orange. La couleur majoritaire dans le voisinage du nœud C est orange, le nœud
C prend la couleur orange. La couleur majoritaire dans le voisinage du nœud
B est orange, le nœud B prend la couleur orange. Enﬁn, la couleur majoritaire
dans le voisinage du nœud E est orange, le nœud E prend la couleur orange.
La premi`ere it´eration de labels est eﬀectu´ee. Chaque nœud poss`ede la couleur
majoritaire de son voisinage, le processus s’arrˆete. Sur d’autres conﬁgurations
de graphe, nous serions pass´es `a la seconde it´eration de labels jusqu’`a ce que
chaque nœud poss`ede la majorit´e des couleurs des voisins.

En appliquant ce proc´ed´e au graphe de la Figure 1.6, les communaut´es ap-

paraissent.

Figure 1.6 – Exemple de propagation de labels

Cependant, l’algorithme souﬀre de mauvaises propagations pouvant don-
ner le ph´enom`ene de communaut´es g´eantes, c’est-`a-dire l’incapacit´e pour l’algo-
rithme de d´etecter de petites structures communautaires. Dans l’exemple de la
Figure 1.7, une mauvaise propagation se fait lorsque le nœud B est visit´e pour
la mise `a jour de son label. A cause de l’´equidistribution des couleurs majori-
taires, le nœud B choisit au hasard une couleur, ce qui par la suite aura pour
cons´equence l’obtention de la communaut´e g´eante.

L’algorithme est non d´eterministe et souﬀre d’une forte instabilit´e. En consid´erant

l’exemple du club de Karat´e (Zachary (1977)), on peut s’apercevoir sur la Figure
1.8 que le nombre de communaut´es change au cours des diﬀ´erentes propagations
de labels. Certains exemples donnent 2 ou 3 communaut´es alors que d’autres ne
donnent qu’une grande communaut´e. Il s’agit d’un algorithme instable, c’est-`a-
dire ne donnant que rarement le mˆeme r´esultat d’un lancement `a l’autre.
Leung et al. (2009) ont propos´e un score pour chaque label qui diminue d’un
certain pas δ ∈ [0, 1] quand la distance g´eod´esique de la source du nœud qui a
´emis le label devient trop ´elev´ee. Cette m´ethode a ´et´e nomm´ee ”propagation de
labels par att´enuation”. Cela a pour cons´equence d’´eviter l’obtention de trop
grandes communaut´es dans les graphes. Les exp´eriences ont montr´e que cette

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

39

Figure 1.7 – Exemple de propagation de labels donnant une communaut´e g´eante

Figure 1.8 – La propagation de labels est un algorithme non d´eterministe et instable.
Application sur le graphe de Karat´e (Zachary (1977))

m´ethode permettait d’´eviter de mauvaises propagations et donnait de meilleurs
r´esultats que le LPA. Le probl`eme restant est de pouvoir param´etrer la distance
du nœud `a la source aﬁn de diminuer le score de la fonction d’att´enuation.
La solution n’est pas stable et n´ecessite plusieurs essais avant l’obtention d’un
r´esultat concluant.

ˇSubelj et Bajec (2011) ont continu´e les travaux de Leung en proposant une
propagation de labels oﬀensive, d´efensive et hybride fond´ee sur la modiﬁca-

40

CHAPITRE 1. ETAT DE L’ART

tion du vote et du pas d’att´enuation. Cette modiﬁcation porte sur l’application
d’une propagation de labels par pr´ef´erence de nœud, qui consiste lors du vote,
`a prendre le label voisin dont le degr´e de centralit´e et la diﬀusion en termes de
marche al´eatoire sont les plus importants. Le facteur de pr´ef´erence est la diﬀu-
sion du label divis´ee par la centralit´e du nœud ´emetteur (m´ethode d´efensive pour
la d´etection de cœurs), et la m´ethode oﬀensive (permettant de d´eﬁnir les bor-
dures des communaut´es) dont la distance de propagation est plus grande. Une
hybridation des deux m´ethodes a men´e `a l’algorithme K−cœurs, qui consiste
`a appliquer la m´ethode d´efensive pour trouver les cœurs, puis `a appliquer la
m´ethode oﬀensive pour trouver les fronti`eres des communaut´es. Les r´esultats
on montr´e de nettes diﬀ´erences entre les m´ethodes avec une stabilit´e plus forte
pour la m´ethode d´efensive. La m´ethode d´efensive trouve de petites commu-
naut´es alors que la m´ethode oﬀensive trouve de tr`es grandes communaut´es. Les
r´esultats sont cependant ´equivalents au LPA en termes de qualit´e de partition-
nement. Les exp´erimentations ont montr´e que la m´ethode hybride ´etait un bon
compromis dont le r´esultat en termes de qualit´e des communaut´es surpassait le
LPA. L’algorithme n´ecessite cependant une param´etrisation importante, comme
le pas d’att´enuation et la puissance `a laquelle on l’´el`eve. L’algorithme n’est ce-
pendant pas d´eterministe.

Zong-Wen et al. (2014) proposent une propagation de labels guid´ee par
consensus. Les auteurs proposent de lancer plusieurs fois l’algorithme de propa-
gation de labels pour obtenir diﬀ´erentes partitions. Un nouveau graphe pond´er´e
est alors cr´e´e o`u la pond´eration des arˆetes repr´esente le nombre de fois que
chaque paire de nœuds est dans une mˆeme communaut´e. C’est alors qu’une
propagation de labels avec consensus fond´ee `a la fois sur les poids des arˆetes et
la fr´equence des labels permet d’assigner `a un nœud un nouveau label. Cette
m´ethode produit de meilleurs r´esultats que le LPA mais une ´etude pr´ealable
pour chaque graphe doit ˆetre faite pour la param´etrisation. Cette m´ethode ne
permet pas l’´elaboration de dendrogramme.

Pour r´esoudre le probl`eme de l’´equidistribution des labels majoritaires pour
le processus de vote, Xie et Szymanski (2013) proposent une propagation de
labels avec op´erateurs aﬁn de stabiliser et de rendre d´eterministe le LPA tout
en am´eliorant la qualit´e de partitionnement. Cela consiste `a stocker, propager
et trier les labels de chaque nœud en utilisant quatre op´erateurs qui sont la
propagation, l’inﬂation, la coupure et une phase de mise `a jour de stabilisation
du LPA. Chaque nœud re¸coit le label majoritaire de ses voisins en ´eliminant les
choix al´eatoires (c’est-`a-dire que s’il y a plusieurs labels majoritaires dans son
voisinage, l’algorithme les ajoute `a un vecteur et s´electionne le label recouvrant
le groupe de nœuds ayant la centralit´e moyenne la plus ´elev´ee. Les communaut´es
se forment it´eration apr`es it´eration). La partition r´esultante est d´eterministe car
il n’y a plus de choix al´eatoires. Le labelrank a une complexit´e algorithmique en
O(m).
Les auteurs ont propos´e par la suite LabelRankT en y ajoutant une condition

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

41

suppl´ementaire sur la mise `a jour des labels, destin´ee aux graphes dynamiques
(graphes o`u les sommets et les arˆetes sont ajout´es au cours du temps dans
leur cas). L’id´ee est de consid´erer la partition actuelle pour inf´erer la partition
suivante. Cela maintient l’ancienne partition tout en mettant `a jour les nœuds
seulement aﬀect´es par l’ajout d’arˆetes. Lorsqu’une nouvelle arˆete se greﬀe dans le
graphe, LabelRankT met `a jour les nœuds qui sont sur ses extr´emit´es. La qualit´e
de partionnement est similaire `a MCL et Informap sur des graphes sociaux, mais
avec une complexit´e algorithmique moins ´elev´ee. Il est cependant plus rapide
que certains algorithmes pour la d´etection de communaut´es dynamiques comme
facetNet et iLCD. La complexit´e globale de cet algorithme entre deux images
cons´ecutives d’un mˆeme r´eseau est en O(k× m), o`u k est le nombre d’it´erations.
LabelRankT peut ˆetre ´etendu `a la d´etection de communaut´es chevauchantes
en lui int´egrant le SLPA (”Speakerlistener Label Propagation Algorithm”) (Xie
et al. (2011)) dont nous donnerons la d´eﬁnition en section 1.4.

Lou et al. (2013), arguent qu’une limitation du LPA est due `a son processus
de vote. En adoptant le label majoritaire de ses voisins l’information topologique
est perdue et cela a pour eﬀet l’instabilit´e du LPA et sa pauvre performance en
termes de qualit´e dans certains cas. C’est en ce sens que les auteurs font interve-
nir une mesure nomm´ee ”coh´erence de proximit´e du voisinage” (W-CNN) dont
l’objectif est de calculer la probabilit´e qu’une paire de nœuds soit dans la mˆeme
communaut´e. Elle est fond´ee sur un voisinage plus large des nœuds consid´er´es
lors du vote. Un label aura plus d’importance si sa source est issue d’un milieu
fortement dense. Dans la phase de mise `a jour des labels, un nœud adoptera le
label ayant la plus forte valeur de W-CNN au lieu du vote majoritaire tradi-
tionnel.
Les auteurs montrent que pour de petits r´eseaux, les r´esultats sont ´equivalents
au LPA sans toujours stabiliser la solution. L’algorithme toutefois montre de
meilleurs r´esultats que le LPA pour de grands graphes de terrain, avec une
meilleure stabilisation.

Xing et al. (2014) proposent une propagation de labels par nœuds inﬂuents.

Cette m´ethode est fond´ee sur un ordre de mise `a jour des labels et sur l’am´elioration
du vote lorsqu’il y a ´equidistribution des labels majoritaires. Cette m´ethode se
fonde sur le (k)-shell d’un nœud et de son voisinage. Un k-shell est un sous
graphe connexe maximum o`u chaque nœud a un degr´e au moins de k. Un k-shell
est form´e des sommets qui sont du k-core mais qui ne sont pas du k + 1-core.
La valeur du k-shell d’un nœud est k. Pour un nœud u, les auteurs notent
Ks(u) la valeur du k-shell du nœud u, N (u) l’ensemble des voisins du nœud u
et d´eﬁnissent l’inﬂuence du nœud par :

N I(u) = Ks(u) + α × (cid:88)

Ks(u)
d(v)

(1.11)

v∈N (u)

o`u d(v), le degr´e du nœud u, α ∈ [0, 1] ´etant un param`etre global (utilis´e pour

42

CHAPITRE 1. ETAT DE L’ART

ajuster l’eﬀet des voisins sur la centralit´e d’un nœud u). Les auteurs ﬁxent l’ordre
de mise `a jour des labels de mani`ere d´ecroissante selon les scores des inﬂuences
des nœuds. Ils d´eﬁnissent ´egalement l’inﬂuence du label fond´ee sur l’inﬂuence du
nœud pour choisir un label lorsqu’il y a plusieurs labels majoritaires au sein d’un
voisinage d’un nœud. De par leurs exp´erimentations, notamment sur des graphes
r´eels comme le club de karat´e, le r´eseau de dauphins, le r´eseau footballistique,
celui des livres politiques et celui portant sur des collaborations scientiﬁques,
les auteurs montrent qu’eﬀectuer la mise `a jour des labels des nœuds ayant un
fort (k)-shell permet de mieux stabiliser la propagation de labels mais que les
r´esultats en termes de qualit´e de partitionnement ne sont toujours satisfaisants.
En eﬀet, le NMI sur les dauphins n’est que de 0.65, celui du r´eseau footballis-
tique n’est que de 0.87 et celui des livres politiques, de 0.656. Ce qui, par rapport
`a d’autres algorithmes notamment celui de Louvain montre que la m´ethode est
moins performante. Les r´esultats sur les graphes al´eatoires conduise a la mˆeme
analyse.
Cette m´ethode est ´egalement sujette au choix de la valeur α qui reste un sujet
de recherche ouvert. Par cons´equent, cette m´ethode ne peut pas ˆetre appliqu´ee
sur des graphes r´eels sans faire une ´etude pr´ealable. Une autre contrainte est le
temps d’ex´ecution n´ecessaire `a la mise `a jour de la fonction d’inﬂuence qui peut
devenir tr`es important pour de grands graphes.

Zhang et al. (2014) ont propos´e une version modiﬁ´ee du LPA avec la capacit´e
`a la pr´ediction de transition de percolation (LPAp). Les eﬀets de la phase de
pr´ediction au sein du LPA permettent de retarder la formation de communaut´es
g´eantes. Les auteurs impl´ementent une condition de mise `a jour dans le but de
r´eduire le temps d’´ex´ecution du LPAp.
Les exp´erimentations ont montr´e que LPAp permettait de trouver des commu-
naut´es de petites tailles, ´etait plus stable que le LPA et donnait de meilleurs
r´esultats. Cependant, la mise `a l’´echelle pour de grands graphes semble ˆetre la
faiblesse de la proposition algorithmique.

Cordasco et Gargano (2012) ont ´etudi´e le comportement de la propagation
de labels synchrone et asynchrone. Dans le but de r´esoudre le probl`eme d’une
impl´ementation parall´elis´ee de la propagation de labels (o`u la propagation se
fait de mani`ere s´equentielle d’ordinaire), les auteurs proposent la propagation de
labels semi-synchrone. Un algorithme de coloration est lanc´e permettant d’obte-
nir une partition D = {D1, D2, ..., Dk} (en k parties) de telle mani`ere que deux
nœuds adjacents n’aient pas la mˆeme couleur. Les couleurs obtenues serviront
d’ordre de visite pour la mise `a jour des labels. Tous les nœuds avec les mˆemes
couleurs eﬀectueront en mˆeme temps la mise `a jour de leurs labels selon le vote
majoritaire classique du LPA. Durant cette mise `a jour, les autres nœuds, dont
la coloration est diﬀ´erente, sont bloqu´es, leur imposant l’impossibilit´e de mettre
`a jour leurs labels. Cela permet d’´eviter de rendre l’algorithme synchrone et
de perdre en qualit´e de partitionnement. Apr`es que cette phase de mise `a jour
est eﬀectu´ee, les nœuds qui ´etaient bloqu´es connaissent les nouveaux labels, no-

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

43

tamment s’il y a eu des modiﬁcations de labels dans leur voisinage. Une autre
couleur est alors consid´er´ee et le processus continue. Lorsque toutes les couleurs
ont ´et´e traˆıt´ees, une propagation de labels globale a ´et´e eﬀectu´ee. On r´ep`ete le
processus un nombre de fois d´etermin´e par l’utilisateur ou jusqu’`a stabilisation
en termes de vote.

Les auteurs ont montr´e que la m´ethode semi-synchrone ´etait plus eﬃcace en
termes de stabilit´e que le LPA (sans la rendre pour autant d´eterministe), et
parall´elisable. Les r´esultats sont cependant ´equivalents au LPA en termes de
qualit´e de partitionnement.

1.3.7 Autres m´ethodes

M´ethodes de modularit´e extr´emale

Guimera et al. (2004) propos`erent le recuit-simul´e fond´e sur l’optimisation
de la modularit´e pour former les communaut´es. Une partition al´eatoire est ef-
fectu´ee sur le r´eseau. Un nœud se d´eplacera dans une autre communaut´e si la
modularit´e augmente ou avec une certaine probabilit´e. L’algorithme est it´eratif
jusqu’`a ce que la modularit´e n’augmente plus. Bien que l’algorithme donne des
r´esultats satisfaisants, la m´ethode n´ecessite de param´etrer le recuit-simul´e, et
n’est pas exempte de tomber dans un optimum local duquel on ne puisse plus
sortir. La complexit´e est diﬃcile `a estimer et d´epend de la param´etrisation. De
nombreuses combinaisons doivent ˆetre test´ees pour faire migrer un nœud d’une
communaut´e `a une autre, ce qui n´ecessite un certains de traitement. La m´ethode
a ´et´e appliqu´ee `a des graphes ayant environ 200 nœuds.

Massen et Doye (2006) ont apport´e deux am´eliorations majeures. La premi`ere
est que l’algorithme s’arrˆete de mani`ere p´eriodique, ´evalue les communaut´es et
teste toutes les possibilit´es de mouvement de certains nœuds qui optimisent
le plus la modularit´e. La seconde r´eside en l’utilisation de l’approche Basin-
Hopping (Wales et Doye (1997)), `a savoir que des groupes de nœuds puissent
changer de communaut´e d’un bloc. Cela permet d’´eviter de tomber dans un op-
timum local concernant la modularit´e. L’algorithme donne de meilleurs r´esultats
que celui de Guimera et al. (2004), mais est plus lent.

Mod`ele de Potts

Le mod`ele d’Ising (aussi appel´e mod`ele de Lenz-Ising), est un mod`ele de
physique statistique. Il repr´esente un syst`eme de particules, chacune poss´edant
deux niveaux d’´energie (on parle de spins). Le spin est le moment cin´etique in-
trins`eque des particules quantiques. Il s’agit, pour simpliﬁer, du sens de rotation
de l’´electron consid´er´e. La spintronique (´electronique de spin) permet de mettre

44

CHAPITRE 1. ETAT DE L’ART

la forme g´en´erale de l’hamiltonien comme ´etant H(x) = −(cid:80)

en ´evidence des ph´enom`enes de transition de phase, c’est-`a-dire une transfor-
mation du syst`eme ´etudi´e provoqu´ee par la variation d’un param`etre ext´erieur
particulier (temp´erature, champ magn´etique...). En consid`erant un syst`eme isol´e
de n particules auxquelles est associ´e un ´etat (ou spin) −1 ou +1, on peut
d´eﬁnir la conﬁguration du syst`eme, qui est la donn´ee de chacun des spins du
syst`eme. L’information peut donc ˆetre contenue dans un vecteur x ∈ {+1,−1}n
En notant par xi la ieme particule tel que x = {xi, 1 ≤ i ≤ n}, on d´eﬁnit
1≤i,j≤n Jijxixj,
o`u les Jij sont les couplages entre les particules i et j (r´eels positifs ou nuls)
et xixj est un produit scalaire. Suivant une certaine conﬁguration du mod`ele,
l’hamiltonien nous donne l’´energie du syst`eme de particules ´etudi´ees selon la
conﬁguration x. L’hamiltonien est une fonction `a optimiser. Plus l’´energie d’un
syst`eme est ´elev´ee, moins le syst`eme est stable. Un syst`eme physique a tendance
`a se trouver dans un ´etat d’´energie minimale. Le mod`ele de Potts consiste en
une g´en´eralisation du mod`ele d’Ising o`u le syst`eme de spins peut ˆetre dans q
´etats diﬀ´erents (x ∈ {1, ..., q}n).

C’est Fu et Anderson (1986) qui ont d´emontr´e par analogie qu’il existe une
relation entre l’´energie des syst`emes physiques (repr´esent´ee par l’Hamiltonien)
et la fonction de coˆut dans un probl`eme d’optimisation discr`ete (probl`eme com-
binatoire). Blatt et al. (1996) ont construit le mod`ele de clustering de Potts.
C’est Reichardt et Bornholdt (2006) qui l’ont retranscrit au probl`eme de la
d´etection de communaut´es, avec l’´energie du syst`eme de spin (soit l’hamilto-
nien) ´equivalente `a la fonction de qualit´e du regroupement `a optimiser, les ´etats
de spins ´etant les indices communautaires. Le lien entre le mod`ele de Potts et
la d´etection de communaut´es se fait en consid´erant les Jij (couplages entre les
particules i et j) comme ´etant la matrice d’adjacence Aij (lien entre les nœuds
i et j).

Reichardt et Bornholdt (2006) d´eﬁnissent l’hamiltonien comme ´etant :

(1.12)

(1.13)

H({σ}) = −(cid:88)
(cid:88)

i(cid:54)=j

(cid:88)
cijAij(1 − δ(σi, σj)) −(cid:88)

aijAijδ(σi, σj) +

i(cid:54)=j

+

i(cid:54)=j

bij(1 − Aij)(1 − δ(σi, σj))

dijAij(1 − δ(σi, σj))

i(cid:54)=j

o`u les Aij sont les ´el´ements de la matrice d’adjacence, σ = {σ1, ..., σn} est le
vecteur repr´esentant la partition du graphe, σi est le label de la communaut´e
du nœud i et aij, bij, cij, dij sont des pond´erations sur les liens entre i et j.
δ(σi, σj) = 1 si les nœuds i et j sont dans la mˆeme communaut´e, 0 sinon. Jœrg
Reichardt et Stefan Bornholdt ont voulu un algorithme permettant d’encourager
la cr´eation de communaut´es `a la fois avec une forte proportion de liens dans ces
derni`eres et une faible proportion de liens en ressortant. Ainsi, peut-on expliquer
la formule pr´ec´edemment expos´ee comme suit :

1. aijAijδ(σi, σj) repr´esente les liens internes
2. bij(1 − Aij)(1 − δ(σi, σj)) repr´esente les liens internes n’existant pas

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

45

3. cijAij(1 − δ(σi, σj)) repr´esente les liens externes
4. dijAijδ(1 − σi, σj) repr´esente les liens externes n’existant pas

Pour les liens n’existant pas, le mod`ele de Jœrg Reichardt et Stefan Bornholdt
utilise un graphe complet avec un poids (1 si le lien existe et 0 dans le cas
contraire). Les auteurs ont r´e´ecrit la formule sous une autre forme :

H({σ}) = −(cid:88)

i(cid:54)=j

(Aij − γpij)δ(σi, σj))

(1.14)

o`u pij est la probabilit´e qu’il existe un lien entre les nœuds i et j dans le
graphe nul (un graphe respectant la distribution des degr´es des nœuds du r´eseau
initial mais o`u les arˆetes ont ´et´e mises de mani`ere al´eatoire). En consid´erant la
derni`ere formule cit´ee, supposons que le facteur γ n’apparaisse pas, nous obte-
nons alors la formule de la modularit´e. La modularit´e est une mesure de par-
titionnement souﬀrant d’une limite de r´esolution. Si des communaut´es sont de
tailles diﬀ´erentes `a l’int´erieur d’un mˆeme graphe, certaines communaut´es, mˆeme
bien d´eﬁnies, pourront ne pas ˆetre distingu´ees dans la partition de modularit´e
optimale. Pour pallier ce probl`eme, les auteurs font intervenir un facteur γ qui a
une incidence sur l’´echelonnabilit´e des tailles des communaut´es d´etect´ees. Pour
γ → 0, le graphe est consid´er´e comme une seule communaut´e. Pour γ → ∞,
chaque nœud est consid´er´e comme une communaut´e. On peut ainsi consid´erer
la fonction hamiltonienne comme une fonction objective `a optimiser, o`u les
´el´ements `a rechercher sont ceux du vecteur σ = {σ1, ..., σn}. Les auteurs uti-
lisent une m´ethode de recuit-simul´e en partant d’un ´etat initial o`u les spins sont
assign´es au hasard aux sommets, avec un nombre d’´etats q ´elev´e. Les r´esultats
exp´erimentaux en termes de qualit´e sont bons, mais cependant sujets au choix
du paramˆetre γ, `a la lenteur de l’algorithme du recuit-simul´e qui demande une
forte param´etrisation et `a sa complexit´e qui ne lui permet pas d’ˆetre appliqu´e
`a de tr`es grands graphes.

√

Ronhovde et Nussinov (2010) ont dans des travaux post´erieurs propos´e des
am´eliorations et diverses fonctions hamiltoniennes, mais ´egalement consid´er´e
d’autres algorithmes de d´etection de communaut´es dont les complexit´es sont
moins fortes que celle du recuit-simul´e. Les auteurs ont montr´e qu’en faisant in-
tervenir γ, le probl`eme de r´esolution de limite persistait dans des communaut´es
γ × m. Ils introduisent le mod`ele absolu permettant de
de taille inf´erieure `a
cr´eer un mod`ele de Potts `a q ´etats sans utiliser le mod`ele nul, en supprimant
par voie de cons´equence le probl`eme de r´esolution de limite. Pour ce faire, les
auteurs proposent d’utiliser la densit´e comme probabilit´e et de maximiser son
esp´erance sur toutes les communaut´es. L’algorithme utilis´e est une m´ethode
multi-niveau permettant la cr´eation d’un dendrogramme. Le syst`eme donne
de meilleurs r´esultats que le mod`ele originel, mais n´ecessite deux grands pa-
ram`etres, le nombre de contractions et le nombre d’´etats au d´epart (un nombre
de communaut´es dont le nombre diminue au cours du temps). Les auteurs pro-
posent par la suite d’autres fonctions hamiltoniennes comme pour des graphes

46

CHAPITRE 1. ETAT DE L’ART

pond´er´es, un mod`ele fond´e sur les graphes al´eatoires d’Erdos-Renyi, et sa ver-
sion pond´er´ee. Les r´esultats en termes de qualit´e sont encourageants et tr`es
proches mais n´ecessitent la param´etrisation de γ qui a un impact tr`es ´elev´e sur
la qualit´e des communaut´es.

Prat-P´erez et al. (2014) en 2014 ont propos´e un algorithme de d´etection
de communaut´es, SCD (pour Scalable Community Detection), fond´e sur l’id´ee
que des communaut´es doivent avoir une fort coeﬃcient de clustering dans les
r´eseaux complexes. SCD comprend deux ´etapes. La premi`ere consiste en l’obten-
tion d’une partition P par optimisation du cœﬃcient de clustering. La deuxi`eme
´etape consiste en un raﬃnage qui fait migrer certains nœuds dans d’autres com-
munaut´es en utilisant un ordre sur les nœuds selon leurs coeﬃcients de cluste-
ring. Les d´eplacements de nœuds s’eﬀectuent jusqu’`a stabilisation, c’est-`a-dire
`a ce qu’il n’y ait plus de migrations. les auteurs proposent une estimation en
O(m × log(n)). Cette derni`ere m´ethode d’estimation a ´et´e d´evelopp´ee sur une
architecture multi-cœurs permettant de travailler sur des graphes de plusieurs
centaines de millions de nœuds ayant un milliard d’arˆetes. Le temps de traite-
ment est d’environ une heure avec une quarantaine de machines. Les machines
ont des processeurs Intel Xeon E5530 de 2.4 Ghz, 32 GO de RAM et 1 t´erabit
d’espace disque. Les r´esultats en termes de qualit´e de partitionnement sont satis-
faisants, l’algorithme surpasse les autres sur sur DBLP, you Tube et live Journal
avec des NMI respectivement de 0.17, 0.05 et 0.030, et des F1-score respective-
ment de 0.38, 0.20 et 0.23. Walktrap ou Louvain donnent cependant de meilleurs
r´esultats en termes de NMI sur Amazon et de DBLP avec des scores respectifs
de 0.29 et 0.31.

Saltz et al. (2015) ont impl´ement´e leurs m´ethodes sur Giraph (Hadoop) pour
pouvoir consid´erer les tr`es grands graphes. Ils ont test´e leur m´ethode sur des
graphes de plus d’une centaine de millions de nœuds et un milliard d’arˆetes pour
une dur´ee d’une heure, en utilisant une quarantaine de machines.

1.3.8 Tableau r´ecapitulatif des m´ethodes disjointes

Nous avons vu de nombreux algorithmes. Certains sont fond´es sur la topo-
logie globale du graphe pour eﬀectuer une coupe alors que d’autres agissent de
mani`ere locale, vis-`a-vis du nœud et de ses voisins. Certains autres sont hy-
brides, utilisant soit une m´ethode locale `a laquelle sont adjointes des mesures
sociales, soit en vis-`a-vis d’un param`etre qui agrandit le voisinage d’un nœud
`a une certaine distance g´eod´esique. Nous proposons un tableau r´ecapitulalif,
Tableau 1.2, permettant d’observer les caract´eristiques globales des m´ethodes
dans la mesure o`u nous souhaitons travailler sur de grands graphes de plusieurs
millions d’arˆetes.

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

47

Classiﬁcation des principaux algorithmes de d´etection de communaut´es

Algorithmes
agglom´eratifs
Blondel et al. (2008)
Pons et Latapy (2006)
Ronhovde et Nussinov (2010)

Traag et al. (2013)

Newman (2004)
De Meo et al. (2013)
divisifs
Girvan et Newman (2002b)
Donetti et Mu˜noz (2004)
Newman (2006)
Newman (2013)
extr´emaux
Guimera et al. (2004)
LPA
Raghavan et al. (2007)

Leung et al. (2009)
ˇSubelj et Bajec (2011)
Lou et al. (2013)
Xing et al. (2014)
Cordasco et Gargano (2012)
Zhang et al. (2014)
Zhang et al. (2015)
Rezaei et al. (2015)
Shi et Zhang (2014a)
Shi et Zhang (2014b)
Hu et al. (2016)
Fang et al. (2016)
Peng et al. (2016)
Zhoua et al. (2016)
Liu et al. (2016)
Th´eorie de
l’information
Rosvall et Bergstrom (2007b)
Rosvall et Bergstrom (2010)
Autres

Radicchi et al. (2004)
Clauset et al. (2004)
Duch et Arenas (2005)

Dend

complexit´e

Par

Type

O(mβ log(n))
O(mβ log(n))

(ordre)
O(m)
O(n3)
β ∼ 1.3
β ∼ 1.3
O(nm2)
O(nm)
O(nm2)
O(mn4)
O(mn3)
O(mn3)

∗

O(n × m)

O(n2 × m)
O(n2 × m)
O(n2 × m)
O(2n + 2km)
O(n2 × m)
O(n2 × m)
O(n2 × m)
O(kn2 + m)
O(m + n)
O(m)
O(km)

O(n3 + nm)
O(n2 × m)
O(kn2 + m)
O(kn + m)

∗

O(m)

O( m4
n2 )

O(nlog(n)2)
O(n2log(n))

MPI
non
non

non

non
non

non
non
non
non

non

MPI

Hadoop
Spark
non
non
non
non
non
non
non
non
non
non
non
non
non
non
non

non
non

non
oui
non

oui
non
non

non

oui
non

non
non
non
non

non

non

non
non
non
non
non
non
non
non
non
non
non
non
non
non
non

non
non

non
non
non

local
global

local-hybride

local-hybride

global
hybride

global
global
global
global

global

local

local
local
local

hybride
hybride
hybride
hybride

local
local

hybride
global
hybride
global
hybride

hybride

local

global
local
local

Tableau 1.2 – Principaux algorithmes de d´etection de communaut´es. Le symbole ”*”
signiﬁe que cela d´epend du param´etrage, diﬃcile `a estimer. Le symbole ”**”, pour le
type d’algorithme, signiﬁe que cela d´epend du param´etrage, un algorithme pouvant
ˆetre local ou hybride. Les notations Dend et Par signiﬁent respectivement ”dendro-
gramme” et ”parall´elis´e”.

Nous pouvons observer, d’apr`es le tableau 1.2, que les m´ethodes globales,
qui utilisent la topologie du graphe dans son entier ont des complexit´es plus
´elev´ees que les m´ethodes locales, fond´ees sur les nœuds et leur voisinage. Nous

48

CHAPITRE 1. ETAT DE L’ART

donnons des ﬁgures portant sur l’´echelonnabilit´e pour observer les m´ethodes
pouvant ˆetre appliqu´ees `a de grands graphes, avec des millions d’arˆetes.

Nous avons recueilli, `a travers les diﬀ´erents articles, la taille des graphes
sur lesquels ont ´et´e appliqu´es les algorithmes que nous avons rencontr´es. Nous
observons, sur la ﬁgure 1.9 que les m´ethodes locales comme la propagation de
labels ou la m´ethode de Louvain peuvent ˆetre appliqu´ees `a des graphes ayant
une centaine de millions d’arˆetes. Les m´ethodes divisives comme la m´ethode
spectrale ou le recuit-simul´e ayant une complexit´e ´elev´ee, ne peuvent ˆetre ap-
pliqu´ees `a de trop grands graphes. Les m´ethodes pour la d´etection de cœurs
sont fond´ees sur le lancement en parall`ele de m´ethodes locales, n´ecessitant une
forte consommation m´emoire et ne permettant pas l’application `a des graphes
de plus de cent mille arˆetes.

Figure 1.9 – M´ethodes pour la d´etection de communaut´es disjointes.

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

49

1.3.9 Mesures supervis´ees et non supervis´ees pour la d´etection

de communaut´es disjointes

Pour appr´ecier la qualit´e de partitionnement des algorithmes de d´etection de
communaut´es, des mesures existent fond´ees sur la comparaison entre partition
r´eelle (observ´ee et ´evalu´ee par des experts) et partition trouv´ee par l’algorithme,
il s’agit des mesures supervis´ees. Par exemple, si l’on consid`ere un r´eseau de col-
laboration scientiﬁque, un syst`eme expert va eﬀectuer des regroupements entre
auteurs ayant publi´e sur de mˆemes th`emes scientiﬁques, cela donnera la vraie
partition. Nous exposons les principales mesures, que nous utiliserons pour me-
ner notre ´etude. Cependant, dans le cas o`u nous n’avons pas de connnaissance
de la v´eritable partition, des mesures fond´ees sur le nombre de liens `a l’int´erieur
des communaut´es et `a l’ext´erieur, ou sur la comparaison de structures avec un
graphe al´eatoire sont utilis´ees, il s’agit dans ce cas des mesures non supervis´ees.

Mesures supervis´ees pour la d´etection de communaut´es disjointes

Les mesures supervis´ees permettent de comparer directement les r´esultats de
l’algorithme propos´e `a la partition donn´ee par des experts. Dans certains, cas,
elles peuvent ´egalement ˆetre utilis´ees pour observer la similarit´e des r´esultats
entre plusieurs algorithmes. Nous pr´esentons l’indice de Rand (et la version
ajust´ee), l’information mutuelle normalis´ee et la puret´e.

L’indice de Rand et la version ajust´ee (Rand (1971))

Consid´erons deux partitions P1 et P2 d’un mˆeme ensemble S ⊆ V . L’id´ee pour
´evaluer la ressemblance entre deux partitions consiste `a mesurer le taux de
bonnes assignations de ces paires d’observations. Pour chaque couple d’obser-
vations , on peut compter quatre types d’assignations possibles :

— N11 le nombre de paires de nœuds class´ees ensemble selon P1 et P2
— N10 le nombre de paires de nœuds class´ees ensemble selon P1 et s´epar´ees

selon P2

— N01 le nombre de paires de nœuds s´epar´ees selon P1 et class´ees ensemble

selon P2

— N00 le nombre de paires de nœuds s´epar´ees `a la fois dans P1 et dans P2

L’indice de Rand est donn´e par la formule suivante :

Rand(P1, P2) =

N11 + N00

N11 + N10 + N01 + N00

(1.15)

Cette mesure varie entre 0 et 1 et prend la valeur maximale en cas de parfaite
correspondance. Cependant, cet indice ne demande pas d’´etablir un appariement
entres les classes r´eelles et celles estim´ees, car seule est prise en compte la clas-
siﬁcation commune des diﬀ´erentes paires d’´el´ements dans les deux partitions.
Cela induit deux probl`emes majeurs. Premi`erement, l’indice est fond´e exclusi-
vement sur les paires d’objets, et non les objets eux mˆemes. Deuxi`emement, une

50

CHAPITRE 1. ETAT DE L’ART

inversion de classiﬁcation pour deux ´el´ements dans deux parties de petite taille
sera moins p´enalis´ee que si elle se produit dans des parties de plus grande taille.
De plus, l’indice de Rand varie beaucoup entre deux partitions tir´ees au hasard.
C’est pourquoi l’indice de Rand ajust´e (ARI) (Hubert et Arabie (1985)) fut pro-
pos´e dont l’esp´erance est nulle lorsque les partitions sont tir´ees al´eatoirement.
Il a pour forme :

ARI(P1, P2) =

2(N11N00 − N01N10)

(N01 + N00)(N11 + N01) + (N00 + N10)(N10 + N11)

(1.16)

Sa valeur est comprise entre 0 et 1. Elle prend la valeur 1 lorsque les deux par-
titions sont identiques. Si la valeur est proche de 0, les deux partitions sont tr`es
diﬀ´erentes.

La puret´e (Manning et al. (2008)) : Cette mesure, pour une communaut´e
ci ∈ P1, avec P1 = {c1, ..., cm}, par rapport `a une autre partition P2 (avec
P2 = {c(cid:48)

n}) se d´eﬁnit comme suit :

1, ..., c(cid:48)

purete(ci, P2) = max
1≤j≤n

j|

|ci ∩ c(cid:48)
|ci|

(1.17)

Cette fonction calcule le taux de recouvrement maximal entre la communaut´e
ci et les communaut´es se trouvant dans la partition P2. On d´eﬁnit la puret´e de
la partition P1 par rapport `a la partition P2 par la somme pond´er´ee de la puret´e
des communaut´es de P1 par rapport `a P2, ce qui nous donne :

m(cid:88)

purete(P1, P2) =

wci × purete(ci, P2)

(1.18)

o`u wci =

|ci|(cid:80)m
i=1 |ci|

i=1

L’information mutuelle normalis´ee (NMI) (Kullback (1959)) : C’est une
mesure qui permet de repr´esenter le degr´e de d´ependance entre deux partitions
P1 et P2. Elle est fond´ee sur la th´eorie de l’information. La probabilit´e qu’un
nœud choisi au hasard dans une partition P1 appartienne `a la communaut´e k
est P (k) = nk
n o`u nk est le nombre de nœuds dans la communaut´e k et n est
le nombre total de nœuds du syst`eme. L’entropie de Shannon, en utilisant la
nk
n , o`u
|P1| est le nombre de communaut´es dans la partition P1. L’entropie de Shannon
de la partition P1 repr´esente la quantit´e d’information fournie par cette mˆeme
partition sur la topologie du graphe en termes de communaut´es.

distance de Kullback-Leibler, est d´eﬁnie comme : H(P1) = −(cid:80)|P1|

nk
n log2

k=1

L’information mutuelle I(P1, P2) ´evalue le niveau d’inter-d´ependance entre
deux partitions d’un graphe. Il est possible de d´eﬁnir une matrice de confusion
pour les partitions P1 et P2 en identiﬁant combien de nœuds nij de la com-
munaut´e i de la partition P1 sont dans la communaut´e j de la partition P2.
) o`u ni est le

L’information mutuelle est I(P1, P2) = (cid:80)P1

(cid:80)P2

nij

n log2( nij

ninj

i=1

j=1

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

51

nombre de nœuds de la communaut´e i de la partition P1 et nj est le nombre
de nœuds de la communaut´e j de la partition P2. La variation de l’information
V (P1, P2) est V (P1, P2) = H(P1) + H(P2)− 2I(P1, P2) qui mesure la ”distance”
de l’information entre les deux partitions P1 et P2. Pour l’obtention d’une valeur
comprise entre 0 et 1, on d´eﬁnit l’information mutuelle normalis´ee comme ´etant
. Sa valeur peut varier entre 0 et 1. Plus la valeur
N M I(P1, P2) =

I(P1,P2)

√

H(P1)+H(P2)

est proche de 1, plus les deux partitions sont identiques.

Le score F1 (van Rijsbergen (1979)), couramment utilis´e dans la recherche
d’information, peut ˆetre vu comme une mesure d’exactitude de la pr´ecision et
du rappel entre deux partitions. En consid´erant deux communaut´es A et B, le
score F1 est d´eﬁnit par :

F1(A, B) = 2

|A ∩ B|
|A| + |B|

(1.19)

|A∩B|
|A| ) et du rappel (rappel(A, B) =

Plus les communaut´es A et B partagent de nœuds en commun, plus le score F1
est proche de 1. Un score nul signiﬁe que les deux communaut´es ne partagent
aucun nœud en commun. Cette m´ethode est fond´e sur la combinaison de la
pr´ecision (precision(A, B) =
Consid´erons la partition trouv´ee par l’algorithme de d´etection de commu-
naut´es P1 = {c1, c2, ..., ct} et la partition repr´esentant l’ensemble des commu-
k}. On note que le nombre de com-
naut´es de v´erit´e de terrains P2 = {c(cid:48)
munaut´es peut ˆetre diﬀ´erent entre les deux partitions. La moyenne du score F1
que nous utilisons est celle concernant les communaut´es trouv´ees par un algo-
rithme o`u nous comparons chacune d’entres elles avec la communaut´e la plus
similaire parmi les communaut´es de la partition de v´erit´e de terrain, c’est-`a-
dire, avec la communaut´e de v´erit´e de terrain partageant le plus de nœuds en
commun. Nous avons ainsi :

|A∩B|
|B| ).

1, ..., c(cid:48)

¯F1(P1, P2) =

1
t

max

j∈(cid:74)1,k(cid:75) F1(ci, c(cid:48)

i)

(1.20)

Cette valeur illustre `a quel point chaque communaut´e que l’algorithme a
trouv´ee est similaire aux communaut´es de la partition de v´erit´e de terrain, en
regardant les communaut´ees entre les deux partitions partageant le plus de
nœuds en commun. Une valeur proche de 0 signiﬁe que les deux partitions sont
totalement diﬀ´erentes, sans aucune similarit´e entre communaut´es d´etect´ees et
r´eelles alors qu’une valeur proche de 1 signiﬁe que les deux partitions sont tr`es
semblables avec les mˆemes nœuds `a l’int´erieur des mˆemes communaut´es.

Mesures non supervis´ees pour la d´etection de communaut´es disjointes

Les mesures non supervis´ees permettent d’avoir une estimation de la qualit´e
de partitionnement sans connaˆıtre les v´eritables partitions. Ces mesures sont
soit fond´ees sur des structures al´eatoires respectant la topologie du graphe ini-
tial, soit fond´ees sur les densit´es et les liens entre communaut´es. Nous utilisons

t(cid:88)

i=1

52

CHAPITRE 1. ETAT DE L’ART

dans nos futures ´etudes la modularit´e et la conductance.

La conductance (Kannan et al. (2004)) : Cette mesure est fond´ee sur la
densit´e des communaut´es et le nombre de liens sortant de celles-ci. Une structure
communautaire est suppos´ee avoir beaucoup de liens en son sein et un nombre
faible de liens sortants. La conductance est fond´ee sur le rapport entre le nombre
de liens sortants, lc
int) pour une
communaut´e c.

out, et le nombre total de liens (int´erieurs lc

En consid´erant une communaut´e c d’un graphe G, avec c = (Vc, Ec) (Vc
l’ensemble des sommets de c et Ec l’ensemble des arˆetes de c), la conductance
out] . En consid´erant une
de cette communaut´e est d´eﬁnie par ϕ(c,G) =
partition P = {c1, ..., ck} en k parties de nœuds disjoints, la conductance de G
se d´eﬁnit comme suit :

lc
out
int+lc

[2lc

k(cid:88)
k(cid:88)

c=1

ΦG =

=

1
k

1
k

[

[

ϕ(c,G)]

lc
out

(1.21)

(1.22)

]

[2lc

int + lc

out]

c=1

La conductance peut avoir une valeur comprise entre 0 et 1. Plus cette valeur
sera proche de 0, plus cela signiﬁera que les communaut´es ont une densit´e forte
avec peu de liens pointant vers l’ext´erieur.

La conductance ne peut ˆetre utilis´ee que dans certains cas pr´ecis. On consid`ere
dans un premier temps que la communaut´e c sur laquelle nous appliquons la
conductance est connexe, plusieurs cas sont `a ´etudier :

— Si lc

int (cid:29) lc

out, la conductance sera proche de 0. Le nombre de liens
sortant de c (ayant une extr´emit´e dans c et une autre dans V − Vc) est
tr`es faible par rapport au nombre de liens `a l’int´erieur de c. Cela induit,
par l’hypoth`ese de la connexit´e de c, que c a une forte densit´e et cela
sera d’autant plus vrai que c sera proche d’une clique. Ces conditions
induisent la pr´esence d’une structure communautaire.

int, la conductance ϕ(c,G) sera proche de 1. Cela entraˆıne
que le nombre de liens sortant de c sera beaucoup plus important que le
nombre de liens `a l’int´erieur de c, ce qui n’est pas typique d’une structure
communautaire.

— Si lc

out (cid:29) lc

Si la communaut´e c n’est pas connexe, c’est-`a-dire qu’il y a des nœuds isol´es
dans c, alors la formule ne peut ˆetre utilis´ee comme mesure de qualit´e pour la
d´etection de communaut´es car le nombre de nœuds isol´es (dont le degr´e est nul)
n’a aucun impact sur la conductance, en eﬀet, les nœuds isol´es n’agissent pas
sur le nombre de liens. Ainsi, si une communaut´e c n’est pas reli´ee au reste du
graphe et qu’il existe des nœuds isol´es en son sein, nous aurons une conductance
faible sans pour autant avoir d´etect´e une structure communautaire.

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

53

Nous illustrons les cas avec des exemples simples. Consid´erons un graphe
G = (V, E) o`u V = {1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12}, d´ecompos´e en deux
communaut´es c1 = (Vc1, Ec1), avec Vc1 = {1, 2, 3, 4, 5, 6} et c2 = (Vc2, Ec2)
avec Vc2 = {7, 8, 9, 10, 11, 12} . Les Figures 1.10,1.11 et 1.12 montrent que
le fait d’augmenter les arˆetes entre les communaut´es augmente la conductance.
Pour la ﬁgure 1.10, nous avons ΦG = 1
2∗15+1 ] = 0.06. Pour la ﬁgure
2 [
1.11, nous avons ΦG = 1
2∗15+2 + 2
2 [
2∗15+2 ] = 0.125. Pour la ﬁgure 1.12, nous
2∗15+3 + 3
avons ΦG = 1
2∗15+3 ] = 0.18.
2 [

2∗15+1 + 1

1

2

3

Figure 1.10 – Deux communaut´es reli´ees par une arˆete.

Figure 1.11 – Deux communaut´es reli´ees par deux arˆetes.

La ﬁgures 1.13 montre le cas o`u les communaut´es sont connexes, en consid´erant
un nouveau graphe G(cid:48) = (V (cid:48), E(cid:48)) o`u V = {1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 11, 12,
13, 14, 15, 16, 17, 18}, d´ecompos´e en deux communaut´es c1 = (Vc1, Ec1), avec
Vc1 = {1, 2, 3, 4, 5, 6, 13, 14, 15, 16} et c2 = (Vc2, Ec2) avec Vc2 = {7, 8, 9, 10,
11, 12, 17, 18}. La pr´esence de nœuds isol´es ne permet pas de modiﬁer la valeur
de la conductance. On ne peux donc pas utiliser la conductance dans le cas o`u
les communaut´es sont non connexes.

Il existe d’autres mesures que nous avons vues auparavant, notamment la
mesure de Mancoridis et al. (1998) ou encore la modularit´e que nous avons

54

CHAPITRE 1. ETAT DE L’ART

Figure 1.12 – Deux communaut´es reli´ees par trois arˆetes.

Figure 1.13 – Deux communaut´es reli´ees par trois arˆetes contenant des nœuds isol´es.

pr´esent´ee en d´ebut de chapitre.

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

55

R´ecapitulatif des mesures supervis´ees et non supervis´ees

Nous avons pu observer qu’il existait de tr`es nombreuses mesures. Nous pro-
posons un tableau r´ecapitulatif des m´ethodes avec leurs sp´eciﬁcit´es et leurs gains
d’informations portant sur les communaut´es au sein du graphe, Tableau 1.3.

Mesures supervis´ees

Mesures
Rand

r´ef´erence

(Rand, 1971)

Rand ajust´ee
NMI

(Hubert et Arabie, 1985)

(Ana et Jain, 2003)

Puret´e

Manning et al. (2008)

F1 score

(van Rijsbergen, 1979)

Information et caract´eristiques

comptages sur les paires

d’objets pareillement class´ees

am´elioration de Rand

quantit´e mesurant la d´ependance
statistique entre deux partitions
taux de recouvrement maximal

entre les communaut´es de deux partitions

combine la pr´ecision et le rappel

et leur moyenne harmonique

Mesures
Modularit´e

r´ef´erence

Information et caract´eristiques

(Newman et Girvan, 2004)

maximise la densit´e des

Mesures non supervis´ees

Conductance

(Kannan et al., 2004)

communaut´es `a travers le mod`ele nul

maximise la densit´e
des communaut´es et

minimise les liens sortants

Hamiltoniens

(Ronhovde et Nussinov, 2010)

maximise la densit´e des communaut´es

`a travers le mod`ele nul avec

un facteur de r´esolution

MQ

Mancoridis et al. (1998)

exprime la somme des diﬀ´erences entre

deux ratios de connectivit´es,

calcul´es pour chaque groupe de nœud

Tableau 1.3 – Classiﬁcation des mesures supervis´ees et non supervis´ees pour la
d´etection de communaut´es disjointes

Dans la litt´erature de la d´etection de communaut´es, les mesures les plus

utilis´ees sont les suivantes :

— la modularit´e
— le F1-score
— la puret´e
— la conductance
— l’indice de Rand ajust´e
— le NMI
Ce sont les mesures que nous utiliserons car elles mettent en œuvre les prin-
cipales caract´eristiques des communaut´es, `a savoir densit´e, nombre de liens sor-
tants et graphe al´eatoire. De plus, elles permettent d’´etablir des ´etudes compara-
tives dans la mesure o`u il s’agit des mesures les plus utilis´ees dans la litt´erature
de la d´etection de communaut´es.

56

CHAPITRE 1. ETAT DE L’ART

1.3.10 Synth`ese et discussion

Ce chapitre nous a permis de formuler le probl`eme de d´etection de commu-

naut´es et de pr´esenter les principales m´ethodes existantes dans la litt´erature.

Nous avons vu qu’il existait trois classes d’algorithmes :

— les m´ethodes globales qui consid`erent la topologie du graphe dans son
entier pour ensuite eﬀectuer une coupe. On peut citer la m´ethode spec-
trale, les m´ethodes gloutonnes de d´eplacement de nœuds ou encore les
m´ethodes utilisant des mesures sociales globales. En eﬀet, la m´ethode
spectrale demande le calcul des valeurs et des vecteurs propres dont la
complexit´e est en O(n3). Les m´ethodes gloutonnes de d´eplacement de-
mandent d’eﬀectuer tous les types de d´eplacement possibles aﬁn d’optimi-
ser une certaine fonction de qualit´e de partitionnement, comme le recuit-
simul´e dont la forte complexit´e d´epend du param´etrage. Les mesures
comme celles de la centralit´e d’interm´ediarit´e demandent de consid´erer,
pour toutes paires de sommets du graphe, les plus courts chemins, avec
une complexit´e O(n3). Les m´ethodes globales ne peuvent ˆetre appliqu´ees
`a de grands graphes, tout au plus, `a ceux de quelques milliers de nœuds
et d’arˆetes.

— les m´ethodes locales sont des m´ethodes dont le point de d´epart est le
nœud et o`u il y a propagation d’une information ou r´ealisation d’une
op´eration. Il y a par exemple propagation de labels (LPA) ou fusion
d’un nœud avec un des voisins (Louvain). Ces algorithmes ont la ca-
ract´eristique d’ˆetre quasi-lin´eaires en termes d’arˆete. Ce qui leur adjoint
la possibilit´e d’ˆetre appliqu´es `a de tr`es grands graphes de plusieurs mil-
lions de nœuds et plusieurs centaines de millions d’arˆetes. Cependant ces
algorithmes sont non d´eterministes et hautement instables. C’est-`a-dire
qu’il ne retournent jamais la mˆeme r´eponse.

— les m´ethodes hybrides sont des m´ethodes locales auxquelles on associe
des mesures sociales ou un gain d’information pour am´eliorer le r´esultat.
Par exemple, la m´ethode de De Meo et al. (2013) utilise un graphe
pond´er´e dont les arˆetes ont ´et´e plac´ees suivant une certaine mesure fond´ee
sur les distances entre nœuds pour y appliquer la m´ethode de Louvain.
Ces m´ethodes donnent g´en´eralement de meilleurs r´esultats en termes de
qualit´e de partitionnement que les m´ethodes originelles. Cependant, les
complexit´es de ces algorithmes d´ependent `a la fois de la complexit´e des
m´ethodes locales et de la complexit´e des mesures sociales utilis´ees. Ainsi,
si les mesures sociales ont une forte complexit´e, l’algorithme hybride ne
pourra pas ˆetre appliqu´e sur un grand graphe.

Nous d´ecidons d’utiliser comme base de nos propositions algorithmiques la

1.3. D ´ETECTION DE COMMUNAUT ´ES DISJOINTES

57

propagation de labels. Elle pr´esente l’avantage d’avoir une complexit´e assez
faible et permet de travailler sur de grands graphes. Elle a cependant certains
inconv´enients comme :

— une mauvaise propagation qui peut mener `a de trop grandes commu-

naut´es (le probl`eme des communaut´es g´eantes).

— une instabilit´e
— de mauvaises propagations qui peuvent donner des communaut´es ayant

le mˆeme label.

Ces inconv´enients seront une partie des challenges que nous traˆıterons dans

la partie algorithmique.

58

CHAPITRE 1. ETAT DE L’ART

1.4 D´etection de communaut´es chevauchantes

La section pr´ec´edente nous a permis d’explorer les m´ethodes pour la d´etection
de communaut´es disjointes. C’est-`a-dire le cas o`u chaque nœud ne peut appar-
tenir qu’`a une seule communaut´e. Cependant, dans de nombreux mod`eles, des
nœuds peuvent appartenir `a plusieurs communaut´es, on parle alors de commu-
naut´es chevauchantes. Par exemple, il existera des communaut´es chevauchantes
dans un r´eseau de chercheurs o`u un auteur aura publi´e dans diﬀ´erents domaines.
L’´etude de ces communaut´es permet d’avoir une analyse plus ﬁne du r´eseau. Les
diﬃcult´es `a surmonter sont d’une part la d´eﬁnition d’un nœud chevauchant, et
d’autre part la mani`ere de maˆıtriser la complexit´e algorithmique qui est plus
importante que dans le cas des m´ethodes disjointes.

1.4.1 Formulation du probl`eme de d´etection de commu-

naut´es chevauchantes

Il est possible que certains nœuds appartiennent `a plusieurs communaut´es.
Par exemple, certains nœuds ont un nombre de liens identiques `a plusieurs com-
munaut´es. En consid´erant l’exemple du club de karat´e pr´esent´e en introduction,
o`u une dispute entre le manager et l’entraˆıneur du club a scind´e le club en
deux, cr´eant deux clubs de karat´e dans une mˆeme rue, on peut voir que le nœud
montr´e par une ﬂˆeche est la fois dans la communaut´e du manager et dans celle
de l’entraineur. Il a ´et´e d´eﬁni comme chevauchant dans la litt´erature.

Figure 1.14 – Le graphe de Zachary avec les deux communaut´es et le nœud chevauchant

Des ´etudes men´ees par Kelley (2009), Lancichinetti et al. (2009), Lee et al.
(2010), Reichardt et Bornholdt (2006), Gregory (2010), Wang et al. (2012) et
Sales-Pardo et al. (2007) ont montr´e que le chevauchement est une caract´eristique
des r´eseaux sociaux.

En d´etection de communaut´es chevauchantes, un ensemble de communaut´es
constituant un graphe, o`u plusieurs nœuds peuvent appartenir `a plusieurs com-
munaut´es, se nomme une couverture (Lancichinetti et al. (2009)). Ainsi, la
d´etection de communaut´es chevauchantes consiste `a trouver des groupes de
nœuds fortement connect´es entre eux et faiblement avec le reste du graphe, avec
des nœuds pouvant appartenir `a plusieurs communaut´es. Plus formellement, il
s’agit de trouver une couverture C = {C1, ..., Ck}, avec Ck (cid:54)= ∅, k n’´etant pas `a
i=1Ci = V , en consid´erant un
sp´eciﬁer avec Ci

(cid:84) Cj (cid:54)= ∅, et ∪k

(cid:84) Cj = ∅ ou Ci

1.4. D ´ETECTION DE COMMUNAUT ´ES CHEVAUCHANTES

59

graphe G = (V, E).
De la d´eﬁnition g´en´erale que nous venons de donner r´esultent deux grandes
grandes cat´egories d’algorithmes qui sont la d´etection de communaut´es chevau-
chantes au sens ﬂou et la d´etection de communaut´es chevauchantes au sens de la
classiﬁcation multi-classe. La d´etection de communaut´es chevauchantes au sens
ﬂou porte sur l’impr´ecision de la classe d’appartenance d’un nœud. Dans cette
cat´egorie de probl`eme, on connaˆıt d´ej`a la classe d’appartenance de la majorit´e
des nœuds vis-`a-vis de leurs communaut´es. Cependant, certains nœuds situ´es `a
la fronti`ere int´erieure (cf. glossaire 6.1) de diﬀ´erentes communaut´es portent une
impr´ecision sur leurs degr´es d’appartenance quant `a ces derni`eres. La d´etection
de communaut´es chevauchantes peut ˆetre ´egalement vue comme un probl`eme
de classiﬁcation multi-classe o`u pour tout nœud du graphe, il s’agit d’´etablir le
degr´e d’appartenance `a diﬀ´erentes communaut´es.

1.4.2 D´etection de communaut´es chevauchantes `a base de

propagation de labels

Nous pr´esentons les principaux algorithmes pour la d´etection de commu-

naut´es chevauchantes `a base de propagations de labels.

La premi`ere m´ethode connue ayant utilis´e la propagation de labels fut pro-
pos´ee par Gregory (2010), `a savoir COPRA. Durant la phase de remplacement
du label d’un nœud u par un autre, les auteurs proposent d’utiliser un vecteur
pour maintenir les labels les plus communs avec l’intervention d’un seuil de pro-
babilit´e. Le r´esultat, grˆace `a cette liste, est qu’un nœud peut appartenir `a une
ou plusieurs communaut´es. Bien que cette m´ethode ait une complexit´e lin´eaire
en termes d’arˆetes, elle n´ecessite de sp´eciﬁer le nombre de communaut´es (ν) `a
laquelle pourrait appartenir un nœud. Cette m´ethode est ´egalement instable, ne
donnant que tr`es rarement la mˆeme partition d’un lancement `a l’autre. L’insta-
bilit´e n´ecessite de lancer plusieurs fois l’algorithme avant d’obtenir une solution
correcte en termes de qualit´e. Cette m´ethode est sujette aux mauvaises propa-
gations de labels, donnant des communaut´es g´eantes. La Figure 1.15 donne un
exemple de r´esultatde COPRA avec ν = 2.

Figure 1.15 – Exemple d’application de COPRA (extrait de Gregory (2010))

60

CHAPITRE 1. ETAT DE L’ART

SLPA pour ”Speakerlistener Label Propagation Algorithm” (Xie et al. (2011))
est un algorithme fond´e sur une m´emoire de labels et sur la popularit´e des labels
les plus inﬂuents au sein du graphe, c’est-`a-dire, des labels que l’on retrouve le
plus souvent pour l’identiﬁcation des communaut´es r´esultantes du graphe. Le
changement de label d’un nœud n’est plus fonction du voisinage actuel, mais
d´epend de la m´emoire du nœud dont les labels voisins ont chang´e au cours
du temps. Initialement, on attribue `a chaque nœud une m´emoire de labels. Il
s’agit d’un vecteur de taille k (si le nœud courant a k voisins) qui est origi-
nellement constitu´e des labels de ses nœuds voisins. Deux types de nœuds sont
d´eﬁnis dans l’algorithme SLPA, les speakers et listeners. Un nœud est alors
s´electionn´e al´eatoirement comme speaker et propage son label pendant que les
autres observent la propagation, jusqu’`a stabilisation. C’est alors qu’un autre
nœud du graphe est s´electionn´e pour jouer le rˆole du speaker. Une fois le pro-
cessus de propagation termin´e, on peut observer la force d’appartenance qu’a
un nœud vis-`a-vis des diverses communaut´es via l’inﬂuence des nœuds dans les
diﬀ´erentes m´emoires. A la ﬁn du processus, on regarde toutes les m´emoires de
tous les nœuds pour y voir les labels des communaut´es les plus fr´equentes. Pour
s´electionner les labels les plus fr´equents, on utilise un seuil r ∈ [0, 1] qui per-
met de consid´erer les labels les plus inﬂuents (ceux les plus fr´equents dans la
m´emoire). Il peut y a voir des labels ayant le mˆeme score d’inﬂuence, permettant
ainsi le chevauchement. Les r´esultats en termes de qualit´e de partitionnement
sont encourageants, la majorit´e des nœuds chevauchants dans les graphes uti-
lis´es dans leurs exp´erimentations sont d´etect´es comme pour le club de karat´e,
le r´eseau footballistique , le r´eseau de livres scientiﬁques, le r´eseau de colla-
boration scientiﬁque et d’autres graphes sociologiques. Cependant, l’instabilit´e
persiste avec la possibilit´e qu’il y ait de mauvaises propagations, surtout si elles
ont lieu au d´ebut de l’algorithme et inﬂuent sur la suite du processus. On peut
´egalement se questionner sur la m´ethode employ´ee, dans la mesure o`u les com-
munaut´es d´etect´ees lorsque qu’un speaker envoie son label sont disjointes. Ce
sont les structures communautaires qui empˆechent la propagation du label du
speaker de continuer, mais pas forc´ement les nœuds qui peuvent appartenir `a
plusieurs communaut´es. Le param`etre r a ´egalement une inﬂuence forte sur le
pourcentage de nœuds chevauchants. L’algorithme est ´egalement assez long car
il n´ecessite d’obtenir la stabilisation, c’est-`a-dire que les communaut´es d´etect´ees
ne puissent plus ´evoluer.

BMLPA pour ”balanced multi-label propagation algorithm” (Wu et al. (2012))
est une am´elioration de COPRA. Les auteurs proposent une strat´egie de mise `a
jour, qui demande que les nœuds ayant le mˆeme label aient un cœﬃcient d’appar-
tenance vis-`a-vis d’autres communaut´es. Cela a pour cons´equence que certains
nœuds puissent appartenir `a plusieurs communaut´es. Les auteurs proposent
´egalement de g´en´erer des ”cœurs bruts”, qui sont utilis´es pour l’initialisation
des vecteurs pour la propagation de labels multiples. Cela permet d’aller plus
vite et de stabiliser une partie du graphe lors de la propagation. Les r´esultats en
termes de qualit´e de partionnement sont encourageants et permettent de limi-

1.4. D ´ETECTION DE COMMUNAUT ´ES CHEVAUCHANTES

61

ter le nombre de mauvaises propagations (ph´enom`ene de communaut´es g´eantes)
sans toutefois les faire disparaˆıtre.

MLPA pour multi-label propagation algorithm (Dai et al. (2013)) utilise une
propagation de labels avec intensit´e qui permet d’attribuer une force aux labels
des nœuds ´emettants. L’id´ee est que lorsqu’un nœud mettra `a jour son label,
il aura connaissance des labels des nœuds voisins, et ´egalement des zones sur
lesquelles ils se sont d´ej`a propag´es , qui sont en fait, les communaut´es en cours
de cr´eation. D`es lors, certaines propagations peuvent s’arrˆeter si l’intensit´e du
label en question est trop forte ou au contraire ˆetre mises en exergue si son
intensit´e est trop faible. L’utilisation de l’intensit´e des nœuds permet de diriger
la propagation de labels pour ´eviter de mauvaises propagations (impossibilit´e
de d´etecter de trop petites commununaut´es). Cette m´ethode a comme force de
donner de l’information sur les structures topologiques qui se cr´eent au fur et
`a mesure du d´eveloppement de l’algorithme. Cependant, c’est une faiblesse, no-
tamment pour des graphes dont la densit´e est ´elev´ee, o`u l’intensit´e devra ˆetre
ajust´ee pour continuer des propagations de labels non ﬁnies.

Les m´ethodes pr´esent´ees ci-dessus se fondent soit sur une modiﬁcation de
la propagation de labels en incluant un facteur d’appartenance, soit sur une
multi-liste de propagations de labels. Cependant, cela ne r´eduit pas l’instabilit´e
et des param`etres doivent ˆetre ´evalu´es pour connaˆıtre le pourcentage de nœuds
chevauchants et le nombre de communaut´es auxquelles appartient un nœud.

1.4.3 Autres m´ethodes pour la d´etection de communaut´es

chevauchantes

Il existe d’autres m´ethodes pour la d´etection de communaut´es chevauchantes,
fond´ees sur la topologie du graphe et le nombre de connexions qu’un nœud a
vis-`a-vis des communaut´es avoisinantes.

Palla et al. (2005) ont cr´e´e Cﬁnder, un algorithme pour la d´etection de
communaut´es chevauchantes fond´e sur la recherche de motifs locaux, par per-
colation de cliques (CPM : Clique Percolation Method). Les auteurs observent
qu’une communaut´e peut-ˆetre d´eﬁnie comme une chaˆıne de k-cliques adjacentes
(cf. glossaire 6.1). Cette m´ethode permet la d´etection de communaut´es cou-
vrantes o`u un sommet peut appartenir `a plusieurs k-cliques. Les r´esultats en
termes de qualit´e de partitionnement sont encourageants mais pr´esentent trois
inconv´enients majeurs. Le premier est la n´ecessit´e de param´etrer k (c’est-`a-
dire la taille des cliques). Le second concerne la complexit´e algorithmique. Il a
´et´e d´emontr´e que la complexit´e pour d´etecter les 3-cliques (Berge (1958)) d’un
graphe ´etait en O(n1.41) (n ´etant le nombre de sommets), mais ce nombre aug-
mente de mani`ere non lin´eaire en fonction du nombre de sommets. Le troisi`eme
inconv´enient est la recherche de motifs statiques qui n’est pas un trait absolu

62

CHAPITRE 1. ETAT DE L’ART

des r´eseaux complexes (avec des nœuds chevauchants des communaut´es de taille
et de topologie diﬀ´erentes). Les exp´erimentations men´ees pas Palla et al. (2005)
ont montr´e que la valeur k = 4 donnait les r´esultats en termes de qualit´e de
partitionnement les plus probants. Cette m´ethode peut selon la param´etrisation
de k ˆetre appliqu´ee `a des graphes de plusieurs centaines de milliers d’arˆetes.
Nous donnons un exemple tir´e du site de Gergely Palla `a la Figure 1.16 o`u les
nœuds de couleur rouge appartiennent `a des communaut´es chevauchantes.

Figure 1.16 – Exemple d’application de la m´ethode CFinder (Extrait du site de Palla
et al. (2005))

Zhang et al. (2007) proposent un algorithme spectral pour la d´etection de
communaut´es chevauchantes. Le principe est de calculer un certain nombre de
vecteurs propres li´es `a la matrice Laplacienne repr´esentant le graphe, puis d’ap-
pliquer sur cet espace propre un algorithme ﬂou de clustering, le Fuzzy C means
(FCM) et de retranscrire les r´esultats sur le graphe pour obtenir les recouvre-
ments. La m´ethode n´ecessite de sp´eciﬁer le nombre de recouvrements et n´ecessite
le calcul des valeurs et des vecteurs propres. Les r´esultats en termes de qualit´e
sont encourageants. L’algorithme a une complexit´e en O(n3 + ndc2i), avec d, le
nombre de dimensions, c le nombre de clusters et i le nombre d’it´erations.

Psorakis et al. (2011) proposent un mod`ele fond´e sur la factorisation par
matrices non n´egatives bay´esiennes (NMF). Cet algorithme n´ecessite de fournir
le nombre K de recouvrements et demande de tr`es nombreux calculs matriciels.
La complexit´e de cet algorithme est en O(Kn2).

Shen et al. (2009) proposent EAGLE (agglomerativE hierarchicAl clusterinG
based on maximaL cliquE). EAGLE est une m´ethode agglom´erative fond´ee sur
la d´etection de cliques maximales (cf. Glossaire 6.1) et l’optimisation locale d’une
fonction de qualit´e permettant l’´elaboration d’un dendrogramme. L’algorithme
op`ere en deux ´etapes sur le graphe. Premi`erement, les cliques maximales sont
trouv´ees pour former les premi`eres communaut´es. La seconde ´etape consiste `a
fusionner les communaut´es ayant la plus grande similarit´e. La fonction de simi-
larit´e n’est autre que la modularit´e de Newman. C’est sur le nœud o`u portera
la fusion qu’il y aura chevauchement. La coupe optimale est donn´ee en utilisant
une version chevauchante de la modularit´e de Newman, la modularit´e de Shen
que nous d´etaillerons dans la partie concernant les mesures non supervis´ees pour

1.4. D ´ETECTION DE COMMUNAUT ´ES CHEVAUCHANTES

63

la d´etection de communaut´es chevauchantes. EAGLE donne des r´esultats satis-
faisants en termes de qualit´e de recouvrement. Cependant, dans certains cas,
les nœuds qui peuvent ˆetre class´es comme chevauchants et qui sont li´es `a des
communaut´es faiblement denses ne sont pas d´etect´es. Cette m´ethode peut soule-
ver certaines questions quant aux strutures communautaires chevauchantes. On
peut reprocher `a cet algorithme d’ˆetre `a la recherche de motifs plutˆot que d’ˆetre
`a la recherche de nœuds entre communaut´es. Des structures communautaires
peuvent exister sans ˆetre des cliques. L’algorithme pr´esente ´egalement une com-
plexit´e assez ´elev´ee en O(n2 + s(h + n)) avec s le nombre de cliques maximales
et h le nombre de paires de cliques maximales qui sont voisines (partageant un
nœud en commun).

Lee et al. (2010) ont propos´e GCE (Greedy Clique Expansion). Cet algo-
rithme est tr`es similaire `a EAGLE. Il identiﬁe dans un premier temps les cliques
comme des graines (leaders) au sein du graphe. Ces graines, qui sont des cœurs
de communaut´es s’agrandissent par optimisation d’une fonction de qualit´e lo-
cale. Les auteurs choisissent la fonction de ﬁtness de Lancichinetti et al. (2009),
out)α o`u α est un param`etre
`a savoir pour une communaut´e S, FS =
ajustable, kS
out (nombre d’arˆetes ayant
une extr´emit´e hors de S). Cette mesure privil´egie une expansion vers des nœuds
maximisant les liens internes et minimisant les liens externes. Lorsque deux
structures communautaires veulent eﬀectuer une agglom´eration sur un nœud
sp´eciﬁque, ce nœud est class´e comme chevauchant. La complexit´e de cet al-
gorithme est en O(mh) avec m, le nombre d’arˆetes et h le nombre de cliques
maximales d´etect´ees initialement et consid´er´ees comme graines. Les r´esultats
exp´erimentaux montrent que la qualit´e de recouvrement est l´eg`erement meilleure
que celle d’EAGLE, notamment sur les graphes artiﬁciels LFR (cf. glossaire 6.1).

in (nombre d’arˆetes internes dans S) et kS

kS
in
in+kS

(kS

Lancichinetti et al. (2011) ont propos´e OSLOM (Order Statistics Local Opti-
mization Method). Il s’agit d’une m´ethode de raﬃnage agissant sur une partition
d´ej`a fournie. OSLOM utilise les algorithmes de Louvain ou d’Infomap pour cr´eer
une premi`ere partition. C’est alors que la m´ethode ajoute ou retire des nœuds
pour arriver `a un ´etat stable o`u il n’est plus int´eressant de modiﬁer la structure
topologique des communaut´es. Le principe consiste `a comparer les structures
communautaires entre le mod`ele nul (cf. glossaire 6.1) et la partition r´eelle en se
fondant sur le nombre de liens dans les communaut´es et sur le degr´e du nœud
´etudi´e. Si le nœud ´etudi´e a plus de connexions vis-`a-vis d’une communaut´e que
la valeur moyenne issue du mod`ele nul, ce nœud sera ajout´e `a cette communaut´e.
Il sera retir´e dans le cas contraire. Le processus se r´ep`ete sur tous les nœuds
du graphe en eﬀectuant des modiﬁcations sur la partition originelle si certains
groupes de nœuds n’ont pas la caract´eristique de structures communautaires.
L’algorithme est non d´eterministe car il d´epend de l’ordre de visite selon lequel
est appliqu´ee cette m´ethode.

L’algorithme comporte quatre param`etres dont un seuil de probabilit´e `a

64

CHAPITRE 1. ETAT DE L’ART

donner. L’algorithme est assez lent et est fonction du nombre de nœuds. Il peut
n´ecessiter plusieurs journ´ees notamment sur de grands graphes comme Live-
Journal. La param´etrisation standard donne cependant des r´esultats corrects
en termes de qualit´e pour les communaut´es r´esultantes.

1.4.4 Tableau r´ecapitulatif des m´ethodes chevauchantes

L’´etat de l’art concernant la d´etection de communaut´es chevauchantes a

montr´e l’existence de tr`es nombreuses m´ethodes. Nous r´ecapitulons les
caract´eristiques concernant leur complexit´e et la taille des r´eseaux sur lesquels
ces solutions peuvent ˆetre appliqu´ees dans la mesure o`u nous souhaitons traˆıter
de grands graphes de plusieurs millions d’arˆetes.

Algorithmes
LPA
COPRA
SLPA
BLMPA
MLPA
EAGLE
NMF
FCM
OSLOM
CFINDER

articles

dendrogramme

Gregory (2010)
Xie et al. (2011)
Wu et al. (2012)
Dai et al. (2013)
Shen et al. (2009)

Psorakis et al. (2011)
Zhang et al. (2007)

Lancichinetti et al. (2011)

Adamcsek et al. (2006)

non
non
non
non
non
non
non
non
non

O(2n + n2m)

complexit´e
(ordre)
O(kmn)
O(kmn)
O(kmn)
O(Kn2)

O(n2 + (h + n)s)
O(n3 + ndc2i)

”*”
O(en)

parall´elis´e

non
non
non
non
non
non
non
non
non

Tableau 1.4 – Ordre de complexit´e des algorithmes chevauchants. Le signe ”*” signiﬁe
que la complexit´e est diﬃcile `a ´etablir. n : nombre de sommets, m : nombre d’arˆetes,
k : paramˆetre (entier), i : nombre d’it´erations, d : le nombre de dimensions de l’espace
propre et c : le nombre de clusters

La comparaison des ﬁgures 1.17 et 1.9 permet d’aﬃrmer que les m´ethodes

chevauchantes ont une complexit´e plus ´elev´ee que les m´ethodes disjointes.

D’apr`es nos exp´erimentations et la taille des graphes sur lesquels ont ´et´e
appliqu´es les algorithmes de la ﬁgure 1.17, nous pouvons constater que certains
algorithmes peuvent ˆetre appliqu´es sur des graphes d’assez grandes tailles alors
que ce n’est pas le cas pour d’autres. Par exemple, OSLOM peut-ˆetre appliqu´e
sur une machine `a des graphes de plus 18 millions de sommets et 300 millions
d’arˆetes (il s’agit du r´eseau web du Royaume-Uni (SNAP)) alors les autres ne
peuvent pas le traˆıter. D’apr`es nos exp´erimentations et en consid´erant comme
crit`ere l’erreur m´emoire, l’algorithme permettant de traˆıter les plus grands
graphes est OSLOM. Les m´ethodes ne permettent pas de traiter les graphes
de plus de 10 millions d’arˆetes.

1.4. D ´ETECTION DE COMMUNAUT ´ES CHEVAUCHANTES

65

Figure 1.17 – M´ethodes pour la d´etection de communaut´es chevauchantes. L’axe des
abscisses repr´esente la taille des graphes, l’axe des ordonn´ees, la complexit´e.

1.4.5 Mesures supervis´ees et non supervis´ees pour la d´etection

de communaut´es chevauchantes

Certaines mesures supervis´ees et non supervis´ees dans le cas de la d´etection
de communaut´es disjointes ont ´et´e retranscrites pour le cas du chevauchement.
Nous nous proposons d’exposer les mesures les plus utilis´ees dans la litt´erature
ainsi que leurs sp´eciﬁcit´es. A la ﬁn de cette section, nous pr´esenterons un ta-
bleau r´ecapitulatif des mesures.

Mesures supervis´ees pour la d´etection de communaut´es chevauchantes

L’information mutuelle normalis´ee pour le chevauchement fut pro-
pos´ee par Lancichinetti et al. (2009) . Consid´erons deux couvertures A et B de
V . La probabilit´e de tirer un ´el´ement et qu’il appartienne `a une partie de la
partition (A ∈ A) est nA
n , o`u nA est le nombre d’´el´ements dans A. L’entropie
de Shanon de la partition A est ainsi d´eﬁnie par :

H(A) = −(cid:88)

A∈A

nA
n

log2

nA
n

(1.23)

Lancichinetti et al. (2009) ont propos´e une version du NMI pour la comparaison
de couvertures A et B comme ´etant :
N M ILF K = 1 − 1
2

H(A|B)

H(A|B)

(

A

(1.24)

+

B

)

66

CHAPITRE 1. ETAT DE L’ART

avec H(A|B) ´etant l’entropie conditionnelle. Cette quantit´e mesure l’entropie
restante provenant de la couverture B, si l’on connait parfaitement la seconde
couverture A. H(A|B) = 0 si et seulement si la couverture B est compl`etement
d´etermin´ee par la couverture A. La valeur de N M ILF K est comprisentre 0 et
1. Plus cette valeur est proche de 1, plus les deux convertures sont identiques.

McDaid et al. (2011) ont propos´e une extension au NMI de Lancichinetti et
al. avec l’intervention d’une p´enalit´e si les deux couvertures sont trop diﬀ´erentes.
Les r´esultats des deux mesures sont ´equivalents.

L’indice d’Omega (Collins et Dent (1988)) est fond´ee sur des paires de

nœuds qui sont dans les mˆemes communaut´es selon les deux couvertures.

Consid´erons deux couvertures P1 et P2, l’indice d’omega est d´eﬁni de la

mani`ere suivante :

Ω(P1, P2) =

ou(P1, P2) − oe(P1, P2)

1 − oe(P1, P2)

(1.25)

(cid:80)
o`u ou(P1, P2) repr´esente la fraction de paires de nœuds qui apparaissent en-
semble dans les mˆemes communaut´es `a la fois dans P1 et P2.
j |tj(P1) ∩ tj(P2)| o`u tj(P ) est l’ensemble des paires de
ou(P1, P2) =
nœuds qui apparaissent dans exactement j communaut´es dans la couverture P .
Le nombre de paires de nœuds est ´egale `a n(n−1)
. Le terme oe(P1, P2) est la
valeur esp´er´ee de cette fraction dans le mod`ele nul.

n(n−1)

2

oe(P1, P2) =

4

n2(n − 1)2

|tj(P1)||tj(P2)|

(1.26)

2

(cid:88)

j

L’indice d’Omega prend sa valeur entre 0 et 1. Une valeur proche de 1 signiﬁe
que les deux couvertures sont identiques. Dans la partie exp´erimentale, nous
utiliserons la notation Ω pour signaler l’indice d’Omega.

Le F1-score pour le chevauchement se d´eﬁnit de la mˆeme mani`ere que pour

le cas disjoint, `a savoir :

F1 =

2 × pr´ecision × rappel
pr´ecision + rappel

(1.27)

o`u le rappel est le nombre de bons nœuds chevauchants d´etect´es divis´e par le
v´eritable nombre de nœuds chevauchants. La pr´ecision est le nombre de bons
nœuds chevauchants d´etect´es divis´e par le nombre total de nœuds chevauchants
d´etect´es. Le F1-score est un bon compromis entre la qualit´e de nœuds che-
vauchants bien d´etect´es et la qualit´e de ces d´etections. Elle atteint sa valeur
maximale `a 1 et sa plus basse `a 0.

1.4. D ´ETECTION DE COMMUNAUT ´ES CHEVAUCHANTES

67

Mesures non supervis´ees pour la d´etection de communaut´es chevau-
chantes

Plusieurs extensions de la modularit´e ont ´et´e propos´ees pour le cas du che-
vauchement. Nous proposons de les exposer en les d´etaillant. Elles se basent
toutes sur un cœﬃcient d’appartenance entre un nœud i et une communaut´e
c, que l’on note ai,c. On consid`ere par la suite une couverture de communaut´es
chevauchantes C = {c1, ..., c|C|} et un vecteur d’appartenance pour un nœud i `a
chacune des communaut´es (ai,c1, ..., ai,c|C|). Le cœﬃcient d’appartenance d’un
nœud i est r´egi par deux contraintes qui sont 0 ≤ ai,c ≤ 1,∀i ∈ V,∀c ∈ C et par

(cid:80)

c∈C ai,c = 1.

Zhang et al. (2007) ont propos´e une extension de la modularit´e qui utilise
la moyenne du cœﬃcient d’appartenance entre deux nœuds pour mesurer la
qualit´e des structures communautaires chevauchantes :
c | + |Eout
2|E|

|Ein
c |
|E| − (

(cid:88)

2|Ein

Ov =

(1.28)

QZ

)2

|

c

c∈C

(cid:80)

2

2

i,j∈c

ai,c+aj,c

c | = 1

avec |Ein

Aij, |Eout

Aij et |E| =
1
i,j Aij. La m´ethode propos´ee par Zhang p´enalise les structures d´etect´ees
2
ayant un nombre de liens trop fort en dehors de ces derni`eres. Les r´esultats
en termes de qualit´e pour des graphes dont les communaut´es pr´esentent des
densit´es ´equivalentes sont bons, mais la qualit´e se d´et´eriore si les structures
communautaires sont trop diﬀ´erentes.

ai,c+(1−aj,c)

i∈c,j(cid:54)∈c

2

c

(cid:80)

| = (cid:80)

leur vecteur d’appartenance not´e sij =(cid:80)

Nepusz et al. (2008) ont consid´er´e le cœﬃcient d’appartenance ai,c comme
la probabilit´e qu’un nœud i soit dans la communaut´e c. Ainsi, la probabilit´e que
le nœud i appartienne `a la mˆeme communaut´e que j est le produit scalaire de
c∈C ai,caj,c. Les auteurs ont ´egalement
consid´er´e sij comme une mesure de similarit´e entre les nœuds i et j. Ainsi, en
rempla¸cant le symbole de Kronecker dans la formule g´en´erale de la modularit´e,
les auteurs d´eﬁnissent leur modularit´e comme ´etant :

(cid:88)

i,j

QN ep

Ov =

1
2|E|

[Aij − kikj

2|E| ]sij

(1.29)

La formule est sujette au degr´e des nœuds chevauchants. C’est-`a-dire que si la
distribution des degr´es des nœuds ne suit pas une loi uniforme, la mesure aura
plus de diﬃcult´e a d´etecter les nœuds chevauchants. Les r´esultats en termes de
qualit´e sur les graphes r´eels sont cependant encourageants.

Nicosia et al. (2009) ont fait une extension `a la modularit´e pour le cas du
chevauchement entre communaut´es. Les auteurs la d´eﬁnissent de la mani`ere

68

suivante :

(cid:88)

(cid:88)

i,j∈V

c

QN i

Ov =

1
m

CHAPITRE 1. ETAT DE L’ART

[βij,cAij − βout

ij,cβin
ij,c

kout
i kin
j
m

]

(1.30)

i

et kin
i

o`u βij,c est le cœﬃcient d’appartenance du lien ij `a la communaut´e c, βout
ij,c est
le cœﬃcient d’appartenance esp´er´e de tous les liens possibles ij du nœud i au
nœud j `a l’int´erieur de la communaut´e c et βin
ij,c est le cœﬃcient d’apparte-
nance de n’importe quel lien ij pointant vers un nœud j dans la communaut´e
c. Les termes kout
sont respectivement le degr´e sortant et entrant du
nœud i. Il est `a noter que βij,c est une fonction de la forme βij,c = F (ai,c, aj,c)
avec ai,c cœﬃcient d’appartenance du nœud i par rapport `a la communaut´e
o`u f (ai,c) est une fonction lin´eaire
c. F (ai,c, aj,c) =
´echelonnable du type f (x) = 2px − p, p ∈ R. Les auteurs ont propos´e d’uti-
liser la fonction f (x) = 60x − 30 pour le param´etrage de la modularit´e che-
vauchante car elle donnait des r´esultats tr`es encourageants. Il s’agit ´egalement
de la param´etrisation standard dans la litt´erature et que nous utiliserons pour
nos exp´erimentations. La valeur de la modularit´e de Nicosia varie entre 0 et
1. Une valeur proche de 0 implique que l’algorithme n’a d´etect´e qu’une seule
communaut´e (le graphe en lui mˆeme) alors qu’une valeur proche de 1 signiﬁe la
pr´esence de structures communautaires possiblement chevauchantes.

−f (ai,c ))(1+e

−f (aj,c))

(1+e

1

Shen et al. (2009) ont propos´e une modularit´e avec un cœﬃcient d’appar-
tenance comme ´etant l’inverse du nombre de communaut´es auxquelles pourrait
appartenir un nœud, ai,c = 1
o`u Oi est le nombre de communaut´es contenant
Oi
le nœud i. La version qu’ont propos´ee les auteurs donne la formule :

(cid:88)

c∈C

(cid:88)

[
(
i,j∈c

QShen1

ov

=

1
2|E|

kikj
|E| )]

1

OiOj

(1.31)

(cid:80)

mum dans un r´eseau contenant l’arˆete (i, k) et ai =(cid:80)

Les r´esultats sont encourageants mais peuvent ˆetre mauvais si le nombre de
communaut´es auxquelles appartient un nœud par rapport `a un autre est trop
important. Ainsi, certains bons chevauchements risquent de ne pas ˆetre d´etect´es.
Par la suite, les mˆemes auteurs ont propos´e une nouvelle modularit´e pour le
chevauchement en se fondant sur la pr´esence de sous-graphes complets, un
nombre ´elev´e de cliques et par une modiﬁcation du cœﬃcient d’appartenance
d’un nœud aux communaut´es auxquelles il pourrait appartenir. Le cœﬃcient
devient ai,c = 1
Aik o`u Mik repr´esente le nombre de cliques maxi-
ai
Aik, avec
M c
ik repr´esentant le nombre de cliques maximum dans la communaut´e c conte-
nant l’arˆete (i, k). Cette derni`ere formule donne en termes de qualit´e de par-
titionnement pour le chevauchement de meilleurs r´esultats que celle pr´esent´ee
auparavant. Sa valeur varie entre 0 et 1, et est sens´ee ˆetre la meilleure r´eponse
pour une valeur proche de 1. Elle pr´esente comme avantage qu’un nœud peut
appartenir `a des communaut´es de tailles diﬀ´erentes.

(cid:80)

M c
ik
Mik

M c
ik
Mik

c∈C

k∈c

k∈c

1.4. D ´ETECTION DE COMMUNAUT ´ES CHEVAUCHANTES

69

(cid:88)

Chen et al. (2013) ont propos´e la densit´e de modularit´e dont l’objectif est
de favoriser les petites structures communautaires pour contourner le probl`eme
de r´esolution de limite, c’est-`a-dire que si il existe des communaut´es de tailles
diﬀ´erentes `a l’int´erieur d’un mˆeme graphe, certaines communaut´es, mˆeme bien
d´eﬁnies, pourront ne pas ˆetre distingu´ees dans la partition de modularit´e op-
timale. Pour ce faire, les auteurs font intervenir une p´enalit´e de coupe qui est
simplement la fraction d’arˆetes qui connecte les nœuds `a d’autres communaut´es.
La densit´e de modularit´e est d´eﬁnie par :
c | + |Ein
c |
2|E|

c∈C
|Ein
c,c(cid:48)|
avec dc = 2|Ein
c |
|c|(|c(cid:48)|) . Les r´esultats en termes de qualit´e sont
bons sur des r´eseaux r´eels mais pr´esentent un inconv´enient notamment pour
les graphes faiblement denses. Cela est d’autant plus vrai que le nombre de
communaut´es avec une forte densit´e sera important. En 2015, les mˆemes auteurs
(Chen et al. (2015)) ont am´elior´e leur m´ethode en y incluant le nombre de liens
sortant des structures communautaires d´etect´ees.

dc)2 − (cid:88)

c |
|Ein
|E| dc − (

|Ec,c(cid:48)|
2|E| dc,c(cid:48)]

|c|(|c|−1) et dc,c(cid:48) =

c(cid:48)∈C,c(cid:48)(cid:54)=c

2|Ein

QChen1

(1.32)

ds

=

[

dc)2 − (cid:88)
(cid:80)
i∈c,j∈c(cid:48) f (ai,c,aj,c(cid:48) ) . |Ein

c |
c | + |Ein
2|E|
(cid:80)
c | =
c(cid:48)∈c,c(cid:48)(cid:54)=c,j∈c(cid:48) f (ai,c, aj,c(cid:48))Aij, |Ec,c(cid:48)| =

|Ec,c(cid:48)|
2|E| dc,c(cid:48)]

c(cid:48)∈C,c(cid:48)(cid:54)=c

|Ein
c,c(cid:48)|

(1.33)

(cid:80)
(cid:80)
(cid:80)
i,j∈c,j∈c(cid:48) f (ai,c,aj,c) et dc,c(cid:48) =
i,j∈c f (ai,c, aj,c)Aij ,|Eout
i∈c,j∈c(cid:48) Aij et|E| le nombre d’arˆetes du graphe.

avec dor´enavant dc =
1
2

| =(cid:80)

2|Ein
c |

i∈c

c

QChen2

ds

=

c |
|Ein
|E| dc − (

[

2|Ein

(cid:88)

c∈C

La fonction f (ai,c, aj,c(cid:48)) peut ˆetre le produit ou la moyenne des vecteurs ai,c et
aj,c. Sa valeur varie entre 0 et 1, et donne la meilleure r´eponse pour une valeur
proche de 1. Les r´esultats sont meilleurs que pour leur premi`ere version mais
la formule propos´ee reste fond´ee sur une moyenne d’appartenance. C’est-`a-dire
que si un nœud est susceptible d’appartenir `a plusieurs communaut´es, il aura
plus de chance de consid´erer les communaut´es avec lesquelles il aura beaucoup
de liens, ce qui peut ˆetre probl´ematique pour les r´eseaux complexes, avec des
tailles de communaut´es diﬀ´erentes.

R´ecapitulatif des mesures supervis´ees et non supervis´ees

Nous proposons un tableau r´ecapitulatif de toutes les mesures cit´ees pr´ec´edemment

avec leurs informations relatives en prenant comme source d’information les ar-
ticles en question. Le tableau 1.5 nous montre l’existence de tr`es nombreuses
mesures. Il y en a d’ailleurs d’autres.

Cependant, dans la litt´erature de la d´etection de communaut´es, les mesures

les plus utilis´ees sont :

70

CHAPITRE 1. ETAT DE L’ART

Mesures supervis´ees (cas du chevauchement)

Mesures
Omega

r´ef´erence

(Collins et Dent, 1988)

NMI

(Lancichinetti et al., 2009)

F1-score

(Yang et Leskovec, 2013)

Information et caract´eristique

comptages sur les paires

disjointes et chevauchantes
d’objets pareillement class´es

quantit´e mesurant la d´ependance
statistique entre deux couvertures.
combine la pr´ecision et le rappel

avec leur moyenne harmonique (cf. glossaire 6.1)

en tenant compte des chevauchements.

Mesures non supervis´ees (cas du chevauchement)
r´ef´erence

Information et caract´eristique

(Nicosia et al., 2009)

maximise la densit´e des

communaut´es `a travers le mod`ele nul

Shen et al. (2009)
(Chen et al., 2013)
(Nepusz et al., 2008)

Mesures
QN icosia

QShen
QChen
QN epusz

Tableau 1.5 – Classiﬁcation des mesures supervis´ees et non supervis´ees pour la
d´etection de communaut´es

— la modularit´e pour le chevauchement ((Nicosia et al., 2009))
— le F1-score pour le chevauchement
— le NMI pour le chevauchement
— l’indice d’omega
Ce sont les mesures que nous utiliserons car elles mettent en œuvre les prin-
cipales caract´eristiques des communaut´es, `a savoir la densit´e, le nombre de liens
sortants et la comparaison entre structures d´etect´ees avec un graphe al´eatoire.

1.4.6 Synth`ese et discussion

Cette section a permis de donner notre formulation du probl`eme de d´etection
de communaut´es chevauchantes, d’analyser les m´ethodes existantes et de voir
les mesures de qualit´e qui y sont associ´ees. Dans la mesure o`u nous souhai-
tons cr´eer une m´ethode de chevauchement stable (c’est-`a-dire donnant quasi-
syst´ematiquement les mˆemes r´esultats) et destin´ee `a des graphes de grandes
tailles, nous portons notre synth`ese sur la complexit´e, le degr´e de param´etrage
de ces m´ethodes et la stabilit´e.

Les m´ethodes chevauchantes pr´esentent des complexit´es plus ´elev´ees que
les m´ethodes disjointes. Cela s’explique du fait qu’une partie des algorithmes
chevauchants repose sur le fait de lancer plusieurs fois un algorithme disjoint
et d’observer pour un nœud les communaut´es auxquelles il appartient le plus
(comme COPRA). Malheureusement, ces algorithmes demandent un espace de
stockage assez fort, d´epassant les capacit´es d’une seule machine.

1.4. D ´ETECTION DE COMMUNAUT ´ES CHEVAUCHANTES

71

Les m´ethodes chevauchantes pr´esentent ´egalement un degr´e de param´etrage
plus ´elev´e. Pour les algorithmes robustes `a base de m´ethodes disjointes, cela
exige de connaˆıtre le nombre d’algorithmes `a lancer en parall`ele. De nombreux
algorithmes n´ecessitent ´egalement de donner un nombre de communaut´es aux-
quelles un nœud pourrait appartenir, ce qui n´ecessite des ´etudes pr´ealables.

La plupart des algorithmes de d´etection de communaut´es chevauchantes sont
instables. Cela est dˆu en partie `a ce que beaucoup d’algorithmes reposent sur
des algorithmes non d´eterministes disjoints.

Cependant, les m´ethodes par propagation de labels ont ´et´e l’objet de nom-
breuses ´etudes et constituent, pour l’´etude des grands graphes, l’option `a pri-
vil´egier.

72

CHAPITRE 1. ETAT DE L’ART

Chapitre 2

Parall´elisme et distribution

Ce chapitre d´ecrit dans un premier temps les principaux outils pour la pro-
grammation et la gestion de graphes dans un domaine parall`ele et distribu´e.
Dans un second temps, les algorithmes pour la d´etection de communaut´es dans
un environnement parall`ele et distribu´e sont pr´esent´es. Nous donnerons `a la ﬁn
de ce chapitre un tableau r´ecapitulatif des m´ethodes de d´etection de commu-
naut´es dans le domaine parall`ele et distribu´e et nous discuterons l’axe `a choisir
pour nos objectifs de recherche.

2.1 Probl´ematique de la d´etection de commu-

naut´es dans de grands graphes

Notre soci´et´e moderne produit un nombre de donn´ees de plus en plus impor-
tant. Des ann´ees 1970 avec le ”minitel” dont les m´emoires moyennes ´etaient de
l’ordre de 8,25 Ko (exemple du minitel 1 bistandard Alcatel/Telic.) au datacen-
ter (417 600 serveurs `a Douglas County, 204 160 serveurs `a Dallas ou 241 280 ser-
veurs `a Council Bluﬀs d’apr`es le site ”http ://www.artiﬁcialbrains.com/google/
datacenters”) de nos jours qui peut stocker plusieurs centaines de milliers de te-
raoctets et consomme en moyenne 103 MW (selon le journal ”The Guardian”),
soit autant que la ville anglaise de Newcastle, le monde a connu une ´evolution
en informatique sans pr´ec´edent. Les ensembles de donn´ees devenant de plus en
plus volumineux, il est diﬃcile de travailler avec des outils classiques de gestion
de bases de donn´ees ou de gestion de l’information. Cela nous am`ene `a la notion
de donn´ees massives.

Aucune d´eﬁnition pr´ecise ou universelle ne peut ˆetre donn´ee du Big Data.
Il s’agit d’un concept de stockage d’un nombre tr`es important d’informations
sur une base num´erique, utilisant plusieurs machines qui forment un cluster,
et les algorithmes peuvent ˆetre utilis´es de mani`ere parall`ele et distribu´ee. La
gestion des donn´ees massives marque une rupture dans l’´evolution des syst`emes

73

74

CHAPITRE 2. PARALL ´ELISME ET DISTRIBUTION

d’information et r´epond `a une quintuple exigence, on parle de la r`egle des ”5V” :
— grand V olume de donn´ees (qui ne peut g´en´eralement ˆetre stock´e sur une

seule machine)

— importante V ari´et´e de ces mˆemes donn´ees.
— V itesse de traitement avoisinant le temps r´eel.
— V ´eracit´e : La v´eracit´e ou ﬁabilit´e des donn´ees (s’assurer que les donn´ees

soient r´eelles et non fauss´ees).

— V aleur : Dans un contexte de surcharge informationnelle, il s’agit de

s´electionner l’information pertinente pour l’obtention d’un meilleur r´esultat.

L’analyse de grands graphes est un exemple de probl´ematique. Par exemple,
la librairie igraph en python, permettant l’analyse de graphes, ne peut charger
un graphe dont la capacit´e de ﬁchier repr´esentant les arˆetes exc`ede 60 Mo. Cela
pose un probl`eme majeur dans la mesure o`u de plus en plus de graphes ont des
tailles de ﬁchier tr`es importantes. Ainsi, les graphes repr´esentant Twitter, Fa-
cebook, You Tube ou encore Amazon ne peuvent ˆetre ´etudi´es. Une autre limite
concerne le cˆot´e algorithmique de l’analyse des grands graphes. Certains algo-
rithmes ont une complexit´e bien trop grande pour pouvoir donner une r´eponse en
un temps acceptable. C’est ainsi que naˆıt le besoin de distribuer et de r´epartir
les donn´ees sur plusieurs machines pour y appliquer un algorithme parall`ele,
donnant une r´eponse en un temps acceptable. C’est pourquoi depuis ces trente
derni`eres ann´ees des plateformes sont apparues permettant le d´eveloppement de
mani`ere parall`ele et distribu´ee.

2.2 Plateformes parall`eles et distribu´ees

Pour traiter de grandes quantit´es de donn´ees, des outils permettant la pa-
rall´elisation d’algorithmes et la distribution des donn´ees ont ´et´e propos´es. Nous
pr´esenterons dans un premier temps les principales plateformes parall`eles et dis-
tribu´ees. Nous focaliserons notre ´etude sur les derni`eres technologies Hadoop et
Spark pour leur eﬃcacit´e `a traˆıter de grandes volum´etries de donn´ees. Nous
pr´esenterons ´egalement des plateformes exclusivement destin´ees aux graphes.

2.2.1 Hadoop

Apache Hadoop, est un logiciel open source, d´evelopp´e sous l’´egide de la fon-
dation Apache depuis 2005, dont la version 1.0 a vu le jour en 2011. Elle consiste
en deux grandes composantes autour desquelles s’agr`egent d’autres fonctionna-
lit´es. La premi`ere grande composante est le framework 1 MapReduce (Dean et
Ghemawat (2008)), la seconde est le HDFS (pour Hadoop Distributed File Sys-
tem).

1. un framework ou structure logicielle est un ensemble de composants logiciels, qui sert `a

cr´eer les fondations de tout ou d’une partie d’un logiciel.

2.2. PLATEFORMES PARALL `ELES ET DISTRIBU ´EES

75

MapReduce est un patron de conception destin´e `a eﬀectuer des analyses et
des op´erations pour de grandes quantit´es de donn´ees et qui permet de distribuer
les donn´ees sur plusieurs machines . Cette grappe de machines est commun´ement
appel´ee cluster. MapReduce comprend trois grandes ´etapes. Une fonction Map
qui prend en param`etre un bloc de donn´ees du lecteur d’entr´ee et le traite. Cette
fonction g´en`ere un ensemble de paires interm´ediaires < cle, valeur >. Une partie
de shuﬄe o`u l’ensemble des paires de < cle, valeur > ´emis par les mappers est
tri´e selon les cl´es, scind´e en lots puis ´ecrit sur le disque. Enﬁn, la fonction Reduce
est invoqu´ee pour chaque cl´e interm´ediaire distincte et applique un traitement
aux valeurs associ´ees `a ces mˆemes cl´es. Le langage natif de programmation sous
Hadoop est le Java, mais il a ´et´e ´etendu ´egalement aux langages Python et R.

Hadoop int`egre un syst`eme de ﬁchiers distribu´es qui prend en charge toutes
les fonctions de r´eplication des donn´ees et de tol´erance aux pannes sur un clus-
ter. Il s’agit du HDFS. Le HDFS d´eﬁnit la notion de bloc qui correspond `a
la plus petite quantit´e de donn´ees qu’il est possible de lire ou d’´ecrire sur un
disque. Cette taille est de 64 Mo. L’architecture du HDFS consiste en un syst`eme
maˆıtre-esclave. Un nœud maˆıtre, appel´e NameNode permet de g´erer l’espace de
nommage et les m´etadonn´ees du syst`eme de ﬁchier. Il associe les blocs aux
diﬀ´erentes machines du cluster. Des processus associ´es `a chaque nœud, que l’on
nomme DataNode g`erent les op´erations de stockage locales, le tout dirig´e par les
instructions du NameNode. Par d´efaut, chaque ﬁchier sur le HDFS est r´epliqu´e
trois fois sur des machines diﬀ´erentes au sein du cluster, pour pr´evenir et assurer
la tol´erance aux pannes.

D’autres fonctionnalit´es s’agr`egent autour du logiciel Hadoop pour r´epondre
`a des contraintes tr`es sp´eciﬁques. Le tableau suivant r´ecapitule les fonctionna-
lit´es annexes du logiciel Hadoop.

Les principales distributions d’Hadoop sont Cloudera, Hortonworks, MapR

et Amazon Elastic MapReduce.

2.2.2 Apache Spark

Spark (Zaharia et al. (2010)) est un projet open source d’analyse de donn´ees
ayant vu le jour en 2009 `a Berkeley et qui fut l’un des projets prioritaires de la
fondation Apache depuis f´evrier 2014. Spark utilise l’infrastructure distribu´ee de
Hadoop, en particulier le HDFS, sans toutefois faire appel au patron de concep-
tion MapReduce. Les performances annonc´ees en termes de vitesse sont jusqu’`a
100 fois plus importantes grˆace `a son architecture in memory. Le d´eveloppement
Spark se veut fonctionnel, c’est en ce sens que le langage de programmation na-
tif de Spark est le Scala. Il est actuellement ´etendu aux langages Python et R.

L’un des atouts de Spark vis-`a-vis d’Hadoop est de maintenir les r´esultats in-
term´ediaires en m´emoire plutˆot que sur le disque, ce qui repr´esente un avantage

76

CHAPITRE 2. PARALL ´ELISME ET DISTRIBUTION

HBase
Zookeeper

Pig

Hive

Oozie

Flume

Sqoop

Fonctionnalit´es agr´eg´ees autour de Hadoop

Base de donn´ees NOSQL orient´ee colonne

Service de coordination de processus
distribu´es au moyen d’un espace de

nommage partag´e disponible en lecture
Langage proc´edural qui parse, optimise

et ex´ecute des scripts PigLatin comme une

s´erie de jobs MapReduce au sein d’un cluster Hadoop.

Infrastructure de datawarehouse construite

sur Hadoop pour simpliﬁer l’analyse

d’ensembles de donn´ees tr`es volumineuses.

Outil permettant de construire

des combinaisons complexes MapReduce, PigLatin ou Sqoop

en une seule unit´e logique et permet

la planiﬁcation de jobs Hadoop.

Solution permettant d’agr´eger en temps

r´eel diﬀ´erents ﬂux de logs de serveurs webs.
Outil permettant de transf´erer eﬃcacement

de grands volumes de donn´ees entre
Hadoop et des SGBD traditionnels

comme MySQL, Oracle, IBM DB2 et Microsoft SQL.

Tableau 2.1 – Composants de l’´eco-syst`eme Hadoop

en termes de temps d’ex´ecution. Spark a ´et´e con¸cu pour travailler aussi bien en
m´emoire que sur le disque. Si les op´erations ne tiennent plus en m´emoire, Spark
utilise alors l’espace disque.

Spark se base sur la notion de RDD (Resilient Distributed Datasets) qui
sont des collections pouvant contenir tout type de donn´ees, qui distribuent les
donn´ees sur le cluster tout en supportant des op´erateurs parall`eles. Les RDD
permettent de r´earranger les calculs et d’optimiser le traitement. Ils sont aussi
tol´erants aux pannes. Les RDD supportent deux types d’op´erations, les trans-
formations et les actions. Les transformations ne retournent pas de valeur seule,
elles retournent seulement un nouveau RDD. Aucune ´evaluation n’est eﬀectu´ee
lorsque l’on fait appel `a une fonction de transformation. Les actions ´evaluent et
retournent une nouvelle valeur. A l’instant o`u une fonction d’action est appel´ee
sur un objet RDD, toutes les requˆetes de traitement des donn´ees sont calcul´ees
(qui correspondent aux transformations) et le r´esultat est retourn´e. C’est en ce
sens que l’on qualiﬁe Spark de syst`eme paresseux (lazy) dans la mesure o`u les
transformations ne s’eﬀectuent pas de suite.

Tout comme Hadoop, Spark contient son propre ´eco-syst`eme sur lequel
s’agr`egent diﬀ´erentes librairies et fonctionnalit´es. Nous r´ecapitulons les librairies
les plus importantes dans le tableau 2.3.

2.2. PLATEFORMES PARALL `ELES ET DISTRIBU ´EES

77

Spark Streaming

Utilis´e pour le traitement en temps r´eel.

Fonctionnalit´es agr´eg´ees autour de Spark

En s’appuyant sur un mode de traitement de ”micro batching”,

il utilise pour les donn´ees temps-r´eel DStream,

c’est-`a-dire une s´erie de RDD.

Spark SQL

Outil agissant comme un ETL. Les jeux de donn´ees Spark

sont mis en exergue via l’API JDBC.

Spark SQL ex´ecute des requˆetes de type

SQL en utilisant les outils BI

et de visualisation traditionnels.
MLlib est une librairie contenant
un grand nombre d’algorithmes et

utilitaires d’apprentissage classiques,
comme la classiﬁcation, la r´egression,
le clustering, le ﬁltrage collaboratif,

la r´eduction de dimensions, en plus des
primitives d’optimisation sous−jacentes.

Outil pour le traitement des

Spark MLlib

Spark GraphX

graphes avec des op´erations parall`eles d´edi´ees.

GraphX ´etend les RDD de Spark en introduisant
le Resilient Distributed Dataset Graph (RDDG),

un multi-graphe orient´e avec des

propri´et´es attach´ees aux nœuds et aux arˆetes.

On peut citer PageRank, la d´etection de composantes connexes,

le parcours en largeur ou la propagation de

labels comme algorithmes ´etant d´ej`a impl´ement´es sous cet outil.

Tableau 2.2 – Composants de l’´eco-syst`eme Spark

2.2.3 Syst`eme de traitement de graphes parall`eles

Il existe d’autres logiciels permettant la distribution et la parall´elisation
d’algorithmes comme OpenMP ou encore les syst`emes MPI. Certains de ces lo-
giciels sont intrins`equement destin´es aux graphes. Nous proposons de lister les
principales solutions permettant le traitement de graphes et le d´eveloppement
d’algorithmes de graphes dans un environnement parall`ele et distribu´e.

Pour g´erer la parall´elisation et la distribution d’algorithmes, les syst`emes ont
dˆu choisir entre diﬀ´erents mod`eles. Nous avons d´ej`a vu le patron de conception
MapReduce d’Hadoop ou encore la notion de RDD avec Spark, mais il en existe
d’autres comme les BSP (pour ”Bulk synchronous parallel”) ou encore le mod`ele
RAD (pour ”Rassembler-Appliquer-Disperser”).

Le mod`ele BSP (Valiant (1990)) d´ecrit un ensemble de paires processeurs-
m´emoires homog`enes en nombre ﬁxe. De par un r´eseau de communication et
une unit´e de synchronisation globale, les ´echanges de donn´ees entre proces-

78

CHAPITRE 2. PARALL ´ELISME ET DISTRIBUTION

seurs sont rendus possibles. L’ex´ecution se d´eroule en plusieurs ´etapes, chacune
constitu´ee d’une phase de calculs locaux (eﬀectu´ee sur chaque processeur) et
d’une phase de communication entre les diﬀ´erents processeurs qui s’eﬀectue
avec des phases de synchronisation. Ce syst`eme garantit le d´eterminisme des
applications d´evelopp´ees et assure l’absence d’´etreintes fatales (interblocages).

Le mod`ele RAD (Gonzalez et al. (2012)) est intrins`equement destin´e au
graphe. Dans la premi`ere phase de ”Rassemblement”, un sommet accumule de
l’information sur ses voisins. La seconde phase ”Application” applique la va-
leur accumul´ee `a ce sommet et met `a jour ses sommets adjacents et arˆetes. La
derni`ere phase ”Dispersion” active les sommets voisins. Les sommets peuvent
directement tirer de l’information des sommets voisins sans toujours interagir
avec eux, `a l’instar du mod`ele BSP. Le mod`ele GAS permet des ex´ecutions asyn-
chrones sans l’aide de barri`ere de synchronisation.

A partir des deux mod`eles cit´es ci-dessus, des syst`emes pour le traitement

de graphes en environnement parall`ele et distribu´e ont pu voir le jour.

Pregel (Malewicz et al. (2010)) est la premi`ere impl´ementation utilisant le
principe du BSP. Ce logiciel a ´et´e orient´e vers les sommets du graphe. Les cal-
culs portant sur le graphe sont sp´eciﬁ´es en termes de ce que doivent faire les
nœuds. Les arˆetes servent de canaux et transmettent l’information r´esultante
d’un sommet vers un autre mais ne participent pas au calcul. Un sommet peut
avoir deux ´etats : actif et inactif. Les nœuds actifs peuvent envoyer et recevoir
les messages de leurs voisins (ou d’un autre sommet du graphe). Les super-
´etapes se terminent avec une barri`ere de synchronisation, assurant que tous les
messages ont bien ´et´e transmis. Pregel se termine lorsque tous les sommets sont
inactifs. Toutes les op´erations avec Pregel sont eﬀectu´ees en m´emoire. Pregel ne
permet pas l’´ecriture sur disque, ce qui oblige `a avoir un important cluster de
machines si la quantit´e de donn´ees `a traiter est grande. L’architecture de Pregel
est de type maˆıtre-esclave. Le nœud maˆıtre du cluster coupe les donn´ees en lots
qui forment des sous-graphes. Chaque sous-graphe est envoy´e `a un ”worker”
sp´eciﬁque (ordinateur du cluster qui eﬀectue une tˆache) qui travaille de mani`ere
ind´ependante des autres. Le nœud maˆıtre est responsable de la bonne synchro-
nisation.

Giraph (Avery (2011)) est une solution open source construite sur Hadoop et
utilisant le HDFS pour stocker les donn´ees. Giraph permet la cr´eation de struc-
tures de graphes et autorise certaines op´erations MapReduce. Giraph utilise Zoo-
keeper pour la coordination, les points de reprise et la d´efaillance des syst`emes de
r´ecup´eration. Facebook (Ching (2013)) a utilis´e Giraph avec quelques am´eliorations
de performances pour analyser 1000 milliards d’arˆetes (relations) en 4 minutes
sur un cluster de 200 machines, dans le but de faire un algorithme de recherche
d’information sur les sommets. Cependant, Giraph cessa depuis 2015 d’ˆetre
document´e, cela ´etant dˆu principalement `a la complexit´e de d´eveloppement
et au temps de traitement des donn´ees trop important pour certains algo-

2.2. PLATEFORMES PARALL `ELES ET DISTRIBU ´EES

79

rithmes, principalement globaux. De nombreux bugs ont ´egalement ´et´e signal´es,
d´ecr´edibilisant l’utilisation ce cette solution (Salihoglu et al. (2015)).

GPS (Salihoglu et Widom (2013)) (pour ”A Graph Processing System”) est
un logiciel open source fond´e sur Pregel. Des exp´erimentations ont montr´e qu’il
´etait jusqu’`a 12 fois plus rapide que Giraph sur certains algorithmes comme
le parcours en largeur. Des optimisations par rapport `a Pregel portent sur
l’am´elioration des communications, o`u les op´erations se font par processeur dans
un premier temps, puis entre processeurs dans un second temps, et non plus par
voisinage comme sur Pregel. Cela permet une r´eduction de la synchronisation
des threads (moins d’´echanges entre processeurs) et une am´elioration de la per-
formance d’ex´ecution en termes de temps. Une caract´eristique de GPS est un
partitionnement de graphe dynamique pour la r´epartition des donn´ees sur le
cluster. Alors que certains syst`emes partitionnent le graphe avant d’eﬀectuer
un processus, des migrations dynamiques de sommets ont lieu entre machines
du cluster. Cette migration est fond´ee non sur une ´equir´epartition des som-
mets (r´epartition de mani`ere uniforme) du graphe au sein du cluster, mais sur
une ´equir´epartition des messages envoy´es entre sommets aﬁn de minimiser leur
nombre. Cependant, la mise `a jour des listes de voisins lors des migrations en-
traˆıne un gain de temps qui ne permet pas au syst`eme d’ˆetre plus performant en
termes d’ex´ecution que le mod`ele de base de Pregel. GPS oﬀre aussi les ”grandes
listes d’adjacences partitionnables” (GLAP) qui permettent de g´erer des nœuds
avec beaucoup de connexions. Une migration des algorithmes de graphes s’ef-
fectue `a ce jour vers GraphX.

Mizan (Khayyat et al. (2013); Kalnis et al. (2012)) est un logiciel open source
fond´e sur l’architecture de GPS avec des am´eliorations concernant les structures
de donn´ees utilis´ees et les m´ethodes de partitionnement. Il a ´et´e report´e comme
´etant deux fois plus rapide que Giraph en mode statique (sans l’option de migra-
tion de nœuds au cours de la partition). Mizan a un partitionnement se fondant
sur la topologie du graphe. L’algorithme, par une estimation de Kolmogorov
(Pettitt et Stephens (1977)), peut d´etecter si le graphe est un graphe de ter-
rain, auquel cas, un partitionnement sp´eciﬁque aura lieu, dans lequel les hubs
(nœuds avec de fortes connexions) seront r´epliqu´es sur plusieurs processeurs.
Comme GPS, Mizan a une option avec partitionnement dynamique au cours
de l’ex´ecution d’un programme en se fondant sur la distribution des messages
entre sommets du graphe. On reporte cependant de tr`es nombreux bugs. La
documentation laisse `a penser que le projet n’est plus d’actualit´e.

GraphLab (Low et al. (2014)) est un projet open source qui int`egre les fonc-
tionnalit´es de Powergraph (Gonzalez et al. (2012)). GraphLab utilise le mod`ele
RAD. L’une des diﬀ´erences avec les autres logiciels est que le partitionnement
ne concerne que les nœuds, pas les arˆetes. Les arˆetes ne sont assign´ees que sur
une seule machine alors que les nœuds sont r´epliqu´es dans la m´emoire cache des
machines du cluster suivant la distribution de leurs degr´es (cela pr´evaut pour les
hubs). Cela a pour cons´equence un gain de temps notable. GraphLab supporte

80

CHAPITRE 2. PARALL ´ELISME ET DISTRIBUTION

les modes d’ex´ecution synchrone et asynchrone. Les sommets qui n’envoient pas
de messages ne sont pas consid´er´es lors des calculs et retir´es du cache, ce qui
am´eliore le temps de calcul.

HAMA (Seo et al. (2010)) est un logiciel fond´e sur le mod`ele BSP tout en
´etant construit sur Hadoop. Il n’est pas exclusivement destin´e aux graphes mais
pr´esente de tr`es nombreux avantages. Il fut con¸cu pour g´erer de tr`es grandes
matrices ainsi que leurs op´erations ´el´ementaires (multiplication, inversion, etc.).
Il est principalement destin´e `a l’alg`ebre lin´eaire. HAMA pr´esente cependant un
int´erˆet particulier pour les algorithmes it´eratifs car il permet de conserver les
donn´ees en m´emoire et de ne pas les ´ecrire sur le disque, tel un pr´ecurseur de
Spark. Les exp´erimentations r´ealis´ees sur PageRank ont montr´e que HAMA
´etait jusqu’`a trois fois plus rapide que Giraph.

Syst`emes permettant le traitement de graphes parall`eles
Langage

optimisation

Mod`ele

partitionnement

Syst`eme
Hadoop
Spark

Pregel
GPS

Mizan

Giraph
GraphLab

Java
Scala

C + +
Java

C + +

Java
C + +

MapReduce

RDD

BSP
BSP

BSP

-

r´eutilisation
des donn´ees

-

GLAP,

migration
dynamique
migration,
r´eplication

BSP, MapReduce

´ecriture en m´emoire

RAD

calcul synchrone

et asynchrone

graphes

de terrains

avec une coupe

minimale

hashage
1D−2D

hashage
GLAP

Mizan α − β

hashage
hashage
Metis,

ParMetis,
hashage

sur les arˆetes

Powergraph

C + +

BSP,RAD

Tableau 2.3 – Caract´eristiques globales des syst`emes pour le traitement de graphes de
mani`ere parall`ele et distribu´ee

2.3 D´etection de communaut´es dans un envi-

ronnement parall`ele et distribu´e

Des m´ethodes issues de la litt´erature de la d´etection de communaut´es ont ´et´e
appliqu´ees et retranscrites pour de grands graphes. Nous nous proposons d’ex-
poser les plus importantes et celles qui permettront d’aboutir `a une strat´egie

2.3. D ´ETECTION DE COMMUNAUT ´ES DANS UN ENVIRONNEMENT PARALL `ELE ET DISTRIBU ´E81

pour notre solution concernant les grands graphes.

Riedy et al. (2011) ont impl´ement´e l’algorithme de Clauset et al., algorithme
agglom´eratif optimisant la modularit´e, en utilisant le multithreading Cray XMT.
Cray XMT est une gamme de super-ordinateurs qui poss`edent plusieurs proces-
seurs. L’algorithme fut lanc´e sur un graphe de deux milliards d’arˆetes et 122
millions de sommets avec plus de 128 processeurs. Les r´esultats sont satisfaisants
mais la qualit´e ne fut jug´ee que par le score de la modularit´e. Les technologies
Cray XMT permettent de r´ealiser des calculs sur de gros volumes de donn´ees
mais sont tr`es on´ereuses. De plus, depuis l’apparition des technologies Hadoop
et Spark, la technologie Cray XMT est de moins en moins utilis´ee. Riedy et al.
(2012) ont am´elior´e leur algorithme en y incluant une implementation OpenMP.
En utilisant 4 processeurs de 80 cœurs, les auteurs ont fait marcher leurs algo-
rithmes sur un graphe de 3,3 milliards d’arˆetes en 500 secondes. Cependant, les
tests concernant la qualit´e ne purent ˆetre faits `a cause de la taille des graphes.

|E(S)|

|S|

Bahmani et al. (2012) ont propos´e un algorithme pour d´etecter des groupes
de nœuds denses, fond´e sur la maximisation de fonctions fond´ees sur la densit´e
de sous graphes. Soit G = (V, E) et S ⊆ V , la densit´e de Bahman Bahmani
. Plus ρ(S) augmente, plus la structure se
et al. est d´eﬁnie par ρ(S) =
rapproche de celle d’un graphe complet. Les auteurs proposent un algorithme
avec deux versions. La premi`ere concerne les graphes denses et construira la
communaut´e S si l’in´egalit´e degS(i) ≤ 2(1 + )ρ(S) est v´eriﬁ´ee, avec  un r´eel
donn´e par l’utilisateur. On peut comprendre cette in´egalit´e comme le fait que
chaque nœud doit avoir un degr´e suﬃsant pour appartenir `a la communaut´e
S. La seconde version, destin´ee `a des graphes tr`es denses, doit v´eriﬁer pour la
cr´eation de structures communautaires l’in´egalit´e suivante degS(i) ≤ 
Les deux versions op`erent de la mˆeme mani`ere. Des nœuds sont enlev´es dans
le but de maximiser la densit´e des structures communautaires. L’inconv´enient
majeur de cette m´ethode est la param´etrisation qui a une grande inﬂuence sur
la qualit´e de partitionnement. Il faut d´ej`a avoir une id´ee de la densit´e ρG du
graphe r´esultant que l’on cherche `a obtenir mais ´egalement avoir `a l’esprit une
taille moyenne pour les communaut´es `a  pr`es. La derni`ere contrainte peut poser
probl`eme pour des graphes complexes, o`u la taille des communaut´es peut ˆetre
tr`es variable. On peut en eﬀet, avec une mauvaise param´etrisation, d´etecter des
communaut´es contenant elles mˆemes d’autres communaut´es. L’une des forces
de cet algorithme est d’avoir ´et´e appliqu´e `a de grands graphes, avec plus de 6
milliards d’arˆetes avec 2000 reducers pour un temps d’ex´ecution d’environ 260
minutes. La qualit´e de partitionnement des m´ethodes n’a pas ´et´e sujette `a des
´etudes, le seul crit`ere ´etant de maximiser les densit´es des communaut´es.

1+|S|.

Tsironis et al. (2013) ont impl´ement´e une m´ethode spectrale sous Hadoop.
La m´ethode consiste `a construire la matrice Laplacienne sur laquelle vont ˆetre
calcul´es les K vecteurs propres associ´es aux K plus petites valeurs propres de la
matrice, puis `a lancer un k-means pour obtenir k clusters. Le calcul des vecteurs

82

CHAPITRE 2. PARALL ´ELISME ET DISTRIBUTION

propres se fait en utilisant HEIGEN (Kang et al. (2014)), un algorithme sous
MapReduce reprenant la m´ethode de Lanczos.
Cette m´ethode pr´esente l’inconv´enient d’ˆetre fond´ee sur le k-means, mais est ce-
pendant destin´ee au partitionnement de graphes. De plus, il faut eﬀectuer une
recherche pr´ealable pour s´electionner les vecteurs propres contenant le plus d’in-
formation. Bien que l’algorithme soit parall`ele et distribu´e, la taille des graphes
sur lesquels il a ´et´e appliqu´e est relativement faible, le plus grand graphe ne
contenant que 20000 nœuds.

Ovelgonne (2013) propose un algorithme ensembliste fond´e sur la propaga-
tion de label tout en r´eduisant la complexit´e du probl`eme, via une r´eduction de
la taille des donn´ees de d´epart. En lan¸cant en parall`ele plusieurs propagations de
labels, une m´ethode de chevauchement maximale permet de trouver les cœurs.
Cependant, Ovelg¨onne n’a pas appliqu´e la m´ethode asynchrone sous Hadoop
car trop gourmande en temps. Il choisit plutˆot une version avec mise `a jour en
fonction de probabilit´es de telle sorte que le nombre de propagations de labels
synchrones soit minimis´e. Cela d´et´eriore la qualit´e de partitionnement. De plus,
pour ´eviter d’´ecrire de trop nombreuses fois sur le disque, certains nœuds ne
sont mis `a jour qu’une seule fois avec un nombre d’it´erations assez faible d`es le
d´epart.
Les r´esultats ont ´et´e appliqu´es sur de tr`es grands r´eseaux de terrain comme
LiveJournal avec une heure pour 20 propagations de labels en parall`ele sur un
cluster de 50 machines. Les r´esultats sont ´evalu´es avec la modularit´e qui donne
des valeurs correctes pour la qualit´e de partitionnement.

Staudt et Meyerhenke (2013) proposent une version ”OpenMP” impl´ementant
la propagation de labels et la m´ethode de Louvain en C ++, avec trois m´ethodes
fond´ees sur le clustering d’ensemble et vote par consensus :

— Ensemble de pr´etraitement
— Ensemble multi-niveaux
— Clustering de cœur et contraction de graphe

Ensemble de pr´etraitement (EPP) : il consiste dans un premier temps `a
assigner le graphe `a plusieurs algorithmes de d´etection de communaut´es. Une
contraction du graphe a lieu selon un consensus entre tous les r´esultats des
diﬀ´erentes d´etections de communaut´es. Le graphe est ainsi contract´e. L’objectif
de ce syst`eme est de pouvoir allier qualit´e (par le consensus) et rapidit´e (par la
contraction).
Ensemble multi-niveaux (EM) : il est une am´elioration de l’EPP dans un
sens it´eratif. A la ﬁn de l’´etape de contraction, un nouveau graphe G(cid:48) est cr´e´e et
le processus fond´e sur l’EPP continue de mani`ere it´erative. Les conditions pour
arrˆeter la contraction sont multiples comme i) obtenir un singleton ii) mettre
un seuil sur la taille du graphe r´eduit en dessous duquel la contraction est in-
terdite iii) la pr´esence d’une diminution de la modularit´e d’une contraction `a
la suivante et iv) la stagnation de la qualit´e des communaut´es d´etect´ees.
Clustering de cœur et contraction de graphe (CCGC) : repr´esente
la m´ethode la plus stricte en termes de consensus. Si une paire de nœuds a

2.3. D ´ETECTION DE COMMUNAUT ´ES DANS UN ENVIRONNEMENT PARALL `ELE ET DISTRIBU ´E83

´et´e identiﬁ´ee comme appartenant `a la mˆeme communaut´e, et ceci dans toutes
les d´etections de communaut´es, alors ces deux nœuds seront contract´es. Cette
derni`ere m´ethode permet de trouver les meilleurs cœurs en termes de qualit´e.
Cependant, il se peut que certains r´esultats de d´etection de communaut´es ne
soient pas de bonne qualit´e. La cons´equence est que des cœurs ne puissent ˆetre
trouv´es.
C’est en utilisant ces derni`eres m´ethodes que la propagation de labels pond´er´ee
et la m´ethode de Louvain ont ´et´e appliqu´ees dans leurs versions parall`eles.
Le parall´elisme de la propagation de labels sur OpenMP (not´e PLP) r´eside en
un tri des nœuds se faisant sur plusieurs threads qui op´erent sur des tableaux de
labels communs. La mise `a jours des labels peut ainsi se faire de mani`ere syn-
chrone ou asynchrone. Il s’agit d’une impl´ementation pour des graphes pond´er´es,
avec une mise `a jour des labels dont les arˆetes liant le nœud sont les plus impor-
tantes. Un seuil δ doit cependant ˆetre sp´eciﬁ´e en dessous duquel le changement
de labels devient impossible.
Le parall´elisme de l’algorithme de Louvain sur OpenMP intervient dans le calcul
de la fonction de modularit´e, qui se fait en utilisant plusieurs threads. En eﬀet,
chaque mouvement d’un nœud dans une autre communaut´e a pour cons´equence
la variation de la modularit´e qui est calcul´ee localement.
Il ressort des exp´erimentations que CCGC semble donner les meilleurs r´esultats
en termes de qualit´e pour PLM et PLP. PLP est extrˆemement rapide mais de
qualit´e moyenne, alors que PLM obtient de meilleurs r´esultats, mais n´ecessite
plus de temps.

Moon et al. (2014) d´evelopp`erent l’algorithme de Girvan et Newman (2002b)
sous Hadoop. Une version du plus court chemin fut d´evelopp´ee sous MapReduce
en quatre ´etapes. La premi`ere phase consiste `a calculer entre chaque paire de
nœuds le plus court chemin. La seconde ´etape consiste dans le calcul de la
centralit´e d’interm´ediarit´e. La troisi`eme ´etape permet de s´electionner k arˆetes
ayant les centralit´es d’interm´ediarit´e les plus ´elev´ees. k est un param`etre de
l’utilisateur. La derni`ere phase consiste `a retirer les arˆetes s´electionn´ees. L’al-
gorithme fut appliqu´e `a deux graphes de petite taille de 6000 et 10000 nœuds
avec respectivement 290 000 et 51 000 arˆetes. Avec plus de 20 machines, le
syst`eme requiert un temps d’ex´ecution de pr`es de 300 secondes. Bien que les
r´esultats en termes de qualit´e soient encourageants, l’algorithme pr´esente deux
inconv´enients majeurs. Le premier est le choix du nombre d’arˆetes `a retirer qui
n’est a priori pas connu de l’utilisateur. Le second inconv´enient est le temps de
calcul du plus court chemin entre chaque paire de nœuds qui est beaucoup trop
important pour des graphes ayant quelques dizaines de milliers d’arˆetes. De ce
fait, l’algorithme ne peut pas ˆetre appliqu´e `a de grands graphes de plusieurs
millions d’arˆetes.

Kuzmin et al. (2015) ont impl´ement´e le SLPA dans sa version parall`ele dans
un contexte multithreading. Chaque thread r´ealise une propagation de labels
sur un sous ensemble de nœuds qui a ´et´e pr´ealablement partitionn´e. Le parti-
tionnement est utilis´e pour ne pas d´epasser la m´emoire vive. C’est alors que les

84

CHAPITRE 2. PARALL ´ELISME ET DISTRIBUTION

sous-graphes r´esultants sont assign´es `a des threads o`u les propagations de labels
sont lanc´ees.
Les r´esultats ont montr´e que la m´ethode ´etait ´equivalente en termes de qualit´e
de partionnement `a la version non parall`ele. Elle obtient cependant de meilleurs
r´esultats en choisissant une m´ethode de partitionnement particuli`ere, mais une
´etude pr´ealable doit ˆetre eﬀectu´ee. Elle fut lanc´ee sur des graphes comme DBLP,
Amazon ou Livejournal, avec plusieurs millions de sommets et jusqu’`a une cen-
taine de millions d’arˆetes.

La propagation de label a ´egalement ´et´e d´evelopp´ee sous Apache Spark, par
une impl´ementation et par une int´egration Pregel dont le mod`ele suit un BSP.
Comme nous l’avons vu, Pregel est un BSP qui permet l’impl´ementation d’algo-
rithmes sur les graphes. Pregel fut construit sur la philosophie ”Penser comme
un sommet”. Chaque calcul est fait sur chaque sommet et les arˆetes sont des
canaux de communication permettant d’envoyer ou de recevoir des informa-
tions ou op´erations des voisinages des nœuds (ou mˆeme d’un nœud `a un autre
nœud en connaissant l’identiﬁant). Pregel ﬁnit une ”super ´etape” lorsque tous
les nœuds du graphe sont dans un ´etat inactif. La propagation de labels fut ainsi
impl´ement´ee de mani`ere synchrone o`u chaque it´eration consiste en une ”super
´etape”. A la ﬁn d’une super ´etape, chaque nœud prend connaissance du label
majoritaire de son voisin et un vote est ainsi eﬀectu´e. Le processus se continue
un nombre de fois sp´eciﬁ´e par l’utilisateur. En consid´erant l’impl´ementation sur
Spark, `a chaque super ´etape, un RDD (Resilient distributed dataset) est cr´e´e et
est utilis´e pour l’it´eration de la propagation de labels suivante. La signature du
LPA sous Spark est lib.LabelPropagation.run(par1, par2).vertices
o`u par1 se r´ef`ere au graphe o`u sera appliqu´e le LPA et par2 sera le nombre
d’it´erations (de super ´etapes) du LPA. Cette impl´ementation peut ˆetre ap-
pliqu´ee `a des graphes de plusieurs millions d’arˆetes en utilisant un cluster de
machines important, mais souﬀre d’un inconv´enient qui lui est intrins`eque. Son
impl´ementation synchrone laisse l’algorithme instable et non d´etermiste. La so-
lution pour r´esoudre ce probl`eme est que l’ordre de visite des nœuds soit toujours
le mˆeme, aﬁn de rendre plus d´eterministe l’algorithme. Cependant, si l’ordre de
visite commence par un nœud qui est situ´e entre plusieurs structures commu-
nautaires, de mauvaises propagations peuvent se produire.

2.4. TABLEAU R ´ECAPITULATIF DES M ´ETHODES PARALL `ELES ET DISTRIBU ´EES85

2.4 Tableau r´ecapitulatif des m´ethodes parall`eles

et distribu´ees

Classiﬁcation des principaux algorithmes de d´etection de communaut´es parall`eles et distribu´es

articles

d

c

complexit´e

framework

Algorithmes
parall`eles
Zhang et al
Bahman et al.
EJ Riedy et al.
EJ Riedy et al.

Tsironis et al.
Ovelgonne
Staudt et al.
Moon et al.
A Prat-P´erez

(Zhang et al., 2009)

(Bahmani et al., 2012)

(Riedy et al., 2011)
(Riedy et al., 2012)

(Tsironis et al., 2013)

(Ovelgonne, 2013)

(Staudt et Meyerhenke, 2013)

(Moon et al., 2014)
(Saltz et al., 2015)

non
non
non
non

non
non
oui
non
non

non
non
non
non

non
non
non
non
non

(ordre)

O(exp(n))
O(kmn)
O(kmn)
O(kmn)
O(kmn)
O(kmn)

Hadoop
Hadoop

Cray XMT
Cray XMT,
OpenMPI

Hadoop
Hadoop

MPI

Hadoop
Giraph-
Hadoop

MPI

Kuzmin et al.

(Kuzmin et al., 2015)

non

oui

Tableau 2.4 – Principaux algorithmes de d´etection de communaut´es parall`eles et dis-
tribu´es. ”*” d´epend du param´etrage, diﬃcile `a estimer, d pour dendrogramme et c
pour chevauchement. Premi`ere partie.

Figure 2.1 – M´ethodes parall`eles et distribu´ees. L’axe des abscisses repr´esente la taille
des graphes, l’axe des ordonn´ees, la complexit´e.

En ´etudiant la ﬁgure 2.1, on voit que les algorithmes permettant de traiter
les plus grands graphes concernent les m´ethodes portant sur la maximisation
de la densit´e des structures communautaires et celles se fondant sur la propaga-
tion de labels. Nous observons que les m´ethodes gobales telles que la m´ethode
spectrale ou celle concernant la centralit´e d’interm´ediarit´e ne permettent pas de
travailler avec des graphes de plus de 30 000 nœuds. Cependant, ces derni`eres
repr´esentent une avanc´ee sur la taille des r´eseaux vis-`a-vis de leurs homologues
originellement non parall`eles et non distribu´ees.

86

CHAPITRE 2. PARALL ´ELISME ET DISTRIBUTION

2.5 Synth`ese et discussion

Ce chapitre nous a permis d’exposer la probl´ematique de la d´etection de com-
munaut´es dans de grands graphes dont les diﬃcult´es majeures r´esident dans :
— le stockage des donn´ees massives du ﬁchier repr´esentant le graphe et

´egalement durant le processus de l’algorithme.

— l’´echelonnabilit´e, c’est-`a-dire le fait qu’un algorithme puisse ˆetre capable
de travailler `a la fois sur de petits graphes et de grands graphes en don-
nant la mˆeme qualit´e de partitionnement et dont le stockage de donn´ees
soit lin´eaire.

Ce seront les challenges pour notre contribution sur de grands graphes.

Ce chapitre a ´egalement permis de voir les plus importantes plateformes pa-
rall`eles et distribu´ees existantes, particuli`erement les PGPS destin´es aux graphes.
C’est en ce sens que nos choix se porteront principalement sur deux plate-
formes Hadoop et Spark. Les raisons principales sont leur faible coˆut ﬁnancier
et le fait que de nombreux algorithmes de graphes furent d´evelopp´es en utili-
sant ces plateformes, comme PEGASUS (Kang et al. (2009)) (le degr´e, Page-
Rank, marche al´eatoire avec red´emarrage (MAR), le diam`etre, les composantes
connexes, etc.) et Giraph pour Hadoop et GraphX (Avery (2011)) pour Spark
(Zaharia et al. (2010)). Hadoop permet l’utilisation du HDFS qui autorise le
traitement de donn´ees massives et la tol´erance aux pannes. Cependant, cette
plateforme connaˆıt des diﬃcult´es dans le traitement de donn´ees en temps r´eel,
ce qui peut ˆetre le cas de la propagation de labels o`u tout autre nœud doit
connaˆıtre le label de ses voisins en temps r´eel (version asynchrone). C’est un
challenge auquel nous souhaitons faire face. L’´etat de l’art nous a permis de
voir que les m´ethodes `a propagation de labels permettaient de traiter de grands
graphes, c’est donc l’option que nous privil´egions.

Chapitre 3

Propositions algorithmiques
sur la d´etection de
communaut´es

Sommaire

3.1 LPA avec barrages et dendrogrammes . . . . . . .

3.1.1 Propagation de labels asynchrone avec barrages . . .
3.1.2 Propagation de labels asynchrone avec barrages et

88
89

d´etection de cœurs . . . . . . . . . . . . . . . . . . .

91

3.1.3 Exp´erimentations portant sur les propositions algo-
rithmiques pour la d´etection de communaut´es dis-
jointes . . . . . . . . . . . . . . . . . . . . . . . . . .

98

3.1.4 Conclusion sur les algorithmes de propagation de la-

bels avec barrages et d´etection de cœurs . . . . . . . 121
3.2 LPA avec coloration . . . . . . . . . . . . . . . . . . 123

3.2.1 Propagation de labels asynchrone avec d´etection de

cœurs et coloration . . . . . . . . . . . . . . . . . . . 123
3.2.2 Exp´erimentation sur R-POP, POP-UP et POP-DOWN125
3.2.3 Conclusion sur les propositions algorithmiques `a base

de coloration . . . . . . . . . . . . . . . . . . . . . . 136
3.3 Analyse comparative des m´ethodes disjointes
. . 137
3.4 Propositions sur le chevauchement . . . . . . . . . 141

3.4.1 De la propagation de labels avec d´etection de cœurs

au chevauchement

. . . . . . . . . . . . . . . . . . . 141
3.4.2 Fonction d’appartenance . . . . . . . . . . . . . . . . 142
3.4.3 Propositions algorithmiques . . . . . . . . . . . . . . 145
3.4.4 Exp´erimentations sur CDLPOV . . . . . . . . . . . . 147
3.4.5 Etude portant sur le temps d’ex´ecution . . . . . . . 155
3.4.6 Analyse comparative . . . . . . . . . . . . . . . . . . 156

87

88

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

3.4.7 Conclusion sur les propositions algorithmiques che-

vauchantes

. . . . . . . . . . . . . . . . . . . . . . . 158

L’´etat de l’art concernant la d´etection de communaut´es disjointes nous a
permis de voir l’existence de trois grandes classes d’algorithmes, `a savoir les
m´ethodes globales, les m´ethodes locales et les m´ethodes hybrides. Dans le but
de cr´eer un algorithme pouvant travailler sur de grands graphes, nous avons
privil´egi´e d’utiliser la propagation de labels. Cependant, l’algorithme de propa-
gation de labels souﬀre de certains probl`emes li´es `a des choix al´eatoires, comme
celui du choix d’un label lorsqu’il y a ´equidistribution des labels majoritaires au
sein du voisinage d’un nœud. Cela peut mener `a :

— de mauvaises propagations de labels (susceptibles de donner des com-
munaut´es g´eantes, groupes de nœuds o`u les structures n’ont pu ˆetre
d´etect´ees) ou des communaut´es non connect´ees avec le mˆeme label)

— l’instabilit´e (ne donnant que tr`es rarement la mˆeme partition apr`es plu-

sieurs lancements)

— l’impossibilit´e de cr´eer un dendrogramme
— l’impossibilit´e de trouver des communaut´es chevauchantes.

Dans cette section, nous allons exposer nos propositions hybrides, fond´ees
sur la propagation de labels en utilisant la d´etection de cœurs et la mise en place
de barrages artiﬁciels sur certaines arˆetes interdisant toute propagation. Nous
ferons une ´etude portant sur la qualit´e de la d´etection de nos algorithmes mais
aussi sur leurs param´etrages. Par la suite, nous proposerons des algorithmes,
fond´es sur nos m´ethodes disjointes, ayant pour vocation le chevauchement. L’ob-
jectif de la partie de chevauchement est de cr´eer une m´ethode permettant `a un
nœud d’appartenir `a autant de communaut´es que n´ecessaire suivant certaines
conditions que nous expliciterons. Une ´etude comparative sera eﬀectu´ee.

Dans la suite de ce manuscrit, nous notons par su ← sv le fait que la valeur

du label du nœud u prenne la valeur du label du nœud v.

3.1 Propagation de labels avec d´etection de cœurs,

barrages et dendrogrammes

Pour diminuer la probabilit´e qu’une mauvaise propagation puisse surve-
nir, nous avons r´eﬂ´echi `a un moyen de limiter cette derni`ere. Il serait souhai-
table que la propagation de labels puisse se faire dans des r´egions du graphe
dens´ement connect´ees en ´evitant de mauvaises propagations entre r´egions fai-
blement connect´ees, ce qui aurait pour cons´equence d’obtenir de trop grosses
communaut´es.

Consid´erons deux exemples donnant une mauvaise propagation de labels. Le

3.1. LPA AVEC BARRAGES ET DENDROGRAMMES

89

premier traite des communaut´es g´eantes alors que le second traite de commu-
naut´es non li´ees ayant les mˆemes labels.

Figure 3.1 – Exemple d’une mauvaise propagation donnant une communaut´e g´eante

En consid´erant l’odre de visite sur le graphe de la ﬁgure 3.1

(cid:19)

(cid:18) 1

s2

σ =

2
s5

3
s6

4
s4

5
s1

6
s3

Une suite d’op´erations possibles peut ˆetre s2 ← s4 (par choix al´eatoire), s5 ← s4
(par choix al´eatoire) s6 ← {s4, s5} (par vote majoritaire) s4 ← {s2, s5, s6} (par
vote majoritaire) s1 ← s2 (par choix al´eatoire) et s3 ← {s2, s1} (par vote ma-
joritaire). Ainsi, les deux structures communautaires, `a savoir {s1, s2, s3} et
{s5, s4, s6} n’ont pas pu ˆetre d´etect´ees. Il s’agit d’une communaut´e g´eante.

Un autre exemple porte sur des communaut´es ayant un mˆeme label mais qui

ne sont pas reli´ees.

Figure 3.2 – Exemple d’une mauvaise propagation donnant des communaut´es avec le
mˆeme label. s7 a transmis son label `a deux structures communautaires
Op´erations de la ﬁgure 3.2 : s2 ← s7, s4 ← s7 ,s5 ← s4,s6 ← {s4, s5},
s1 ← s2, s3 ← {s2, s1}, s10 ← s9, s8 ← {s9, s10}, s9 ← {s8, s10} and s7 ←
{s8, s9, s10}.

L’id´ee est donc d’imaginer une m´ethode pour interdire ce genre de mauvaises

propagations.

3.1.1 Propagation de labels asynchrone avec barrages

La solution que nous proposons est de mettre des barrages artiﬁciels per-
mettant de stopper certaines propagations, particuli`erement sur des liens o`u le
risque de mauvaises propagations est ´elev´e, ce qui pourrait induire par la suite
la cr´eation de trop grandes communaut´es.

La propagation de labels avec barrages a pour objectif de d´etecter des com-
munaut´es, en utilisant `a la fois l’information globale topologique du graphe et
une m´ethode locale. La propagation de labels souﬀrant d’instabilit´e et du fait

90

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

de produire de trop grandes communaut´es, nous proposons une m´ethode pour
r´esoudre ces deux probl`emes en interdisant `a certaines arˆetes de propager un
label tout en eﬀectuant une d´etection de cœurs en lan¸cant plusieurs fois l’al-
gorithme non d´eterministe. Pour une raison de stabilisation (Raghavan et al.
(2007)), nous privil´egions la version asynchrone de la propagation de labels.

Les mesures issues de l’analyse des r´eseaux sociaux peuvent se r´ev´eler tr`es
utiles pour connaˆıtre l’importance de certaines arˆetes ou sommets au sein d’un
graphe. Nous proposons d’utiliser la mesure d’interm´ediarit´e de Girvan et New-
man (2002a) (pr´esent´ee au premier chapitre) qui nous permettra de placer des
barrages lors de l’ex´ecution de la propagation de labels. Ce choix vient du fait
que cette mesure permet de d´eceler des arˆetes connectant des groupes de nœuds
g´en´eralement dens´ement connect´es.

Nous proposons d’utiliser la centralit´e d’interm´ediarit´e pour mettre nos bar-
rages et ´eviter l’obtention de trop grandes communaut´es. Nous notons cet al-
gorithme, la propagation de labels avec barrages (PLAB) (Algorithme 2). La
complexit´e de la centralit´e d’interm´ediarit´e ´etant en O(n3) (Fortunato (2010)),
la complexit´e de PLAB est en O(n3 + k(m − β × m)), o`u k est le nombre
d’it´erations pour les diﬀ´erentes propagations de labels.

Algorithme 2 PLAB
Param`etres : Un graphe G = (V, E), un r´eel β (pourcentage de barrages)
Sortie : Une partition P = {P1, ..., PC} (communaut´es de G)
1: Calcul de la centralit´e d’interm´ediarit´e de G
2: S´electionner β pourcentage des arˆetes ayant les plus grandes valeurs de

centralit´e d’interm´ediarit´e et mettre des barrages

3: Lancer la propagation de labels asynchrone.
4: Retourner Une partition P = {P1, ..., PC}

Figure 3.3 – Exemples de propagation de labels avec barrages a) le graphe originel b)
mise en place d’un barrage sur l’arˆete avec la plus forte centralit´e d’interm´ediarit´e c)
lancement de la propagation de labels

Dans l’exemple de la ﬁgure 3.3, le graphe comprend 6 sommets. On calcule
dans un premier temps la centralit´e d’interm´ediarit´e des arˆetes. Un tri est alors
eﬀectu´e sur les arˆetes. Une s´election permet de prendre l’arˆete ayant la plus

3.1. LPA AVEC BARRAGES ET DENDROGRAMMES

91

grande valeur d’interm´ediarit´e. On place alors un barrage artiﬁciel qui sera uti-
lis´e lors de la propagation de labels. Ce barrage interdit `a la propagation de
s’eﬀectuer. On trouve par la suite deux communaut´es.

Notre premi`ere ´etude consiste `a appr´ecier la mise en place de barrages aﬁn
d’observer une possible am´elioration de la qualit´e par rapport `a la propagation
de labels standards. Nous proposons de faire varier le nombre de barrages sur
certains r´eseaux classiques de la litt´erature dont nous connaissons les vraies
structures communautaires, tout en calculant les mesures supervis´ees et non
supervis´ees.

En utilisant PLAB sur le r´eseau de karat´e, la Figure 3.4, l’ajout de bar-
rages n’am´eliore pas signiﬁcativement la qualit´e de partitionnement. La qualit´e
se d´et´eriore par la suite avec une augmentation du nombre de communaut´es.
Cependant, les r´esultats ne sont pas stables. On peut voir l’exemple sur le NMI,
la Figure 3.4c, la pr´esence de nombreux pics respectivement `a 20%, 40% et 60%.
Cela est dˆu `a l’instabilit´e de la d´etection de communaut´es qui ne produit que
tr`es rarement le mˆeme r´esultat d’un test `a un autre. On peut ainsi ne pas obte-
nir une d´ecroissance lin´eaire, mais avec cassures.

En consid´erant l’exemple des clubs de foot o`u les communaut´es r´epr´esentent
des conf´erences, sur la Figure 3.5, on voit que l’apport de barrages augmente
sensiblement la qualit´e de partitionnement. De 2, 5% `a 55% de barrages, les
r´esultats sont meilleurs que ceux du LPA, avec un NMI atteignant 0.93 pour
PLAB par rapport `a 0.88 pour le LPA. Des pics r´ecurrents apparaissent, signa-
lant l’instabilit´e de la m´ethode.

3.1.2 Propagation de labels asynchrone avec barrages et

d´etection de cœurs

L’algorithme PLAB pr´esente deux inconv´enients : le choix du nombre de
barrages, et l’instabilit´e r´eduite, mais toujours pr´esente. Pour rem´edier `a ces
probl`emes nous proposons deux algorithmes fond´es sur la d´etection de cœurs.
Le premier algorithme est fond´e sur l’optimisation d’une fonction de qualit´e qui
peut par exemple ˆetre la modularit´e ou la conductance. Nous eﬀectuons plu-
sieurs fois PLAB avec un certain β (le pourcentage de barrages sur les arˆetes
ayant la plus forte valeur de centralit´e d’interm´ediarit´e) pour alimenter une ma-
trice de fr´equence. Cette matrice permet de voir, pour chaque paire de nœuds
i et j, le nombre de fois qu’ils sont dans la mˆeme communaut´e au cours des N
propagations de labels. Nous recommen¸cons le proc´ed´e en changeant la valeur
de β, β variant de 0 `a 1 par un pas ∆ choisi par l’utilisateur avec une nouvelle
matrice de fr´equence de fr´equence. Pour chaque matrice de fr´equence, nous cal-
culons les composantes connexes qui repr´esentent les communaut´es et eﬀectuons
une ´evaluation avec une fonction de qualit´e et en utilisant un seuil α. Le seuil α
est un r´eel positif permettant de cr´eer un nouveau graphe `a partir d’une matrice

92

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Mesure supervis´ees

Mesure non supervis´ees

(a) La puret´e

(b) La conductance

(c) Le NMI

(d) La modularit´e

(e) ARI

(f) #

Figure 3.4 – Mesures supervis´ees et non supervis´ees avec PLAB sur le r´eseau Zachary.
# repr´esente le nombre de communaut´es. L’axe des abcisses repr´esente le pourcentage
de barrages.

de fr´equence. En faisant varier α de 0 `a 1 par un certain pas ∆, il est possible
d’obtenir un dendrogramme. Chaque matrice de fr´equence donne un dendro-
gramme en faisant varier le seuil α. Parmi tous les dendrogrammes, le r´esultat
ayant le score optimal de modularit´e ou de conductance permet de retourner une
partition. La complexit´e de l’algorithme est en O(n3 + 1
o`u k est le nombre d’it´erations pour les diﬀ´erentes propagations de labels.
Nous exposons ci-dessous la multiple propagations de labels avec barrages et
stabilisation avec optimisation d’une fonction de qualit´e (MPLBS) (Algorithme
3).

∆ × k ×N × (m− βm)),

3.1. LPA AVEC BARRAGES ET DENDROGRAMMES

93

Mesure supervis´ees

Mesure non supervis´ees

(a) La puret´e

(b) La conductance

(c) Le NMI

(d) La modularit´e

(e) ARI

(f) #

Figure 3.5 – Mesures supervis´ees et non supervis´ees avec PLAB sur le r´eseau foot-
ballistique. # repr´esente le nombre de communaut´es. L’axe des abcisses repr´esente le
pourcentage de barrages.

Nous donnons un exemple d’application sur un petit graphe de la m´ethode

MPLBS, Figure 3.6. Dans cet exemple, chaque matrice est aliment´ee par diﬀ´erentes
propagations de labels (ici 10 pour l’exemple) avec un certain pourcentage de
barrages. On commence avec un barrage en appliquant 10 propagations de labels
qui alimentent une matrice de fr´equence, puis on alimente une nouvelle matrice
de fr´equence avec deux barrages et ainsi de suite jusqu’au nombre maximal
de barrages possibles. On s’aper¸coit que plus le nombre de barrages augmente,
plus la matrice de fr´equence se transforme en matrice diagonale. L’obtention
d’une matrice diagonale signiﬁe que chaque nœud repr´esente sa propre commu-
naut´e. En utilisant un seuil α que l’on fait varier entre 0 et 1, nous pouvons
obtenir diﬀ´erents dendrogrammes selon les valeurs des ´el´ements de la matrice
de fr´equence. Nous voyons que certaines matrices de fr´equences sont identiques

94

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Algorithme 3 MPLBS
Param`etres : Un graphe G = (V, E), un seuil α, N le nombre de propagations

de labels, ∆ le pas

Sortie : communaut´es de G

1: Calcul de la centralit´e d’interm´ediarit´e de G
2: Liste P artition = []
3: Pour j = 0 `a 1 avec un pas de ∆ Faire
4: Mettre des barrages sur les j × |E| arˆetes ayant les plus grandes valeurs

5:

6:

7:

ij (j)

ij (j) en lan¸cant N fois la propagation de labels

d’interm´ediarit´e
Allouer une matrice vide P N
Alimenter la matrice P N
sur le graphe avec barrages.
Cr´eer un nouveau graphe G(cid:48) = (V, E(cid:48)) en partant de P N
arˆetes dont la pond´eration est ´egale ou sup´erieure `a α
Cr´eer une partition Pj en consid´erant les C composantes connexes.
Liste P artition.ajouter(Pj)
j = j + ∆

8:
9:
10:
11: Fin Pour
12: Retourner la partition Pk de Liste P artition avec le meilleur score de la

ij (j) avec des

fonction de qualit´e choisie par l’utilisateur : P ∗

k = {P1, ..., PC}

avec un nombre diﬀ´erent de barrages. Pour s´electionner le dendrogramme pou-
vant donner le meilleur r´esultat en termes de qualit´e de partitionnement, nous
utilisons les mesures non supervis´ees de modularit´e et de conductance.

Le second algorithme fait varier le nombre de barrages en alimentant une
seule matrice de fr´equence, puis d´etecte les composantes connexes. L’id´ee est
qu’alimenter une matrice de fr´equence par une mˆeme m´ethode, qui ne produit
pas toujours de bons r´esultats ne peut pas ˆetre satisfaisant. L’alimentation est
faite en lan¸cant la m´ethode non d´eterministe s´equentiellement un nombre N
de fois pour remplir la matrice de fr´equence, et ainsi voir les nœuds ayant une
forte probabilit´e d’ˆetre dans une mˆeme communaut´e. Cependant, alimenter une
matrice, avec diﬀ´erentes m´ethodes, ayant diﬀ´erents niveaux de barrage pourrait
am´eliorer la qualit´e des composantes connexes trouv´ees pour la d´etection de
communaut´e. L’algorithme prend en param`etre, outre le seuil α et le nombre
d’essais N , l’intervalle consid´er´e pour l’alimentation de notre matrice, ∆[x;y],
x ∈ [0, 1],y ∈ [0, 1] et x < y, avec un pas pour parcourir cet intervalle ∆.
Nous exposons ci-dessous l’algorithme de propagation de labels avec barrages
utilisant la stabilisation (PLBS) (Algorithme 4). La complexit´e de l’algorithme
est en O(n3 + k × N × (m − βm) × (y−x)
∆ ), o`u k est le nombre d’it´erations
pour les diﬀ´erentes propagations de labels. Nous exposons un exemple d’appli-
cation de la m´ethode PLBS, Figure 3.7. Dans cet exemple, une seule matrice
de fr´equence est aliment´ee par diﬀ´erentes propagations de labels avec des pour-
centages de barrages diﬀ´erents. Nous observons que nous obtenons une matrice

3.1. LPA AVEC BARRAGES ET DENDROGRAMMES

95

Figure 3.6 – Exemple de la multiple propagations de labels avec barrages et stabilisa-
tion avec optimisation d’une fonction de qualit´e

96

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

par bloc. Bien que le graphe poss`ede une structure de sym´etrie (deux triangles),
on peut observer que les valeurs des ´el´ements dans la matrice de fr´equence sont
diﬀ´erents, notamment en comparant les triangles a, b, c et d, e, f . Cela vient
du fait que lorsqu’il existe une sym´etrie, le choix pour mettre un barrage est
al´eatoire. Ainsi, il est possible que des barrages se mettent dans une structure
communautaire alors qu’une autre structure, identique, attendra plus tard pour
la mise en place de barrages en son sein. Par alimentation, les valeurs dans ces
structures sym´etriques sont diﬀ´erentes, ce qui explique que la fr´equence d’ap-
partition des nœuds e et d soit de 0.4, diﬀ´erente de la fr´equence d’apparition
au sein d’une mˆeme communaut´e des nœuds a et c, qui est de 0.3. En utilisiant
un seuil α, que l’on fait varier entre 0 et 1, un dendrogramme apparaˆıt. Nous
utilisons les mesures non supervis´ees de modularit´e et de conductance pour re-
tourner la partition selon la valeur de α.

Algorithme 4 PLBS
Param`etres : Un graphe G = (V, E), un seuil α, N le nombre de propagations

de labels, ∆ le pas, l’intervalle pour l’alimentation ∆[x;y]

Sortie : communaut´es de G

Calcul de la centralit´e d’interm´ediarit´e de G

Pour j = x `a y avec un pas ∆ Faire

2: Allocation d’une matrice de fr´equence vide
4: Mettre des barrages sur les j × |E| arˆetes ayant les plus grandes valeurs
d’interm´ediarit´e
Lancer N fois la propagation de labels avec un nombre diﬀ´erent de bar-
rages
Remplir la matrice de fr´equence avec les r´esultats des diﬀ´erentes propa-
gations de labels
j = j + ∆

6:

8: Fin Pour

Cr´eer un nouveau graphe G(cid:48) = (V, E(cid:48)) en partant de P N
dont la pond´eration est ´egale ou sup´erieure `a α
Retourner La partition P = {P1, ..., PC}.

10: Cr´eer une partition P en consid´erant les C composantes connexes.

ij avec des arˆetes

Enﬁn, nous proposons la propagation de labels avec d´etection de cœurs sans
barrage, not´ee CDLP. La complexit´e de l’algorithme est en O(N × k× (n + m)),
o`u k est le nombre d’it´erations pour les diﬀ´erentes propagations de labels. Nous
donnons un exemple de la propagation de labels avec d´etection de cœurs `a la
Figure 3.8. Dans cet exemple, une seule matrice de fr´equence est aliment´ee par
diﬀ´erentes propagations de labels. On voit que la matrice de fr´equence donne
une matrice par bloc, avec des valeurs diﬀ´erentes entre certaines paires de nœuds
permettant de voir les deux structures communautaires. En faisant varier α de
0 `a 1 pour obtenir un dendrogramme, on s’aper¸coit que des valeurs diﬀ´erentes
de α donnent parfois de mˆemes partitions. Nous utilisons les mesures non su-

3.1. LPA AVEC BARRAGES ET DENDROGRAMMES

97

Figure 3.7 – Exemple de la propagation de labels avec barrages utilisant la stabilisation

pervis´ees de modularit´e et de conductance pour retourner la partition selon la
valeur de α. L’objectif d’utiliser le CDLP dans nos futures exp´erimentations est
d’observer si des barrages peuvent donner de meilleurs r´esultats en termes de
qualit´e de partitionnement.

Algorithme 5 CDLP
Param`etres : Un graphe G = (V, E), un seuil α, N le nombre de propagations

de labels

Sortie : communaut´es de G
2: Lancer N fois la propagation de labels asynchrone.

Allocation d’une matrice de fr´equence vide

Remplir la matrice de fr´equence avec les r´esultats des diﬀ´erentes propaga-
tions de labels.

4: Cr´eer un nouveau graphe G(cid:48) = (V, E(cid:48)) en partant de P N

ij avec des arˆetes

dont la pond´eration est ´egale ou sup´erieure `a α
Cre´er une partition P en consid´erant les C composantes connexes.

6: Retourner la partition P = {P1, ..., PC}.

98

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Figure 3.8 – Exemple de la propagation de labels avec d´etection de cœurs

3.1.3 Exp´erimentations portant sur les propositions algo-
rithmiques pour la d´etection de communaut´es dis-
jointes

Nous nous proposons d’eﬀectuer notre ´etude sur des r´eseaux r´eels mod´elisant
des ph´enom`enes sociologiques, pour lesquels des experts ont ´etabli les com-
munaut´es qu’ils jugent correctes. Cependant, certains r´eseaux r´eels n’ont pas
b´en´eﬁci´e d’´etudes permettant de connaˆıtre les v´eritables partitions, c’est en ce
sens que nous n’utiliserons que les mesures non supervis´ees sur ces derni`eres.

Les r´esultats du PLBS et du MPLBS seront donn´es dans un tableau avec
un pas faible ∆ = 0, 025. La ligne des abscisses repr´esente le pourcentage de
barrages alors que l’ordonn´ee repr´esente le score avec la matrice de fr´equence
relative au nombre de barrages. Pour le PLBS, nous choisirons 3 intervalles,
∆[0.0;0.33] ; ∆[0.33;0.66] et ∆[0.66;1.0], en utilisant un pas ∆ = 0.025.

Dans la suite de cette ´etude, nous avons utilis´e une machine Predator G3,

IntelCoreT M i5 processeur 4440, 3,60 Ghz avec 16 GO de RAM. Le d´eveloppement
des algorithmes est en Python 2.7.

Stabilisation du CDLP

L’une des premi`eres ´etudes porte sur le nombre de propagations de labels

permettant de stabiliser la propagation de labels, avec le CDLP.

3.1. LPA AVEC BARRAGES ET DENDROGRAMMES

99

Figure 3.9 – Stabilisation

Figure 3.10 – Conductance

100

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Figure 3.11 – #

Nous observons que la valeur α joue un rˆole sur la stabilisation du LPA,
Figure 3.9. Pour α ≥ 0.5, on voit qu’il faut `a peu pr`es 80 it´erations pour arriver
`a stabilisation. Pour α ≥ 0.6, la stabilisation se fait apr`es 54 propagations de
labels. En consid´erant la conductance pour son information sur la densit´e intra
et inter communaut´e, Figure 3.10, plus α est important, plus la stabilisation
arrivera rapidement, avec plus de communaut´es de petites tailles, Figure 3.11.

3.1. LPA AVEC BARRAGES ET DENDROGRAMMES

101

Etude exp´erimentale sur le MLPBS

Nous avons lanc´e la propagation de labels avec barrages et d´etections de
cœurs sur des r´eseaux dont nous connaissions d’avance les vraies communaut´es,
mais aussi sur certains o`u ce n’est pas le cas. Nous avons choisi pour tous
les r´eseaux un nombre de propagations de labels pour alimenter la matrice de
fr´equence de N = 100. Le seuil permettant de cr´eer les composantes connexes `a
partir de la matrice de fr´equence se situera dans l’intervalle α ∈ [0, 3; 0, 8] avec
un pas de 0, 1

Graphe avec v´erit´e de terrains

Pour Zachary, Figure 3.12, nous observons que les r´esultats sont assez diﬀ´erents
selon les valeurs du seuil α. Pour α ≥ {0.3, ..., 0.5}, la mise en place de barrages
a une incidence sur la d´etection de communaut´es. De base, CDLP ne trouve
qu’une grande communaut´e. C’est entre 20% et 45% de barrages que la m´ethode
obtient de meilleurs r´esultats. Pour α ≥ 0, 6, on obtient un pic du NMI `a 0.78
`a 20% de barrages. Pour de tr`es fortes valeurs de α, la pr´esence des barrages
ne permet pas d’am´eliorations notables de la qualit´e de partitionnement, ce qui
est le cas pour α ≥ {0, 7; 0, 8}. Plus le nombre de barrages augmente, moins
la propagation de labels peut s’eﬀectuer. On voit que pour toutes les valeurs
de α, un forte augmentation de la conductance a lieu apr`es 40% de barrages,
avec une augmentation du nombre de communaut´es. Apr`es 60% de barrages,
on voit une convergence pour toutes les valeurs α, due au tr`es grand nombre de
barrages. Pour ce graphe, l’utilisation des barrages semble int´eressante pour de
faibles valeurs de α.

102

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Mesures supervis´ees

Mesures non supervis´ees

(a) NMI

(b) Nombre de communaut´es

(c) ARI

(d) Modularit´e

(e) Puret´e

(f) Conductance

Figure 3.12 – R´esultat de la propagation de labels avec barrages et d´etection de cœurs
sur Zachary (l’axe des ordonn´ees repr´esente les scores des mesures supervis´ees et non
supervis´ees, l’axe des abscisses repr´esente le pourcentage de barrages).

Pour le club de football, Figures 3.13b, 3.13a, 3.13f, 3.13d 3.13e et 3.13c,
la qualit´e augmente jusqu’`a 50% de barrages. La matrice de fr´equence stabilise
correctement le LPA, sans pr´esence de grands pics. Le nombre de communaut´es
n’augmente que tr`es faiblement jusqu’`a 40% et stagne jusqu’`a 50%. Les arˆetes
o`u les barrages ont ´et´e mis sont sur les liens qui lient les communaut´es entre
elles. Apr`es 55% de barrages, la qualit´e se d´et´eriore tr`es rapidement. Selon nos
observations, c’est `a partir de ce seuil que les barrages se mettent dans des
zones fortement denses, c’est-`a-dire dans des sous graphes complets, ce qui a
pour cons´equence de d´etruire les structures communautaires. La propagation
de labels ne peut plus s’eﬀectuer et la qualit´e de partitionnement se d´et´eriore.

3.1. LPA AVEC BARRAGES ET DENDROGRAMMES

103

Mesures supervis´ees

Mesures non supervis´ees

(a) NMI

(b) Nombre de communaut´es

(c) ARI

(d) Modularit´e

(e) Puret´e

(f) Conductance

Figure 3.13 – R´esultat de la propagation de labels avec barrages et d´etection de cœurs
sur le r´eseau footballistique (l’axe des ordonn´ees repr´esente les scores de mesures su-
pervis´ees et non supervis´ees, l’axe des abscisses repr´esente le pourcentage de barrages).

Pour le r´eseau de dauphins, Figures 3.14, les meilleurs r´esultats sont obtenus
pour α ≥ {0.3, 0.4}. La qualit´e se d´et´eriore apr`es α ≥ 0.6. Pour α ≥ 0.3, jusqu’`a
7.5% de barrages, aucune communaut´e n’est d´etect´ee `a 10%, deux communaut´es
sont d´etect´ees avec un NMI de 0.95. Pour de faibles valeurs de α, la mise en
place de barrages peut se r´ev´eler b´en´eﬁque et permet d’am´eliorer la qualit´e de
la d´etection de communaut´es, ce qui n’est pas le cas pour des valeurs de α tr`es
´elev´ees. Pour α ≥ 0.8, les conductances sont tr`es ´elev´ees et l’utilisation de bar-
rages devient inutile.

104

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Mesures supervis´ees

Mesures non supervis´ees

(a) NMI

(b) Nombre de communaut´es

(c) ARI

(d) Modularit´e

(e) Puret´e

(f) Conductance

Figure 3.14 – R´esultat de la propagation de labels avec barrages et d´etection de cœurs
sur le r´eseau de dauphins (l’axe des ordonn´ees repr´esente les scores de mesures super-
vis´ees et non supervis´ees, l’axe des abscisses repr´esente le pourcentage de barrages).

3.1. LPA AVEC BARRAGES ET DENDROGRAMMES

105

Pour les livres politiques de Krebs, Figures 3.15, jusqu’`a 10%, le nombre de
communaut´es reste stable avec un bon NMI et un bon ARI. Puis, ce nombre
augmente de mani`ere proportionnelle avec le nombre de barrages.

Mesures supervis´ees

Mesures non supervis´ees

(a) NMI

(b) Nombre de communaut´es

(c) ARI

(d) Modularit´e

(e) Puret´e

(f) Conductance

Figure 3.15 – R´esultat de la propagation de labels avec barrages et d´etection de cœurs
sur les livres politiques de Krebs (l’axe des ordonn´ees repr´esente les scores de me-
sures supervis´ees et non supervis´ees, l’axe des abscisses repr´esente le pourcentage de
barrages).

Les premiers r´esultats de ces exp´erimentations permettent d’aﬃrmer que la
qualit´e de partionnement avec la mise en place de barrages sera fonction de la
valeur de α. Si la valeur de α est faible ( α ≤ 0, 3 ), le graphe est consid´er´e
comme une seule communaut´e. L’algorithme se comportera comme si on enl`eve
les arˆetes ayant la plus forte centralit´e d’interm´ediarit´e. Pour une valeur de α
comprise entre 0, 3 et 0, 7, notamment pour les graphes sociaux, la mise en place

106

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

de barrages permet d’am´eliorer la qualit´e de partitionnement jusqu’`a un certain
seuil. Les observations montrent que le nombre de barrages pour une partition
de bonne qualit´e tourne autour de 25% `a 40% sur les r´eseaux sociaux. Pour
un α fort (≥ 0, 8 pour les graphes sociaux), la mise en place de barrages n’a
pas d’eﬀet signiﬁcatif sur la qualit´e de partitionnement, les communaut´es ´etant
de petites tailles. Cependant, un pourcentage trop ´elev´e de barrages d´et´eriore
la qualit´e de partitionnement car ces derniers se mettent sur des sous-graphes
complets, des cliques.

Graphe sans connaissance des communaut´es de terrains

Le r´eseau de jazz Gleiser et Danon (2003) est un graphe o`u les nœuds sont
les musiciens et les liens le fait qu’ils aient jou´e ensemble ou pas. Il comporte
198 nœuds pour 5484 arˆetes. On observe dans ce cas que α joue un rˆole im-
portant sur la stabilit´e et la qualit´e de l’algorithme. Pour α ≥ {0, 3; 0, 4}, la
modularit´e est faible avec un pic entre 15% et 20% de barrages puis `a 65%.
Un faible α ne permet pas de trouver de bonnes structure communautaires. Les
meilleurs r´esultats de la modularit´e sont atteints avec α ≥ {0, 7; 0, 8}, o`u il n’y a
pas de pr´esence de cassures. Les communaut´es ´etant de plus petites tailles, cela
diminue le risque de mauvaise propagation. Les meilleurs r´esultats sont atteints
entre 15% et 20% de barrages. On voit d’ailleurs la conductance plus ´elev´ee avec
α ≥ {0, 7; 0, 8} que pour α ≥ {0, 3; 0, 4}.

(a) Conductance

(b) #

(c) Modularit´e

Figure 3.16 – R´esultat de la propagation de labels avec barrages et d´etection de cœurs
sur le r´eseau de musiciens de jazz avec α ≥ 0, 5 (l’axe des ordonn´ees repr´esente les
scores des mesures supervis´ees et non supervis´ees, l’axe des abscisses, le pourcentage
de barrages). # d´enote le nombre de communaut´es.

3.1. LPA AVEC BARRAGES ET DENDROGRAMMES

107

Le r´eseau Netscience Newman (2006) est un graphe de collaboration dans
le domaine des r´eseaux et leurs applications. Il comprend 1589 nœuds et 2742
arˆetes. Les liens se font en utilisant la condition ” l’auteur X a ´ecrit de mani`ere
conjointe un travail avec l’auteur Y ”.

(a) Conductance

(b) #

(c) Modularit´e

Figure 3.17 – R´esultat de la propagation de labels avec barrages et d´etection de cœurs
sur le r´eseau de collaboration scientiﬁque Netscience (l’axe des ordonn´ees repr´esente
les scores des mesures supervis´ees et non supervis´ees, l’axe des abscisses le pourcentage
de barrages). # d´enote le nombre de communaut´es.

Les r´esultats sont quasi-lin´eaires en fonction du nombre de barrages. Il s’agit
d’un exemple o`u le fait de mettre des barrages n’apporte pas d’am´elioration dans
le partitionnement.

Le r´eseau US-Air 97 est un graphe repr´esentant des infrastructures pour le
transport a´erien entre le Canada, les Etats-Unis et le Mexique. Il comprend 332
nœuds et 2126 arˆetes. Les communaut´es repr´esentent des infrastructures comme
des a´eroports, et les arˆetes, leurs connexions. Cependant, elles y sont tr`es rares,
ce graphe ayant une distribution des degr´es des nœuds assez uniforme.

(a) Conductance

(b) #

(c) Modularit´e

Figure 3.18 – R´esultat de la propagation de labels avec barrages et d´etection de cœurs
sur le r´eseau de collaboration scientiﬁque Netscience avec α ≥ 0.5 (l’axe des ordonn´ees
repr´esente les scores des mesures supervis´ees et non supervis´ees, l’axe des abscisses, le
pourcentage de barrages). # d´enote le nombre de communaut´es.

L’obtention de la modularit´e maximale requiert pr`es de 80% de barrages.
Ceci s’explique par le fait que ce graphe n’a pas de v´eritables structures com-
munautaires.

108

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

De ces analyses, nous pouvons observer que des intervalles sont plus propices
`a donner de meilleurs r´esultats que d’autres, ce qui nous a amen´e `a l’´elaboration
du PLBS.

3.1. LPA AVEC BARRAGES ET DENDROGRAMMES

109

Etudes exp´erimentales portant sur le PLBS

MPLBS retournait la meilleure partition sur un intervalle, mais au prix d’une
forte complexit´e. PLBS n’utilise plus qu’une seule matrice de fr´equence, dont
l’alimentation se fait sur un intervalle sp´eciﬁque.

Algorithmes
Zac #2
∆[0.0;0.3]
∆[0.3;0.6]
∆[0.6;1.0]
Foot #11
∆[0.0;0.3]
∆[0.3;0.6]
∆[0.6;1.0]
Dauphins #2
∆[0.0;0.3]
∆[0.3;0.6]
∆[0.6;1.0]
Pol #3
∆[0.0;0.3]
∆[0.3;0.6]
∆[0.6;1.0]

Experiences portant sur PLBS

Q

Φ

NMI

ARI

Puret´e #

0.1314
0.378
0.0736

0.599
0.5844
0.3133

0.2749
0.3924
0.281

0.4961
0.4594
0.2122

0.0309
0.0728
0.5502

0.012
0.0419
0.3271

0.0684
0.4098
0.6943

0.0288
0.104
0.3129

0.2283
0.5653
0.3773

0.9108
0.9311
0.8309

0.5466
0.4558
0.3283

0.5649
0.6006
0.4344

0.0908
0.498
0.068

0.8523
0.9066
0.622

0.5968
0.2991
0.0708

0.6713
0.6684
0.1941

0.6765
0.9706

1.0

0.913
0.9565
0.9913

0.9032

1.0
1.0

0.8571
0.9333
0.9619

3
6
23

12
16
48

3
18
35

6
16
45

Tableau 3.1 – R´esultats du PLBS sur des r´eseaux connus de la litt´erature

A partir du tableau 3.1, les meilleurs r´esultats pour les r´eseaux Zac,Pol et
Foot sont en prenant l’intervalle [0.3, 0.6] (en faisant donc varier le nombre de
barrages de 30 `a 60 %.), permettant l’alimentation de la matrice de fr´equence.
Pour les dauphins, il s’agit de l’intervalle [0.0, 0.3]. Nous notons que plus les
bornes de l’intervalle ont des valeurs importantes (avec un pourcentage de bar-
rages assez fort), plus le nombre de communaut´es est important. Cela s’explique
du fait que la propagation ne peut plus s’eﬀectuer dans certaines r´egions du
graphe. Par voie de cons´equence, plus le nombre de communaut´es est important,
plus les densit´es de ces derni`eres augmentent, ce qui entraˆıne une augmentation
de la conductance. On observe que la qualit´e des communaut´es se d´egrade, avec
un NMI et un ARI tendant vers 0.

Etudes comparative entre le PLBS et CDLP

Nous proposons d’analyser le comportement du PLBS vis-`a-vis de CDLP
sur de petits graphes r´eels. L’objectif est d’observer l’impact du pourcentage de
barrages lors de l’alimentation de la matrice du PLBS sur la qualit´e de partition-
nement, d’observer la sensibilit´e des m´ethodes vis-`a-vis du seuil α (qui permet de
cr´eer le graphe seuill´e `a partir de la matrice de fr´equence) et de voir si augmenter
le nombre de propagations de labels a un impact sur les partitions r´esultantes.

110

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Nous proposons d’utiliser le PLBS aliment´e par 10%, 20% puis par 30% de
barrages avec comme fonction supervis´ee le NMI, et avec N = 100, N = 500
puis N = 1000. Les Figures 3.19,3.20,3.21 et 3.22 montrent les r´esultats res-
pectivement sur Zachary, les dauphins, le r´eseau footballistique et le r´eseau de
livres politiques vis-`a-vis du seuil α qui permet de cr´eer le graphe seuill´e pour
la d´etection des communaut´es.

Figure 3.19 – Etude comparative entre PLBS et CDLP sur Zachary

Figure 3.20 – Etude comparative entre PLBS et CDLP sur les dauphins

Figure 3.21 – Etude comparative entre PLBS et CDLP sur le r´eseau footballistique

Figure 3.22 – Etude comparative entre PLBS et CDLP sur le r´eseau de livres politiques

3.1. LPA AVEC BARRAGES ET DENDROGRAMMES

111

D’apr`es les exp´erimentations, PLBS est plus sensible aux valeurs de α que ne
l’est CDLP. En eﬀet, les premi`eres communaut´es d´etect´ees pour le PLBS sont
`a partir de α ≥ 0.2 pour Zachary avec 30% de barrages alors que les premi`eres
communaut´es avec CDLP ne sont d´etect´ees qu’`a partir de α ≥ 0.4. Pour les
livres politiques, c’est `a partir de α ≥ 0.20 que les premi`eres communaut´es sont
d´etect´ees avec PLBS et α ≥ 0.38 pour CDLP. De mˆeme, pour le r´eseau de
dauphins, avec α ≥ 0.22 PLBS d´etecte ses premi`eres communaut´es alors que
CDLP d´etecte les siennes `a partir de α ≥ 0.40. Les communaut´es sont d´etect´ees
plus vite avec un fort pourcentage de barrage (30%).
Augmenter N ne stabilise pas davantage le PBLS. Pour le r´eseau de dau-
phins, augmenter N stabilise plus le CDLP o`u des ﬂuctuations avec N = 100
apparaissent `a α = 0.45 etα ≥ 0.58, que l’on ne voit plus pour N = 500 et
N = 1000. CDLP montre des r´esultats parfois meilleurs que PBLS notamment
pour Zachary, mais sur des intervalles tr`es petits. PBLS donne en moyenne de
meilleurs r´esultats que CDLP. Alimenter les matrices de 10% `a 30% de barrages
donne des r´esultats tr`es similaires pour PLBS pour ces types de r´eseaux.

Visualisation des matrices PLBS et CDLP

Dans cette section, nous nous focalisons sur l’alimentation des matrices de
fr´equence, mais ´egalement sur l’ajout de barrages pour l’alimentation de la ma-
trice du PLBS.

Pour le CDLP, nous lan¸cons s´equentiellement N propagations de labels,
ind´ependantes les unes des autres. A chaque propagation de label, les ´el´ements
de la matrice de fr´equence sont incr´ement´es de 1. Lorsque toutes les propaga-
tions de labels ont ´et´e eﬀectu´ees, il y a normalisation en divisant chaque ´el´ement
par N . Pour PLBS, nous verrons que la mise en place de barrages va modiﬁer
signiﬁcativement la matrice de fr´equence. L’id´ee est ´egalement d’observer si des
zones, avec un pourcentage fort de barrages, apparaissent. Nous exposons le
CDLP et le PLBS avec diﬀ´erents pourcentages de barrages sur le graphe de Ka-
rat´e Figure 3.23, sur celui des dauphins Figure 3.24, sur le r´eseau footballistique
3.25, sur le r´eseau de livres politiques 3.26 et sur le r´eseau de jazz 3.27.

112

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Figure 3.23 – Matrices du PLBS et du CDLP sur Zachary

3.1. LPA AVEC BARRAGES ET DENDROGRAMMES

113

Figure 3.24 – Matrices du PLBS et du CDLP sur le r´eseau de dauphins

114

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Figure 3.25 – Matrices du PLBS et du CDLP sur le r´eseau footballistique

3.1. LPA AVEC BARRAGES ET DENDROGRAMMES

115

Figure 3.26 – Matrices du PLBS et du CDLP sur les livres politiques

116

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Figure 3.27 – Matrices du PLBS et du CDLP sur le r´eseau de jazz

Les matrices r´esultantes sont des matrices par bloc comme nous pouvons le
voir pour le club de Karat´e, les dauphins et les livres politiques. En observant les
matrices de CDLP, nous pouvons voir des groupes de nœuds qui ont une forte
probablit´e d’ˆetre ensemble. Par exemple, en observant la matrice du club de
Karat´e, nous voyons de petites matrice rouges, qui pour le PBLS, en augmentant
les barrages, restent pr´esentes. Ces liens qui ont une forte valeur sont signiﬁcatifs
de la pr´esence de cœurs. C’est par exemple le cas pour le r´eseau footballistique

3.1. LPA AVEC BARRAGES ET DENDROGRAMMES

117

o`u les points rouges, sont les paires de nœuds se trouvant tr`es fr´equemment dans
les mˆemes communaut´es.

En augmentant le pourcentage de barrages, les matrices deviennent presque

diagonales, ce qui est le cas sur tous nos exemples.

Etude sur le temps d’ex´ecution

L’algorithme est compos´e de plusieurs parties dont les temps d’ex´ecution
sont diﬀ´erents les uns des autres. Nous rappelons que nous avons utilis´e une
machine Predator G3, IntelCoreT M i5 processeur 4440, 3,60 Ghz avec 16 GO
de RAM. Le d´eveloppement des algorithmes est en Python 2.7.

Le temps d’ex´ecution du PLBS n´ecessite 3 ´etapes :
— le temps de calcul de la centralit´e d’interm´ediarit´e (∆CI )
— le temps pour mettre les barrages, l’allocation d’une matrice de fr´equence
et son alimentation par les diﬀ´erentes propagations de labels (∆matriceLP A)
— le temps pour la d´etection de composantes connexes correspondant `a nos

communaut´es (∆CC)

Cela peut se sch´ematiser par la formule suivante :

∆TP LBS = ∆CI + ∆matriceLP A + ∆CC

(3.1)

Les parties de lecture et d’´ecriture n’ont pas ´et´e mises dans la mesure o`u elles ne
consid`erent pas le corps de l’algorithme. Nous obtenons les r´esultats suivants :
Pour l’algorithme PLBS, nous prenons N = 100, un intervalle de ∆[x,y] =

∆[0.0,0.3] avec un pas ∆ = 0.025.

Temps d’ex´ecution en secondes

R´eseau
Zac
Dauphins
Pol
Foot
Jazz
US-Air 97
Netscience

|V | et |E|
34 \ 78
62 \ 159
105 \ 441
115 \ 615
198 \ 5484
332 \ 2126
1589 \ 2742

∆CI
0.0004
0.002
0.008
0.010
0.125
0.095
0.061

∆M atrice(LP A) ∆CC ∆TP LBS
0.284
0.608
4.382
4.6

0.280
0.587
4.158
4.309
15.432
16.935
91.72

0.003
0.019
0.217
0.276
0.077
0.226
1.218

15.634
17.256
93.098

Tableau 3.2 – R´esultats sur le temps d’´execution du PLBS

Nous observons que la partie prenant le plus de temps concerne l’alimenta-
tion de la matrice par les N propagations de labels. Pour Netscience, le temps
commence `a devenir cons´equent avec pr`es de 93.1 secondes. Le calcul de la cen-
tralit´e d’interm´ediarit´e est assez rapide sur Igraph, bien que sa complexit´e soit
´elev´ee.

MPLBS utilise quant `a elle K matrices diﬀ´erentes avec diﬀ´erents niveaux de

barrages. Le temps d’ex´ecution du MPLBS comprend 4 ´etapes :

118

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

— le temps de calcul de la centralit´e d’interm´ediarit´e (∆CI )
— le temps pour mettre les barrages, l’allocation des K matrices de fr´equence
et leur alimentation par les diﬀ´erentes propagation de labels (∆matriceLP A)
— le temps pour la d´etection de composantes connexes correspondant `a nos

communaut´es (∆CC)

— le temps de calcul de la fonction de qualit´e choisie, la modularit´e ∆Q ou
Pour l’algorithme MPLBS, nous prenons un intervalle ∆ = 0.025 et N = 100.

la conductance ∆Φ

Le temps d’ex´ecution peut se sch´ematiser par la formule suivante :

∆TM P LBS = ∆CI + ∆matriceLP A + ∆CC

(3.2)

Pour le calcul du temps global, nous sommerons le temps de calcul de la

modularit´e et celui de la conductance.

R´eseau
Zac
Dauphins
Pol
Foot
Jazz
US-Air 97
Netscience

∆CI
0.0005
0.084
0.018
0.022
0.147
0.095
0.061

Temps d’ex´ecution en secondes

∆M atrice(LP A)

∆Q

|V | et |E|
34 \ 78
62 \ 159
105 \ 441
115 \ 615
198 \ 5484
332 \ 2126
1589 \ 2742

0.0005
0.0005
0.0007
0.0009
0.0011
2.631
0.007
Tableau 3.3 – R´esultats sur le temps d’ex´ecution du MPLBS

0.642
1.711
4.355
3.614
21.676
98.381
376.167

∆CC
0.0006
0.001
0.002
0.002
0.006
0.042
0.02

∆Φ
0.068
0.002
0.002
0.958
0.639
0.484
73.981

∆TM P LBS

0.712

1.8

4.378
4.597
22.47

101.632
450.236

En observant les Tableaux 3.2 et 3.3, nous voyons que le temps d’ex´ecution
du MPLBS est beaucoup plus important que celui du PLBS. Cela vient du
fait qu’il y a 1
∆ matrices de fr´equence `a alimenter, d’apr`es les notations de
l’Algorithme 3. C’est ´egalement cette alimentation qui prend le plus de temps
par rapport aux autres traitements, qui prennent beaucoup moins de temps.
Le temps de calcul de la conductance et de la modularit´e ainsi que le temps
de calcul des composantes connexes sont tr`es faibles. La taille de la matrice `a
alimenter est fonction de la taille du graphe consid´er´e. Plus le graphe aura de
nœuds, plus le temps d’alimentation sera important. Une ´etude comparative
avec les algorithmes de d´etection de communaut´es issus de la litt´erature pourra
ˆetre trouv´ee `a la sous-section 3.3.

Etude de la corr´elation entre la centralit´e d’int´erm´ediarit´e et la ma-
trice de fr´equence du CDLP

Les ´etudes pr´ec´edentes ont montr´e que l’ajout de barrage en utilisant l’infor-
mation de la centralit´e d’interm´ediarit´e pouvait dans certains cas am´eliorer la
qualit´e de partitionnement. Cependant, la question est de savoir si mettre des
barrages sur les liens de forte centralit´e d’interm´ediarit´e ne serait pas ´equivalent
`a mettre des barrages en fonction des valeurs des ´el´ements de la matrice de

3.1. LPA AVEC BARRAGES ET DENDROGRAMMES

119

fr´equence, c’est`a-dire des ´el´ements ayant une faible probabilit´e d’ˆetre ensemble.
Pour r´epondre `a cette question, nous ´etudions exp´erimentalement la corr´elation
entre les valeurs de la matrice de fr´equence pij et la centralit´e d’interm´ediarit´e
fond´ee sur les arˆetes. Nous faisons diﬀ´erents tests avec un nombre de propaga-
tions de labels diﬀ´erent pour voir si cela peut avoir une inﬂuence sur le r´esultat,
notamment avec N = 100, N = 500 et N = 1000.

Figure 3.28 – Etude de la corr´elation entre la centralit´e d’interm´ediarit´e et les ´el´ements
de la matrice de fr´equence sur Zachary

Figure 3.29 – Etude de la corr´elation entre la centralit´e d’interm´ediarit´e et les ´el´ements
de la matrice de fr´equence sur le r´eseau de dauphins

Figure 3.30 – Etude de la corr´elation entre la centralit´e d’interm´ediarit´e et les ´el´ements
de la matrice de fr´equence sur le r´eseau footballistique

120

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Figure 3.31 – Etude de la corr´elation entre la centralit´e d’interm´ediarit´e et les ´el´ements
de la matrice de fr´equence sur le r´eseau de livres politique

Figure 3.32 – Etude de la corr´elation entre la centralit´e d’interm´ediarit´e et les ´el´ements
de la matrice de fr´equence sur le r´eseau de jazz

Figure 3.33 – Etude de la corr´elation entre la centralit´e d’interm´ediarit´e et les ´el´ements
de la matrice de fr´equence sur le r´eseau de collaboration scientiﬁque

R´eseaux
Zachary
Dauphins
Foot
Livres politiques
Jazz
Netscience

N = 100 N = 500 N = 1000
−0.592
−0.573
−0.226
−0.216
−0.756
−0.761
−0.570
−0.571
−0.189
−0.186
−0.170
−0.176

−0.592
−0.229
−0.762
−0.575
−0.189
−0.197

Tableau 3.4 – Coeﬃcient de Pearson entre la centralit´e d’interm´ediarit´e et les ´el´ements
de la matrice de fr´equence.

3.1. LPA AVEC BARRAGES ET DENDROGRAMMES

121

Les ﬁgures ci-dessus et le Tableau 3.4 montrent le degr´e de corr´elation entre
la centralit´e d’interm´ediarit´e et les ´el´ements de la matrice de fr´equence du CDLP,
soit les pij. Nous aurions pu nous attendre `a ce que les liens ayant une forte cen-
tralit´e d’interm´ediarit´e soient des arˆetes avec un faible pij, c’est-`a-dire dont les
sommets auraient une faible probabilit´e d’ˆetre dans une mˆeme communaut´e et
inversement. Cependant, les coeﬃcients de Pearson montrent qu’il y a une faible
anti-corr´elation (parfois mˆeme qu’il n’y a pas de corr´elation du tout comme pour
Netscience avec −0.170) entre les deux s´eries de mesures. De plus le Tableau 3.4
montre que le fait d’augmenter le nombre de propagations de labels pour stabi-
liser la m´ethode n’am´eliore pas la corr´elation entre les deux s´eries de mesures.

3.1.4 Conclusion sur les algorithmes de propagation de

labels avec barrages et d´etection de cœurs

Nous avons expos´e de nouveaux algorithmes fond´es sur la propagation de
labels. Nos exp´erimentations ont montr´e que notre m´ethode hybride, liant pro-
pagation de labels et barrages issus de l’interm´ediarit´e des arˆetes permettait
l’obtention de r´esultats satisfaisants.

Le choix du seuil α d´epend de la topologique du graphe consid´er´e. Pour nos
exemples, et ce qui concerne le CDLP, un α faible ne permet pas de d´etecter
de communaut´es. Ainsi c’est pour Zachary, c’est avec α ≥ 0.5 que les premi`eres
communaut´es sont d´etect´ees, il en est de mˆeme pour le r´eseau de dauphins et le
r´eseau de livres politiques. Pour le r´eseau footballistique et le r´eseau de collabo-
ration scientiﬁque, les premi`eres communaut´es sont d´etect´ees avec α ≥ 0.3. Plus
le seuil α augmente, plus le nombre de LPA n´ecessaires est faible. Sur le club
de karat´e, il faut `a peu pr`es une soixantaine de LPA pour rendre la m´ethode
d´eterministe et seulement une vingtaine avec α ≥ 0.8. Ce constat peut ˆetre
r´ealis´e pour tous les r´eseaux que nous avons ´etudi´es.

Concernant le PLBS, l’ajout de barrages stabilise davantage l’algorithme
que le CDLP. En mettant des barrages sur les liens, certaines propagations
de labels ne peuvent plus s’eﬀectuer. En augmentant le nombre de barrages `a
l’alimentation du PLBS, la matrice de fr´equence se rapproche d’une matrice
diagonale. Nous avons observ´e qu’avec un pourcentage de barrages assez fort,
(60%,70%,80% et 90%) des paires de nœuds apparaissent, ce qui montre la
pr´esence de cœurs. Ce constat peut ˆetre r´ealis´e pour tous les r´eseaux que nous
avons ´etudi´es.

L’ajout de barrages permet de d´etecter plus rapidement les communaut´es,
c’est-`a-dire avec un seuil α plus faible, par exemple, pour le club de karat´e,
En eﬀet, les premi`eres communaut´es d´etect´ees pour PLBS le sont `a partir de
α ≥ 0.2 pour Zachary avec 30% de barrages alors que les premi`eres commu-
naut´es avec CDLP ne sont d´etect´ees qu’`a partir de α ≥ 0.5. Sur l’ensemble du
spectre du seuil α PLBS donne de meilleurs r´esultats que CDLP en termes de

122

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

qualit´e de partitionnement.

Nous avons men´e une ´etude exp´erimentale qui a montr´e qu’il n’y avait pas de
fortes corr´elations entre la centralit´e d’interm´ediarit´e des arˆetes et les valeurs de
la matrice de fr´equence du CDLP. Par exemple, le coeﬃcient de Pearson entre
les s´eries de mesures pour le r´eseau de dauphins n’est que de −0.216.

Les algorithmes MPLBS, PLBS et CDLP sont d´eterministes par rapport `a
des algorithmes tels que Louvain ou le LPA. Cependant, un crit`ere de partition-
nement est n´ecessaire pour couper le dendrogramme, c’est en ce sens que des
mesures non supervis´ees comme la modularit´e sont utilis´ees. En utilisant comme
crit`ere de partionnement la modularit´e, nous verrons dans la section portant sur
l’analyse comparative 3.3, que nos m´ethodes donnent de meilleurs r´esultats en
termes de qualit´e de partitionnement que le LPA. Cependant, leur complexit´e
est plus ´elev´ee.

Au chapitre 4, nous proposons une version parall`ele et distribu´ee du CDLP

pour travailler sur les grands graphes ayant plusieurs millions d’arˆetes.

3.2. LPA AVEC COLORATION

123

3.2 Propagation de labels avec d´etection de cœurs,

ordre et coloration pour la d´etection de com-
munaut´es disjointes

Nous avons utilis´e dans la section pr´ec´edente la notion de barrages en uti-
lisant la centralit´e d’interm´ediarit´e fond´ee sur les arˆetes. Bien que permettant
de meilleurs r´esultats que le LPA, la complexit´e algorithmique pour le calcul de
la centralit´e d’interm´ediarit´e est de O(n3) (et peut ˆetre r´eduite en O(nm) par
approximation). Nous nous proposons d’observer le comportement de la propa-
gation de labels avec cœurs en utilisant un ordre de visite fond´e sur certaines
mesures sociales. L’objectif est d’´etudier `a la fois la stabilit´e de l’algorithme et
la qualit´e par rapport aux versions pr´ec´edemment propos´ees.

Nous avons vu au chapitre 1 que la propagation de labels avait ´et´e mod´elis´ee
en utilisant la coloration dans un but de parall´elisation, nomm´ee la propagation
de labels semi-synchrone. Ainsi, des groupes de nœuds connect´es ayant la mˆeme
coloration peuvent faire la mise `a jour de leurs labels alors que d’autres sont dans
un ´etat d’attente (ou en ”pause”). En it´erant sur toutes les couleurs, une pro-
pagation de label globale a lieu. L’id´ee est de r´eutiliser le concept de coloration
mais pour eﬀectuer une mise `a jour des labels des nœuds en fonction de leurs
structures sociales et topologiques au sein du r´eseau. En introduisant un ordre
fond´e sur la topologie des groupes de nœuds d’une coloration, la propagation de
label pourra ainsi ˆetre eﬀectu´ee. Il s’agit d’une proposition algorithmique dans
un but exp´erimental, aﬁn de savoir si l’ordre peut jouer sur la stabilit´e et sur la
qualit´e de la d´etection de communaut´es.

3.2.1 Propagation de labels asynchrone avec d´etection de

cœurs et coloration

En eﬀectuant une coloration du graphe G = (V, E), nous obtenons une parti-
tion D = {D1, D2, ..., Dl} (de l parties). L’id´ee est de trier ces groupes de nœuds
non connect´es en fonction de leurs caract´eristiques topologiques. C’est alors
qu’un ordre de visite permet de mettre `a jour les labels des nœuds d’une cer-
taine couleur de mani`ere croissante ou d´ecroissante selon les valeurs des r´esultats
des mesures sociologiques utilis´ees.

Nous consid´erons comme ordre :
— la centralit´e de degr´es
— l’al´eatoire

En consid´erant l’exemple suivant, on peut s’apercevoir que l’ordre fond´e sur
la coloration permet de r´eduire le nombre de propagations de labels et de gagner

124

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

en temps de calcul.

Figure 3.34 – Exemple de propagation de label semi-sychrone fond´e sur l’ordre de
visite

En appliquant un algorithme de coloration, nous obtenons les deux groupes
de nœuds D1 = {s1} et D2 = {s2, s3, s4, s5, s6, s7}. Le degr´e moyen des nœuds de
D1 (ici juste du nœud s1) est de 6 alors que le degr´e moyen du groupe D2 est de
1. Notons par σ, la matrice qui repr´esente l’ordre de visite pour la propagation
de labels, o`u les ´el´ements de la ieme colonne repr´esentent en premi`ere ligne
le num´ero de visite du nœud dont l’identiﬁant est en seconde ligne (si). En
commen¸cant par la mise `a jour des labels des nœuds ´etant dans le groupe dont
la centralit´e est la plus faible, nous obtenons l’ordre et la propagation de labels
suivants :

(cid:19)

(cid:18) 1

s2

σ =

2
s4

3
s5

4
s6

5
s7

6
s3

7
s1

s2 ← s1, s4 ← s1 ,s5 ← s1, s6 ← s1, s7 ← s1, s3 ← s1, s1 ← {s2, s3, s4, s5, s6, s7}

Une seule it´eration de propagation de labels suﬃt pour que tous les nœuds
aient le mˆeme label. En ayant consid´er´e l’ordre commen¸cant par D1 et ensuite
D2, nous aurions dˆu avoir plusieurs it´erations de la propagation de label pour
obtenir le mˆeme label pour tous les nœuds.

La complexit´e de l’algorithme dans le pire cas est en O(n × N × k × (m) +
n2 + n + m), o`u k est le nombre d’it´erations de propagations de labels et m le
nombre d’arˆetes du graphe.

Dans le cadre de l’Algorithme 6, nous proposons de mettre `a jour les labels
des nœuds en commen¸cant par les groupes de nœuds de mˆeme couleur ayant
la centralit´e la plus faible (POP-UP), cela de mani`ere croissante. Nous pro-
posons ´egalement une seconde version, qui consiste `a commencer de mani`ere
d´ecroissante, des groupes de nœuds ayant la centralit´e la plus ´elev´ee vers ceux
ayant la centralit´e la moins forte (POP-DOWN). Le cas o`u l’ordre est al´eatoire
sera not´e R-POP (R pour random). De ces trois derni`eres propositions, il est
possible, en faisant ﬂuctuer la valeur de α, d’obtenir des dendrogrammes. La
question est de savoir si elles sont fonci`erement diﬀ´erentes, tant en termes de
niveaux qu’en termes de partition.

3.2. LPA AVEC COLORATION

125

Algorithme 6 La propagation de label semi-synchrone avec ordre pr´ef´erentiel
(POP)
Input : Un graphe G = (V, E), un seuil α, N le nombre de propagations de

labels, une mesure sociale M fond´ee sur les nœuds

Output : Les communaut´es trouv´ees par l’algorithme sur le graphe G = (V, E)
1: Eﬀectuer une coloration du graphe G, D = {D1, D2, ..., Dl} (de l parties)
2: Allouer une matrice de fr´equence vide P N
3: Pour chaque groupe de nœuds d’une mˆeme couleur Di, calculer la mesure
moyenne de la mesure sociale M, puis trier les groupes de nœuds suivant
les r´esultats de mani`ere croissante ou d´ecroissante pour cr´eer un ordre de
visite σ.
4: Appliquer N fois la propagation de labels semi-synchrone en utilisant l’ordre
pr´ef´erentiel σ et remplir la matrice P N

ij

ij

poids sup´erieur ou ´egal `a α

5: Cr´eer un nouveau graphe G(cid:48) = (V, E(cid:48)) issu de P N
ij dont les arˆetes ont un
6: Cr´eer une partition P en consid´erant les C composantes connexes comme
7: Retourner la partition P = {P1, ..., PC}.

cœurs

3.2.2 Exp´erimentation sur R-POP, POP-UP et POP-DOWN

Dans cette partie exp´erimentale, nous souhaitons :

1. savoir si l’ordre de visite fond´e sur la centralit´e moyenne des groupes de
nœuds ayant la mˆeme couleur am´eliorera la qualit´e des communaut´es
d´etect´ees

2. connaˆıtre le nombre N de propagations de labels semi-synchrones `a lancer

pour stabiliser le processus de d´etection de communaut´es

3. savoir s’il existe un seuil pour lequel la valeur α n’est plus sujette `a l’ordre

de visite

4. savoir si l’ordre de visite a une cons´equence sur la taille des dendro-

grammes cr´e´es

Dans la suite des exp´erimentations, nous notons par Ix le fait que les pro-

pagations de labels ont ´et´e it´er´ees x fois.

Etude sur la stabilisation de la propagation de label semi-synchrone

Les exp´erimentations port´ees sur trois r´eseaux montrent que l’ordre joue un

rˆole sur la stabilisation de la propagation de labels.

126

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Figure 3.35 – Stabilit´e de la propagation de labels semi-sychrone fond´ee sur l’ordre de
visite sur Zachary

Figure 3.36 – Stabilit´e de la propagation de labels semi-sychrone fond´ee sur l’ordre de
visite sur les dauphins

3.2. LPA AVEC COLORATION

127

Figure 3.37 – Stabilit´e de la propagation de labels semi-sychrone fond´ee sur l’ordre de
visite sur les livres politiques

En comparant la stabilisation du CDLP et des algorithmes `a base de co-
loration, Figures 3.9, 3.35,3.36 et 3.37, on observe que les m´ethodes `a base de
coloration n´ecessitent moins de LPA pour arriver `a stabilisation de l’algorithme
pour des α ≤ 0.8. Nous observons que l’ordre joue un rˆole ´egalement sur la
stabilit´e de l’algorithme.

Pour Zachary, Figure 3.35, avec α ≤ 0, 5, R-POP ne d´etecte pas de commu-
naut´e alors que CDLP en d´etecte 2. Pour les algorithmes `a base de coloration,
il faut une vingtaine de LPA pour arriver `a stabilisation. α a une incidence plus
forte sur les algorithmes sans coloration que sur ceux avec.

Pour les dauphins, Figure 3.36, l’ordre a un rˆole plus marqu´e sur le nombre de
LPA n´ecessaires `a la stabilisation. POP-UP n´ecessite entre 45 et 50 LPA contre
une vingtaine pour POP-DOWN et POP-UP. Pour α ≥ {0.3; 0.4} R-POP ne
trouve pas de communaut´es. CDLP est plus sensible `a α que les m´ethodes `a
base de coloration.

Pour les livres politiques, Figure 3.37, CDLP ne trouve pas de communaut´e
pour α ≥ {0.3; 0.4} alors que les autres m´ethodes d´etectent de petits groupes
de nœuds d`es α ≥ 0.3 qui correspondent aux livres neutres sur le plan politique.
POP-DOWN est l’algorithme n´ecessitant le moins de LPA pour arriver `a stabi-
lisation.

Etude exp´erimentale sur des r´eseaux r´eels avec connaissance des com-
munaut´es de terrains

Le Club de Karat´e de Zachary

128

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Coloration de graphe sur Zachary

Couleurs
C1
C2
C3
C4
C5
C6

distribution

38.235 %
26.47 %
20.588 %
5.882 %
5.882 %
2.941 %

¯d

7.383
3.889
4.286

9.0
4.5
17.0

V ar
39.172
4.543
7.061

9.0
0.25
0.0

Tableau 3.5 – Distribution des tailles pour chaque groupe de nœuds ayant la mˆeme
couleur Ci, ¯d repr´esente le degr´e moyen du groupe de nœuds ayant la couleur Ci et
V ar repr´esente la variance concernant le degr´e des nœuds au sein d’une mˆeme couleur.

R-POP sur Zachary (I5 ey N = 100)
α ≥ 0.5

α ≥ 0.6
0.133
0.001
0.206
0.072
0.647

Modularit´e
Conductance
NMI
ARI
Puret´e
#
Tableau 3.6 – Mesures supervis´ees et non supervis´ees avec R-POP

0.0
0.0
0.0
0.0
0.5
1

2

5

α ≥ 0.7
0.399
0.032
0.649
0.63
0.97

4

α ≥ 0.8
0.376
0.061
0.615
0.593
0.97

5

α ≥ 0.9
0.376
0.061
0.615
0.593
0.97

α ≥ 0.5
0.37

POP-UP sur Zachary (I5 et N = 100) OK
α ≥ 0.8
0.376
0.032
0.653
0.648
0.97

α ≥ 0.7
0.399
0.002
0.691
0.684
0.97

α ≥ 0.6
0.399
0.0023
0.691
0.684
0.97

0.0004
0.837
0.882
0.97

2

3

3

4

Modularit´e
Conductance
NMI
ARI
Puret´e
#

α ≥ 0.9
0.392
0.035
0.571
0.472
0.97

5

Tableau 3.7 – Mesures supervis´ees et non supervis´ees avec POP-UP

POP-DOWN sur Zachary (I5 et N = 100) OK
α ≥ 0.8
0.402
0.002
0.568
0.59
0.941

α ≥ 0.6
0.402
0.002
0.568
0.59
0.941

α ≥ 0.5
0.372
0.0004
0.677
0.772
0.941

α ≥ 0.7
0.402
0.002
0.568
0.59
0.941

2

3

3

3

Modularity
Conductance
NMI
ARI
Puret´e
#

α ≥ 0.9
0.376
0.061
0.615
0.593
0.97

5

Tableau 3.8 – Mesures supervis´ees et non supervis´ees avec POP-DOWN

3.2. LPA AVEC COLORATION

129

Sur la ﬁgure 3.38, nous exposons les r´esultats de R-POP, POP-UP et POP-
DOWN en lan¸cant 100 propagations de labels (N = 100). Les nœuds 0 et
33 repr´esentent respectivement le manager et l’entraˆıneur qui se sont fˆach´es.
D’apr`es les Tableaux 3.7, 3.6 et 3.8, et leurs repr´esentations sur les Figures
3.41, 3.39 et 3.40 avec la visualisation sur la ﬁgure 3.38, nous obtenons 6 ni-
veaux pour le dendrogramme avec R-POP et 5 niveaux pour POP-UP et POP-
DOWN. POP-UP a un NMI de 0.837 pour α ≥ 0.5 et produit les meilleurs
r´esultats alors que POP-DOWN produit les moins bons. POP-UP et POP-
DOWN trouvent bien les deux communaut´es pour α ≥ 0.5 alors que R-POP
ne trouve qu’une seule grande communaut´e. Pour α ≥ 0.6 R-POP trouve une
petite communaut´e reli´ee au manager, alors que 3 communaut´es sont d´etect´ees
par les autres m´ethodes. Pour R-POP et POP-DOWN, les meilleurs r´esultats
sont obtenus pour α ≥ 0.7. Pour α ≥ 0.8, POP-DOWN conserve une conduc-
tance assez faible alors qu’elle devient importante pour R-POP et POP-UP. Au
niveau du nombre de communaut´es, nous obtenons un nombre tr`es semblable
pour toutes les m´ethodes. Les changements se font vis-`a-vis de nœuds particu-
liers souvent consid´er´es comme chevauchants dans litt´erature. On note que le
nœud ”9”, qui est souvent consid´er´e comme appartenant `a deux communaut´es
est d´etect´e seul avec R-POP, alors qu’avec POP-UP, il rejoint la plus grande
communaut´e et avec POP-DOWN, la plus petite.

130

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Figure 3.38 – Dendrogramme (Etude visuelle) sur Zachary, a) R-POP b) POP-UP c)
POP-DOWN d)les valeurs de α (sup´erieur strictement)

Figure 3.39 – Dendrogramme avec R-POP sur Zachary

3.2. LPA AVEC COLORATION

131

Figure 3.40 – Dendrogramme avec POP-UP sur Zachary

Figure 3.41 – Dendrogramme avec POP-DOWN sur Zachary

distribution

Coloration de graphe sur les dauphins
Var
4.289
7.979
6.321
4.531

4.884
4.857
5.889
7.571

¯d

8.0
8.0
10.0

3.5
1.0
0.0

Couleurs
C1
C2
C3
C4
C5
C6
C7

40.322 %
22.58 %
14.516 %
11.29 %
6.452 %
3.226 %
1.613 %

Tableau 3.9 – Distribution des tailles pour chaque groupe de nœuds ayant la mˆeme
couleur Ci, ¯d repr´esente le degr´e moyen du groupe de nœud ayant la couleur Ci

et V ar repr´esente la variance concernant le degr´e des nœuds au sein d’une mˆeme

couleur.

R-POP sur les Dauphins (I5 and N = 100)
α ≥ 0.8
0.492
0.07

Modularit´e
Conductance
NMI
ARI
Puret´e
#
Tableau 3.10 – Mesures supervis´ees et non supervis´ees avec R-POP

α ≥ 0.5
0.478
0.0004
0.756
0.63
1.0
3

α ≥ 0.7
0.498
0.0503
0.604
0.443

α ≥ 0.6
0.51
0.018
0.638
0.469

0.5555
0.386

1.0
9

α ≥ 0.9
0.461
0.082
0.476
0.272

1.0
12

1.0
5

1.0
7

Nous obtenons 7 couleurs 3.9. la distribution n’est pas uniforme, avec les

132

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

α ≥ 0.5
0.48

POP-UP sur les dauphins (I5 and N = 100)
α ≥ 0.8
0.483
0.071
0.506
0.295

α ≥ 0.6
0.5202
0.0013
0.585

0.43250

α ≥ 0.7
0.52
0.001
0.5852
0.4325
0.984

0.0004
0.676
0.58
0.984

3

Modularit´e
Conductance
NMI
ARI
Puret´e
#

0.984

4

4

1.0
10

α ≥ 0.9
0.461
0.082
0.476
0.272

1.0
12

Tableau 3.11 – Mesures supervis´ees et non supervis´ees avec POP-UP

POP-DOWN sur les dauphins (I5 and N = 100)

α ≥ {0.3, 0.4, 0.5}

Modularit´e
Conductance
NMI
ARI
Puret´e
#

0.373

6.2*e-05

1.0
1.0
1.0
2

α ≥ 0.6
0.5196
0.001
0.652
0.465

α ≥ 0.7
0.515
0.0208
0.594
0.412

1.0
4

1.0
6

α ≥ 0.8
0.505
0.0372
0.582
0.408

1.0
7

Tableau 3.12 – Mesures supervis´ees et non supervis´ees avec POP-DOWN

deux couleurs les plus importantes repr´esentant `a elles seules 62.902 % de la
population totale (en termes de nœuds). D’apr`es les r´esultats des tableaux 3.10,
3.11 et 3.12, le dendrogramme de R-POP poss`ede 6 niveaux, comme pour POP-
DOWN. POP-DOWN trouve parfaitement les deux communaut´es avec un NMI
de 1.0 avec de faibles valeurs de α ( {0.3; 0.2}). Pour POP-UP, nous obtenons
5 niveaux. En termes de qualit´e, c’est POP-DOWN qui produit les meilleurs
r´esultats et qui est persistant par rapport `a α. La qualit´e se d´et´eriore plus ra-
pidement avec POP-UP et R-POP lorsque α augmente.

Le r´eseau footballistique de Newman

¯d

distribution

Coloration de graphe sur le r´eseau footballistique
Couleur
C1
C2
C3
C4
C5
C6
C7
C8
C9

16.522 %
14.783 %
16.522 %
15.652 %
12.174 %
11.304 %
6.956 %
4.348 %
1.739 %

Var
1.008
1.031
0.875
0.6944
0.143
0.71
0.25
0.64
0.0

10.853
10.705
10.579
10.5
11.0
10.538
10.5
10.6
11.0

Tableau 3.13 – Distribution des tailles pour chaque groupe de nœuds ayant la mˆeme
couleur Ci, ¯d repr´esente le degr´e moyen du groupe de nœuds ayant la couleur Ci

et V ar repr´esente la variance concernant le degr´e des nœuds au sein d’une

mˆeme couleur.

3.2. LPA AVEC COLORATION

133

R-POP sur le r´eseau footballistique (I5 et N = 100)

α ≥ 0.5 α ≥ 0.6 α ≥ 0.7 α ≥ 0.8 α ≥ 0.9
0.0628
0.053
0.51
0.002
0.699
0.172
0.015
0.164
0.2
0.904
3

Modularit´e
Conductance
NMI
ARI
Puret´e
#
Tableau 3.14 – Mesures supervis´ees et non supervis´ees avec R-POP

0.284
0.055
0.575
0.2927
0.591

0.134
0.192
0.663
0.269
0.722

0.102
0.333
0.6832
0.2362

0.8
40

55

12

18

POP-UP sur le r´eseau footballistique (I5 et N = 100)

α ≥ 0.5 α ≥ 0.6 α ≥ 0.7 α ≥ 0.8 α ≥ 0.9
0.375
0.478
0.0004
0.249
0.417
0.756
0.214
0.63
1.0
1.0
3
21

Modularity
Conductance
NMI
ARI
Puret´e
#
Tableau 3.15 – Mesures supervis´ees et non supervis´ees avec POP-UP

0.498
0.05
0.604
0.443
1.0
7

0.51
0.018
0.638
0.469
1.0
5

0.492
0.07
0.555
0.386
1.0
9

POP-DOWN sur Football (I5 et N = 100)

Modularit´e
Conductance
NMI
ARI
Puret´e
#

α ≥ 0.5 α ≥ 0.6 α ≥ 0.7 α ≥ 0.8 α ≥ 0.9
0.033
0.148
0.607
0.002
0.248
0.693
0.109
0.046
0.235
0.922

0.242
0.087
0.545
0.197
0.548

0.054
0.451
0.655
0.116
0.817

0.11
0.222
0.628
0.221
0.704

3

13

17

42

67

Tableau 3.16 – Mesures supervis´ees et non supervis´ees avec POP-DOWN

L’algorithme de coloration trouve bien 9 couleurs dont la distribution sur les
nœuds est assez uniforme. 6 couleurs repr´esentent pr`es de 86,99 % de nœuds.
Les r´esultats sur cet exemple sont assez diﬀ´erents, notamment en fonction de α.
Pour R-POP et POP-DOWN, les meilleurs r´esultats sont obtenus pour α ≥ 0.6.
Cependant, le nombre de communaut´es r´esultantes par ces m´ethodes est tr`es
volatil par rapport `a α. Pour R-POP et POP-DOWN, apr`es α ≥ 0.7, le nombre
de communaut´es augmente consid´erablement.

134

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Les livres politiques de Krebs (´election pr´esidentielle am´ericaine

de 2004)

distribution

Coloration de graphes sur les livres politiques de Krebs
Couleurs
C1
C2
C3
C4
C5
C6
C7
C8

30.476 %
22.857 %
15.238 %
10.476 %
11.428 %
3.809 %
3.809 %
1.904 %

¯d
8.41
8.0
8.75
9.091
9.25
15.5
11.5
20.5

Var
45.05
21.5
33.81
34.44
18.18
41.25
17.25
6.25

Tableau 3.17 – Distribution des tailles pour chaque groupe de nœuds ayant la mˆeme
couleur Ci, ¯d repr´esente le degr´e moyen du groupe de nœud ayant la couleur Ci

et V ar repr´esente la variance concernant le degr´e des nœuds au sein d’une

mˆeme couleur.

R-POP sur les livres politiques de Krebs (I5 et N = 100)

α ≥ 0.5
0.493
0.0002
0.578
0.69
0.85

α ≥ 0.6
0.493
0.0002
0.578
0.69
0.847

Modularit´e
Conductance
NMI
ARI
Puret´e
#
Tableau 3.18 – Mesures supervis´ees et non supervis´ees avec R-POP

3

3

9

7

α ≥ 0.8
0.503
0.03
0.550
0.668
0.857

α ≥ 0.9
0.485
0.04
0.515
0.55
0.867

α ≥ 0.7
0.503
0.03
0.55
0.668
0.857

7

POP-UP sur les livres politiques de Krebs (I5 et N = 100)

Modularit´e
Conductance
NMI
ARI
Puret´e
#

α ≥ 0.5
0.09

0.0002
0.049
0.057
0.486

2

α ≥ 0.6
0.0905
0.0002
0.049
0.057
0.486

α ≥ 0.7
0.494
0.01
0.592
0.703
0.857

α ≥ 0.8
0.494
0.01
0.592
0.703
0.857

α ≥ 0.9
0.483
0.047
0.504
0.521
0.867

2

4

4

10

Tableau 3.19 – Mesures supervis´ees et non supervis´ees avec POP-UP

La Figure 3.42 et les tableaux 3.18, 3.19 et 3.20 sont la retranscription des
r´esultats de R-POP, POP-DOWN et POP-UP. Pour α ≥ 0.5, R-POP trouve
bien 3 communaut´es, avec pour chaque communaut´e, une identiﬁcation politique

3.2. LPA AVEC COLORATION

135

POP-DOWN sur les livres politiques de Krebs (I5 et N = 100)
α ≥ 0.9
0.49
0.046
0.539
0.668
0.876

α ≥ 0.5
0.457
0.000
0.598
0.667
0.848

α ≥ 0.6
0.4568
0.000
0.598
0.667
0.848

α ≥ 0.7
0.489
0.011
0.585
0.705
0.866

α ≥ 0.8
0.489
0.011
0.585
0.705
0.866

Modularit´e
Conductance
NMI
ARI
Puret´e
#

2

2

5

5

10

Tableau 3.20 – Mesures supervis´ees et non supervis´ees avec POP-DOWN

Figure 3.42 – Visualisation des communaut´es pour α ≥ 0.5 et α ≥ 0.7 a)
R-POP b) POP-UP c) POP-DOWN

distincte. Nous notons que la communaut´e repr´esentant les livres ”neutres” sur
le plan politique est dispatch´ee entre les trois principales communaut´es. POP-
DOWN ne d´etecte que deux communaut´es, les r´epublicains et les d´emocrates,
les neutres ´etant majoritairement plac´es dans la communaut´e d´emocrate. Pour
α ≥ 0.7, R-POP est celui qui dissocie le mieux les neutres des deux plus grands
partis. Les d´emocrates et les r´epublicains sont parfaitement d´etect´es.Une par-
tie des neutres se retrouve n´eanmoins chez les d´emocrates. POP-UP d´etecte la
majorit´e des neutres, mais la coupe en deux grandes parties.

D’apr`es les r´esultats, les principaux groupes de nœuds, `a savoir les d´emocrates

136

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

et les r´epublicains sont bien d´etect´es par les trois m´ethodes. Les diﬀ´erences
portent entre les livres neutres sur le plan politique.

3.2.3 Conclusion sur les propositions algorithmiques `a base

de coloration

L’id´ee de donner un ordre de visite en utilisant la coloration fut d’´eviter
la survenue de mauvaises propagations, c’est-`a-dire, d’´eviter qu’une propaga-
tion suive un chemin menant `a une communaut´e g´eante par succession de choix
al´eatoires inad´equats.

Nos exp´erimentations ont montr´e que l’ordre de visite a un impact sur la qua-
lit´e de partitionnement, mais ´egalement vis-`a-vis du seuil α lors des d´etections
des toutes premi`eres communaut´es. Par exemple, avec le r´eseau de dauphins,
R-POP ne d´etecte les premi`eres communaut´es qu’`a partir de α ≥ 0.5 alors que
POP-UP et POP-DOWN ne d´etectent leurs premi`eres communaut´es qu’`a partir
de α ≥ 0.3. Le nombre de communaut´es varie selon les m´ethodes. Par exemple,
sur le r´eseau footballistique, avec α ≥ 0.7, POP-UP d´etecte 7 communaut´es
alors que R-POP en d´etecte 11 et POP-DOWN en d´etecte 17.

Nos exp´erimentations ne d´emontrent pas qu’un ordre d´etermin´e am´eliore
la qualit´e de partitionnement mais r´ev`elent l’obtention de partitions de qualit´e
diﬀ´erente. Cependant, ces m´ethodes sont d´eterministes. Nous verrons qu’il est
d´elicat de comparer les r´esultats de qualit´e de partitionnement avec les autres
algorithmes car l’ordre induit une incertitude quant aux partitions obtenues.

3.3. ANALYSE COMPARATIVE DES M ´ETHODES DISJOINTES

137

3.3 Analyse comparative des m´ethodes disjointes

Nous proposons d’utiliser les algorithmes de la litt´erature suivants pour la
d´etection de communaut´es, `a savoir : la m´ethode de Girvan et Newman (GN)
Girvan et Newman (2002a), la m´ethode de Louvain (Louvain) Blondel et al.
(2008) et sa version avec les cœurs Seiﬁ et al. (2013), la m´ethode spectrale fond´ee
sur l’optimisation de la modularit´e (spectral Newman) de Newman (2006), le
mod`ele de Potts (spin) de Ronhovde et Nussinov (2010), le LPA (LPA) de Ra-
ghavan et al. (2007) et ses am´eliorations comme ˇSubelj et Bajec (2011) (DPA)
et Leung et al. (2009) (Leung) , l’algorithme `a base de leaders (LICOD) de Ka-
nawati (2011), un algorithme venant de la th´eorie de l’information (Infomap)
de Rosvall et Bergstrom (2007a), et ﬁnalement, la m´ethode de marche al´eatoire
(Walktrap) de Pons et Latapy (2006).

Les observations des tableaux 3.23, 3.21 et 3.22 montrent que les algorithmes
MPLBS et PLAB propos´es apportent des am´eliorations par rapport `a ceux issus
de la litt´erature, donnant de bonnes valeurs pour le NMI et le ARI, ainsi que
notre version ﬁnale PLBS. En eﬀet, PLBS pour le r´eseau de football obtient un
NMI de 0.931 et un ARI de 0.907.
Nos exp´erimentations ont ´egalement montr´e qu’alimenter une matrice d’appar-
tenance avec diﬀ´erents barrages pouvait donner de tr`es bons r´esultats comme le
montre PLBS. En eﬀet, selon les r´esultats des mesures supervis´ees, PLBS montre
qu’elle donne de meilleurs r´esultats dans la majeure partie des cas par rapport au
MPLBS. Imposer des barrages limite la propagation de labels et ´evite le fait de
tomber dans de trop grandes communaut´es. C’est ce que montrent les r´esultats
de PLAB qui n´ecessitent cependant de tester β. Pour la param´etrisation, nous
avons choisi α = 0.5 pour tous les r´eseaux de PLBS. Un α trop fort donne-
rait de trop nombreuses communaut´es, et trop faible, risquerait de ne don-
ner qu’une communaut´e. Le MPLBS utilisant la modularit´e, nous retourne la
param´etrisation maximisant cette derni`ere, avec la partition r´esultante. Une
derni`ere observation montre que PLBS et MPLBS donnent des conductances
assez faibles en comparaison des autres algorithmes de la litt´erature, ceci s’ex-
pliquant par le fort nombre de barrages. Par rapport au LPA ou `a la m´ethode
de Louvain, nos m´ethodes sont d´eterministes.

Concernant les algorithmes `a base de colorations et de visites pr´ef´erentielles,

nos algorithmes donnent des r´esultats tr`es satisfaisants par rapport `a la litt´erature.
On observe que l’ordre joue un rˆole sur le d´eterminisme de la m´ethode utili-
sant la matrice de fr´equence. On a pu observer que les communaut´es classiques
avaient ´et´e d´etect´ees par toutes les m´ethodes (R-POP,POP-UP et POP-DOWN)
mais que la diﬀ´erence r´esidait surtout sur certains nœuds qui sont d’apr`es la
litt´erature chevauchants. Comme l’exemple de Zachary ou celui des livres poli-
tiques, les nœuds qui diﬀ`erent de communaut´es selon la m´ethode utilis´ee sont
surtout des nœuds appel´es chevauchants. C’est-`a-dire que ce sont des nœuds
susceptibles d’appartenir `a plusieurs communaut´es. On observe ´egalement qu’en

138

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Analyse comparative avec certains algorithmes de d´etection de communaut´es

Q

Φ

NMI

ARI

Puret´e

#

Zachary #2
0.420
Louvain
0.420
Seiﬁ
0.401
GN
0.005
Spin
0.393
Spectral
0.353
WalkTrap
0.399
Leung
0.336
LPA*
0.42
DPA
0.402
Infomap
0.24
LICOD
0.347
SLPH*
0.399
R-POP
POP-UP
0.399
POP-DOWN 0.402
PLBS
0.378
0.399
PLAB
0.402
MPLBS
CDLP
0.376
Football #11
0.602
Louvain
0.602
Seiﬁ
0.600
GN
0.003
Spin
0.488
Spectral
0.604
WalkTrap
0.569
Leung
0.595
LPA*
0.606
DPA
0.579
Infomap
0.49
LICOD
0.59
SLPH*
0.284
R-POP
POP-UP
0.510
POP-DOWN 0.242
0.584
PLBS
0.598
PLAB
0.602
MPLBS
CDLP
0.602

0.005
0.005
0.0348
0.2740
0.005
0.01
0.002
0.001

0.002

0.147
0.032
0.002
0.002
0.073
0.178
0.181
0.242

0.002
0.002
0.003
0.293
0.002
0.002
0.005
0.005

0.013

0.312
0.055
0.018
0.087
0.042
0.317
0.310
0.310

0.49
0.49
0.485
0.588
0.579
0.49
0.328
0.575
0.660
0.568
0.60
0.615
0.649
0.691
0.568
0.565
0.691
0.5684
0.6154

0.855
0.855
0.879
0.892
0.695
0.887
0.900
0.887

0.9
0.9
0.83
0.893
0.555
0.638
0.545
0.931
0.929
0.927
0.927

0.392
0.392
0.3915
0.464
0.435
0.321
0.515
0.570

0.59
0.62
0.628
0.63
0.684
0.59
0.498
0.684
0.591
0.593

0.728
0.728
0.778
0.816
0.891
0.815
0.836
0.779

0.853
0.69
0.799
0.293
0.469
0.197
0.907
0.900
0.889
0.889

0.941
0.941
0.941
0.97
0.97
0.912
0.97
0.895

0.941

0.909
0.97
0.97
0.941
0.97
0.97
0.941
0.97

0.922

0.8

0.835
0.8696
0.626
0.922
0.922
0.854

0.913

0.879
0.591
1.0
0.548
0.957
0.939
0.930
0.930

4
4
5
4
4
5
3

2.61

3
3
2
5
3
3
6
3
3
5

9
9
10
10
8
10
13

10.39

12
16
4
18
5
21
16
13
12
12

Tableau 3.21 – Analyse comparative avec certains algorithmes issus de la litt´erature
(Part 1)

* signiﬁe que nous avons lanc´e l’algorithme 100 fois et que nous avons retranscrit la
moyenne des scores.

3.3. ANALYSE COMPARATIVE DES M ´ETHODES DISJOINTES

139

Analyse comparative avec certains algorithmes de d´etection de communaut´es

Q

Φ

NMI

ARI

Puret´e

#

Dauphins #2
0.519
Louvain
0.519
Seiﬁ
0.519
GN
0.529
Spin
0.491
Spectral
0.489
WalkTrap
0.519
Leung
0.483
LPA*
0.529
DPA
0.519
Infomap
0.35
LICOD
0.491
SLPH*
0.511
R-POP
POP-UP
0.520
POP-DOWN 0.373
PLBS
0.275
0.376
PLAB
0.457
MPLBS
CDLP
0.518
Politiques #3
0.521
Louvain
0.521
Seiﬁ
0.517
GN
0.526
Spin
0.467
Spectral
0.507
WalkTrap
0.498
Leung
0.492
LPA*
0.527
DPA
0.522
Infomap
0.42
LICOD
0.495
SLPH*
0.503
R-POP
POP-UP
0.495
POP-DOWN 0.49
0.459
PLBS
0.495
PLAB
0.495
MPLBS
CDLP
0.506

0.002
0.002
0.006
0.003
0.002
0.005
0.003
0.000

0.008

0.003
0.018
0.001
0.000
0.068
0.055
0.043
0.197

0.001
0.001
0.002
0.003
0.001
0.001
0.001
0.000

0.002

0.094
0.030
0.009
0.046
0.104
0.078
0.069
0.120

0.510
0.511
0.554
0.586
0.449
0.537
0.481
0.623
0.774
0.481
0.41
0.621
0.632
0.585
1.0
0.547
0.943
0.598
0.631

0.512
0.512
0.559
0.466
0.520
0.543
0.348
0.555
0.805
0.493
0.68
0.553
0.551
0.592
0.539
0.601
0.573
0.586
0.541

0.327
0.327
0.395
0.373
0.283
0.417
0.299
0.502

0.291
0.32
0.488
0.469
0.433
1.0
0.597
0.956
0.667
0.454

0.558
0.558
0.682
0.466
0.547
0.653
0.393
0.651

0.536
0.67
0.656
0.668
0.703
0.668
0.668
0.675
0.689
0.652

0.968
0.968
0.984
1.0
0.952
0.952
0.968
0.979

0.968

0.984
1.0
0.984
1.0
0.903
1.0
0.848
1.0

0.724
0.848
0.857
0.439
0.847
0.848
0.867
0.845

0.848

0.846
0.857
0.857
0.876
0.933
0.848
0.848
0.857

5
5
5
5
5
4
6

3.85

6
2
4
5
4
2
3
3
2
5

4
4
5
6
4
4
7

3.38

6
6
3
7
4
10
16
4
3
7

Tableau 3.22 – Analyse comparative avec certains algorithmes issus de la litt´erature
(Part 2)

* signiﬁe que nous avons lanc´e l’algorithme 100 fois et que nous avons pris la
moyenne des scores.

140

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Foot #11
α
β
Zac #2
α
β

PLAB
PLBS
{0.6}
{0.5}
{0.05} ∆[0.3;0.6]
PLAB
PLBS
{0.6}
{0.5}
{0.1}
∆[0.3;0.6]

MPLBS
{0.5}∗
{0.3}∗
MPLBS
{0.5}∗
{0.5}∗

Dauphins #2

α
β

Pol #3

α
β

PLAB
PLBS
{0.6}
{0.5}
{0.05} ∆[0.0;0.3]
PLAB
PLBS
{0.6}
{0.5}
{0.3}
∆[0.3;0.6]

MPLBS
{0.3 − 0.5}∗
{0.3}∗
MPLBS
{0.3 − 0.5}∗
{0.0}∗

Tableau 3.23 – Param´etrisation de nos algorithmes, ”*” signiﬁe que c’est le r´esultat
retourn´e par l’algorithme par optimisation de la modularit´e. α est la valeur pour la
cr´eation du graphe issu de la matrice de fr´equence et β, le pourcentage de barrages.

moyenne, la m´ethode `a base de coloration produit en g´en´eral plus de commu-
naut´es que les autres m´ethodes, avec une conductance plus importante, c’est-`a-
dire la cr´eation de tr`es petites communaut´es.

3.4. PROPOSITIONS SUR LE CHEVAUCHEMENT

141

3.4 Propagation de labels avec d´etection de cœurs

pour la d´etection de communaut´es chevau-
chantes

La section pr´ec´edente a pr´esent´e divers algorithmes pour la d´etection de com-
munaut´es disjointes dont les objectifs sont d’am´eliorer le LPA. En consid´erant
l’exemple du CDLP et par observation de la matrice de fr´equence, on voit
des nœuds fr´equemment ensemble au cours des diﬀ´erentes LPA, mais aussi des
nœuds induire une id´ee de chevauchement car appartenant `a diﬀ´erentes com-
munaut´es. Dans certains r´eseaux, comme celui de collaborations scientiﬁques o`u
des chercheurs publient leurs travaux de recherche, il peut y avoir des personnes
appartenant `a plusieurs communaut´es. C’est par exemple le cas si un chercheur
a publi´e un article dans le domaine des graphes, et un autre dans le domaine
de l’oncologie. Les citations du premier se feront par des articles li´es au graphe
alors que le second sera cit´e par des articles traitant de l’oncologie. L’auteur
sera donc cit´e par deux groupes de personnes dont les champs scientiﬁques sont
diﬀ´erents. Nous proposons dans cette section la possibilit´e pour un nœud d’ap-
partenir `a plusieurs communaut´es suivant certaines conditions en utilisant une
fonction d’appartenance fond´ee sur la topologie du graphe, la pond´eration des
arˆetes et les caract´eristiques sociales des communaut´es.

3.4.1 De la propagation de labels avec d´etection de cœurs

au chevauchement

L’objectif principal du CDLP pr´esent´e `a la section pr´ec´edente fut de stabili-
ser la propagation de labels en lan¸cant plusieurs fois l’algorithme tout en utili-
sant une matrice de fr´equence. Cependant, bien que cette m´ethode puisse mettre
en exergue des cœurs de communaut´es, c’est-`a-dire des nœuds fr´equemment en-
semble durant les diﬀ´erentes propagations de labels, elle montre que certains
nœuds peuvent appartenir `a des communaut´es diﬀ´erentes suite `a l’application
de plusieurs CDLP. Ce sont sur ces nœuds, dont l’impr´ecision d’appartenance `a
plusieurs classes est ´elev´ee, que nous portons notre attention. Dans le cadre de
ce travail doctoral, nous proposons d’´etablir une mesure de d´ecision permettant
de sp´eciﬁer pour un certain nombre de nœuds, d´elicats `a classer, leurs diﬀ´erentes
communaut´es d’appartenance possibles, cr´eant par voie de cons´equence, le che-
vauchement entre communaut´es. Pour ce faire, nous proposons de donner ou
de rappeler certaines d´eﬁnitions que nous utiliserons pour l’´elaboration d’une
fonction de d´ecision pour le chevauchement.

D´eﬁnition Un cœur de communaut´e est l’ensemble des nœuds se trouvant
fr´equemment ensemble dans une mˆeme communaut´e apr`es plusieurs lancements
d’un algorithme non d´eterministe (exemple de Louvain avec Seiﬁ et al. (2013)).

Ainsi, les nœuds ´etant presque toujours dans les mˆemes communaut´es au
cours des diﬀ´erentes propagations de labels ne portent pas `a confusion quant `a

142

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

la communaut´e `a laquelle ils appartiennent. Cependant, certains nœuds ont une
fr´equence d’apparition vis-`a-vis de certaines communaut´es bien plus faible. Nous
portons notre attention sur les nœuds qui sont li´es `a plusieurs communaut´es.
Nous d´eﬁnissons ainsi la bordure de communaut´e.

D´eﬁnition La bordure (ou fronti`ere) d’une communaut´e est l’ensemble des
nœuds ayant au moins un lien vers une autre communaut´e. Elle constitue l’en-
semble des candidats potentiels au chevauchement.

Figure 3.43 – Exemple de bordure (ou fronti`ere), ici les nœuds B, C et D

Dans l’exemple de la Figure 3.43, il y a deux communaut´es avec la partition
P = {{A, B, E, F},{C, D}}. En consid´erant la communaut´e P1 = {A, B, E, F},
seul le nœud B poss`ede des liens `a l’ext´erieure de la sa communaut´e, il ap-
partient donc `a la bordure de sa communaut´e (sa fronti`ere). En consid´erant la
communaut´e P2 = {C, D}, les nœuds C et D poss`edent au moins un lien vers
une autre communaut´e, ils sont donc aussi sur la bordure de leurs communaut´es.

Pour nos ´etudes exp´erimentales, nous utilisons certaines statistiques portant
sur les nœuds chevauchants. Nous d´eﬁnissons pour cela le pourcentage de chevau-
chement, le taux de chevauchement pour un nœud et le taux de chevauchement
moyen.

D´eﬁnition Le pourcentage de chevauchement est le pourcentage de nœuds ap-
partenant `a plusieurs communaut´es.

D´eﬁnition Le taux de chevauchement pour un nœud est le rapport entre le
nombre de communaut´es auxquelles le nœud appartient et le nombre de com-
munaut´es auxquelles il est reli´e.

D´eﬁnition Le taux de chevauchement moyen est la moyenne des taux de che-
vauchement de tous les nœuds du graphe.

3.4.2 Fonction d’appartenance

La proposition algorithmique pour la d´etection de communaut´es chevau-
chantes est fond´ee sur l’aspect sociologique d’un individu vis-`a-vis de ses rela-
tions et des communaut´es auxquelles il est li´e.

3.4. PROPOSITIONS SUR LE CHEVAUCHEMENT

143

Consid´erons l’exemple sociologique suivant o`u le nœud ´etudi´e est u avec deux
communaut´es d’individus. Les nœuds sont des individus et les arˆetes leurs degr´es
d’amiti´es. On suppose que le nœud u est ami avec Rebecca et avec Valentin.
Lors d’une soir´ee, la question est de savoir vers quelle communaut´e pourrait
aller le nœud u.

Figure 3.44 – Exp´erience sociale

Le nœud u a donc le choix entre trois communaut´es. Sa d´ecision se fera selon
son degr´e d’amiti´e avec Rebecca, Valentin et William mais aussi vis-`a-vis des
relations de ses amis. On peut s’apercevoir de la forte collaboration au sein du
groupe de Valentin avec les nœuds ayant une forte centralit´e (certains ayant un
degr´e de 4 ou de 5). Dans le groupe de Rebecca, la collaboration semble moins
forte mais est pr´esente. Dans le groupe de William, la collaboration semble faible,
certains nœuds ne communiquent pas ensemble. En observant la topologie des
structures communautaires, le nœud u pourrait rejoindre au cours de la soir´ee
le groupe de Rebecca ou celui de Valentin. Cependant, le nœud u ira cotoyer
un groupe si son lien avec l’individu est assez fort. Si u a une plus grande
aﬃnit´e pour Rebecca et Valentin que pour William, u ira cotoyer en premier le
groupe de Rebecca puis celui de Valentin. Le nœud u pourrait alors appartenir `a
deux communaut´es. Notre proposition algorithmique repose sur le graphe seuill´e
G(cid:48), r´esultante de la matrice de fr´equence P N
ij . L’id´ee est de pouvoir utiliser la
pond´eration des liens que l’on peut trouver dans la matrice de fr´equence comme
une relation d’amiti´e.
Le nouveau graphe G(cid:48) est alors projet´e sur le graphe originel G, tout en
respectant sa topologie. Cela signiﬁe que les arˆetes pr´esentes dans G(cid:48) mais pas
dans G ne seront pas consid´er´ees, aﬁn de ne pas mettre de liens absurdes. Ce
peut ˆetre le cas s’il y a des conﬂits entre personnes ou que des individus re-
fusent de parler `a d’autres individus, comme dans le graphe de Zachary entre
le manager et l’entraˆıneur. Nous utilisons ainsi l’information stock´ee dans P N
ij
pour pond´erer G. Cela nous permet de voir les paires de nœuds ayant une forte
probabilit´e d’ˆetre ensemble en terme communautaire. En utilisant le seuil α sur
le nouveau graphe pond´er´e, nous obtenons les communaut´es et les liens entre
communaut´es (LEC). Les nœuds qui sont `a la fronti`ere de leurs communaut´es
et reli´es `a d’autres sont de possibles candidats pour le chevauchement. Pour sa-
voir si ces nœuds candidats sont de potentiels futurs nœuds chevauchants, nous
proposons les fonctions d’appartenances suivantes.

Consid´erant un nœud candidat u, l’id´ee est de mesurer le pouvoir d’ap-
partenance qu’a ce nœud en observant ses communaut´es avoisinantes et leurs
structures topologiques. Nous ´ecrivons Cu = {Cu
K}, les diﬀ´erentes commu-

1 , ...,Cu

144

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

naut´es auxquelles le nœud u est li´e. Si u est li´e `a K diﬀ´erentes communaut´es,
nous le notons par |Cu| = K.

Fonctions d’appartenance pour le chevauchement

En consid´erant les K diﬀ´erentes communaut´es pr´esentes dans le voisinage

du nœud u, nous proposons la fonction d’appartenance :

fX : u × {C u

1 , ..., C u

K} (cid:55)−→ R+

fX (u,{C u

1 , ..., C u

K}) =

c∈(cid:0)Cu

K
j

(cid:1),j∈{1,...,K}

max

(

(3.3)

ωu,iX S(i))

(3.4)

|c| ×(cid:88)

1

i∈c

o`u c est une liste de combinaisons de communaut´es voisines d’un nœud u et
X un param`etre portant sur une mesure sociale fond´ee sur la structure topolo-
gique d’un sous-graphe. Le terme c va prendre toutes les combinaions possibles,
notamment avec j ∈ {1, ..., K}. Par la suite, le terme i ∈ c signiﬁe que l’on
va regarder toutes les combinaisons de communaut´es de c, ainsi, nous pourrons
avoir les pond´erations des liens ωu,i, o`u ωu,i est la somme des poids des arˆetes
liant le nœud u aux communaut´es dans la liste i. Le terme X S(i) repr´esente la
valeur d’une mesure sociale du sous graphe (ici la communaut´e) S constitu´e de
l’union des communaut´es de i.

(cid:1) permet de calculer les j combinaisons dans un
(cid:1)). Cela permet au nœud u d’appartenir `a une ou plusieurs commu-

ensemble de Cu
K ´el´ements, les ´el´ements ´etant les communaut´es. Ainsi, un nœud
va essayer toutes les combinaisons de communaut´es auquel il pourrait appartenir

Le cœﬃcient binomial (cid:0)Cu
(c ∈ (cid:0)Cu

K
j

naut´es. La conﬁguration ayant le score le plus ´elev´e permettra l’assignement du
nœud u aux communaut´es choisies.

K
j

Nous notons dans la formule ci-dessus que j ∈ {1, ..., K}, mais il est tout `a
fait possible de forcer un nœud candidat soit chevauch´e par au moins L com-
K|}. Cela permet `a l’utilisateur de choisir le
munaut´es, en ´ecrivant j ∈ {L, ...,|C u
nombre de communaut´es auxquelles peut appartenir un nœud candidat.

Pour les mesures sociales portant sur la structure topologique des commu-
naut´es, nous proposons d’utiliser la densit´e (dont la fonction d’appartenance est
not´e fd) et le cœﬃcient de clustering (dont la fonction d’appartenance est not´e
fcc). Ces mesures sont utilis´ees pour eﬀectuer une ´etude comparative.

En ce qui concerne la fonction d’appartenance fond´ee sur la densit´e, un nœud
avec une forte pond´eration sur ses liens connect´es `a des communaut´es ayant de
fortes densit´es aura plus de chance d’ˆetre chevauchant plutˆot qu’un nœud avec
de faibles pond´erations sur ses arˆetes connect´ees `a des communaut´es de faibles

3.4. PROPOSITIONS SUR LE CHEVAUCHEMENT

145

densit´es. Cependant, dans certaines situations, les chevauchements ne peuvent
pas se faire. Cela peut ˆetre le cas si un nœud u est tr`es faiblement li´e `a ses
communaut´es avoisinantes, elles mˆemes de faibles densit´es, avec une valeur de
fd relativement faible. Fond´e sur ce constat, le chevauchement sera eﬀectu´e si
et seulement si fd(u,{C u
S∈c dS o`u dS est la densit´e du sous
graphe (ici la communaut´e) S.

K}) ≥ 1|c|

1 , ..., C u

(cid:80)

L’id´ee d’utiliser ensuite le cœﬃcient de clustering est que le nœud candi-
dat observera les connexions au sein des communaut´es, et la pr´esence de lea-
ders, caract´eristique des graphes de terrains dont la distribution des degr´es
des nœuds suit une loi faible. De mˆeme que pour la densit´e, si un nœud u
est tr`es faiblement li´e `a ses communaut´es avoisinantes, elles mˆemes de faibles
cœﬃcients de clustering, il n’y a pas de raison pour qu’il y ait de chevauche-
ment. Fond´e sur ce constat, le chevauchement sera eﬀectu´e si et seulement si
fcc(u,{C u
S∈c ccS o`u ccS est le coeﬃcient de clustering du sous
graphe (ici la communaut´e) S.

K}) ≥ 1|c|

1 , ..., C u

(cid:80)

Supposons que nous ayons le graphe de la ﬁgure 3.45, avec la partition
P = {C1, C2, C3, C4} telle que C1 = {v1, v2, v3},C2 = {v4, v5, v6}, C3 = {v7, v8}
and C4 = {u}, r´esultante de la propagation de labels avec matrice de fr´equence.
La question est de savoir si le nœud u peut appartenir `a plusieurs communaut´es.
On observe que la meilleure conﬁguration pour l’obtention de communaut´es che-
vauchantes sur le nœud u est donn´ee avec C1 et C2. Le nœud u est ainsi assign´e
dans la combinaison o`u les densit´es sont les plus ´elev´ees, et les pond´erations des
liens sont les plus fortes.

Figure 3.45 – Apr`es avoir calcul´e fd et fcc sur le nœud u, u appartient `a deux com-
munaut´es.

3.4.3 Propositions algorithmiques pour la d´etection de com-

munaut´es chevauchantes

Nous exposons la propagation de labels avec d´etection de cœurs et chevau-

chement (CDLPOV), algorithme 7.

fappartenance fait r´ef´erence `a la fonction choisie par l’utilisateur, `a savoir fd ou
fCC. SN M (S) est la mesure d’analyse des r´eseaux sociaux utilis´ee concernant
l’aspect topologique de la communaut´e S, `a savoir la densit´e ou le CC. En faisant

146

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Algorithme 7 Le CDLP avec fonction d’appartenance (CDLPOV)
Entr´ee : Un graphe G = (V, E), le seuil α, N le nombre de lancements
Sortie : Les communaut´es chevauchantes de G
1: Allouer une matrice de fr´equence vide
2: Lancer N fois la propagation de labels asynchrone
3: Remplir la matrice de fr´equence avec les r´esultats des N LPA
4: Cr´eer un nouveau graphe G(cid:48) = (V, E(cid:48)) de P N
ij avec des arˆetes dont la pond´eration
5: Projeter le graphe G(cid:48) sur G avec la pond´eration (mais en enlevant les arˆetes
6: Cr´eer une partition P = {P1, ..., PC} en consid´erant les C composantes connexes

est sup´erieure ou ´egale `a α
pr´esentes dans G(cid:48) mais pas dans G)

comme cœurs

7: Calculer les arˆetes entre communaut´es (AEC)
8: Cand ← [] {Cand est une liste de candidats potentiels au chevauchement (nœuds

`a la fronti`ere des communaut´es)}

Cand.ajouter(u)

9: Pour chaque nœud u ayant une arˆete dans AEC Faire
10:
11: Fin Pour
12: P Ov ← P {Partition chevauchante que renverra l’algorithme}
13: Pour chaque nœud u dans Cand Faire
14:
15: Fin Pour
16: Pour chaque nœud u dans Cand Faire
17:

Si fappartenance(u,{C u

K}) ≥(cid:80)

Cand.ajouter(u)

18:
Fin Si
19:
20: Fin Pour
21: Retournez la partition P Ov = {P Ov

1

, ..., P OvC }.

Dupliquer le nœud u dans les communaut´es correspondantes de P Ov

1 , ..., C u

S∈{Cu

1 ,...,Cu

K} SN M (S) Alors

3.4. PROPOSITIONS SUR LE CHEVAUCHEMENT

147

varier α dans un intervalle et avec un pas sp´eciﬁque, nous pouvons obtenir un
dendrogramme chevauchant.

3.4.4 Exp´erimentations sur CDLPOV

Nous testons nos m´ethodes sur des graphes r´eels sociologiques que nous avons
expos´es en introduction. Pour l’´evaluation de nos m´ethodes, nous consid´erons
l’information mutuelle normalis´ee dans sa forme chevauchante (NMI), le F-Score
dans sa forme chevauchante (F1), l’indice d’omega (Ω) et la modularit´e de
Nicosia (QN ic
Ov ). D’autres informations sont donn´ees telles que le pourcentage
de candidats au chevauchement (cand), le pourcentage de nœuds chevauchants
(candOv) et le pourcentage d’arˆetes entre communaut´es (AEC).

Pour analyser les r´esultats des deux m´ethodes propos´ees, nous utilisons des
r´eseaux r´eels dont certains sont connus comme ayant des nœuds chevauchants.
A ce titre, nous exposons les caract´eristiques portant sur le chevauchement des
r´eseaux que nous utilisons. Nous mettons ´egalement les ﬁgures pour certains.

Le graphe de Zachary Karat´e club est connu comme ayant deux commu-
naut´es, et mˆeme trois pour certains. La litt´erature montre l’existence de deux
nœuds appartenant `a plusieurs communaut´es. Le graphe de Zachary s’est construit
sur une dispute opposant le manager et l’entraˆıneur d’un club de karat´e. Le
r´esultat de cette dispute fut la cr´eation de deux clubs de karat´e dans une mˆeme
rue. Le premier nœud qui est chevauchant est ami `a la fois avec le manager et
l’entraineur du club. Il poss`ede un lien dans chacune des deux communaut´es. Le
second nœud chevauchant est interne `a une grande communaut´e, que l’on peut
subdiviser en deux. Il s’agit d’un groupe de personnes amies entre elles dont
l’unique connexion au groupe est une personne amie du manager. Ce nœud ap-
partient `a un chevauchement.

Figure 3.46 – Les nœuds chevauchants dans le graphe de Zachary

148

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Le r´eseau de dauphins est caract´eris´e par deux communaut´es repr´esentant
d’un cˆot´e les mˆales et de l’autre les femelles. C’est un graphe o`u il n’y a pas de
chevauchement.

Le r´eseau footbalistique repr´esente 11 conf´erences. On consid`ere qu’il y a

huit clubs qui appartiennent `a plusieurs communaut´es.

Le graphe des livres politiques, des ann´ees 50 `a l’´election pr´esidentielle
am´ericaine de 2004 est constitu´e de trois communaut´es, `a savoir les r´epublicains,
les neutres et les d´emocrates. Les livres politiquement neutres sont une r´etrospective
de la politique am´ericaine, notamment par des explications historiques. La po-
litique am´ericaine a connu une succession de diﬀ´erentes politiques d´emocrates et
r´epublicaines. Depuis 1961 et jusqu’en 2004, quatre pr´esidents ont ´et´e d´emocrates
et cinq pr´esidents ont ´et´e r´epublicains. Certains livres du r´eseau citent des
p´eriodes pr´esidentielles marqu´ees par des politiques diﬀ´erentes, men´ees par des
partis diﬀ´erents. C’est par exemple le cas de ”Ghost wars”, de Steve Coll qui
retrace l’histoire de la CIA depuis les cinquantes derni`eres ann´ees. Nous nous
attendons `a ce que ce livre puisse appartenir aux trois communaut´es que sont
les r´epublicains, les neutres et les d´emocrates.

Le r´eseau de collaboration scientiﬁque montre des communaut´es caract´eris´ees
par un th`eme scientiﬁque. Cependant, certains chercheurs ont publi´e dans di-
vers domaines et sont susceptibles d’appartenir `a plusieurs communaut´es. Par
exemple, Mark Newman, physicien am´ericain, publie `a la fois dans le domaine
de la d´etection de communaut´es mais ´egalement dans divers domaines li´es au
graphe comme les hypergraphes. Cependant, le graphe qui a ´et´e form´e a d´ej`a
´et´e bien d´eﬁni au sens communautaire et il n’y a que peu de chevauchement.

Zachary Karate Club

Le graphe est caract´eris´e par deux communaut´es.

Figure 3.47 – Communaut´es avec diﬀ´erentes valeurs de α en utilisant fd et fcc, a)
α ≥ 0.6, b) α ≥ 0.7 c) α ≥ 0.8

Sur la ﬁgure 3.47, les candidats pour le chevauchement avec fd et fcc sont

3.4. PROPOSITIONS SUR LE CHEVAUCHEMENT

149

les mˆemes. Pour α ≤ 0.6, seul le nœud 10 est chevauchant. Il est assign´e `a la
communaut´e C2 avec fcc alors qu’il est assign´e `a deux communaut´es avec fd
(qui sont C3 et C4). Cela vient du fait que la communaut´e C2 a un nombre plus
important de triangles que C4.

Pour α ≥ 0.8, le nœud 3 qui est connu dans la litt´erature comme ´etant che-
vauchant, est assign´e `a deux communaut´es avec fd (C5 et C4), mais juste `a une
communaut´e avec fcc (C4). Le nœud 1 est assign´e `a une communaut´e (C2) pour
chacune des deux m´ethodes.

D’apr`es les r´esultats du tableau 3.24, plus la valeur de α est ´elev´ee, plus le
nombre de candidats pour le chevauchement devient important. Cela vient du
fait que les tailles des communaut´es diminuent alors que α croˆıt. De ce fait,
le pourcentage AEC devient plus important, augmentant les nœuds candidats.
Mˆeme si les nœuds chevauchants sont les mˆemes selon fd et fcc jusque α ≥ 0.9,
la qualit´e des r´esultats est meilleure en utilisant fd plutˆot que fcc. La valeur de
la modularit´e la plus ´elev´ee est pour α ≥ 0.7 (0.62 pour chacune des m´ethodes)
avec les valeurs les plus fortes pour le NMI et pour l’indice Ω.

R´esultat avec fd et fcc sur le club de Karate

Cand

CandOv
2.94% (1)
8.824% (3)

47.058%
41.17%
55.88% 32.352% (11)
55.88% 32.352% (11)
Cand

NMI #
fd
α ≥ 0.6
2
0.237
α ≥ 0.7
4
0.518
α ≥ 0.8
5
0.349
α ≥ 0.9
0.349
5
NMI #
fcc
α ≥ 0.6
2
0.237
α ≥ 0.7
3
0.518
α ≥ 0.8
5
0.349
α ≥ 0.9
0.349
5
Tableau 3.24 – Cand : candidats possibles , CandOv : Pourcentage de nœuds chevau-
chants

QN ic
AEC
Ov
17.95% 0.399
16.0%
0.621
26.92% 0.420
26.92% 0.420
QN ic
AEC
Ov
17.948% 0.399
0.621
26.923% 0.420
26.923% 0.420

2.941% (1)
8.823% (3)

47.058%
41.176%
55.882% 32.353% (11)
55.882% 32.353% (11)

F1
0.65
0.857
0.75
0.75
F1
0.65
0.857
0.75
0.75

Ω

0.065
0.711
0.492
0.492

Ω

0.064
0.711
0.492
0.492

CandOv

16.0%

Les femmes du sud de Davis (r´eseau bipartie)

Il s’agit d’un r´eseau repr´esentant 18 femmes, observ´ees sur une p´eriode de 9
mois dans les ann´ees 1930. Durant cette p´eriode, de nombreux sous-groupes de
ces femmes vont se rencontrer dans une s´erie de 14 ´ev`enements sociaux infor-
mels. Chacun des nœuds dans ce r´eseau `a deux modes a un nom, repr´esentant
une femme ou un ´ev`enement (avec la notation Ek pour le k`eme ´ev`enement).

150

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Figure 3.48 – R´esultat sur le reseau FM avec α ≥ 0.9

R´esultat avec fd sur FM

α ≥ 0.9
α ≥ 1.0

Cand

71.875%

87.5%

CandOv
25.0% (5)
75.0% (14)

QN ic
AEC
Ov
33.33% 0.502∗
56.99% 0.021∗

R´esultat avec fcc sur FM

α ≥ 0.9
α ≥ 1.0

Cand

CandOv

71.875% 65.625% (12)

87.5%

87.5% (16)

QN ic
AEC
Ov
33.33% 0.157*
0.0∗
56.989%

#
4
17

#
4
17

Tableau 3.25 – Cand : candidats possibles, CandOv : Pourcentage de nœuds chevau-
chants

En consid´erant le Tableau 3.25, pour α ≥ 0, 8, nous n’avons qu’une commu-
naut´e. Pour α ≥ 0, 9, sur la ﬁgure 3.48, nous obtenons quatre communaut´es.
Apr`es avoir calcul´e fd, nous avons 25% de nœuds dans des communaut´es che-
vauchantes. Comme nous pouvons le voir, c’est `a la fois les nœuds repr´esentant
des individus et des ´ev`enements qui sont assign´es `a des communaut´es chevau-
chantes. Verne est assign´e `a E7, E8, E9 et E12. E7 et E9 sont assign´es `a
Theresa, Laura et Brenda (dans la communaut´e C1), puis pour Verne dans C4
et ﬁnalement pour H´el`ene et Sylvia C3, soit `a trois communaut´es diﬀ´erentes.
Theresa est assign´ee aux activit´es E6, E7 et E8. A la ﬁn du processus, certains
nœuds sont li´es `a plusieurs ´ev`enements comme Verne avec E7, E8, E9 et E12.
pour α = 1, 0, nous obtenons 17 communaut´es. La majorit´e des communaut´es
regroupe des personnes avec leurs ´ev`enements qui sont assign´es aux personnes
ayant de fortes centralit´es.

On observe qu’utiliser fcc entraˆıne un pourcentage de chevauchement plus
important qu’en utilisant fd (65.625% contre 25.0%), avec un taux de chevau-
chement moyen plus important, particuli`erement pour les ´ev`enements.

Les dauphins de Nouvelle Z´elande

Le graphe est compos´e de deux communaut´es, qui regroupent les mˆales et les
femelles.

3.4. PROPOSITIONS SUR LE CHEVAUCHEMENT

151

R´esultats avec fd et fcc sur le r´eseau de dauphins

Cand

CandOv

0.0%

6.451% (4)
8.065% (5)

19.355% (12)
25.81% (16)

51.61% %
54.838%
64.51%
61.29%
77.41%
Cand

fd
α ≥ 0.5
α ≥ 0.6
α ≥ 0.7
α ≥ 0.8
α ≥ 0.9
fcc
α ≥ 0.5
α ≥ 0.6
0.594
α ≥ 0.7
0.457
α ≥ 0.8
0.442
α ≥ 0.9
0.277
Tableau 3.26 – Cand : candidats possibles, CandOv : Pourcentage de nœuds chevau-
chants

QN ic
AEC
Ov
20.38% 0.7959
24.050% 0.750
0.714
30.57%
29.30%
0.605
0.542
43.94%
QN ic
AEC
Ov
20.382% 0.796
24.051% 0.750
0.714
30.57%
29.3%
0.606
43.949% 0.441

NMI #
2
1.0
4
0.594
5
0.457
8
0.442
0.246
12
NMI #
2
1.0
4
5
8
12

51.613%
54.838%
64.516%
61.29%
77.419%

F1
1.0
.857
0.75
0.618
0.549

Ω
1.0

0.617
0.478
0.478
0.355

Ω
1.0

0.613
0.429
0.478
0.588

CandOv

0.0%

6.451% (4)
8.065% (5)

F1
1.0
.857
0.75

0.6184
0.533

19.355% (12)
35.483% (22)

A partir du tableau 3.26, pour α ≥ 0.5, l’algorithme et les fonctions trouvent
les deux communaut´es, sans aucun chevauchement, avec un NMI, un indice
d’omega et un F1 score de 1,0. En augmentant la valeur de α, la taille des
communaut´es diminue tandis que le nombre de candidats possibles pour le che-
vauchement augmente. Le pourcentage de chevauchement est le mˆeme pour
α ≥ 0.6 jusqu’`a α ≥ 0.8. Malgr´e cela, les deux m´ethodes n’assignent pas les
nœuds candidats de la mˆeme mani`ere. fcc produit la mˆeme qualit´e en termes de
communaut´es mais a un pourcentage de chevauchement et un taux de chevau-
chement moyen plus important qu’avec fd, surtout pour de fortes valeurs de α.

Figure 3.49 – R´eseaux de dauphins a) α ≥ 0, 5, b) α ≥ 0, 6, les nœuds chevauchants
avec fcc et fdd sont les mˆemes

En observant la ﬁgure 3.49, pour α ≥ 0.6, nous voyons que 4 nœuds ont
´et´e selectionn´es pour appartenir `a plus d’une communaut´e. En consid´erant leurs
aspects topologiques, SN 89 est li´e `a deux communaut´es avec une arˆete li´ee `a
chacune, il est assign´e `a ses communaut´es voisines. Il en est de mˆeme pour
T opless qui a 6 arˆetes `a l’int´erieur de sa communaut´e et 4 `a l’ext´erieur. Zap a
trois nœuds `a l’int´erieur de sa communaut´e et 2 `a l’ext´erieur. Il est assign´e `a C4.
SN 100 a 4 arˆetes `a l’int´erieur de sa communaut´e et deux `a l’ext´erieur vers deux
communaut´es. Il est assign´e aux communaut´es C3 et C4. SN 9 a juste une arˆete

152

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

de plus que SN 100 `a l’int´erieur de la communaut´e avec la mˆeme conﬁguration
topologique, il n’est cependant pas assign´e. Pour α ≥ 0.6, les r´esultats, que cela
soit en utilisant fd ou fcc sont les mˆemes. Pour chacune des deux m´ethodes, la
taille des dendrogrammes est de 6. De α ≥ 0.5 `a α ≥ 0.9, le nombre de nœuds
s´electionn´es pour le chevauchement est le mˆeme, mais le pourcentage de che-
vauchement avec fcc est plus important avec fd.

Le r´eseau footballistique

R´esultats avec fd sur le r´eseau footballistique

Ω

CandOv

0.0%
0.0%
0.0%

F1

0.762
0.810
0.854
0.854
0.861
0.819
0.819

0.530
0.681
0 .865
0.851
0.882
0.825
0.825

Cand
100.0%
100.0%
100.0%
100.0% 0.87% (1)
100.0% 1.74% (2)
100.0% 8.69% (10)
100.0% 8.69% (10)
Cand
100.0%
100.0%
100.0%
100.0% 0.87% (1)
100.0% 1.74% (2)
100.0% 8.69% (10)
100.0% 8.69% (10)

fd
α ≥ 0.2
α ≥ 0.3
α ≥ 0.4
α ≥ 0.5
α ≥ 0.6
α ≥ 0.7
α ≥ 0.8
fcc
α ≥ 0.2
α ≥ 0.3
α ≥ 0.4
α ≥ 0.5
α ≥ 0.6
α ≥ 0.7
α ≥ 0.8
Tableau 3.27 – Cand : Candidats possibles, CandOv : Pourcentage de nœuds chevau-
chants

NMI #
9
0.597
10
.639
0.685
11
11
0.682
12
0.666
13
0.629
0.629
13
NMI #
9
0.512
10
0.639
11
0.685
0.682
11
12
0.666
13
0.629
0.629
13

F1
0.76
0.81
0.854
0.854
0.85
0.819
0.819

0.7

EC

QN ic
Ov
29.53% 0.722
29.53% 0.708
30.01%
30.01% 0.699
30.83% 0.690
31.32% 0.629
31.32% 0.629
QN ic
Ov
29.53% 0.722
29.53% 0.708
30.016% 0.699
30.016% 0.699
30.832% 0.690
31.321% 0.629
31.32% 0.629

EC

Ω

0.530
0.681
0.865
0.851
0.882
0.825
0.825

CandOv

0.0%
0.0%
0.0%

Selon le tableau 3.27, c’est pour α ≥ 0, 5 que les premiers nœuds chevau-
chants apparaissent. De α ≥ 0, 5 `a α ≥ 0.9, le nombre de nœuds chevauchants
est le mˆeme, ainsi que leur taux de chevauchement moyen. Les r´esultats en
termes de similarit´e de score de qualit´es sont semblables. les meilleurs scores
sont pour α ≥ 0, 5 avec un NMI 0.68. Le nombre de communaut´es augmente
tr`es lentement puis fortement avec α = 1.0.

Les livres politiques de Kreb

3.4. PROPOSITIONS SUR LE CHEVAUCHEMENT

153

C’est un r´eseau de livres politiques datant de l’´election pr´esidentielle am´ericaine

de 2004 et vendus sur le site de vente en ligne Amazon.com. Ce graphe comporte
trois communaut´es au sens politique, `a savoir les d´emocrates, les r´epublicains
et le centre sur l’´echiquier politique.

0.0%

Resultats avec fcc et fd sur les livres politiques de Kreb
F1

CandOv

EBC

Ω

Cand

0.95% (1)
1.90% (2)
5.71% (6)

24.762%
26.67%
31.43%
32.38%
35.24%
Cand

NMI #
fd
α ≥ 0.4
2
0.452
α ≥ 0.5
2
0.494
α ≥ 0.6
0.387
3
α ≥ 0.7
4
0.354
α ≥ 0.8
0.290
7
NMI #
fd
α ≥ 0.4
0.504
2
α ≥ 0.5
2
0.494
α ≥ 0.6
3
0.449
α ≥ 0.7
4
0.340
α ≥ 0.8
0.28
7
Tableau 3.28 – Cand : Candidats possibles , CandOv : Pourcentage de nœuds chevau-
chants

QN ic
Ov
5.215% 0.834
6.576% 0.834
7.71%
0.845
0.76
9.07%
0.653
9.98%
QN ic
EBC
Ov
5.215% 0.834
6.576% 0.834
7.709% 0.844
9.070% 0.782
9.977% 0.6533

24.761%
26.67%
31.428%
32.380%
35.238% 15.238% (16)

0.952% (1)
0.952% (1)
5.714% (6)

0.788
0.784
0.713
0.664
0.566

0.667
0.654
0.676
0.686
0.667

F1

0.788
0.774
0.719
0.653
0.532

Ω

0.667
0.654
0.676
0.687
0.667

15.24% (16)

CandOv

0.0%

D’apr`es le tableau 3.30, c’est pour α ≥ 0.5 que les premiers nœuds chevau-
chants apparaissent. Les r´esultats sont tr`es similaires pour les deux m´ethodes,
n´eanmoins, fd donne un pourcentage de chevauchement et un taux de chevau-
chement moyen plus ´elev´e selon nos observations qu’en utilisant fcc. Le nombre
de communaut´es augmente lentement en fonction de la valeur α, comme celui
des candidats au chevauchement. De 0.4 ≤ α ≤ 0.8, la majorit´e des nœuds che-
vauchants sont neutres sur le plan politique am´ericain.

(a) Le r´eseau de livres politiques avec
α ≥ 0, 3

(b) Le r´eseau de livres politiques avec
α ≥ 0, 6

Figure 3.50 – R´esultats avec fd et fcc

Sur la ﬁgure 3.50a, nous voyons que la m´ethode pour α ≥ 0.3 donne deux
communaut´es qui repr´esentent les r´epublicains et les d´emocrates, il n’y a pas
de chevauchements. Sur la ﬁgure 3.50b, avec α ≥ 0.6, la m´ethode trouve trois

154

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

communaut´es, les r´epublicains, les d´emocrates et les neutres et un nœud che-
vauchant, mais qui n’est pas associ´e aux communaut´es de la mˆeme fa¸con selon
les fonctions d’appartenance utilis´ees. Il s’agit du livre ”Ghost Wars” ´ecrit par
Steve Coll et publi´e en 2004. Ce livre retrace l’action de la CIA des ann´ees
1965 `a 2004, sous les diﬀ´erentes administrations am´ericaines, contre des r´eseaux
criminels. Ce livre n’a pas d’orientation politique et n’est qu’historique. Les
tableaux 3.29 et 3.30 montrent certains livres chevauchant plusieurs commu-
naut´es. Pour Ghost Wars, le livre est neutre pour α ≥ 0.5, puis chevauche la
communaut´e r´epublicaine avec α ≥ 0.6 et ﬁnalement chevauche ´egalement la
communaut´e d´emocrate avec α ≥ 0.7, quelles que soient les fonctions utilis´ees.
Ce livre est chevauchant car il est cit´e de nombreuses fois par les communaut´es
r´epublicaines et d´emocrates. En eﬀet, des ann´ees 1965 `a 2004, les diﬀ´erentes ad-
ministrations am´ericaines ´etaient soit d´emocrates (Lyndon B. Johnson, Jimmy
Carter et Bill Clinton), soit r´epublicaines (Richard M. Nixon, Gerald R. Ford,
Ronald W. Reagan, George H. W. Bush). N´eanmoins,il existe plus de liens vers
la communaut´e r´epublicaine (4) que vers la communaut´e d´emocrate (3), c’est
l’une des raisons qui ont pu le placer dans le parti r´epublicain lors du premier
chevauchement. Les autres livres ont une appartenance politique, mais restent
proches de la fronti`ere des communaut´es. Ils sont chevauch´es avec la commu-
naut´e neutre.

Livres
Ghost Wars
Ghost Wars
Ghost Wars
Disarming
Disarming
Rise of the Vulcans
The choice
The great unraveling
American Dynasty

D´emocrates

Neutres

Resultats avec fd
√
√
√
√
√
√
√
√

√
√
√
√
√
√

R´epublicains

√
√
√
√
√
√

Tableau 3.29 – Les livres chevauchants

Livres
Ghost Wars
Ghost Wars
Ghost Wars
Disarming
Disarming
Rise of the Vulcans
The choice
The great unraveling
American Dynasty

D´emocrates

Neutres

Resultats avec fcc
√
√
√
√
√
√
√
√
√

√
√
√
√
√

R´epublicains

√
√

√
√

Tableau 3.30 – Les livres chevauchants

α
0.5
0.6
0.7
0.6
0.7
0.7
0.7
0.7
0.7

α
0.5
0.6
0.7
0.7
0.7
0.7
0.7
0.7
0.7

3.4. PROPOSITIONS SUR LE CHEVAUCHEMENT

155

Les r´eseaux de collaborations scientiﬁques de Newman (Netscience)

Ce graphe repr´esentant des collaborations scientiﬁques entre chercheurs est ca-
ract´eris´e par une tr`es faible densit´e 0.0021. Les tailles de communaut´es d´etect´ees
sont tr`es petites. Observant le tableau 3.31, c’est pour α ≥ 0.4 que les premiers
nœuds chevauchants apparaissent. Le nombre d’arˆetes entre communaut´es est
relativement faible, de 2.39% d’arˆetes avec α ≥ 0.2 `a 18.27% avec α ≥ 0.8,
impliquant un faible pourcentage de candidats. Seulement 0.61% de nœuds sont
candidats avec α ≥ 0.4 tandis que l’on obtient 6.36% pour fd. Pour chacune
des m´ethodes, le pourcentage de chevauchement est tr`es similaire et relative-
ment faible. Observant la modularit´e, les r´esultats sont tr`es similaires. On peut
conclure que pour des graphes faiblement denses, les r´esultats sont tr`es similaires
en utilisant les fonctions fond´ees sur la densit´e ou sur le coeﬃcient de clustering.

fd
α ≥ 0.2
α ≥ 0.3
α ≥ 0.4
α ≥ 0.5
α ≥ 0.6
α ≥ 0.7
α ≥ 0.8
fcc
α ≥ 0.2
α ≥ 0.3
α ≥ 0.4
α ≥ 0.5
α ≥ 0.6
α ≥ 0.7
α ≥ 0.8

CandOv (nombre)

0.0%
0.0%

CandOv (nombre)

0.616% (9)
0.684% (10)
2.396% (35)
4.517% (72)
6.366% (101)

Resultats avec fd sur Netscience
QN ic
AEC
Ov
2.396% 0.977
4.175% 0.972
5.79%
0.948
7.734% 0.940
12.731% 0.886
15.332% 0.845
18.275% 0.817
QN ic
AEC
Ov
2.396% 0.977
4.175% 0.972
3.146% 0.949
4.232% 0.942
6.966% 0.886
0.855
8.39%
10.0%
0.813

Cand
3.285%
5.544%
7.392%
9.240%
14.099%
16.016%
18.07%
Cand
3.285%
5.544%
7.392%
9.240%
14.1%
16.016%
18.07%

0.0%
0.0%

0.548% (8)
0.616% (9)
2.164% (36)
5.339% (85)
7.05% (112)

#
293
297
308
315
342
360
371
#
293
297
308
315
342
360
371

Tableau 3.31 – Cand : Candidats possibles, CandOv : Pourcentage de nœuds chevau-
chants

3.4.5 Etude portant sur le temps d’ex´ecution

Le temps d’ex´ecution de l’algorithme d´epend `a la fois du temps n´ecessaire au
calcul des N propagations de labels alimentant la matrice de fr´equence ∆CDLP
(incluant le temps de cr´eation du nouveau graphe qui induit la recherche des
composantes connexes qui sont nos communaut´es) et le temps de calcul de la
fonction d’appartenance ∆f onction. Le temps de lecture et d’´ecriture des ﬁchiers

156

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

n’est pas pris en compte. Le temps d’ex´ecution est ainsi d´ecompos´e de la mani`ere
suivante : ∆T = ∆CDLP + ∆f onction.

Concernant le temps d’ex´ecution du CDLP, ﬁgure a) 3.51, le temps est
presque constant, avec une tr`es l´eg`ere diminution lorsque α augmente. Plus α est
´elev´e, plus le nombre d’arˆetes du graphe seuill´e devient faible. Par cons´equence,
le temps d’ex´ecution pour le calcul des composantes connexes diminue.

Pour la fonction d’appartenance fond´ee sur la densit´e des communaut´es, ﬁ-
gure b) 3.51, en observant tous les r´eseaux, le temps est quasi-lin´eaire jusqu’`a
ce qu’une cassure intervienne `a α ≤ 0.8, o`u parall`element le temps augmente
soudainement, de mˆeme que l’AEC et par voie de cons´equence, le nombre de
candidats potentiels au chevauchement. Le nombre de combinaisons devenant
de plus en plus important, le temps augmente. Nous voyons ´egalement que plus
la densit´e du graphe est ´elev´ee, plus le temps de calcul de fd est important.

Concernant la fonction d’appartenance fond´ee sur le cœﬃcient de clustering,
deux choses sont `a consid´erer : le temps de calcul du CCL et le nombre potentiel
de candidats au chevauchement. D’apr`es la ﬁgure b) 3.51, les temps ne sont pas
constants. Pour le r´eseau des dauphins, le temps augmente jusqu’`a α ≥ 0.5,
et diminue juste apr`es. Cela vient du fait que dans les grosses communaut´es,
le temps de calcul du CCL est plus important. Avec une forte valeur de α, le
temps de calcul du CCL diminue alors que le nombre de candidats potentiels
au chevauchement augmente, avec un nombre de combinaisons plus important
pour la fonction d’appartenance. Pour α ≥ 0.8, le temps d’ex´ecution augmente
brutalement.

Figure 3.51 – Temps d’ex´ecution du CDLP, l’axe horizontal repr´esentant la valeur α
et l’axe vertical repr´esentant le temps en secondes. a) Temps du CDLP b) Temps de
fd c) Temps du fcc

3.4.6 Analyse comparative

Nous comparons nos propositions algorithmiques avec celles issues de la
litt´erature les plus utilis´ees, `a savoir : CFinder Palla et al. (2005), COPRA
(ν = 2 et ν = 3 Gregory (2010), ν ´etant le nombre de communaut´es auquel un
nœud appartient), OSLOM Lancichinetti et al. (2011), SLPA Xie et al. (2011),

3.4. PROPOSITIONS SUR LE CHEVAUCHEMENT

157

et CONGA Gregory (2007).

Analyse comparative

F1

Ω

NMI

0.48
0.86
0.65
0.281
0.684
0.86
0.852
0.852

0.701
0.954
0.823
0.933
0.944
0.748
0.854
0.854

0.57
1.0
0.85
0.933
0.893
0.56
1.0
1.0

0.855
0.814
0.688
0.687
0.702
0.755
0.784
0.788

0.35
0.84
0.113
0.266
0.359
0.633
0.711
0.711

0.64
0.802
0.321
0.788
0.747
0.684
0.865
0.865

0.35
0.914
0.892
0.788
0.767
0.754
1.0
1.0

0.740
0.704
0.651
0.637
0.649
0.648
0.654
0.667

0.18
0.80
0.274
0.228
0.347
0.564
0.518
0.518

0.55
0.759
0.423
0.705
0.712
0.612
0.751
0.751

0.26
0.852
0.821
0.751
0.701
0.632
1.0
1.0

0.79
0.55
0.49
0.385
0.416
0.497
0.495
0.503

R´eseaux
Zac #2
CFinder
OSLOM
CONGA
COP RA2*
COP RA3*
SLPA*
CDLPOV fd*
CDLPOV fcc*
Foot #12
CFinder
OSLOM
CONGA
COP RA2*
COP RA3*
SLPA*
CDLPOV fd*
CDLPOV fcc*
SW
CDLPOV fd*
CDLPOV fcc*
#2
CFinder
OSLOM
CONGA
COP RA2*
COP RA3*
SLPA*
CDLPOV fd*
CDLPOV fcc*
Pol #4
CFinder
OSLOM
CONGA
COP RA2*
COP RA3*
SLPA*
CDLPOV fd*
CDLPOV fcc*
NS
CDLPOV fd*
CDLPOV fcc*

QN ic
Ov

0.52
0.748
0.441
0.414
0.452
0.608
0.621
0.621

0.51
0.696
0.451
0.693
0.668
0.715
0.699
0.699
0.502∗
0.157∗

0.66
0.742
0.746
0.693
0.677
0.742
0.796
0.796

0.884
0.847
0.779
0.825
0.827
0.83
0.844
0.834

0.977
0.977

#

3
2
2

11.3
6.4
2.12

4
4

13
12
11
10.8
11.2
10.30

11
11

4
4

4
2
2

10.8
3.7
3.44

2
2

4
2
4
3
2.8
3.40

3
2

293
293

%

5.88%
2.94%
2.94%
5.58%
12.64%
2.20%
8.82%
8.82%

6.9%
0.0%
60.0%
0.52%
2.52%
1.69%
0.0%
0.0%

25.0%
65.6%

3.72%
1.61%
3.22%
0.52%
7.73%
2.00%
0.0%
0.0%

(9)

1.90%
4.16%
1.05%
6.47%
12.5%
1.90%
0.0%

0.0%
0.0%

Tableau 3.32 – (*) algorithmes `a base de propagation de labels

158

CHAPITRE 3. PROPOSITIONS ALGORITHMIQUES

Nous montrons les r´esultats de nos m´ethodes donnant les scores des me-
sures non supervis´ees les plus ´el´ev´es dans le tableau 3.32. Nos propositions
algorithmiques donnent d’assez bons r´esultats en termes de qualit´e. Nous ob-
tenons de meilleurs r´esultats que COPRA et une meilleure stabilisation. Mˆeme
si les algorithmes `a base de propagation de labels produisent en moyenne plus
de communaut´es, le CDLP avec fd et fcc en produit moins. Nous expliquons ce
fait par la pr´esence de la matrice de fr´equence qui stabilise la propagation de
labels.

3.4.7 Conclusion sur les propositions algorithmiques che-

vauchantes

Nous avons propos´e deux m´ethodes appliqu´ees `a la propagation de label
par cœurs pour la d´etection de communaut´es chevauchantes. Chacune de ces
m´ethodes utilise la matrice de fr´equence et les caract´eristiques sociales et topo-
logiques des communaut´es pour savoir si certains nœuds peuvent appartenir `a
plusieurs communaut´es. Les utilisateurs ont le choix entre laisser l’algorithme
assigner de possibles candidats au chevauchement `a un nombre sp´eciﬁque de
communaut´es auxquelles ces nœuds appartiendraient, ou laisser les fonctions
d’appartenance tester toutes les combinaisons pour des assignations automa-
tiques. Les fonctions d’appartenances sont fond´ees sur la densit´e (fd), le CC
(fcc) et sur les communaut´es d´etect´ees. Les r´esultats selon les diﬀ´erentes fonc-
tions sont assez similaires en termes de qualit´e. N´eanmoins, le taux d’assigna-
tion de nœuds chevauchants `a un plus grand nombre de communaut´es est plus
important avec fd qu’avec fcc. Concernant le temps d’ex´ecution, plus la den-
sit´e du graphe ´etudi´e est importante, plus le nombre de candidats est grand,
augmentant ainsi le nombre de combinaisons `a tester pour nos fonctions, et par
cons´equence le temps augmentera. Nous avons vu que calculer les 100 LPA pour
alimenter la matrice de fr´equence est assez rapide, (1 seconde pour Zachary et
6 secondes pour NS). N´eanmois, le temps de calcul de fcc est plus important
que celui de fd. Cela vient du calcul du nombre de triangles au sein des commu-
naut´es pour calculer le CCL. Le temps de calculs des deux fonctions augmente
parall`element `a α. Mais `a partir d’un seuil (α ≥ 0.8 ou α ≥ 0.9 selon les graphes
test´es), le temps devient tr`es important. Pour α ≥ 0.5 , nous avons besoin de
30 secondes pour calculer fd et 60 secondes sur NS. Pour α ≥ 0.8, nous avons
besoin d’une centaine de secondes pour calculer fd et fcc toujours sur NS. Pour
les r´eseaux portant sur Zachary, les dauphins, SW ou les livres politiques, il
faut approximativement 10 secondes pour fd et pr`es de 20 secondes avec fcc.
Les perspectives seront pr´esent´ees au chapitre 4.

Chapitre 4

Propositions algorithmiques
sur la d´etection de
communaut´es parall`eles et
distribu´ees

Sommaire

4.1 Propagation de labels avec d´etection de cœurs

avec Apache Hadoop . . . . . . . . . . . . . . . . . 160

4.1.1 Proposition algorithmique pour la propagation de

labels parall`ele et distribu´ee avec d´etection de cœurs 161

4.1.2 Mod´elisation MapReduce de PAR-CDLP . . . . . . 161

4.1.3 Cr´eation d’un dendrogramme . . . . . . . . . . . . . 171

4.2 Exp´erimentations

. . . . . . . . . . . . . . . . . . . 173

4.2.1 Etude de la stabilisation . . . . . . . . . . . . . . . . 173

4.2.2 Etude sur de grands graphes de terrains . . . . . . . 174

4.2.3 Etude volum´etrique trait´ee par le HDFS . . . . . . . 183

4.3 Conclusion portant sur les propositions li´ees au

parall´elisme et la distribution . . . . . . . . . . . . 186

Dans le chapitre pr´ec´edent, nous avions pr´esent´e des propositions algorith-
miques permettant la d´etection de communaut´es disjointes et chevauchantes.
Cependant, dans un monde o`u le volume des donn´ees devient de plus en plus
important, il est utile de pouvoir retranscrire nos propositions algorithmiques
pour de grands graphes.

Ce chapitre aura comme objectif de pr´esenter une version parall`ele et dis-
tribu´ee du CDLP sous Apache Hadoop. Nous testerons notre framework sur

159

160CHAPITRE 4. PROPOSITIONS SUR LE PARALL ´ELISME ET LA DISTRIBUTION

quatre grands graphes de la litt´erature et eﬀectuerons une ´etude comparative
avec d’autres algorithmes issus de la litt´erature.

4.1 Propositions sur le parall´elisme et la distri-

bution

Apache Hadoop est une architecture permettant d’eﬀectuer du calcul pa-
rall`ele et distribu´e pour r´epondre aux traitements des donn´ees de taille massive.
Comme nous l’avons vu au chapitre 1, Hadoop poss`ede un framework MapRe-
duce compos´e de deux fonctions, un mapper et un reducer.

La propagation de labels peut s’eﬀectuer de mani`ere synchrone ou asyn-
chrone (cette derni`ere ´etant plus stable et oﬀrant une meilleure qualit´e de par-
titionnement). Cependant, la m´ethode asynchrone n´ecessite la mise en place
d’un ordre de visite sur les nœuds (qui peut ˆetre al´eatoire) aﬁn d’eﬀectuer les
changements de labels pour chacun des nœuds. Cette op´eration s’eﬀectue d’or-
dinaire de mani`ere s´equentielle. C’est-`a-dire que lorsqu’un nœud a son label
modiﬁ´e, les autres nœuds du graphe sont inform´es et un autre nœud change
son label par un vote majoritaire en utilisant la nouvelle information. Cela peut
ˆetre fait pour de petits graphes, mais pas pour de grands r´eseaux. Il ne serait
pas souhaitable d’avoir un graphe de plusieurs centaines de milliers de nœuds et
de visiter s´equentiellement chacun d’entre eux pour en modiﬁer le label. C’est
en ce sens que nous proposons d’utiliser la m´ethode semi-synchrone pour eﬀec-
tuer un changement de label qui puisse ˆetre parall`ele et distribu´e. Pour rendre
l’algorithme semi-synchrone plus d´eterministe, nous utilisons la matrice de co-
fr´equence. La propagation de labels semi-synchrone consiste `a colorier le graphe
de telle sorte que chaque nœud du graphe ait une couleur diﬀ´erente de celle
de ses voisins. La propagation de labels se fait en suivant les nœuds ayant une
mˆeme couleur. Ainsi, lorsqu’un nœud met `a jour son label par un vote majori-
taire, son label est chang´e alors que celui de ses nœuds voisins ne l’est pas. Ce
processus se fait sur tous les nœuds ayant la mˆeme couleur. Puis, on fait savoir
aux nœuds voisins le nouveau label du nœud derni`erement modiﬁ´e. On passe
alors `a une autre couleur pour continuer la propagation de label. Le processus
consiste donc `a colorier, propager les labels des nœuds ayant une couleur donn´ee,
faire une mise `a jour des voisins des nœuds ayant subi une modiﬁcation de leurs
labels puis r´ep´eter les phases de propagation de labels et de mise `a jour sur les
nœuds restants. Ce sont ces op´erations que nous avons mises sous forme Ma-
pReduce pour parall´eliser et distribuer le CDLP. Nous rappelons que le CDLP
a deux param`etres principaux qui sont le seuil α (utilis´e apr`es l’alimentation
de la matrice de fr´equence pour cr´eer un nouveau graphe pond´er´e) et le nombre
de propagations de labels (N ) lanc´ees en parall`ele. En utilisant le seuil α, les
composantes connexes ainsi cr´e´ees repr´esentent les communaut´es.

4.1. PROPAGATION DE LABELS AVEC D ´ETECTION DE CŒURS AVEC APACHE HADOOP161

4.1.1 Proposition algorithmique pour la propagation de
labels parall`ele et distribu´ee avec d´etection de cœurs

Nous exposons la propagation de labels parall`ele et distribu´ee avec d´etection
de cœurs, Algorithme 8. Il s’agit de la version parall`ele et distribu´ee du CDLP
pr´esent´e au Chapitre 2. La complexit´e de l’algorithme est en O(N × k × (m) +
n + m + n2 × m).

Algorithme 8 La propagation de labels semi-synchrone parall`ele et distribu´ee
avec d´etection de cœurs PAR-CDLP
Input : Un graphe G = (V, E), un seuil α, N le nombre de propagations de

labels

trice P N

ij

Output : Les communaut´es trouv´ees par l’algorithme sur le graphe G = (V, E)
1: Eﬀectuer une coloration du graphe G, D = {D1, D2, ..., Dl} (de l parties)
2: Allouer une matrice de co-fr´equence vide P N
3: Appliquer N fois la propagation de labels semi-synchrone et remplir la ma-

ij

poids sup´erieur ou ´egal `a α

4: Cr´eer un nouveau graphe G(cid:48) = (V, E(cid:48)) issu deP N
ij , dont les arˆetes ont un
5: Cr´eer une partition P en consid´erant les C composantes connexes comme
6: Retourner la partition P = {P1, ..., PC}.

cœurs

4.1.2 Mod´elisation MapReduce de PAR-CDLP

Notre proposition algorithmique comprend 4 grandes parties :
— la mise en place d’un algorithme de coloriage de graphe
— le lancement de N propagations de labels semi-synchrones
— l’alimentation d’une matrice de co-fr´equence
— la d´etection des composantes connexes avec un seuil α

Dans la suite de cette section, nous proposons de suivre un petit exemple vi-
suel pour une meilleure compr´ehension du d´eveloppement de PAR-CDLP. Nous
consid´erons un ﬁchier d’arˆetes o`u chaque ligne repr´esente un lien i− j (et j − i),
Figure 4.1.

Etape de coloration de graphe :

Cette ´etape consiste `a attribuer `a chaque nœud une couleur de telle sorte
que deux nœuds adjacents n’aient pas la mˆeme couleur. C’est `a partir de cette
couleur que la propagation de labels semi-synchrone pourra ˆetre eﬀectu´ee, o`u les
nœuds ayant une mˆeme couleur vont changer leur label en fonction de leur voi-
sinage, qui a une couleur diﬀ´erente. Nous commen¸cons avec un ﬁchier contenant

162CHAPITRE 4. PROPOSITIONS SUR LE PARALL ´ELISME ET LA DISTRIBUTION

Figure 4.1 – Exemple avec un triangle pour l’illustration de notre proposition algo-
rithmique PAR-CDLP.

toutes les arˆetes du graphe sous la forme i−j et j−i comme le montre l’exemple
Figure 4.1. Un algorithme de coloration est appliqu´e. Une implantation d’un
tel algorithme a ´et´e propos´ee par Gandhi et Misra (2015). Le r´esultat est un
ﬁchier contenant les r´esultats de la nouvelle coloration avec les lignes i − j − Cj
et j − i − Ci, o`u Ci est la couleur du nœud i, Figure 4.2.

Figure 4.2 – Exemple avec un triangle ayant subi une coloration de graphe

Propagation de label semi-synchrone :

A chaque nœud est associ´e une vecteur de labels qui permet d’eﬀectuer les N
propagations de labels en parall`ele. Chaque couleur servira d’ordre de visite sur
le graphe avec l’intention de faire la mise `a jour des labels aﬁn de faire la propa-
gation de labels semi-synchrone. Une ´etape suivante de mise `a jour consistera `a
transmettre les nouveaux labels aux nœuds voisins qui n’ont pas encore connu
de mise `a jour de leur label.

Le premier job consiste en une fonction FirstReadMap, Algorithme 9, et
une fonction FirstReadReduce, Algorithme 10. Le mapper FirstReadMap
lit le ﬁchier d’entr´ee et ´emet j − li − i − Ci o`u li est un vecteur de taille N ,
contenant le label courant du nœud i pour les N diﬀ´erentes propagations de
labels. Nous notons par |li| la taille du vecteur li. Initialement, chaque nœud
a son propre label pour les N propagations de labels, li = [i, i, ..., i]. La ligne

4.1. PROPAGATION DE LABELS AVEC D ´ETECTION DE CŒURS AVEC APACHE HADOOP163

j − li− i− Ci signiﬁe que le nœud j va recevoir le vecteur li du nœud i. Le nœud
j connaˆıtra donc les labels de son voisin i pour les N propagations de labels.
La phase de shuﬄing groupe les nœuds selon le nœud j qui re¸coit l’information
pour la phase de r´eduction. Les reducers, prenant comme cl´e sp´eciﬁque j et
comme valeur, les lignes j o`u ´etait le receveur lors de la phase de map, ´emettent
j − li − Ci sans faire la moindre op´eration, Figure 4.3.

Figure 4.3 – R´esultats de la fonction FirstReadMap avec N = 5

La seconde partie consiste en une boucle sur deux jobs. Le premier job r´ealise
un vote sur les nœuds de la couleur courante. Cela consiste en VoteMap, Al-
gorithme 11 et VoteReduce, Algorithme 12. Le second job eﬀectue une mise
`a jour sur les nœuds ayant transmis l’information ou sur les nœuds concern´es
par la prochaine propagation de labels (comme les voisins des nœuds ayant subi
une modiﬁcation de leur label). Cela consiste en UpdateMap, Algorithme 11
et UpdateReduce, Algorithme 13. La boucle sur ces deux jobs se fonde sur
la coloration comme compteur (le vote ayant lieu pour les nœuds de la couleur
courante).

164CHAPITRE 4. PROPOSITIONS SUR LE PARALL ´ELISME ET LA DISTRIBUTION

Algorithme 9 FirstReadMap
Entr´ee : N le nombre de lancements, Map( Cl´e : Nom du ﬁchier, Valeur :
ﬁchier d’arˆetes repr´esentant un graphe G = (V, E) avec la coloration
(i − j − Cj))

Sortie : ´emettre les lignes (j − lj − i − Cj) ,avec |lj| = N
1: lj ←− [] {vecteur pour les N propagations de labels diﬀ´erentes}
2: Pour ligne dans valeur Faire
3: Pour j = 0 `a N Faire

lj.ajouter(label(i)) {label(i) est le label du nœud i}

4:
5:
6: Fin Pour
7: Emettre(j − lj − i − Cj) {la ligne contient N + 3 ´el´ements du fait que lj

Fin Pour

contient N ´el´ements, j, i et Cj, juste un pour chaque}

It´erateur [ [lj − Cj],...)

Algorithme 10 FirstReadReduce
Entr´ee : N le nombre de lancements, Reduce(Cl´e
Sortie : ´emettre les lignes (i − lj − j − Cj) avec |lj| = N
1: Pour ligne dans Itvaleur Faire
2: Emettre (j − line) {´equivalent `a j − lj − i − Cj, avec une longueur de
N + 3 ´el´ements, du fait que li contient N ´el´ements, j, i et Cj, une pour
chacune}
3: Fin Pour

: nœud i,

Itvaleur

:

Algorithme 11 VoteMap,UpdateMap,CommunityMap,GPrimAlphaMap
Entr´ee : N le nombre de lancements, Map( Cl´e : nom de ﬁchier , Valeur :
ﬁchier d’arˆetes avec la propagation de labels avec couleurs (j − li − i − Cj))
Sortie : ´emettre des lignes j − lj − i − Cj (avec |lj| = N )
1: lj ←− [] {vecteur pour les N propagations de labels}
2: Pour ligne dans Valeur Faire
3: Emettre(j − li − i − Cj) {ligne contenant N + 3 ´el´ements, du fait que li

contient N ´el´ements, j, i et Cj, une pour chaque ligne}

4: Fin Pour

4.1. PROPAGATION DE LABELS AVEC D ´ETECTION DE CŒURS AVEC APACHE HADOOP165

Algorithme 12 VoteReduce
Entr´e : N le nombre de lancements, Reduce(Cl´e : j, It´erateur valeurs : lignes
avec la propagation de labels et coloration [[(li − i − Cj)],...]) {valeurs est
un vecteur de vecteurs, on note par valeurs[k] le kth ´el´ement du vecteur
valeurs}

Sortie : ´emettre des lignes (j − lj − i − Cj) avec |lj| = N
1: couleur actuelle ←− lignevaleurs[k][N + 3] {valeurs[k][N + 3] correspond `a

la couleur du nœud j pour le kith ´el´ement du vecteur valeurs}

2: Si couleur actuelle = Cj Alors
3:
4:

liste de vote ←− [] {vecteur pour les N propagations de labels}
nouvelle ligne de labels ←− [] {vecteur pour les N propagations de la-
bels}

5: Pour w = 0 `a N par pas de 1 Faire

Pour k = 0 `a T aille(values) par pas de 1 Faire

{utilisation d’une double boucle Pour pour permettre de faire le vote
colonne par colonne, pour les N propagations de labels diﬀ´erentes}
liste de vote.ajouter(values[w][k]) {valeurs[w][k] r´ef`ere au label du
kth voisin du nœud j de la wth propagation de labels}

6:
7:

8:

9:

15:

Fin Pour
vote majoritaire ←− arg maxl |N l(j)| utilisant liste de vote
ligne de nouveaux .ajouter(vote majoritaire)

10:
11:
12:
13: Pour k = 0 `a T aille(valeurs) par un pas de 1 Faire
14:

valeurs[k][N +2]

Fin Pour

-

- nouvelle ligne de labels

Emettre(j
cou-
leur actuelle) {valeurs[k][N + 2] est le nœud transmetteur pour
les labels, }
Emettre(valeurs[k][N +2]−nouvelle ligne de labels−couleur actuelle−
”∗”) {le signe ”∗” sera utilis´e pour la mise `a jour des labels du voisinage
du nœud transmettant la nouvelle information. Elle sera `a la position
(N + 2) de la ligne ´emise}

-

Fin Pour
Emettre( j − li − i − Cj)

16:
17: Sinon
18:
19: Fin Si

166CHAPITRE 4. PROPOSITIONS SUR LE PARALL ´ELISME ET LA DISTRIBUTION

Algorithme 13 UpdateReduce
Entr´ee : N le nombre de lancements, Reduce(Cl´e : j, It´erateur valeurs : lignes
avec propagation de labels, coloration et nœuds `a mettre `a jour [[(li − i −
Cj)],[li − i − ” ∗ ”],...]
Sortie : ´emettre les lignes

j − lj − i − Cj (with |lj| = N )

1: Pour w = 0 `a Taille(valeur) par pas de 1 Faire
2:
3:

Si valeurs[w][N + 1] = ” ∗ ” Alors
nœud a modif ier ←− valeurs[w][N ]
nouveaux labels ←− valeurs[w]
Pour k = 0 `a Taille(valeurs) par pas de 1 Faire

Si non(” ∗ ” dans values[k]) et (nœud a modif ier = valeurs[w][N ])
Alors

values[k] ←− nouveaux labels {Phase de mise `a jour}

4:
5:
6:

7:
8:

Sinon

Ne rien faire

Sinon

Ne rien faire

Fin Si
Fin Pour

9:
10:
11:
12:
13:
Fin Si
14:
15: Fin Pour
16: Pour k = 0 `a Taille(valeurs) par pas de 1 Faire
17:
18:

Si pas(” ∗ ” dans valeurs[k]) Alors
Emettre(j − valeurs[k]) { ´equivalent `a j − nouveaux labels − i − Cj
(avec |nouveaux labels| = N )}

19:

Sinon

Ne rien faire

20:
Fin Si
21:
22: Fin Pour

4.1. PROPAGATION DE LABELS AVEC D ´ETECTION DE CŒURS AVEC APACHE HADOOP167

bels}

nœud j}

avec propagation de labels et coloration [[(li − i − Cj)],...])

Algorithme 14 CommunityReduce
Entr´ee : N le nombre de lancements, Reduce(Cl´e : j, It´erateur valeurs : lignes
Sortie : ´emission de lignes i − li (avec |li| = N )
1: couleur actuelle ←− ligne[N + 3] {ligne[N + 3] correspond `a la couleur du
2: liste des votes ←− [] {vecteur pour les N propagations de labels}
3: ligne de nouveaux labels ←− [] {vecteur pour les N propagations de la-
4: Pour w = 0 `a N par pas de 1 Faire
5: Pour k = 0 `a T aille(values) par pas de 1 Faire
6:

liste des votes.ajouter(valeurs[w][k]) {valeurs[w][k] r´ef`ere au label du
kieme voisin du nœud j `a la wieme propagation de label}
Fin Pour
vote majoritaire ←− arg maxl |N l(j)| avecg liste des votes
ligne de nouveaux labels.ajouter(vote majoritaire)

8:
9:
10: Fin Pour
11: Pour k = 0 `a T aille(valeurs) par pas de 1 Faire
12: Emettre(valeurs[k] [N + 2 ] - ligne de nouveaux labels) {Un dernier
vote est fait, valeurs[k][N + 2] est ´equivalent au nœud i, ainsi (i −
ligne de nouveaux labels)}

7:

13: Fin Pour

chier d’arˆetes avec propagation de labels i li)

Algorithme 15 OccurrenceMatrixMap
Entr´ee : N le nombre de lancements, Map(Cl´e : nom du ﬁchier , valeur : ﬁ-
Sortie : ´emission de lignes k − i − lk
1: lj ←− [] {vecteur pour les N propagations de labels}
2: Pour line in Input Faire
3: Pour k = 0 to N Faire
Emettre(k − i − lk

i ) {label(i) signiﬁe le label du nœud i }

i (pour la kth propagation de labels du

nœud i)

4:
5:
6: Fin Pour

Fin Pour

168CHAPITRE 4. PROPOSITIONS SUR LE PARALL ´ELISME ET LA DISTRIBUTION

valeurs [[i1, 1], [i2, 1], ..., [iK, 1]], r´eel : α )

Algorithme 16 GPrimAlphaReduce -α
Entr´ee : N le nombre de lancements, Reduce(Cl´e : nœud i, Valeur : It´erateur
Sortie : ´emission de lignes (nœud i− nœud j − αij) avec αij ≥ α et i > j
1: Pour v ∈ valeurs Faire
3: N bOcc ←− nombre d’occurrences du nœud v dans valeurs

depuis que la matrice est sym´etrique

2:

Somme ←− 0
Si N bOccN ≥ α Alors
αiv ←− N bOccN
Emettre (i, v, αi,v)

4:

5:
6:

Ne rien faire

Sinon

7:
8:
Fin Si
9:
10: Fin Pour

Si k est le nombre de couleurs, les votes auront lieu pour les nœuds ayant la
couleur C1, suivis d’une mise `a jour (permettant la mise `a jour des labels pour
les nœuds ´emetteurs ou concern´es par ces changements de labels). C’est ensuite
pour les nœuds ayant la couleur C2 que le vote s’eﬀectue, suivi ´egalement d’une
mise `a jour. Le processus continue jusqu’`a parvenir `a la couleur Ck.
VoteMap consiste `a ´emettre j − li − i − Cj, aucune op´eration sp´eciﬁque n’est
eﬀectu´ee. La phase de shuﬄing permet de trier les donn´ees selon le nœud j, qui
sera mis `a jour si Cj est la couleur du nœud actuel consid´er´e. Toutes les lignes
avec la mˆeme cl´e j vont dans le mˆeme reducer. VoteReduce prend comme cl´e
le nœud j et comme valeur, des vecteurs de labels des nœuds qui sont voisins
du nœud j.

VoteReduce fait un vote pour le nœud j si la couleur associ´ee `a j est la
couleur actuelle. Cela aura pour cons´equence la mise `a jour du vecteur de labels.
Pour chacune des N propagations de labels, le vote majoritaire est fait suivant
le LPA standard, colonne par colonne, par utilisation des vecteurs de labels des
nœuds qui sont voisins du nœud j, dans ce cas lj1, lj2 , ..., ljk (si le nœud j a k
voisins). Le reducer ´emet pour le nœud j son nouveau vecteur de labels qui est
re¸cu de ses voisins, j − lnouveau
est le nouveau vecteur de
labels de i qui est transmis `a j, r´esultant du vote. Une information de mise `a
jour est aussi ´emise pour les nœuds qui sont concern´es par le nouveau label du
nœud j, en ´emettant i−lnouveau
−j−∗, ∗ permettant de connaˆıtre l’information
de mise `a jour et i ´etant le nœud dont le vecteur de propagation de labels sera
mis `a jour pour le prochain job. Nous donnons un petit exemple avec l’exemple
du triangle `a Fig. 4.4.

− i − Cj o`u lnouveau

i

i

i

4.1. PROPAGATION DE LABELS AVEC D ´ETECTION DE CŒURS AVEC APACHE HADOOP169

Figure 4.4 – a) Les r´esultats de VoteMap avec VoteReduce, b) UpdateMap avec
UpdateReduce

Le job comprenant UpdateMap Algorithme 11 et UpdateReduce, Algo-
rithme 13 eﬀectue la mise `a jour d’information des nœuds qui sont aﬀect´es
directement par les changements de labels du dernier VoteReduce. Pour sa-
voir quels nœuds sont concern´es, nous utilisons les lignes contenant le symbole
”*”, ´emis par VoteReduce.

UpdateMap : Cette fonction lit les donn´ees, et ´emet chaque ligne sans faire

170CHAPITRE 4. PROPOSITIONS SUR LE PARALL ´ELISME ET LA DISTRIBUTION

de modiﬁcation. Aucune op´eration sp´eciﬁque n’est eﬀectu´ee. La phase de shuf-
ﬂing permet de trier les donn´ees selon le nœud receveur j.
UpdateReduce : Cette fonction prend en param`etre les donn´ees ayant la mˆeme
cl´e j, et comme valeur, un it´erateur avec les diﬀ´erentes propagations de labels
− j −∗). Pour chaque partie ayant la mˆeme
(j − lnouveau
cl´e, si la fonction d´etecte le symbole ∗, une mise `a jour se fera sur les lignes
sujettes `a l’ancienne propagation de labels (des nœuds voisins ou des nœuds
transmetteurs d’information). Ainsi, les lignes j − lnew
i − i − ∗ serviront `a faire
la mise `a jour des lignes de la forme i − li − j − Ci.

− i− Cj et i− lnouveau

i

i

La troisi`eme ´etape consiste `a donner `a chaque nœud un vecteur de label,
sans coloration. Cette ´etape est r´ealis´ee par le job comprenant CommunityMap,
Algorithme 11, et CommunityReduce, Algorithme 14. Les r´esultats seront
utilis´es pour la phase de d´etection de cœurs.

MapCommunity : Cette fonction, Algorithme. 9, lit les donn´ees, et ´emet
chaque ligne sans aucune modiﬁcation. Aucune op´eration sp´eciﬁque n’est ef-
fectu´ee. la phase de shuﬄing permet de trier les donn´ees sur le disque suivant
le nœud receveur j. La signature de cette fonction est : CommunityMap (Cl´e :
ﬁchier (j − li − i − Cj) → (Cl´e : j, Valeur : (li, i, Cj))).

CommunityReduce : Cette fonction re¸coit comme entr´ee toutes les lignes
ayant la mˆeme cl´e j et leurs vecteurs de labels, les nœuds voisins et la couleur
relative comme valeur. Pour chaque ligne j, un dernier vote est fait de telle
sorte que le reducer ´emette chaque nœud avec son vecteur de labels associ´e :
j − li − i − Ci(∀i ∈ V (j)) → i − lnouveau
. La signature de cette fonction est :
CommunityReduce(Cl´e : j , Valeur : It´erateur ([[li − i − Cj], ...]) → (Cl´e : i,
Valeur : (lnouveau

))).

i

i

La quatri`eme partie consiste `a remplir une matrice de co-fr´equence, P N

ij , o`u
la colonne i et la ligne j repr´esentent le nombre de fois que les nœuds i et j
sont ensemble durant les N diﬀ´erentes propagations de labels. Ce job consiste
en OccurrenceMatrixMap, Algorithme 15 et OccurrenceMatrixReduce.
Le mapper retourne pour chaque propagation de labels le nœud avec sa couleur
associ´ee et le reducer ´emet chaque paire de nœuds qui sont ensemble durant les
N propagations de labels avec le chiﬀre ”1”.

OccurrenceMatrixMap prend comme entr´ee i − li (le nœud et son vec-
teur associ´e de labels) et retourne rk − i − lk
i o`u rk est la kieme propagation de
labels et lk
i , le kieme label correspondant au nœud i. La phase de shuﬄing trie
les donn´ees selon la cl´e rk, soit la kieme propagation de labels. La signature de
cette fonction est : OccurrenceMatrixMap(Cle : ﬁchier (i − li) → (Cl´e : rk,

4.1. PROPAGATION DE LABELS AVEC D ´ETECTION DE CŒURS AVEC APACHE HADOOP171

i )). OccurrenceMatrixReduce prend en param`etre rk − i − li
Valeur : (i, lk
et ´emet i − j − 1, soit chaque paire de nœuds qui sont dans les mˆemes com-
munaut´es, propagation de labels apr`es propagation de labels. La signature de
cette fonction est : OccurrenceMatrixReduce(Cle : rk , Valeur : It´erateur
([[i, lk

i ], ...]) → (Cl´e : (i, j), Valeur : 1)).

La cinqui`eme partie consiste en GPrimAlphaMap, Algorithme 11 et

GPrimAlphaReduce, Algorithme 16.
GPrimAlphaMap prend en entr´ee i − j − 1 et ´emet cette mˆeme ligne. Aucune
op´eration sp´eciﬁque n’est eﬀectu´ee. La phase de shuﬄing permet de trier la ligne
selon le nœud i. La signature de cette fonction est : GPrimAlphaMap(Cle : ﬁ-
chier (i, j, 1) → (Cle : i, j, Valeur : 1)).
GPrimAlphaReduce prend comme cl´e le nœud i, i − j − 1 et α comme
valeur. α permet d’´emettre les arˆetes dont les nœuds ont une fr´equence d’ap-
parition commune dans les mˆemes communaut´es sup´erieure ou ´egale `a ce seuil.
Cette fonction ´emet i− j− αij ou αij ≥ α, o`u αij est la fr´equence o`u les nœuds i
et j se sont trouv´es dans les mˆemes communaut´es au cours des N diﬀ´erentes pro-
pagations de labels. La signature de cette fonction est : GPrimAlphaReduce-α
(Cl´e : rk , Valeur : It´erateur ([[j, 1], ...]) → (Cl´e : (i, j), Valeur : αij)).

La derni`ere ´etape consiste `a trouver les composantes connexes qui corres-
pondent aux communaut´es. PEGASUS (Kang et al. (2009)), un outil d’ana-
lyse de r´eseaux sociaux destin´e aux grands graphes et fond´e sur le patron de
conception MapReduce oﬀre une implantation d’un algorithme de d´etection de
composantes connexes.

On peut ainsi r´esumer les diﬀ´erentes ´etapes du Par-CDLP par l’algorithme
regroupant la succession de jobs, Algorithme 17. On note qu’il est possible d’ap-
pliquer la simple propagation de label semi-synchrone (SLPH) sous Hadoop avec
N = 1 en terminant avec la fonction CommunityReduce.

4.1.3 Cr´eation d’un dendrogramme

Il est ´egalement possible de produire un dendrogramme avec notre mod`ele
Hadoop en cr´eant plusieurs jobs (GPrimAlphaMap et GPrimAlphaReduce)
avec diﬀ´erentes valeurs de α. Il est ainsi possible de cr´eer un intervalle avec
un pas ∆, et plusieurs ﬁchiers avec diﬀ´erentes valeurs de α, comme une suite
num´erique (un)min≤n≤max de telle sorte un+1 = un + ∆. Le dendrogramme
entier peut ˆetre obtenu avec u0 = 0 et max = 1. Si le niveau un+1 est le mˆeme
que le niveau un (mˆeme partitionnement, donnant les mˆemes communaut´es au

172CHAPITRE 4. PROPOSITIONS SUR LE PARALL ´ELISME ET LA DISTRIBUTION

Figure 4.5 – a) CommunityMap et CommunityReduce b) OccurrenceMatrixMap c)
GPrimAlphaMap d) GPrimAlphaReduce

4.2. EXP ´ERIMENTATIONS

173

Algorithme 17 Le CDLP
Entr´ee : Un graphe G = (V, E), le seuil α, N le nombre de lancements, ∆ le

pas

VoteMap
VoteReduce-Ci
MapUpdate
UpdateReduce

Sortie : communaut´es de G
1: FirstReadMap-N
2: FirstReadReduce
3: Pour i = 0 au nombre de couleur de G Faire
4:
5:
6:
7:
8: Fin Pour
9: CommunityMap
10: CommunityReduce
11: OccurrenceMatrixMap
12: OccurrenceMatrixReduce
13: GPrimAlphaMap
14: GPrimAlphaReduce
15: return La partition : P = {P1, ..., PC}.

nœud pr`es), le niveau un+1 n’est pas ´ecrit. Plus faible sera le pas ∆, plus grand
sera la taille de l’arbre.

4.2 Exp´erimentations

Nous exp´erimentons notre proposition algorithmique sur quatre grands graphes

de la litt´erature qui sont Amazon, DBLP, You Tube et Live Journal pour ´etudier
la qualit´e des communaut´es r´esultantes, la scalabilit´e de notre proposition al-
gorithmique, le temps d’ex´ecution et la masse des donn´ees g´en´er´ees et trait´ees.
Pour nos exp´erimentations, nous avons un cluster Hadoop de cinq machines
dont la description est au Tableau 4.1. Une ´etude comparative sera propos´ee
avec certains algorithmes de la litt´erature.

4.2.1 Etude de la stabilisation

Comme nous l’avions vu au chapitre 2, notamment pour le CDLP, un cer-
tain nombre de propagations de labels suﬃt `a stabiliser l’algorithme suivant
la topologie du graphe. Cependant, cela ne rend pas l’algorithme totalement
d´eterministe. Certaines oscillations peuvent apparaˆıtre, notamment sur les nœuds
consid´er´es comme chevauchants. Sur l’exemple de Zachary, nous avions vu qu’il
suﬃsait de 55 propagations de labels pour stabiliser la m´ethode, avec une ﬂuc-
tuation sur le nœud 10 qui est entre les deux principales communaut´es. Ainsi,

174CHAPITRE 4. PROPOSITIONS SUR LE PARALL ´ELISME ET LA DISTRIBUTION

Cluster Hadoop (5 machines Acer Predator G3-605 )

Nb. de cœurs
Nb. de threads
Fr´equence de base
Fr´equence Turbo maxi
Hadoop
Connection ethernet
Capacit´e m´emoire maxi

4 (Cor TM i7)
12
3.00 GHz
3.60 GHz
version 2.7.2
1 Gigabits entre les machines
1 TO

Tableau 4.1 – Caract´eristique du cluster Hadoop

des oscillations faisaient que nous avions 1 ou 2 communaut´es pour α ≤ 0.5. Si
l’on consid`ere de grands graphes de terrain tels qu’Amazon, DBLP, You-Tube
Ou Live Journal, des oscillations peuvent ´egalement avoir lieu. C’est ce que nous
avons pu observer et qui a rendu l’´etude de la stabilisation tr`es complexe. On
ne peut pas simplement se fonder comme indicateur sur le nombre de commu-
naut´es, la ﬂuctuation due `a certains nœuds rend l’´etude tr`es diﬃcile. Il a ´et´e
montr´e qu’il existait des milliers de structures communautaires dans les r´eseaux
que nous avons cit´es. En ayant observ´e de tr`es nombreuses oscillations, nous
ne sommes pas dans la capacit´e de conclure quant au nombre de propagations
de labels n´ecessaire. C’est actuellement une voie de recherche sur laquelle nous
portons notre attention. C’est en ce sens que nous avons d´ecid´e de poser pour la
suite de nos exp´erimentations N = 200. Nous proposons ´egalement une ´etude
sur la propagation de label semi-synchrone sous Hadoop (SLPH avec N = 1).

Nous donnons un exemple d’exp´erimentation o`u la seule observation tangible
est que l’augmentation du nombre de propagations de labels permet de r´eduire
le nombre de communaut´es jusqu’`a des oscillations qui ne permettent pas de
conclure. Pour le calcul du NMI et du F1 scores, nous utilisons la connais-
sance des vraies communaut´es, leur top 5000, disponible sur SNAP `a l’adresse
http : //snap.stanf ord.edu.

4.2.2 Etude sur de grands graphes de terrains

Etude sur Amazon

Le nombre de couleurs d´etect´ees est de 24 pour faire marcher la propagation
de labels semi-synchrone, Tableau 4.2. La distribution des degr´es moyens selon
les couleurs est ´egalement donn´ee au Tableau 4.2.

La premi`ere analyse traite de la distribution des couleurs. Il y a 24 couleurs
d´etect´ees sur le graphe d’Amazon. Nous voyons que 48.8% des nœuds ont la
mˆeme couleur, c’est-`a-dire qu’ils mettront `a jour leurs propres vecteurs de la-
bels en mˆeme temps durant le processus Hadoop. Nous observons ´egalement que
le pourcentage de nœuds par couleur n’est pas uniform´ement distribu´e. Les cou-
leurs C1,C2,C3,C4,C5 et C23 repr´esentent 86.5206% des nœuds du graphe alors

4.2. EXP ´ERIMENTATIONS

175

Figure 4.6 – Exp´erimentation sur la stabilisation du Par-CDLP avec Amazon et α ≥ 0.5

Coloration de graphe sur Amazon
dist

dist

0.117 %
0.106 %
0.035 %
0.030 %
0.008 %
0.007 %
0.002 %
0.001 %
0.0008 %
0.0005 %
5.5142 %
0.0003 %

Color
C1
C2
C3
C4
C5
C6
C7
C8
C9
C10
C11
C12

48.449 %
4.0476 %
16.003 %
4.524 %
7.987 %
3.856 %
3.659 %
2.420 %
1.369 %
1.065 %
0.429 %
0.361 %

Color
C13
C14
C15
C16
C17
C18
C19
C20
C21
C22
C23
C24

Tableau 4.2 – Distribution des tailles (dist) pour chaque groupe ayant une couleur
sp´eciﬁque Ci

que C13,C14,C15,C16, C17,C18, C19,C20,C21,C22,C23 et C24 ne repr´esentent que
0.3076% du total des nœuds du graphe.

Notre premi`ere ´etude porte sur le SLPH, c’est-`a-dire notre proposition Ha-
doop avec N = 1. Nous avons fait marcher le SLPH it´eration apr`es it´eration, 10
fois, Tableau 4.3. L’objectif ´etant de voir si la propagation de label s’eﬀectue
de mani`ere correcte it´eration apr`es it´eration. Les observations nous montrent

176CHAPITRE 4. PROPOSITIONS SUR LE PARALL ´ELISME ET LA DISTRIBUTION

que les communaut´es deviennent de plus en plus importantes it´eration apr`es
it´eration. La premi`ere propagation de label (I1) donne 85, 913% de commu-
naut´es avec une taille comprise entre 1 et 10 nœuds. A la dixi`eme propagation
de labels, nous avons 57, 0532% de communaut´es dont la taille est comprise entre
1 et 10. L’algorithme est capable de d´etecter des communaut´es de diﬀ´erentes
tailles, petites et plus grandes. A I10, 1, 4774% des communaut´es ont une taille
comprise entre 41 et 50, alors que 0, 3776% des communaut´es ont une taille
sup´erieure `a 100. La ﬁgure 4.7 montre l’existence d’une convergence apr`es 10
it´erations. La conductance diminue parall`element `a la diminution constante du
nombre de communaut´es, dont les densit´es augmentent. C’est en ce sens que
nous proposons d’augmenter le nombre d’it´erations `a 15, pour une meilleure
qualit´e de partitionnement.

Figure 4.7 – Propagation de labels semi-synchrone sur Hadoop (SLPH)avec N = 1,
it´eration apr`es it´eration.

En observant le Tableau 4.4, nous voyons que le seuil α joue bien un rˆole
sur la taille des communaut´es et la qualit´e qui en r´esulte. Plus α est important,
plus le nombre de communaut´es augmente.

Pour N = 100, Tableau 4.5, avec α ≥ 0, 4, 73, 081% des communaut´es ont
une taille comprise entre 1 et 10 nœuds alors qu’avec α ≥ 0, 6, ce pourcentage
s’´el`eve `a 89, 057%. N´eanmoins, certaines grandes communaut´es sont trouv´ees
pour chaque valeur de α, montrant la robustesse de certaines communaut´es.
Avec α ≥ 0, 4, 1, 012% des communaut´es ont une taille sup´erieure `a 100. Appli-
quer une matrice de co-fr´equence diminue fortement la taille des communaut´es.
Avec α ≥ 0, 8, seulement 0, 0018% des communaut´es ont une taille sup´erieure `a

Tailles
1-10
11-20
21-30
31-40
41-50
51-60
61-70
71-80
81-90
91-100
> 100
Tailles
1-10
11-20
21-30
31-40
41-50
51-60
61-70
71-80
81-90
91-100
> 100

85.913 % 72.8953 % 66.7653 % 63.1801 % 61.1225 %
11.1707 % 19.5767 % 22.7308 % 24.4647 % 25.2975 %
2.046 %
8.0646 %
2.7505 %
0.5455 %
1.3159 %
0.1854 %
0.6652 %
0.0759 %
0.0388 %
0.302 %
0.000 %
0.000 %
0.1546 %
0.0106 %
0.0791 %
0.0018 %
0.0124 %
0.2411 %

4.7709 %
1.5736 %
0.5957 %
0.3163 %
0.1476 %
0.000 %
0.029 %
0.0316 %
0.0604 %

7.2787 %
2.6763 %
1.1455 %
0.5728 %
0.2864 %
0.000 %
0.133 %
0.0545 %
0.2009 %

6.369 %
2.312 %
0.8725 %
0.4518 %
0.243 %
0.000 %
0.0623 %
0.0592 %
0.1276 %

I6

I7

I8

I9

I10

59.5642 % 58.6458 % 58.0986 % 57.4829 % 57.0532 %
26.9699 % 27.1485 %
26.0335 % 26.5051 %
8.4246 %
8.9127 %
9.0191 %
3.336 %
3.2328 %
2.9832 %
1.4774 %
1.5005 %
1.3892 %
0.8062 %
0.8131 %
0.6965 %
0.3538 %
0.3967 %
0.4527 %
0.000 %
0.000 %
0.000 %
0.2065 %
0.2043 %
0.1713 %
0.1152 %
0.1139 %
0.108 %
0.268 %
0.4084 %
0.3776 %

26.63 %
8.763 %
3.1534 %
1.5612 %
0.7399 %
0.3951 %
0.000 %
0.2014 %
0.1162 %
0.3255 %

8.52 %
3.1702 %
1.3794 %
0.7964 %
0.3658 %
0.000 %
0.202 %
0.0953 %
0.3085 %

4.2. EXP ´ERIMENTATIONS

177

Distribution des tailles de communaut´es avec SLPH sur Amazon
I5

I4

I3

I2

I1

Tableau 4.3 – Distribution des tailles des communaut´es SLPH (N = 1)

CDLP on Amazon (I15 and N = 100)
α ≥ 0.5
0.3522
0.3552
0.328038
0.404496
101821

α ≥ 0.6
0.3248
Q
0.4125
φ
0.3015
NMI
0.3849
F1
#
113972
Tableau 4.4 – Scores des mesures supervis´ees et non supervis´ees

α ≥ 0.4
0.4789
0.2160
0.359236
0.4240019

α ≥ 0.2
0.5559
0.1176
0.3604
0.4225
60077

α ≥ 0.3
0.5768
0.1150
0.377456
0.433952

85801

69628

100. Plus α augmente, plus la taille des communaut´es diminue. Le SLPH trouve
approximativement 25 000 communaut´es.

L’analyse des mesures supervis´ees et non supervis´ees montre que la m´ethode
de d´etection de cœurs donne de relativement bons r´esultats mais reste ´equivalente
en termes de qualit´e au SLPH. Cela vient du fait que les structures communau-
taires du graphe Amazon sont de tr`es petite taille.

178CHAPITRE 4. PROPOSITIONS SUR LE PARALL ´ELISME ET LA DISTRIBUTION

α ≥ 0.6

CDLP sur Amazon (distribution des tailles des communaut´es) (I10 and N = 20)
Tailles
1-10
11-20
21-30
31-40
41-50
51-60
61-70
71-80
81-90
91-100
101-200
201-300
>300

α ≥ 0.7
α ≥ 0.5
82.145% 89.057 % 94.4227 %
10.257 % 7.303 %
4.2461 %
5.251 % 1.9563 % 0.8188 %
1.258 % 0.7863 % 0.2952 %
0.554 % 0.3535 % 0.0984 %
0.2748 % 0.1775 % 0.0594 %
0.082 % 0.1125 % 0.0297 %
0.0240 %
0.0345 % 0.0563 % 0.0084 %
0.0347 % 0.0476 % 0.0046 %
0.062% 0.1239 %
0.014 %
0.0186 % 0.0009 %
0.120
0.0232
0.0042 % 0.0012 %

α ≥ 0.4
73.081
12.057
7.548
3.314
1.369
0.845
0.145
0.378
0.024
0.1458
0.275
0.351
0.386

0.0006 %
Tableau 4.5 – Distribution des tailles de communaut´es du CDLP et de SLPH

α ≥ 0.8
97.729 %
1.9291 %
0.2488 %
0.0611 %
0.0167 %
0.009 %
0.0026 %

0.0 %

0.0013 %
0.0006 %
0.0012 %

0.0 %

0.0 %

0.0 %

Nous donnons quelques exemples d’´el´ements issus des communaut´es que Par-

CDLP a d´etect´ees, Tableau 4.6.

Communaut´es

Agatha Christie

Judith Philips

Exemples de communaut´es d´etect´ees

articles
The Man in the Brown Suit
(St. Martin’s Minotaur Mysteries)
Lord Edgware Dies
Poirot Investigates
Murder on the Orient Express :
A Hercule Poirot Mystery
4 : 50 from Paddington Miss
Marple Mysteries
Southwestern Landscaping with Native Plants
New Mexico Gardener’s Guide (Gardener’s Guides)
New Mexico Gardener’s Guide (Jul 3, 2001)
Natural by Design : Beauty
and Balance in Southwest Gardens
Plants for Natural Gardens : Southwestern

Kelli Dolecek

Native, Adaptive Trees, Shrubs,
Wildﬂowers, Grasses
Month-To-Month
Gardening, New Mexico

Tableau 4.6 – Exemple de communaut´es d´etect´ees sur Amazon

genre et th`eme
enquˆete polici`ere

enquˆete polici`ere
enquˆete polici`ere
enquˆete polici`ere

enquˆete polici`ere

jardinage (g´en´eral)
jardinage (d´esert)
jardinage (d´esert)
jardinage (sud-ouest)

jardinage
(Texas et Californie)

jardinage (d´esert)

4.2. EXP ´ERIMENTATIONS

179

Etude sur DBLP

Tailles
Q
φ
NMI
F1
#

α ≥ 0.3
0.6424
0.0361
0.1948
0.267489

24771

CDLP sur DBLP (I10 et N = 100)
α ≥ 0.4
0.6979
0.0523
0.2202
0.304575

α ≥ 0.5
0.7104
0.00647
0.260057
0.373641

α ≥ 0.6
0.6680
0.025

0.246206
0.367221

28660

36218

35439

α ≥ 0.7
0.6273
0.045
0.2364
0.345877

40521

SLPH
0.6546
0.0612
0.2241
0.325454

45276

Tableau 4.7 – Scores des mesures supervis´ees et non supervis´ees

α ≥ 0.6

α ≥ 0.7

SLPH

Distribution des tailles de communaut´es, CDLP sur DBLP (I20 et N = 100)
Tailles
1-10
11-20
21-30
31-40
41-50
51-60
61-70
71-80
81-90
91-100
101-200
201-300
> 300

α ≥ 0.8
α ≥ 0.5
79.300 % 85.6181 % 90.2142 % 93.4246 %
5.1026 %
13.400 % 10.0392 % 7.2451 %
3.800 %
1.5352 %
0.921 %
0.315 %
0.5514 %
1.500 %
0.1235 %
0.2162 %
0.800 %
0.0403 %
0.1097 %
0.400 %
0.300 %
0.0494 %
0.029 %
0.000 %
0.0 %
0.0455 %
0.100 %
0.0238 %
0.100 %
0.2701 %
0.300 %
0.0929 % 0.0785 %
0.000 %
0.0132 %

0.0014
0.00 %
Tableau 4.8 – Distribution des tailles des communaut´es avec Par-CDLP

69.8484 %
19.8401 %
5.9319 %
2.2757 %
0.9611 %
0.4954 %
0.284 %
0.0 %

0.0113 %
0.0063 %
0.0293 %
0.0428 %
0.00 %

0.0 %

0.0154 %
0.0108 %
0.0477 %
0.0517 %
0.008 %

2.488 %
0.8986 %
0.4176 %
0.2197 %
0.1306 %

0.0 %

0.0727 %
0.0892 %
0.1749 %

L’algorithme de coloration trouve pour le graphe DBLP 116 couleurs. La
distribution des tailles des groupes de nœuds suivant les couleurs n’est pas uni-
form´ement r´epartie. 7 couleurs r´epr´esentent pr`es de 90, 377%. Certaines couleurs
ne r´epr´esentent que 0, 0003% de la population totale.

Le SLPH trouve 24469 communaut´es avec une modularit´e de 0.6894 et un
NMI de 0.218794. La majorit´e des communaut´es d´etect´ees sont de taille comprise
entre 1 et 10 (69.8484 %). Cependant, de grandes communaut´es sont d´etect´ees
avec plus de 0.1895% des communaut´es ayant une taille sup´erieure `a 100 nœuds.

Nous observons au tableau 4.7 que la qualit´e des communaut´es d´etect´ees par
Par-CDLP, notamment pour α ≥ {0.5, 0.6, 0.7, 0.8}, est meilleure qu’avec le
SLPH. Par-CDLP obtient un NMI de 0.260057 avec α ≥ 0.5. La m´ethode `a
base de d´etection de cœurs permet d’am´eliorer la qualit´e de partitionnement.
Pour α ≥ 0.8, le nombre de communaut´es avec Par-CDLP devient tr`es im-
portant. Comme SLPH, Par-CDLP d´etecte quelques grandes communaut´es qui

180CHAPITRE 4. PROPOSITIONS SUR LE PARALL ´ELISME ET LA DISTRIBUTION

disparaissent avec l’augmentation de α.
Nous donnons quelques exemples de communaut´es d´etect´ees avec plusieurs va-
leurs de α, Tableau 4.9. (Il ne s’agit que d’une partie des communaut´es).

4.2. EXP ´ERIMENTATIONS

181

Exemples de communaut´es d´etect´ees sur DBLP (n = 317080 et m = 1049866)

Auteurs
Maria Malek
(α ≥ 0.3)

Maria Malek (α ≥ 0.85)
Marc Zolghadri (α ≥ 0.3)

communaut´es
”Dominique Laurent”
”Dalia Sulieman”
”Hubert Kadima”
”Rushed Kanawati”
”Sylvie Salotti”
”Farida Zehraoui”
”Vincent Rialle”
”Ahmad A. Kardan”
”AHM Ragab”
”M Ebrahimi”
”DR Millen”
”Nicola Spyratos”
etc.
”Rushed Kanawati”
”Rachid Chelouah”
”Citlalih Gutierrez Estrada”
”Bruno Vallespir”
”Yan Liu”
”Salah Zouggar”
”St´ephane Brunel”
”Philippe Girard”
”Claude Olivier”
”P Agarwal”
”M Sahai”
”V Mishra”
”Claude Baron”
etc.

genre et th`eme
Recommandation s´ematique et sociale
Recommandation s´emantique et sociale
Recommandation s´emantique et sociale
COBRA

recommandation

syst`eme multi-agent

COBRA
Meta-heuristics

Power-based supplier
Power-based supplier
Power-based supplier

Tableau 4.9 – Exemple de communaut´es d´etect´ees

182CHAPITRE 4. PROPOSITIONS SUR LE PARALL ´ELISME ET LA DISTRIBUTION

Etude comparative

Nous proposons une ´etude comparative portant sur la qualit´e de partition-
nement. Les algorithmes pour cette ´etude sont la m´ethode de Louvain (Blondel
et al. (2008)), WalkTrap (Pons et Latapy (2006)), OSLOM (Lancichinetti et al.
(2011)), Infomap (Rosvall et Bergstrom (2008)), Bigclam (Yang et Leskovec
(2013)), SCD (Prat-P´erez et al. (2014)), LPA (Raghavan et al. (2007)) et SLPA
(Xie et al. (2011)) sur quatre grands graphes, Amazon, DBLP, You Tube et Live
Journal.

Figure 4.8 – NMI sur les quatre grands r´eseaux avec diﬀ´erents algorithmes

Figure 4.9 – F1 sur les quatre grands r´eseaux avec diﬀ´erents algorithmes

Les premi`eres observations des Figures 4.8 et 4.9 montrent que notre solution
est comp´etitive par rapport aux solutions issues de la lit´erature. On observe

4.2. EXP ´ERIMENTATIONS

183

que le CDLP donne de meilleurs r´esultats que les autres m´ethodes `a base de
propagation de labels. SLPH est presque ´equivalent au LPA sur you Tube et
live Journal, mais donne cependant de meilleurs r´esultats en termes de qualit´e
sur Amazon ou DBLP. Cependant, d’autres m´ethodes surpassent CDLP comme
Louvain ou SCD en termes de qualit´e de partitionnement.

4.2.3 Etude volum´etrique trait´ee par le HDFS

Nous ´etudions la quantit´e de donn´ees produites par chaque job. En ef-
fet, certaines solutions de cloud computing comme ”Google Cloud Paltform”
(https ://cloud.google.com/) ou ”Amazon EMR” (https ://aws.amazon.com)
facturent selon la quantit´e de donn´ees stock´ee. Sur la Figure 4.10, nous r´ecapitulons
chaque job, avec les mappers et reducers associ´es.

job1
job2
job3
job4
job5
job6

Jobs MapReduce

FirstReadMap

VoteMap
MapUpdate

MapCommunity

FirstReadReduce
VoteReduce−Ci
UpdateReduce

ReduceCommunity

MapOccurrenceMatrix

ReduceOccurrenceMatrix

MapGPrimAlpha

ReduceGPrimAlpha

Tableau 4.10 – jobs MapReduce pour le Par-CDLP

Figure 4.10 – Quantit´e de donn´ees produite par les jobs et stock´ee par le HDFS en
fonction du nombre de propagations de labels lanc´ees en parall`ele, ”*” signiﬁe que le
calcul est une moyenne, α ≥ 0.1.

Initialement, nous utilisons 80 reducers pour une simple machine. Le nombre
de reducers sera multipli´e par deux `a chaque fois qu’une nouvelle machine sera
ajout´ee. Le temps n´ecessaire, Figure 4.11, pour faire marcher la propagation

184CHAPITRE 4. PROPOSITIONS SUR LE PARALL ´ELISME ET LA DISTRIBUTION

Figure 4.11 – Temps d’ex´ecution (en heures), l’axe des abcisses repr´esente le nombre
de machines fonctionnant en parall`ele

de labels semi-synchrone sur Amazon, de l’´etape de coloration `a l’´etape de la
d´etection des composantes connexes avec N = 100 est d’environ deux heures
pour une simple machine (avec une version Hadoop standalone) alors qu’il n’est
que de 35 minutes pour le SLPH. Il est donc int´eressant de pouvoir utiliser un
cluster de machines pour tenter de r´eduire le temps d’ex´ecution. Avec l’augmen-
tation des machines, le temps d’ex´ecution diminue pour arriver `a 35 minutes,
toujours avec N = 100.

La quantit´e de donn´ees stock´ee est repr´esent´ee `a la Figure 4.10. Par d´efaut,
le HDFS r´eplique chaque bloc de donn´ees produit 3 fois sur son cluster. Nous
avons volontairement supprim´e cette fonctionnalit´e pour mieux rendre compte
de la quantit´e de donn´ees produite par le logiciel. Nous rappelons que les noms
des jobs sont au Tableau 4.10. Pour les jobs 2, 3, 4 et 5, nous donnons la quantit´e
de donn´ees moyenne produite par une couleur depuis que nous proc´edons `a la

4.2. EXP ´ERIMENTATIONS

185

destruction des donn´ees interm´ediaires, avec un script de nettoyage de donn´ees.
Nous observons un facteur de proportionnalit´e en fonction de N . Les jobs 1, 2
et 3 produisent les plus grandes quantit´es de donn´ees. Pour le job 5 et pour
chaque N , la quantit´e de donn´ees est presque la mˆeme depuis que ce job associe
`a chaque nœud sa communaut´e.

Nous avons ´egalement observ´e que la valeur de α n’avait aucune inﬂuence
sur le temps et sur la quantit´e de donn´ees produites par les jobs 1 `a 5. Cela
vient du fait que ce param`etre n’intervient pas dans le processus algorithmique.
Il intervient cependant au job 6 o`u la volum´etrie et le temps d’ex´ecution ﬂuc-
tueront en fonction de la valeur α. La valeur de α aura pour cons´equence une
ﬂuctuation du temps de calcul des composantes connexes, qui repr´esentent nos
communaut´es. Un α produisant plus d’arˆetes demandera un temps de calcul
pour les composantes connexes plus important.

Sur la Figure 4.10, le volume de donn´ees a ´et´e calcul´e avec α ≥ 0, 1. C’est
le job 1 qui produit la plus importante quantit´e de donn´ees depuis qu’il a fallu
instancier un vecteur de labels de taille N , j − li − i − Ci.

Nous avons, `a titre exp´erimental, test´e plusieurs valeurs de N et jou´e sur
le nombre de couleurs pour le temps d’ex´ecution, `a la Figure 4.11. Le temps
d’ex´ecution de notre mod`ele sera fonction de N , mais ´egalement du nombre de
couleurs d´etect´ees par l’algorithme de coloration. Plus le nombre de couleurs
est important, plus le temps d’ex´ecution est important. Sur DBLP, nous avons
pr`es de 90, 377% des nœuds qui ne r´epr´esentent que 7 couleurs alors que cela
est du mˆeme ordre pour Amazon, avec une couverture de 90.355% de nœuds
avec juste 7 couleurs. Cela sous entend que de nombreux jobs traiteront uni-
quement 10% des nœuds du graphe, avec un temps excessivement important
dˆu `a l’importance du nombre de couleurs. C’est en ce sens que nous lan¸cons
`a la fois l’algorithme original et une version r´eduite (CDLPRED) comprenant
exclusivement 7 couleurs plus 1 qui servira `a la propagation des autres labels `a
la ﬁn du processus.

En ce qui concerne Par-CDLP, augmenter le nombre de machines et le
nombre de reducers diminue le temps d’ex´ecution pour un N ´elev´e. Ce n’est
pas toujours le cas lorsque la quantit´e de donn´ees `a traiter n’est pas tr`es inpor-
tante comme pour SLPH. Nous voyons que les versions r´eduites vont beaucoup
plus vite. En eﬀet, certaines couleurs ne repr´esentent que certains nœuds du
graphe (comme la couleur C24 avec moins de 0, 0003% du total des nœuds du
graphe). Il faut beaucoup de temps pour eﬀectuer la propagation d’un nombre
aussi faible de labels.

186CHAPITRE 4. PROPOSITIONS SUR LE PARALL ´ELISME ET LA DISTRIBUTION

4.3 Conclusion portant sur les propositions li´ees

au parall´elisme et la distribution

Dans ce chapitre, nous avons d´ecrit une implantation informatique possible
parall`ele et distribu´ee de la propagation de labels avec cœurs. Pour r´esoudre
le probl`eme de la propagation de labels asynchrone, nous avons propos´e d’uti-
liser le principe de coloration, o`u des groupes de nœuds changent leurs labels
en mˆeme temps suivant la propagation de labels habituelle, alors que d’autres
attendent leur tour.

En utilisant comme crit`ere la modularit´e, les exp´erimentations ont montr´e
de meilleurs r´esultats en termes de qualit´e de partitionnement par rapport aux
m´ethodes `a base de propagation de labels comme le LPA, mais cependant moins
bons que pour la m´ethode de Louvain.

La m´ethode propos´ee est relativement lente. Le temps d’ex´ecution, que ce
soit pour DBLP, You Tube ou live Journal peut n´ecessiter plusieurs heures. Le
nombre de couleurs joue un rˆole majeur sur le temps d’ex´ecution. Par exemple,
nous avons trouv´e 24 couleurs sur le graphe d’Amazon alors que 6 couleurs
repr´esentent 86.52% des nœuds du graphe. Certaines couleurs ne repr´esentent
quant-`a-elles que 0.0003% du total des nœuds du graphe, soit une dizaine de
nœuds. Appliquer Par-CDLP sur un aussi petit groupe de nœuds requiert un
temps tr`es important. Ce constat fut ´etabli pour tous les grands graphes qui
furent utilis´es pour les exp´erimentations. De plus, l’´ecriture sur disque des
donn´ees requiert un temps qui peut ˆetre tr`es important.

Nous ´etudions actuellement un moyen de r´eduire le temps d’ex´ecution, comme
fusionner des groupes de nœuds de couleurs diﬀ´erentes au risque de d´et´eriorer
la qualit´e de partitionnement. Cette impl´ementation pourrait ´egalement ˆetre
utile pour une version parall`ele et distribu´ee destin´ee au chevauchement. Nous
´etudions ´egalement une version en m´emoire RAM, notamment en utilisant
Apache Spark.

Chapitre 5

Conclusion

Sommaire

5.1 Contributions algorithmiques . . . . . . . . . . . . 188

5.2 Perspectives . . . . . . . . . . . . . . . . . . . . . . . 189

Dans cette th`ese, nous nous sommes int´eress´es aux probl`emes de d´etections
de communaut´es disjointes et chevauchantes, et `a la scalabilit´e de nos m´ethodes
en proposant une version Hadoop pour la propagation de labels avec d´etection
de cœurs.

Le premier chapitre a permis de d´ecrire trois grandes classes d’algorithmes en
d´etection de communaut´es disjointes : les m´ethodes globales, locales et hybrides.
Il a ´et´e observ´e que les m´ethodes locales, c’est-`a-dire dont le point de d´epart est
atomique (par le nœud), permettaient de traˆıter de plus grands graphes que les
m´ethodes globales, ou encore divisives. La propagation de labels est une m´ethode
locale, qui a l’avantage d’ˆetre rapide et applicable `a des graphes de plusieurs
millions de nœuds et d’arˆetes mais elle pr´esente certains inconv´enients, `a savoir
de mauvaises propagations qui peuvent donner des communaut´es g´eantes, une
forte instabilit´e due au non d´eterminisme de l’algorithme et l’impossibilit´e de
trouver des communaut´es chevauchantes. C’est en ce sens que notre premi`ere
contribution fut i) de proposer une version am´elior´ee de la propagation de labels
en y incluant une stabilisation par recherche de cœurs et la mise en place de bar-
rages artiﬁciels pour ´eviter de mauvaises propagations. La seconde contribution
ii) fut d’am´eliorer la m´ethode pr´ec´edente pour le chevauchement en y incluant
une fonction d’appartenance permettant de d´etecter des nœuds pouvant ap-
partenir `a plusieurs communaut´es. Plusieurs fonctions d’appartenance fond´ees
sur la densit´e et le cœﬃcient de clustering sont propos´ees en vue d’une ´etude
comparative. Enﬁn, nous avons propos´e iii) une impl´ementation MapReduce de
notre propagation de labels pour travailler sur de plus grands graphes ayant au
moins plusieurs millions de nœuds et d’arˆetes. La propagation de labels dans
sa forme asynchrone pr´esenta une diﬃcult´e pour le parall´elisme `a laquelle nous

187

188

avons r´epondu.

CHAPITRE 5. CONCLUSION

5.1 Contributions algorithmiques

Pour r´epondre `a la probl´ematique de d´etection de communaut´es disjointes,
et rem´edier aux probl`emes de la propagations de labels, nous avons propos´e la
propagation de labels avec barrages qui a montr´e des r´esultats encourageants
en termes de qualit´e de partionnement sur des graphes sociaux.

Nous avons propos´e deux versions fond´ees sur la d´etection de cœurs et sur
des matrices de fr´equence. La premi`ere m´ethode ´etait fond´ee sur la cr´eation
de plusieurs matrices de fr´equence aliment´ees avec diﬀ´erents niveaux de bar-
rages. La seconde m´ethode consiste `a alimenter une seule matrice de fr´equence
mais avec diﬀ´erents niveaux de barrages. La premi`ere m´ethode n´ecessite l’in-
tervention d’une mesure de qualit´e pour savoir quelle matrice serait capable de
donner le meilleur partitionnement. La seconde m´ethode, not´ee PLBS, n´ecessite
de donner un intervalle sur lequel les propagations de labels avec diﬀ´erents ni-
veaux de barrages alimenteraient la matrice de fr´equence. Les r´esultats pour
la simple propagation de labels avec barrages ont montr´e que le fait de mettre
des barrages artiﬁciels pouvait am´eliorer la qualit´e de partitionnement comme
sur le r´eseau footballistique. Cependant, il y certains cas o`u la mise en place de
barrages semble inutile, comme le cas du r´eseau de collaboration scientiﬁque o`u
les communaut´es sont d´ej`a bien d´eﬁnies. Concernant les m´ethodes de d´etection
par cœurs, PLBS montre des r´esultats tr`es satisfaisants, notamment en alimen-
tant la la matrice de co-fr´equence de 0 `a 30 % de barrages. En alimentant une
matrice de co-fr´equence par diﬀ´erents niveaux de labels, le syst`eme assure que
les nœuds avec une forte probabilit´e d’ˆetre ensemble auront une valeur ´elev´ee
au sein de la matrice. Si le nombre de barrages est trop grand, le risque est
d’obtenir dans le pire des cas un nœud correspondant `a une communaut´e, ce
qui est ´equivalent `a ce que la diagonale de la matrice de co-occurence ne soit
pas vide. Cependant, la diagonale n’est pas prise en compte pour la cr´eation des
composantes connexes (ce qui est un avantage de la solution). On souhaiterait
n´eanmoins trouver un intervalle pour am´eliorer le partitionnement avec un cer-
tain pas et ne pas d´et´eriorer la qualit´e de partionnement.

Nous nous sommes ´egalement focalis´es sur l’ordre de visite des nœuds lors
du processus par propagation de labels. Les exp´erimentations ont montr´e que
l’ordre avait une incidence `a la fois sur la stabilisation et sur la qualit´e de par-
titionnement.

Pour r´epondre `a la probl´ematique de d´etection de communaut´es chevau-
chantes, nous avons voulu am´eliorer notre algorithme basique de d´etection de
cœurs par propagation de labels en utilisant `a la fois l’information topologique
sur les structures communautaires et l’information sur les arˆetes, notamment

5.2. PERSPECTIVES

189

celle concernant la pond´eration du graphe par utilisation de la matrice de
fr´equence. Les fonctions d’appartenances fond´ees sur la centralit´e de nœuds et
sur le cœﬃcient de clustering ont montr´e des r´esultats satisfaisants en mati`ere
de qualit´e. L’une des forces des m´ethodes propos´ees est que l’algorithme per-
met de r´epliquer certains nœuds dans des communaut´es diﬀ´erentes autant de
fois que n´ecessaire, c’est-`a-dire qu’un nœud peut appartenir `a une ou plusieurs
communaut´es suivant la fonction utilis´ee. Mais cela n´ecessite, pour un nœud
candidat au chevauchement, de tester toutes les combinaisons avec les commu-
naut´es qui lui sont li´ees. Cela a pour cons´equence une augmentation du temps
d’ex´ecution du programme informatique, notamment lorsqu’il y a beaucoup de
communaut´es autour d’un nœud. Ainsi, nous avons pu observer, dans notre
impl´ementation, que si un nœud ´etait li´e `a beaucoup de communaut´es, la taille
du vecteur comprenant toutes les combinaisons pouvait devenir gigantesque et
ralentir l’ex´ecution informatique. Nous proposons de ne pas consid´erer toutes les
possibilit´es mais d’eﬀectuer une proc´edure d’´echantillonnage. L’objectif ´etant, `a
court terme, de pouvoir exploiter cette solution pour de grands graphes. Nous
travaillons ´egalement sur d’autres mesures sociales en vue de faire une ´etude
comparative.

Pour r´epondre `a la probl´ematique des grands graphes, nous avons d´evelopp´e
une base pour la propagation de labels semi-synchrones `a base de cœurs. Notre
m´ethode est fond´ee sur une coloration de graphe, qui sera utilis´ee pour eﬀec-
tuer la propagation de label semi-synchrone pour la d´etection de cœurs. Cette
m´ethode permet l’´elaboration d’un dendrogramme. Notre mod´elisation Hadoop
pour la d´etection de communaut´es a montr´e des r´esultats en termes de qua-
lit´e de partitionnement encourageants. Cependant, le temps d’ex´ecution reste
trop important. Nos observations ont montr´e que la coloration sur les nœuds du
graphe ne suivait pas une loi uniforme. Un nombre r´eduit de couleurs couvre la
majeure partie du r´eseau alors que la majorit´e des couleurs ne couvre qu’une
inﬁme partie du r´eseau. Cela a pour cons´equence que notre m´ethode prendra
la majeure partie du temps `a la mise `a jour de labels d’un faible nombre de
nœuds. Pour rem´edier `a ce probl`eme, nous avons d´ej`a fusionn´e des couleurs de
telle sorte qu’il n’existe pas de connexions entre les nœuds de ces couleurs, ce qui
a pu r´eduire le temps d’ex´ecution. Une piste, pour notre mod`ele Hadoop, serait
d’analyser la fr´equence de mise `a jour des nœuds des labels et de ne pas eﬀec-
tuer de mise `a jour de certains nœuds. Par exemple, un nœud connect´e `a une
communaut´e dont le label ne change plus depuis un certain nombre d’it´erations
pourrait ne plus voir son label modiﬁ´e. Nous d´eveloppons actuellement une so-
lution in-memory en utilisant Apache Spark.

5.2 Perspectives

Suite `a l’analyse des r´esultats des exp´erimentations portant sur la propaga-

tion de labels avec barrages, les questions en suspens portent sur :

190

CHAPITRE 5. CONCLUSION

— le nombre de barrages n´ecessaires au PLAB pour obtenir la meilleure

solution.

— l’intervalle `a consid´erer pour le PBLS pour obtenir des r´esultats satisfai-

sants.

En consid´erant des cliques connect´ees, il paraˆıt n´ecessaire de mettre en place
des barrages entre elles. Cependant, mettre davantage de barrages ne semble
pas apporter une am´elioration signiﬁcative dans le partitionnement de graphe,
cela aurait plutˆot tendance `a d´et´eriorer la qualit´e de partitionnement.

Une des pistes que nous ´etudions concerne l’information de certaines r´egions
du graphe. Nous pensons interdire la mise en place de barrages dans des zones
denses ayant un fort taux de triangles. Cela pourrait s’eﬀectuer en observant les
voisinages des arˆetes et en ´etudiant la structure topologique des communaut´es
it´eration apr`es it´eration en termes de pourcentages de barrages. Nos recherches
portent ´egalement sur l’ordre de la mise `a jour des labels . En utilisant l’infor-
mation fond´ee sur le nœud et son horizon (`a quelques arˆetes), nous souhaitons
cr´eer un ordre de visite de mise `a jour des labels des nœuds ´evitant de mauvaises
propagations et permettant une convergence plus rapide de l’algorithme.

Nos m´ethodes de d´etection de communaut´es chevauchantes nous incitent
`a chercher `a diminuer le temps d’ex´ecution, tout en les appliquant `a de plus
grands graphes grˆace `a un mod`ele parall`ele et distribu´e. Le nombre important
de mesures sociales nous permettra ´egalement de faire une ´etude comparative
portant sur le taux de chevauchement entre communaut´es.

Notre mod`ele Hadoop permet de traiter des graphes de plusieurs millions de
nœuds et d’arˆetes. Cependant, la coloration, qui est la base de cet algorithme,
pr´esente des inconv´enients surtout lorsqu’un tr`es faible nombre de nœuds a la
mˆeme couleur. Cela n´ecessite de faire une mise `a jour du graphe dans son en-
semble, alors qu’un tr`es faible nombre de nœuds est concern´e. Une solution
in-memory serait appr´eciable pour faire une ´etude comparative portant sur les
volum´etries traˆıt´ees et le temps d’ex´ecution avec le mod`ele Hadoop.

En observant les communaut´es d’Amazon et en allant sur le site de vente
en ligne, nous nous sommes rendu compte d’une grande similarit´e entre les
´el´ements des communaut´es et les recommandations. Nous pensons que notre
mod`ele pourrait ˆetre la base pour un syst`eme de recommandation `a grande
´echelle. Cela constitue une piste de recherche.

Chapitre 6

Glossaire

Nous proposons un glossaire permettant de d´eﬁnir certaines notions, princi-
palement li´ees au graphe. Dans ce cadre, nous consid´erons un graphe G = (V, E)
avec V un ensemble de sommets et E un ensemble d’arˆetes E. |V | d´enote le
nombre de sommets du graphe et |E| le nombre d’arˆetes.

6.1 D´eﬁnitions relatives aux graphes

Benchmark LFR : Le benchmark LFR (Lancichinetti-Fortunato-Radicchi)
est un algorithme de cr´eation de graphes al´eatoires dont les caract´eristiques se
veulent aussi proches que des r´eseaux complexes. Les avantages de l’algorithme
sur les autres m´ethodes est qu’il tient compte de l’h´et´erog´en´eit´e de la distribu-
tion des degr´es des noeuds et des tailles de communaut´es. L’algorithme demande
un certains nombre de param`etres :

— n : le nombre de noeuds
— k : le degr´e interne moyen des communaut´es
— maxk : le degr´e maximum
— mu : l param`etre de mixage
— t1 : exposant pour la s´equence de degr´e
— t2 : exposant pour la distribution des tailles des communaut´es
— minc : taille minimum des communaut´es
— maxc : taille maximum des communaut´es
— on : nombre de noeuds chevauchants
— om : nombre de communaut´es auxquelles appartiennent les noeuds che-

vauchants

La bordure (ou fronti`ere) d’une communaut´e est l’ensemble des nœuds

ayant au moins un lien vers une autre communaut´e.

191

192

CHAPITRE 6. GLOSSAIRE

Coloriage : Il s’agit d’attribuer une couleur `a chacun des sommets d’un
graphe de mani`ere que deux sommets reli´es par une arˆete soient de couleur
diﬀ´erente.

Graphe complet : Un graphe complet est un graphe o`u chaque sommet
est reli´e `a tous les autres. On note Kn le graphe complet `a n sommets o`u chaque
sommet est de degr´e n − 1.

Graphe nul : Si l’on consid`ere un graphe G, le mod`ele nul (ou graphe nul)
consiste en la cr´eation d’un graphe G(cid:48) respectant la distribution des degr´es des
noeuds avec des arˆetes pos´ees de mani`ere al´eatoire.

Clique : sous-ensemble de sommets d’un graphe dont le sous-graphe in-
duit est complet, c’est-`a-dire que deux sommets quelconques de la clique sont
toujours adjacents. Une K-clique est un sous-ensemble de k sommets tous adja-
cents (sous-graphe complet), et deux k-cliques sont adjacentes si elles partagent
k − 1 sommets.

Clique maximum : Une clique maximum d’un graphe est une clique dont
le cardinal est le plus grand (c’est-`a-dire qu’elle poss`ede le plus grand nombre
de sommets).

Contraction : Une contraction consiste `a supprimer une arˆete d’un graphe
en fusionnant les deux extr´emit´es. Ainsi, la contraction G/e d’une arˆete exy `a
un sommet x rend le sommet x adjacent `a tous les voisins pr´ec´edents de y. On
retrouve les premiers principes de contraction avec les m´ethodes multi-niveau de
partitionnement de graphe (Karypis et Kumar, 1995) (Karypis et Kumar, 1998a)
(Karypis et Kumar, 1998b) (Hendrickson et Leland, 1995b) (Hendrickson et Le-
land, 1995a) qui seront utilis´ees par la suite pour les m´ethodes agglom´eratives
comme Louvain ou celle de Rotta (Rotta et Noack, 2011) ou de Noack (Noack
et Rotta, 2009).

Dendrogramme : un dendrogramme est une repr´esentation graphique
sous forme d’arbre binaire permettant l’observation d’une hi´erarchie des par-
ties (communaut´es) au sein du graphe. On peut ainsi observer pour un noeud
sa communaut´e, mais ´egalement les imbrications entre communaut´es jusqu’`a la
racine.

Fronti`ere des arˆetes : Les arˆetes menant d’une partie d’un graphe au

reste du graphe.

Fronti`ere int´erieure des sommets

: Les sommets d’une partie d’un

graphe reli´ees au reste du graphe.

Fronti`ere ext´erieure des sommets : Les sommets du reste d’un graphe

reli´ees `a une partie du graphe.

6.1. D ´EFINITIONS RELATIVES AUX GRAPHES

193

Moyenne harmonique : La moyenne harmonique H de nombres r´eels
La moyenne

strictement positifs x1, ..., xn est d´eﬁnie comme ´etant H =
harmonique est utilis´ee lorsqu’on veut d´eterminer un rapport moyen, dans un
domaine o`u il existe des liens de proportionnalit´e inverse.

n

1
x1

+...+ 1
xn

194

CHAPITRE 6. GLOSSAIRE

Bibliographie

Bal´azs Adamcsek, Gergely Palla, Ill´es J Farkas, Imre Der´enyi et Tam´as
Vicsek : Cﬁnder : locating cliques and overlapping modules in biological
networks. Bioinformatics, 22(8):1021–1023, 2006.

R´eka Albert, Hawoong Jeong et Albert-L´aszl´o Barab´asi : Internet : Dia-

meter of the world-wide web. Nature, 401(6749):130–131, 1999.

LNF Ana et Anil K Jain : Robust data clustering.

In Computer Vision
and Pattern Recognition, 2003. Proceedings. 2003 IEEE Computer Society
Conference on, volume 2, pages II–128. IEEE, 2003.

George E Andrews : The theory of partitions, volume 2 of encyclopedia of

mathematics and its applications, 1976.

Ching Avery : Giraph : Large-scale graph processing infrastructure on hadoop.

Proceedings of the Hadoop Summit. Santa Clara, 11, 2011.

David A Bader, Shiva Kintali, Kamesh Madduri et Milena Mihail : Ap-
proximating betweenness centrality. In Algorithms and Models for the Web-
Graph, pages 124–137. Springer, 2007.

Bahman Bahmani, Ravi Kumar et Sergei Vassilvitskii : Densest subgraph in
streaming and mapreduce. Proceedings of the VLDB Endowment, 5(5):454–
465, 2012.

Albert-L´aszl´o Barab´asi et R´eka Albert : Emergence of scaling in random

networks. science, 286(5439):509–512, 1999.

Albert-L´aszl´o Barab´asi et Eric Bonabeau : Scale-free networks. Scientiﬁc

American, 288(5):50–59, 2003.

Stephen T Barnard : Pmrsb : Parallel multilevel recursive spectral bisec-
tion. In Proceedings of the 1995 ACM/IEEE conference on Supercomputing,
page 27. ACM, 1995.

Stephen T Barnard et Horst D Simon : Fast multilevel implementation of
recursive spectral bisection for partitioning unstructured problems. Concur-
rency : Practice and experience, 6(2):101–117, 1994.

195

196

BIBLIOGRAPHIE

ER Barnes et AJ Hoffman : On bounds for eigenvalues of real symmetric

matrices. Linear Algebra and its Applications, 40:217–223, 1981.

John Arundel Barnes : Class and committees in a Norwegian island parish.

Plenum New York, 1954.

Vladimir Batagelj et Andrej Mrvar : Pajek datasets, 2006.

Claude Berge : Les nombres fondamentaux de la th´eorie des graphes , volume

361. Th´eorie des Graphes, ´editions Dunod, 1958.

Marcelo Blatt, Shai Wiseman et Eytan Domany : Superparamagnetic clus-

tering of data. Physical review letters, 76(18):3251, 1996.

Vincent D Blondel, Jean-Loup Guillaume, Renaud Lambiotte et Etienne
Lefebvre : Fast unfolding of communities in large networks. Journal of
statistical mechanics : theory and experiment, 2008(10):P10008, 2008.

Phillip Bonacich : Technique for analyzing overlapping memberships. Socio-

logical methodology, 4:176–185, 1972.

Ulrik Brandes : A faster algorithm for betweenness centrality*. Journal of

mathematical sociology, 25(2):163–177, 2001.

Ulrik Brandes, Daniel Delling, Marco Gaertler, Robert Gorke, Martin
Hoefer, Zoran Nikoloski et Dorothea Wagner : On modularity clustering.
IEEE Transactions on Knowledge and Data Engineering, 20(2):172–188, 2008.

Ronald L Breiger : The duality of persons and groups. Social forces, 53

(2):181–190, 1974.

Mingming Chen, Tommy Nguyen et Boleslaw K Szymanski : On measuring
the quality of a network community structure. In Social computing (Social-
Com), 2013 international conference on, pages 122–127. IEEE, 2013.

Mingming Chen, Tommy Nguyen et Boleslaw K. Szymanski : A new metric

for quality of network community structure. CoRR, abs/1507.04308, 2015.

Avery Ching : Scaling apache giraph to a trillion edges. Facebook Engineering

blog, page 25, 2013.

Fan R. K. Chung : Spectral Graph Theory (CBMS Regional Conference Series
in Mathematics, No. 92). American Mathematical Society, d´ecembre 1996.
ISBN 0821803158.

Aaron Clauset, Mark EJ Newman et Cristopher Moore : Finding community

structure in very large networks. Physical review E, 70(6):066111, 2004.

Aaron Clauset, Cosma Rohilla Shalizi et Mark EJ Newman : Power-law

distributions in empirical data. SIAM review, 51(4):661–703, 2009a.

BIBLIOGRAPHIE

197

Aaron Clauset, Cosma Rohilla Shalizi et Mark EJ Newman : Power-law

distributions in empirical data. SIAM review, 51(4):661–703, 2009b.

Linda M Collins et Clyde W Dent : Omega : A general formulation of the
rand index of cluster recovery suitable for non-disjoint solutions. Multivariate
Behavioral Research, 23(2):231–242, 1988.

Gennaro Cordasco et Luisa Gargano : Label propagation algorithm : a
semi-synchronous approach. International Journal of Social Network Mining,
1(1):3–26, 2012.

Qiguo Dai, Maozu Guo, Yang Liu, Xiaoyan Liu et Ling Chen : Mlpa : De-
tecting overlapping communities by multi-label propagation approach.
In
Evolutionary Computation (CEC), 2013 IEEE Congress on, pages 681–688.
IEEE, 2013.

Allison Davis, Burleigh Bradford Gardner et Mary R Gardner : Deep South :
A social anthropological study of caste and class. Univ of South Carolina Press,
2009.

Pasquale De Meo, Emilio Ferrara, Giacomo Fiumara et Alessandro Pro-
vetti : Enhancing community detection using a network weighting strategy.
Information Sciences, 222:648–668, 2013.

Jeﬀrey Dean et Sanjay Ghemawat : Mapreduce : simpliﬁed data processing

on large clusters. Communications of the ACM, 51(1):107–113, 2008.

L. Donetti et M. A. Mu˜noz : Detecting network communities : a new syste-
matic and eﬃcient algorithm. Journal of Statistical Mechanics : Theory and
Experiment, 10:12, octobre 2004.

Jordi Duch et Alex Arenas : Community detection in complex networks using

extremal optimization. Physical review E, 72(2):027104, 2005.

Lei Fang, Qun Yang, Jiawen Wang et Weihua Lei : Signed network label pro-
pagation algorithm with structural balance degree for community detection.
In International Conference on Smart Homes and Health Telematics, pages
427–435. Springer, 2016.

Miroslav Fiedler : Algebraic connectivity of graphs. Czechoslovak mathema-

tical journal, 23(2):298–305, 1973.

Miroslav Fiedler : A property of eigenvectors of nonnegative symmetric ma-
trices and its application to graph theory. Czechoslovak Mathematical Journal,
25(4):619–633, 1975.

Santo Fortunato : Community detection in graphs. Physics Reports, 486

(3):75–174, 2010.

Linton C Freeman : Centrality in social networks conceptual clariﬁcation.

Social networks, 1(3):215–239, 1978.

198

BIBLIOGRAPHIE

Yaotian Fu et Philip W Anderson : Application of statistical mechanics to
np-complete problems in combinatorial optimisation. Journal of Physics A :
Mathematical and General, 19(9):1605, 1986.

Nishant M Gandhi et Rajiv Misra : Performance comparison of parallel graph
coloring algorithms on bsp model using hadoop. In Computing, Networking
and Communications (ICNC), 2015 International Conference on, pages 110–
116. IEEE, 2015.

Robert Geisberger, Peter Sanders et Dominik Schultes : Better approxi-
mation of betweenness centrality. In Proceedings of the Meeting on Algorithm
Engineering & Expermiments, pages 90–100. Society for Industrial and Ap-
plied Mathematics, 2008.

David Gfeller, Jean-C´edric Chappelier et Paolo De Los Rios : Finding
instabilities in the community structure of complex networks. Physical Review
E, 72(5):056135, 2005.

M. Girvan et M. E. J. Newman : Community structure in social and biological
networks. Proceedings of the National Academy of Sciences, 99(12):7821–7826,
2002a.

Michelle Girvan et Mark EJ Newman : Community structure in social and
biological networks. Proceedings of the national academy of sciences, 99(12):
7821–7826, 2002b.

Murray Glanzer et Robert Glaser : Techniques for the study of group struc-
ture and behavior : Ii. empirical studies of the eﬀects of structure in small
groups. Psychological Bulletin, 58(1):1, 1961.

Pablo M Gleiser et Leon Danon : Community structure in jazz. Advances in

complex systems, 6(04):565–573, 2003.

Gene H Golub : Cf van loan matrix computations. The Johns Hopkins, 1996.

Joseph E Gonzalez, Yucheng Low, Haijie Gu, Danny Bickson et Carlos
Guestrin : Powergraph : Distributed graph-parallel computation on natural
graphs. In OSDI, volume 12, page 2, 2012.

Steve Gregory : An algorithm to ﬁnd overlapping community structure in
networks. In Knowledge discovery in databases : PKDD 2007, pages 91–102.
Springer, 2007.

Steve Gregory : Finding overlapping communities in networks by label pro-

pagation. New Journal of Physics, 12(10):103018, 2010.

R. Guimera, M. Sales-Pardo et L.A.N. Amaral : Modularity from ﬂuc-
tuations in random graphs and complex networks. Physical Review E, 70
(2):025101, 2004.

BIBLIOGRAPHIE

199

Roger Guimera et Luis A Nunes Amaral : Functional cartography of complex

metabolic networks. Nature, 433(7028):895–900, 2005.

Kenneth M Hall : An r-dimensional quadratic placement algorithm. Manage-

ment science, 17(3):219–229, 1970.

Bruce Hendrickson et Robert Leland : An improved spectral graph par-
titioning algorithm for mapping parallel computations. SIAM Journal on
Scientiﬁc Computing, 16(2):452–469, 1995a.

Bruce Hendrickson et Robert W Leland : A multi-level algorithm for parti-

tioning graphs. SC, 95:28, 1995b.

George C Homans : The human group new york. Harpers, 1950.

Roger A Horn et Charles R Johnson : Matrix analysis cambridge university

press. New York, 1985.

Xuegang Hu, Wei He, Huizong Li et Jianhan Pan : Role-based label propaga-

tion algorithm for community detection. CoRR, abs/1601.06307, 2016.

Lawrence Hubert et Phipps Arabie : Comparing partitions. Journal of clas-

siﬁcation, 2(1):193–218, 1985.

Panos Kalnis, Karim Awara, Hani Jamjoom et Zuhair Khayyat : Mizan :
Optimizing graph mining in large parallel systems. Rapport technique, King
Abdullah University of Science and Technology, 2012.

Rushed Kanawati : Licod : Leaders identiﬁcation for community detection in
complex networks. In Privacy, Security, Risk and Trust (PASSAT) and IEEE
Third Inernational Conference on Social Computing (SocialCom), pages 577–
582. IEEE, 2011.

U Kang, Brendan Meeder, Evangelos E Papalexakis et Christos Falout-
sos : Heigen : Spectral analysis for billion-scale graphs. IEEE Transactions
on knowledge and data engineering, 26(2):350–362, 2014.

U Kang, Charalampos E Tsourakakis et C.Faloutsos : Pegasus : A peta-
scale graph mining system implementation and observations. In Data Mining,
2009. ICDM’09. Ninth IEEE International Conference on, pages 229–238.
IEEE, 2009.

Ravi Kannan, Santosh Vempala et Adrian Vetta : On clusterings : Good,

bad and spectral. Journal of the ACM (JACM), 51(3):497–515, 2004.

Brian Karrer, Elizaveta Levina et Mark EJ Newman : Robustness of com-

munity structure in networks. Physical Review E, 77(4):046119, 2008.

George Karypis et Vipin Kumar : Multilevel graph partitioning schemes. In

ICPP (3), pages 113–122, 1995.

200

BIBLIOGRAPHIE

George Karypis et Vipin Kumar : A fast and high quality multilevel scheme
for partitioning irregular graphs. SIAM Journal on scientiﬁc Computing, 20
(1):359–392, 1998a.

George Karypis et Vipin Kumar : Multilevelk-way partitioning scheme for
irregular graphs. Journal of Parallel and Distributed computing, 48(1):96–
129, 1998b.

Stephen Kelley : The existence and discovery of overlapping communities in
large-scale networks. Th`ese de doctorat, RENSSELAER POLYTECHNIC
INSTITUTE, 2009.

Anne-Marie Kermarrec, Erwan Le Merrer, Bruno Sericola et Gilles
Tr´edan : Second order centrality : Distributed assessment of nodes criti-
city in complex networks. Computer Communications, 34(5):619–628, 2011.

Zuhair Khayyat, Karim Awara, Amani Alonazi, Hani Jamjoom, Dan
Williams et Panos Kalnis : Mizan : a system for dynamic load balancing
in large-scale graph processing.
In Proceedings of the 8th ACM European
Conference on Computer Systems, pages 169–182. ACM, 2013.

Yehuda Koren, Liran Carmel et David Harel : Ace : A fast multiscale eigen-
vectors computation for drawing huge graphs. In Information Visualization,
2002. INFOVIS 2002. IEEE Symposium on, pages 137–144. IEEE, 2002.

Valdis Krebs : Books about us politics. unpublished, http ://www. orgnet. com,

2004.

S Kullback : Statistics and information theory. J. Wiley and Sons, New York,

1959.

Konstantin Kuzmin, Mingming Chen et Boleslaw K Szymanski : Parallelizing
slpa for scalable overlapping community detection. Scientiﬁc Programming,
2015:4, 2015.

Andrea Lancichinetti, Santo Fortunato et J´anos Kert´esz : Detecting the
overlapping and hierarchical community structure in complex networks. New
Journal of Physics, 11(3):033015, 2009.

Andrea Lancichinetti, Santo Fortunato et Filippo Radicchi : Benchmark
graphs for testing community detection algorithms. Physical review E, 78
(4):046110, 2008.

Andrea Lancichinetti, Filippo Radicchi, Jos´e J Ramasco et Santo Fortu-
nato : Finding statistically signiﬁcant communities in networks. PloS one,
6(4):e18961, 2011.

Cornelius Lanczos : An iteration method for the solution of the eigenvalue
problem of linear diﬀerential and integral operators. United States Governm.
Press Oﬃce Los Angeles, CA, 1950.

BIBLIOGRAPHIE

201

Conrad Lee, Fergal Reid, Aaron McDaid et Neil Hurley : Detecting highly
overlapping community structure by greedy clique expansion. In SNAKDD
Workshop, page 4533–42, 2010.

Ian XY Leung, Pan Hui, Pietro Lio et Jon Crowcroft : Towards real-time
community detection in large networks. Physical Review E, 79(6):066107,
2009.

Wei Liu, Xingpeng Jiang, Matteo Pellegrini et Xiaofan Wang : Discove-
ring communities in complex networks by edge label propagation. Scientiﬁc
reports, 6, 2016.

Hao Lou, Shenghong Li et Yuxin Zhao : Detecting community structure using
label propagation with weighted coherent neighborhood propinquity. Physica
A : Statistical Mechanics and its Applications, 392(14):3095–3105, 2013.

L´aszl´o Lov´asz : Combinatorial problems and exercises, volume 361. American

Mathematical Soc., 1993.

Yucheng Low, Joseph E. Gonzalez, Aapo Kyrola, Danny Bickson, Carlos
Guestrin et Joseph M. Hellerstein : Graphlab : A new framework for
parallel machine learning. CoRR, abs/1408.2041, 2014.

Robert Harry Lowie : Social organization. 1950.

R Duncan Luce et Albert D Perry : A method of matrix analysis of group

structure. Psychometrika, 14(2):95–116, 1949.

David Lusseau, Karsten Schneider, Oliver J Boisseau, Patti Haase, Elisa-
beth Slooten et Steve M Dawson : The bottlenose dolphin community of
doubtful sound features a large proportion of long-lasting associations. Be-
havioral Ecology and Sociobiology, 54(4):396–405, 2003.

Grzegorz Malewicz, Matthew H Austern, Aart JC Bik, James C Dehnert,
Ilan Horn, Naty Leiser et Grzegorz Czajkowski : Pregel : a system for
large-scale graph processing. In Proceedings of the 2010 ACM SIGMOD In-
ternational Conference on Management of data, pages 135–146. ACM, 2010.

Spiros Mancoridis, Brian S Mitchell, Chris Rorres, Yih-Farn Chen et
Emden R Gansner : Using automatic clustering to produce high-level system
organizations of source code. In IWPC, volume 98, pages 45–52, 1998.

Christopher D Manning, Prabhakar Raghavan et Hinrich Sch¨utze : Flat

clustering. Introduction to information retrieval, pages 350–374, 2008.

Claire P Massen et Jonathan PK Doye : Thermodynamics of community

structure. arXiv preprint cond-mat/0610077, 2006.

Aaron F McDaid, Derek Greene et Neil Hurley : Normalized mutual infor-
mation to evaluate overlapping community ﬁnding algorithms. arXiv preprint
arXiv :1110.2515, 2011.

202

BIBLIOGRAPHIE

Guy Melancon : Just how dense are dense graphs in the real world ? : a me-
thodological note. In Proceedings of the 2006 AVI workshop on BEyond time
and errors : novel evaluation methods for information visualization, pages
1–7. ACM, 2006.

Pasquale De Meo, Emilio Ferrara, Giacomo Fiumara et Alessandro Pro-
vetti : Generalized louvain method for community detection in large net-
works.
In Intelligent Systems Design and Applications (ISDA), 2011 11th
International Conference on, pages 88–93. IEEE, 2011.

Seunghyeon Moon, Jae-Gil Lee, Minseo Kang et al. : Scalable community de-
tection from networks by computing edge betweenness on mapreduce. In 2014
International Conference on Big Data and Smart Computing (BIGCOMP),
pages 145–148. IEEE, 2014.

Jacob L Moreno : Who shall survive, volume 58. JSTOR, 1934.

Jacob Levy Moreno : Sociometry, experimental method and the science of

society. 1951.

George Peter Murdock : Social structure. 1949.

S Nadel : The theory of social structure (cohen and west, london). 1957.

Tam´as Nepusz, Andrea Petr´oczi, L´aszl´o N´egyessy et F¨ul¨op Bazs´o : Fuzzy
communities and the concept of bridgeness in complex networks. Physical
Review E, 77(1):016107, 2008.

