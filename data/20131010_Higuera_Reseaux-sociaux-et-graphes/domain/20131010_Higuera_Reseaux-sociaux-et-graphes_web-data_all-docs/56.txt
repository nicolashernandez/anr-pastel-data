http://grenet.drimm.u-bordeaux1.fr/pdf/2006/CHALOPIN_JEREMIE_2006.pdf

No d’ordre : 3257

TH`ESE

PR´ESENT´EE `A

L’UNIVERSIT´E BORDEAUX I

´ECOLE DOCTORALE DE MATH´EMATIQUES ET

D’INFORMATIQUE

Par J´er´emie CHALOPIN

POUR OBTENIR LE GRADE DE

DOCTEUR

SP´ECIALIT´E : INFORMATIQUE

Algorithmique Distribu´ee, Calculs Locaux

et Homomorphismes de Graphes

Soutenue le : 24 novembre 2006

Apr`es avis des rapporteurs :

Joﬀroy Beauquier . . . . Professeur
Jacques Mazoyer . . . . . Professeur
Antoni Mazurkiewicz Professeur

Devant la commission d’examen compos´ee de :

Joﬀroy Beauquier . . . . Professeur Rapporteur
Bruno Courcelle . . . . Professeur
Jacques Mazoyer . . . . . Professeur Rapporteur
Yves M´etivier . . . . . . . Professeur Directeur de Th`ese

Pr´esident

2006

Remerciements

Mes remerciements s’adressent en premier lieu `a mon directeur de th`ese, Yves M´etivier.
Il m’a dans un premier temps encadr´e lors de mon stage de D´EA et c’est `a cette occasion
qu’il m’a fait d´ecouvrir le domaine de l’algorithmique distribu´ee. Par la suite, il m’a encadr´e
durant ma th`ese et je tiens le remercier pour l’´ecoute et la disponibilit´e dont il a fait preuve
au cours de ces ann´ees : cela a ´et´e un r´eel plaisir de travailler avec lui.

Je tiens `a remercier chaleureusement Joﬀroy Beauquier, Jacques Mazoyer et Antoni
Mazurkiewicz qui m’ont fait l’honneur de relire mon m´emoire. Leurs commentaires ont ´et´e
tr`es enrichissants et je tiens `a exprimer ma gratitude pour l’int´erˆet qu’ils ont port´e `a mon
travail.

Je remercie ´egalement Bruno Courcelle pour avoir accept´e de pr´esider mon jury et

pour l’int´erˆet qu’il a port´e `a mes travaux au cours de ma th`ese.

Je remercie ´egalement mes coll`egues, amis et parfois coauteurs du LaBRI. Parmi les
plus jeunes, je tiens `a remercier particuli`erement Alexandre, Pascal, Olivier, Bilel, Maxime,
Julien, S´everine, Daniel, Omer, Jocelyn, Antoine, Jean-Fran¸cois, Brahim, Rodrigue, Abe-
laaziz.

Je souhaite ´egalement remercier les personnes ext´erieures au LaBRI avec qui j’ai eu
l’occasion de travailler durant ces trois derni`eres ann´ees : Daniel Paulusma, Shantanu Das,
Paola Flocchini, Nicola Santoro, Wies(cid:3)law Zielonka, Emmanuel Godard.

Finalement, je tiens `a remercier ma famille pour leur soutien.

i

ii

Introduction

Un syst`eme distribu´e est un environnement o`u plusieurs processus collaborent pour
r´ealiser un objectif commun. Dans un r´eseau, les diﬀ´erents processus ne peuvent commu-
niquer directement qu’avec un nombre limit´e d’autres processus, leurs «voisins». L’algo-
rithmique distribu´ee a pour but de d´ecrire quelles sont les tˆaches qui peuvent ˆetre r´ealis´ees
dans de tels syst`emes. Un ´el´ement du r´eseau est un «noeud» et ce qui permet de distinguer
un noeud d’un autre peut ˆetre un identiﬁant (comme une adresse IP sur Internet), mais
plus g´en´eralement, c’est la position de chaque noeud dans le r´eseau qui permet de le distin-
guer. Ce qui caract´erise les syst`emes distribu´es est qu’il n’existe pas a priori de syst`eme de
centralisation qui peut coordonner globalement les diﬀ´erents processus. L’algorithmique
distribu´ee cherche ainsi `a d´eterminer quels sont les comportements globaux qui peuvent
ˆetre obtenus dans de tels syst`emes o`u les comportements des diﬀ´erents processus ont des
eﬀets locaux.

Quelques Probl´ematiques de l’Algorithmique Distribu´ee

Dans ce m´emoire, on ´etudie principalement des probl`emes o`u la «sym´etrie» initiale du
r´eseau doit ˆetre bris´ee. Le probl`eme de l’´election est un probl`eme de ce type, qui a ´et´e
pour la premi`ere fois ´etudi´e par Lelann [LeL77]. Le but d’un algorithme d’´election est de
distinguer un noeud du r´eseau qui est dans l’´etat ´elu `a la ﬁn de l’ex´ecution de l’algorithme,
alors que tous les autres noeuds sont dans l’´etat non-´elu. Si les noeuds poss`edent des
identiﬁants uniques, alors on peut ´elire le noeud qui a le plus petit identiﬁant. Si de tels
identiﬁants n’existent pas, le r´eseau est dit anonyme et on va voir qu’il est impossible
de r´esoudre l’´election dans certains r´eseaux anonymes qui sont trop «sym´etriques». Un
autre probl`eme qui n´ecessite de briser la sym´etrie initiale du r´eseau est le probl`eme du
nommage. Le but d’un algorithme de nommage est d’arriver dans une conﬁguration ﬁnale
o`u un identiﬁant unique est associ´e `a chaque noeud. Les probl`emes du nommage et de
l’´election sont ´equivalents dans certains mod`eles (si on sait r´esoudre l’un, on sait r´esoudre
l’autre), mais ce n’est pas toujours le cas. D’autres probl`emes classiques en algorithmique
distribu´ee sont aussi bas´es sur la rupture de la «sym´etrie» comme par exemple le calcul
d’un arbre couvrant ou la reconstruction d’une carte du r´eseau o`u chaque noeud doit
connaˆıtre sa position dans le r´eseau.

Ces probl`emes sont tr`es importants en algorithmique distribu´ee puisque de nombreux
algorithmes existants ne fonctionnent correctement que sous l’hypoth`ese qu’il existe un
noeud distingu´e ou que les processus ont des identiﬁants uniques. Disposer d’un noeud
distingu´e permet par exemple, de centraliser ou de diﬀuser de l’information, d’initialiser
l’ex´ecution d’un algorithme, de prendre une d´ecision de mani`ere centralis´ee, etc. De mˆeme,

iii

iv

disposer d’une carte du r´eseau o`u chaque processeur connaˆıt sa position dans le r´eseau per-
met de diﬀuser de l’information `a partir d’un noeud en minimisant le nombre de messages
utilis´es.

Ces probl`emes ont ´et´e tr`es ´etudi´es dans la litt´erature, et de nombreux algorithmes
ont ´et´e propos´es pour des topologies particuli`eres : les arbres, les anneaux, les tores,
etc. On pourra se r´ef´erer aux livres de Tel [Tel00], d’Attiya et Welch [AW04] ou de
Lynch [Lyn96] pour plus de d´etails sur ces r´esultats. Dans les sections suivantes, on pr´esente
les r´esultats existants pour les r´eseaux de topologies arbitraires obtenus par Yamashita et
Kameda [YK96b], par Boldi, Codenotti, Gemmell, Shammah, Simon et Vigna [BCG+96]
et par Mazurkiewicz [Maz97].

Dans ce m´emoire, dans tous les mod`eles qu’on consid`ere, un r´eseau est mod´elis´e par
un graphe simple dont les sommets correspondent aux processus et dont les arˆetes cor-
respondent aux liens de communication. On consid`ere des r´eseaux de topologie arbitraire
qui sont ﬁables : il ne se produit aucune d´efaillance, ni sur les noeuds, ni sur les liens de
communication.

Des R´esultats G´en´eraux

Caract´eriser les graphes admettant des algorithmes d’´election ou de nommage dans les
diﬀ´erents mod`eles est un probl`eme important pour l’´etude de ces mod`eles. D’une part,
on va voir que cela permet de mettre en ´evidence les diﬀ´erences entre les mod`eles et cela
permet de pouvoir montrer qu’un mod`ele a une puissance de calcul strictement plus forte
qu’un autre. Ces caract´erisations permettent de d´ecrire de mani`ere combinatoire quelles
sont les «sym´etries» d’un graphe qui empˆechent de le distinguer d’un autre.

D’autre part, la compr´ehension des caract´eristiques des graphes admettant un algo-
rithme d’´election ou de nommage dans les diﬀ´erents mod`eles est une ´etape importante
dans la compr´ehension de ce qui est calculable de mani`ere distribu´ee. Ainsi, les travaux de
Yamashita et Kameda [YK96a, YK98] sur les fonctions qui pouvaient ˆetre calcul´ees dans
un mod`ele o`u les processus communiquent par ´echange de messages utilisent les concepts
introduits dans [YK96b] o`u ils caract´erisent les r´eseaux admettant un algorithme d’´election
dans ce mˆeme mod`ele.

Dans [BCG+96], Boldi, Codenotti, Gemmell, Shammah, Simon et Vigna caract´erisent
les graphes qui admettent un algorithme d’´election dans un mod`ele o`u en un pas de calcul,
un sommet peut modiﬁer son ´etat en fonction de l’´etat de ses voisins. Ils consid`erent
un mod`ele synchrone o`u en un pas de calcul tous les sommets du graphe appliquent
une transition de ce type et un mod`ele entrelac´e, o`u `a chaque ´etape, il y a un unique
sommet qui applique une transition. `A partir des r´esultats pr´esent´es dans [BCG+96], Boldi
et Vigna ont caract´eris´e quelles fonctions pouvaient ˆetre calcul´ees de mani`ere distribu´ee
dans le mˆeme mod`ele [BV99, BV01]. Toujours en utilisant les mˆemes outils, ils ont aussi
caract´eris´e quelles tˆaches pouvaient ˆetre eﬀectu´ees de mani`ere auto-stabilisante [BV02b]
dans un syst`eme synchrone.

Dans [Maz97], Mazurkiewicz caract´erise les graphes admettant un algorithme de nom-
mage dans un mod`ele o`u en un pas de calcul, un sommet peut modiﬁer son ´etat et l’´etat
de ses voisins en fonction de son propre ´etat et de l’´etat de ses voisins. Ce mod`ele est
entrelac´e puisque deux voisins ne peuvent pas appliquer simultan´ement une transition de
ce type. Dans [GM02], Godard et M´etivier utilisent l’algorithme de Mazurkiewicz ainsi que

v

d’autres outils pour caract´eriser quelles sont les familles de graphes qui admettent un al-
gorithme universel d’´election dans ce mod`ele. Cet algorithme est aussi utilis´e dans [MT00]
par M´etivier et Tel aﬁn de d´eterminer quelles conditions permettent de d´etecter la termi-
naison globale d’un algorithme distribu´e. Dans les travaux de Godard, M´etivier et Mu-
scholl [GMM04, GM03], l’algorithme de Mazurkiewicz est aussi l’un des outils utilis´es aﬁn
de caract´eriser les classes de graphes qui peuvent ˆetre reconnues de mani`ere distribu´ee
dans ce mod`ele.

Importance des Connaissances Initiales

Une fois qu’on sait qu’un r´eseau admet un algorithme d’´election dans un mod`ele, on
cherche `a savoir quelle caract´eristique du r´eseau est n´ecessaire pour obtenir un algorithme
d’´election pour ce r´eseau. L’algorithme peut ˆetre tout `a fait sp´eciﬁque : pour un r´eseau
diﬀ´erent, il faudra utiliser un autre algorithme. On peut toutefois souhaiter obtenir des
algorithmes universels pour certaines familles de graphes.

Si on consid`ere l’ensemble des graphes de taille n qui admettent un algorithme d’´elec-
tion, est-il possible de trouver un algorithme universel qui permette de r´esoudre le probl`eme
de l’´election sur tous ces graphes ? Autrement dit, est-il possible de r´esoudre le probl`eme
de l’´election en connaissant seulement la taille du graphe ? De mˆeme, on peut se demander
s’il est possible de r´esoudre le probl`eme de l’´election en connaissant seulement une borne
sur la taille du graphe ou sans aucune connaissance sur le graphe.

Puisque tous les graphes n’admettent pas d’algorithme d’´election, il est assez naturel
de se demander quelles sont les connaissances «minimales» qui permettent `a un algorithme
de d´etecter qu’on ne peut pas r´esoudre le probl`eme sur le graphe sur lequel l’algorithme est
ex´ecut´e. Il est clair que si on connaˆıt la topologie du graphe et qu’on sait caract´eriser les
graphes n’admettant pas d’algorithme d’´election, il est possible de d´etecter qu’on ne peut
pas r´esoudre le probl`eme sur le graphe avant mˆeme de commencer l’ex´ecution. Cependant,
est-il possible de d´etecter que le probl`eme ne peut pas ˆetre r´esolu sur un graphe de mani`ere
distribu´ee en connaissant seulement la taille du graphe ou une borne sur la taille du
graphe ?

La recherche de solutions g´en´erales de ce type permet d’obtenir des algorithmes plus
«ﬁables» : les conditions que doivent v´eriﬁer un r´eseau pour que l’algorithme fonctionne
correctement sont moins contraignantes. Ainsi, on pr´ef´erera un algorithme d’´election qui
n´ecessite la connaissance d’une borne sur la taille du graphe `a un algorithme qui n´ecessite
de connaˆıtre la topologie du graphe, puisque dans le premier cas, on peut ajouter ou
enlever un certain nombre de sommets et continuer `a utiliser le mˆeme algorithme.

Travaux Existants

Depuis le travail original d’Angluin [Ang80], il est connu que certains r´eseaux n’ad-
mettent pas d’algorithme d’´election en raison de leur «sym´etrie» trop importante. Dans le
mod`ele d’Angluin, l’outil pour exprimer ces sym´etries est la notion de revˆetements simples
qui sont des homomorphismes de graphes simples localement bijectifs. Par ailleurs, le rai-
sonnement d’Angluin permet de montrer aussi qu’il existe des graphes qu’on ne peut pas
distinguer les uns des autres. Ainsi, si un graphe G est un revˆetement simple d’un graphe
H, il n’existe pas d’algorithme permettant aux sommets du graphe sur lequel l’algorithme

vi

est ex´ecut´e de d´ecider si le graphe auquel ils appartiennent est le graphe G ou le graphe
H.

Ce r´esultat d’impossibilit´e a ensuite ´et´e adapt´e dans le mod`ele consid´er´e par Mazurkie-
wicz [Maz97] et dans le mod`ele ´etudi´e par Boldi et al. [BCG+96]. Mazurkiewicz [Maz97]
a donn´e un algorithme qui permet de r´esoudre nommage et ´election dans tous les graphes
pour lesquels le raisonnement d’Angluin ne permettait pas d’obtenir un r´esultat d’impos-
sibilit´e. L’algorithme de Mazurkiewicz repose seulement sur les connaissances locales que
chaque sommet peut collecter `a propos de ses voisins et permet de r´esoudre les probl`emes
de l’´election et du nommage sur tout graphe qui n’est un revˆetement d’aucun autre graphe
que lui-mˆeme.

La caract´erisation obtenue par Yamashita et Kameda [YK96b] dans un mod`ele o`u les
processus communiquent par ´echange de messages est tr`es diﬀ´erente de celle de Mazurkie-
wicz et les techniques utilis´ees sont elles aussi totalement diﬀ´erentes. La caract´erisation de
Yamashita et Kameda [YK96b] est exprim´ee en termes de «vues», o`u la vue d’un sommet
v est un arbre inﬁni dont les sommets sont les chemins issus de v dans le graphe. Yama-
shita et Kameda montrent que pour tout algorithme, si deux sommets ont la mˆeme vue, il
existe une ex´ecution de l’algorithme o`u ces deux sommets restent toujours dans le mˆeme
´etat. L’algorithme de Yamashita et Kameda repose sur un r´esultat de Norris [Nor95] qui
a montr´e que deux sommets d’un graphe de taille n avaient la mˆeme vue si leurs vues
tronqu´ees `a la hauteur n ´etaient les mˆemes. Ainsi, dans l’algorithme de Yamashita et Ka-
meda, chaque sommet construit sa vue tronqu´ee `a la hauteur n et la compare ensuite avec
celle des autres sommets du graphe ; le sommet ayant la plus «petite» vue est ensuite ´elu.
Les travaux de Boldi et al. [BCG+96] permettent d’´etablir un premier lien entre les
travaux de Yamashita et Kameda et ceux de Mazurkiewicz. En eﬀet, Boldi et al. utilisent
un raisonnement «`a la Angluin» pour ´etablir des r´esultats d’impossibilit´e mais leurs al-
gorithmes d’´election fonctionnent sur le mˆeme principe que l’algorithme de Yamashita et
Kameda. Les r´esultats d’impossibilit´e pr´esent´es par Boldi et al. reposent sur la notion de ﬁ-
brations qui sont des homomorphismes de graphes dirig´es qui induisent une bijection entre
les arcs entrants de chaque sommet et les arcs entrants de son image. Dans [BCG+96],
Boldi et al. montrent comment obtenir des ﬁbrations (qui ont des propri´et´es similaires aux
revˆetements) `a partir de la vue de chaque sommet.

Cependant, les algorithmes utilis´es par Yamashita et Kameda et par Boldi et Vigna
restent tr`es diﬀ´erents de l’algorithme de Mazurkiewicz. En eﬀet, les algorithmes de Yama-
shita et Kameda et de Boldi et Vigna n´ecessitent des connaissances initiales sur le graphe
aﬁn de savoir jusqu’`a quelle hauteur chaque sommet doit calculer sa vue. Au contraire, l’al-
gorithme de Mazurkiewicz ne n´ecessite aucune connaissance initiale et il termine toujours,
mˆeme si sans connaissance initiale, il est impossible aux sommets de d´etecter si l’ex´ecution
de l’algorithme est termin´ee ou non. Cette diﬀ´erence est importante puisque cette pro-
pri´et´e de l’algorithme de Mazurkiewicz est utilis´ee dans [GMM04] aﬁn de caract´eriser les
classes de graphes reconnaissables de mani`ere distribu´ee dans le mod`ele consid´er´e par
Mazurkiewicz (dans ce cadre, les sommets ne doivent pas n´ecessairement d´etecter la ter-
minaison de l’algorithme). Dans [God02b], Godard pr´esente une version auto-stabilisante
de l’algorithme de Mazurkiewicz et cette propri´et´e de terminaison permet d’assurer que
le temps de stabilisation est ﬁni.

Par ailleurs, pour ex´ecuter l’algorithme de Mazurkiewicz, les sommets d’un graphe G
ont besoin d’une m´emoire polynomiale en la taille du graphe, alors que les algorithmes

vii

de Yamashita et Kameda et de Boldi et Vigna n´ecessitent que chaque sommet ait une
m´emoire exponentielle en la taille du graphe. Cette propri´et´e est importante puisque dans
l’algorithme de Yamashita et Kameda, la taille de la m´emoire de chaque processus est li´ee
`a la taille des messages ´echang´es, qui sont aussi de taille exponentielle.

Techniques et R´esultats
´Etudier des Mod`eles Interm´ediaires

Une premi`ere motivation des travaux pr´esent´es dans ce m´emoire est d’´etudier des
mod`eles «interm´ediaires» entre le mod`ele de Mazurkiewicz et le mod`ele de Yamashita et
Kameda. Le but de ce travail est de comprendre quelles sont les limites de chaque mod`ele
et d’essayer de d´eterminer si un r´esultat d’impossibilit´e ou de possibilit´e est sp´eciﬁque `a
un mod`ele ou s’il est plus g´en´eral.

Dans ce but, on consid`ere diﬀ´erents mod`eles utilisant des calculs locaux dont le mod`ele
´etudi´e par Mazurkiewicz est le plus puissant. Dans de tels mod`eles, l’´etat global du syst`eme
distribu´e est repr´esent´e par un graphe simple ´etiquet´e o`u le graphe correspond au r´eseau
sous-jacent et o`u l’´etiquette de chaque sommet repr´esente l’´etat du processus correspon-
dant.

Dans le mod`ele de Mazurkiewicz [Maz97], un pas de calcul permet `a un sommet de
modiﬁer son ´etiquette et l’´etiquette de ses voisins en fonction de sa propre ´etiquette et des
´etiquettes de ses voisins. Ainsi, dans ce mod`ele, un algorithme peut ˆetre d´ecrit `a l’aide de
r`egles de r´e´etiquetage qui permettent de modiﬁer les ´etiquettes des sommets d’une ´etoile
du graphe (un sommet et ses voisins) en fonction seulement des ´etiquettes apparaissant
sur cette ´etoile. Ce mod`ele correspond au mod`ele (7) de la Figure 1. Les r´esultats de
Mazurkiewicz [Maz97] et des corollaires de r´esultats plus g´en´eraux obtenus par Godard et
M´etivier [GM02] sont pr´esent´ees au Chapitre 2.

Dans le mod`ele entrelac´e de Boldi et al. [BCG+96], un pas de calcul permet `a un som-
met de modiﬁer seulement son ´etiquette en fonction de sa propre ´etiquette et de l’´etiquette
de ses voisins. Ce mod`ele peut ˆetre d´ecrit `a l’aide de r`egles de r´e´etiquetage de graphes qui
permettent de modiﬁer l’´etiquette d’un sommet en fonction des ´etiquettes de ses voisins.
Ce mod`ele correspond au mod`ele (5) de la Figure 1. On ´etudie ce mod`ele au Chapitre 4 :
on pr´esente de nouvelles preuves des r´esultats de Boldi et al. [BCG+96]. On pr´esente
en particulier des algorithmes de nommage et d’´election qui utilisent certaines id´ees de
l’algorithme de Mazurkiewicz et qui n´ecessitent que chaque sommet ait une m´emoire po-
lynomiale en la taille du graphe, et non exponentielle comme les algorithmes de Boldi et
al.

Les mod`eles ´etudi´es par Boldi et al. [BCG+96] et par Mazurkiewicz [Maz97] sont des
mod`eles plus abstraits que le mod`ele ´etudi´e par Yamashita et Kameda, mais dans lesquels
les caract´erisations pr´esent´ees s’expriment de mani`ere ´el´egante. Ces mod`eles correspondent
`a diﬀ´erents niveaux de synchronisation entre voisins. En eﬀet, bien que l’ex´ecution soit
globalement asynchrone, un pas de calcul n´ecessite une synchronisation entre un sommet
et ses voisins.

Dans ce m´emoire, on ´etudie aussi des mod`eles o`u en un pas de calcul, une synchronisa-
tion a lieu entre deux sommets voisins du graphe. Ou bien, les ´etiquettes des deux sommets
peuvent ˆetre modiﬁ´ees en un pas de calcul, ou alors un seul sommet peut modiﬁer son
´etiquette en fonction de l’´etiquette d’un de ses voisins.

viii

(7)

(6)

(1)

(4)

(3)

(2)

(5)

Fig. 1 – Les diﬀ´erents mod`eles de calculs locaux ´etudi´es dans ce m´emoire d´ecrits par le
type de r`egles utilis´ees. Un sommet noir est un sommet actif dont l’´etiquette peut ˆetre
modiﬁ´ee par l’application de la r`egle, alors qu’un sommet blanc est un sommet passif qui
permet d’appliquer la r`egle mais dont l’´etiquette n’est pas modiﬁ´ee. Dans les mod`eles (3),
(4) et (6), les ´etiquettes des arˆetes peuvent ˆetre modiﬁ´ees alors que ce n’est pas possible
dans les autres mod`eles.

On se rend rapidement compte que dans ces mod`eles o`u les synchronisations ont
lieu sur des arˆetes, on obtient des mod`eles strictement plus puissants lorsque les r`egles
de r´e´etiquetages peuvent modiﬁer les ´etiquettes des arˆetes sur lesquelles elles sont ap-
pliqu´ees. De mˆeme, dans le mod`ele de Boldi et al., on obtient un mod`ele plus puissant si
les r`egles de r´e´etiquetage peuvent modiﬁer les ´etiquettes des arˆetes incidentes au sommet
dont l’´etiquette est modiﬁ´ee. On verra au Chapitre 2 que ce n’est pas le cas pour le mod`ele
de Mazurkiewicz.

Dans le mod`ele (6) de la Figure 1, un pas de calcul permet `a un sommet de modiﬁer son
´etiquette et les ´etiquettes des arˆetes qui lui sont incidentes en fonction de son ´etiquette,
des ´etiquettes des arˆetes qui lui sont incidentes et des ´etiquettes de ses voisins. La seule
diﬀ´erence entre ce mod`ele et le mod`ele (5) de la Figure 1 est le fait que les arˆetes du
graphe peuvent ˆetre ´etiquet´ees et r´e´etiquet´ees.

Dans les mod`eles (2) et (4) de la Figure 1, un pas de calcul permet `a deux sommets
voisins de modiﬁer leurs ´etiquettes en fonction de leurs ´etiquettes pr´ec´edentes. La diﬀ´erence
entre ces deux mod`eles est que dans le mod`ele (4), les arˆetes du graphes peuvent ˆetre
´etiquet´ees et r´e´etiquet´ees et lorsqu’une r`egle de r´e´etiquetage est appliqu´ee sur une arˆete,
la r`egle peut d´ependre de l’´etiquette de l’arˆete et peut modiﬁer cette ´etiquette.

Dans les mod`eles (1) et (3) de la Figure 1, un pas de calcul permet `a un sommet de
modiﬁer son ´etiquette en fonction de l’´etiquette d’un de ses voisins. Dans le mod`ele (3),
comme dans le mod`ele (4), les arˆetes du graphes peuvent ˆetre ´etiquet´ees et lorsqu’une r`egle
de r´e´etiquetage permet de modiﬁer l’´etiquette d’un sommet v en fonction de l’´etiquette
(cid:2)} et peut
de l’un de ses voisins v
modiﬁer cette ´etiquette.

(cid:2), la r`egle peut d´ependre de l’´etiquette de l’arˆete {v, v

Dans les Chapitres 2, 3, 4, 5 et 6, on ´etudie les diﬀ´erents mod`eles de la Figure 1 `a

ix

travers les probl`emes de l’´election et du nommage. Pour chaque mod`ele, on caract´erise les
graphes dans lesquels on peut r´esoudre les probl`emes de l’´election et du nommage. Pour
obtenir des conditions n´ecessaires, il faut d’abord trouver quels sont les homomorphismes
qui permettent d’obtenir un lemme de rel`evement «`a la Angluin» pour la classe de graphes
la plus large possible pour chaque mod`ele consid´er´e. Pour obtenir des conditions suﬃsantes,
il faut ensuite trouver un algorithme qui permette de nommer dans tous les graphes pour
lesquels on n’a pas obtenu de r´esultat d’impossibilit´e. La recherche de ces homomorphismes
et de ces algorithmes sont tr`es li´es, puisqu’il faut r´eussir `a d´eterminer exactement quelles
sont les informations que peut obtenir chaque sommet `a propos de ses voisins. Par exemple,
dans certains mod`eles, un sommet peut r´eussir `a d´etecter s’il a un ou plusieurs voisins
qui ont la mˆeme ´etiquette, alors que ce n’est pas possible dans d’autres mod`eles. Les
algorithmes qu’on propose sont inspir´es de l’algorithme de Mazurkiewicz, au sens o`u,
un sommet essaie d’obtenir le plus d’information possible `a propos de son voisinage. Il
faut toutefois noter que les algorithmes propos´es ne sont pas des adaptations triviales
de l’algorithme de Mazurkiewicz et qu’il faut dans chaque mod`ele utiliser des m´ethodes
particuli`eres aﬁn de s’assurer que chaque sommet r´eussisse `a collecter toute l’information `a
propos de ses voisins dont il a besoin. Les caract´erisations obtenues permettent de mettre
en ´evidence les relations entre les mod`eles et la diﬀ´erence entre leurs puissances de calcul
respectives.

On cherche ensuite `a d´eterminer quelles connaissances initiales sont n´ecessaires pour
r´esoudre ces probl`emes. Les r´esultats obtenus nous permettent de mettre en ´evidence
quels sont les r´esultats existants dans le mod`ele de Mazurkiewicz [MT00, GM02, GM03,
GMM04] qu’on peut esp´erer pouvoir ´etendre dans les diﬀ´erents mod`eles consid´er´es et quels
sont les r´esultats qui sont sp´eciﬁques `a certains mod`eles. Cela permet de pr´esenter sous
un angle diﬀ´erent les diﬀ´erences entre les mod`eles consid´er´es.

Dans le Chapitre 3, on ´etudie les mod`eles (3), (4) et (6) de la Figure 1. Dans ces trois
mod`eles, les arˆetes peuvent ˆetre ´etiquet´ees (et r´e´etiquet´ees). On montre que les mod`eles
(3) et (4) ont la mˆeme puissance de calcul et que si chaque sommet connaˆıt initialement
son degr´e (i.e., son degr´e fait partie de son ´etiquette initiale), ces mod`eles sont aussi
puissant que le mod`ele (6). La caract´erisation des graphes admettant un algorithme de
nommage ou d’´election dans ces mod`eles est bas´ee sur la notion de revˆetements, qui sont
des homomorphismes de graphes localement bijectifs, o`u les graphes consid´er´es peuvent
avoir des arˆetes multiples. On montre que les mod`eles consid´er´es au Chapitre 3 ont la
mˆeme puissance de calcul que le mod`ele ´etudi´e par Angluin [Ang80] et que le mod`ele
de communication synchrone dans un syst`eme asynchrone. On obtient ainsi la premi`ere
caract´erisation des graphes admettant un algorithme de nommage ou d’´election dans ces
mod`eles `a partir des r´esultats obtenus pour les mod`eles (3), (4) et (6) de la Figure 1. Une
partie des r´esultats pr´esent´es au Chapitre 3 a ´et´e publi´ee dans [CM04].

Lorsque les arˆetes ne peuvent pas ˆetre ´etiquet´ees, on ne peut pas obtenir de r´esultats
d’´equivalence correspondant `a ceux pr´esent´es au Chapitre 3. Dans le Chapitre 4, on ´etudie
le mod`ele entrelac´e de Boldi et al. [BCG+96] qui correspond au mod`ele (5) de la Fi-
gure 1. Les caract´erisations des graphes admettant un algorithme d’´election ou de nom-
mage pr´esent´ees au Chapitre 4 permettent de montrer que le mod`ele (5) a une puissance
de calcul strictement plus faible que le mod`ele (6).

Dans le Chapitre 5, on ´etudie le mod`ele (2) de la Figure 1. Aﬁn de caract´eriser les
graphes admettant un algorithme d’´election ou de nommage dans ce mod`ele, on introduit

x

la notion de pseudo-revˆetements. Grˆace `a cette caract´erisation, on peut montrer que le
mod`ele (2) a une puissance de calcul strictement plus faible que les mod`eles (3) et (4)
et que les puissances de calcul des mod`eles (2) et (5) sont incomparables. Une partie des
r´esultats pr´esent´es au Chapitre 5 a ´et´e publi´ee dans [Cha05].

Dans le Chapitre 6, on ´etudie le mod`ele (1) de la Figure 1. La caract´erisation des
graphes admettant un algorithme de nommage dans ce mod`ele est bas´ee sur la notion
de submersions qui sont des homomorphismes localement surjectifs de graphes simples.
Cette caract´erisation permet de montrer que le mod`ele (1) a une puissance de calcul
strictement plus faible que les mod`eles (2) et (5). La caract´erisation des graphes admettant
un algorithme d’´election dans ce mod`ele repose aussi sur la notion de submersions mais
la caract´erisation obtenue et l’algorithme d’´election pr´esent´e sont assez techniques. Une
partie des r´esultats pr´esent´es au Chapitre 6 a ´et´e publi´ee dans [CMZ04] et une version
compl`ete est parue dans [CMZ06].

Des Algorithmes plus Eﬃcaces et de Nouvelles Caract´erisations

Un autre objectif de ce m´emoire est de fournir un nouvel algorithme d’´election dans
le mod`ele o`u les processus communiquent par ´echange de messages. Il s’agit d’obtenir un
algorithme «`a la Mazurkiewicz» dans le mod`ele de Yamashita et Kameda ; le but ´etant
d’obtenir un algorithme plus eﬃcace et «impl´ementable».

Dans le Chapitre 7, on consid`ere comme Yamashita et Kameda [YK96b], les syst`emes
o`u les processus communiquent par ´echange de messages. On pr´esente d’abord un codage
du r´eseau qui permet d’exprimer toutes les transitions possibles d’un tel syst`eme par des
r`egles de r´e´etiquetages du mˆeme type que celles du mod`ele (4) de la Figure 1. `A partir de
ce codage et des r´esultats d’impossibilit´e du Chapitre 3, on d´eduit une condition n´ecessaire
que doivent v´eriﬁer les graphes qui admettent un algorithme d’´election et de nommage.
On pr´esente ensuite un algorithme de nommage «`a la Mazurkiewicz» qui a des pro-
pri´et´es int´eressantes que l’algorithme de Yamashita et Kameda n’a pas. Ainsi, notre al-
gorithme est «totalement» polynomial, au sens o`u le temps d’ex´ecution, le nombre de
messages et les tailles des messages ´echang´es sont polynomiaux en la taille du graphe,
alors que l’algorithme de Yamashita et Kameda n´ecessite un nombre polynomial de mes-
sages de tailles exponentielles. Par ailleurs, pour tout graphe, on montre qu’il existe une
ex´ecution de notre algorithme qui permet d’´elire et de nommer dans ce graphe. Ainsi,
notre algorithme permet parfois d’exploiter l’asym´etrie qui provient de l’ex´ecution et non
du graphe.

On explique ensuite comment ces r´esultats peuvent ˆetre g´en´eralis´es `a des mod`eles plus
faibles o`u les processus communiquent par ´echange de messages qui ont ´et´e ´etudi´es par
Yamashita et Kameda dans [YK99].

Une partie des r´esultats pr´esent´es au Chapitre 7 a ´et´e publi´ee dans [CM05]. D’autres
r´esultats ont ´et´e obtenus dans ce mod`ele [CDS06, CGMT07] et sont pr´esent´es dans la
conclusion du Chapitre 7.

Dans le Chapitre 8, on consid`ere les mod`eles distribu´es o`u les diﬀ´erents sommets du
r´eseau sont passifs et o`u des agents mobiles qui se d´eplacent sur le r´eseau sont en charge
de l’ex´ecution de l’algorithme distribu´e. On montre qu’un tel syst`eme `a agents mobiles est
´equivalent `a un syst`eme distribu´e o`u les processus communiquent par ´echange de messages
si les graphes sous-jacents sont identiques. On en d´eduit une caract´erisation des syst`emes `a

xi

agents mobiles dans lesquels on peut r´esoudre le probl`eme du rendez-vous, et on g´en´eralise
ainsi des r´esultats existants.

Les r´esultats pr´esent´es au Chapitre 8 ont ´et´e publi´es dans [CGMO06]. D’autres r´esul-
tats obtenus dans un mod`ele l´eg`erement diﬀ´erent, qui ont ´et´e publi´es dans [Cha06], sont
pr´esent´es dans la conclusion du Chapitre 8.

Complexit´e

Dans le Chapitre 9, on ´etudie la complexit´e de d´ecider si un graphe admet un algo-
rithme d’´election ou de nommage dans les diﬀ´erents mod`eles consid´er´es dans ce m´emoire.
On montre qu’`a l’exception de deux mod`eles o`u les processus communiquent par ´echange
de messages, il est co-NP-complet de d´ecider si un graphe donn´e admet un algorithme
d’´election ou de nommage dans chaque mod`ele. Ce r´esultat et le fait que les algorithmes
pr´esent´es dans les Chapitres 2,3, 4 et 7 sont des algorithmes distribu´es polynomiaux per-
mettent de mettre en ´evidence l’aspect non-d´eterministe d’une ex´ecution distribu´ee. Les
r´esultats pr´esent´es au Chapitre 9 ont ´et´e publi´es dans [CP06].

xii

Table des mati`eres

1 Pr´eliminaires

1
1
1.1 Graphes non-dirig´es
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.2 Graphes dirig´es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
1.3 R´e´etiquetages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
1.4
1.5 Terminaison Implicite et Explicite
. . . . . . . . . . . . . . . . . . . . . . . 14
1.6 Connaissances Initiales . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

´Election et Nommage

2 Calculs Locaux sur les ´Etoiles Ferm´ees

17
2.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.2 Revˆetements Simples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3 Calculs Locaux sur les ´Etoiles Ferm´ees . . . . . . . . . . . . . . . . . . . . . 23
´Enum´eration, Nommage et ´Election . . . . . . . . . . . . . . . . . . . . . . 24
2.4
2.5
Importance de la Connaissance Initiale . . . . . . . . . . . . . . . . . . . . . 32
2.6 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

3 Calculs Locaux sur les Arˆetes ´Etiquet´ees

39
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
3.1
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
3.2 Revˆetements
3.3 Calculs Locaux (Cellulaires) sur les Arˆetes ´Etiquet´ees
. . . . . . . . . . . . 44
3.4 Un R´esultat d’´Equivalence . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
´Enum´eration, Nommage et ´Election . . . . . . . . . . . . . . . . . . . . . . 57
3.5
3.6
Importance de la Connaissance du Degr´e . . . . . . . . . . . . . . . . . . . . 66
3.7 Conclusion et Perspectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83

4 Calculs Locaux Cellulaires sur les ´Etoiles

85
4.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
4.2 Fibrations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
4.3 Calculs Locaux Cellulaires sur les ´Etoiles
. . . . . . . . . . . . . . . . . . . 91
4.4 Nommage et ´Enum´eration . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
´Election . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
4.5
4.6 Conclusions et Perspectives . . . . . . . . . . . . . . . . . . . . . . . . . . . 107

5 Calculs Locaux sur les Arˆetes Non-´Etiquet´ees

109
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111

5.1
5.2 Pseudo-revˆetements

xiii

xiv

TABLE DES MATI `ERES

5.3 Calculs Locaux sur les Arˆetes Non-´Etiquet´ees . . . . . . . . . . . . . . . . . 114
´Enum´eration, Nommage et ´Election . . . . . . . . . . . . . . . . . . . . . . 115
5.4
5.5 Connaissance Initiale du Degr´e . . . . . . . . . . . . . . . . . . . . . . . . . 127
5.6 Conclusion et Perspectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136

6 Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees

139
6.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
6.2 Submersions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
6.3 Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees . . . . . . . . . . . 143
´Enum´eration et Nommage . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
6.4
´Election . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
6.5
6.6 Exemples
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
6.7 Connaissance Initiale du Degr´e . . . . . . . . . . . . . . . . . . . . . . . . . 166
6.8 Conclusion et Perspectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167

7 ´Echanges de Messages en Mode Asynchrone

169
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
7.1
7.2 Fibrations et Revˆetements Dirig´es
. . . . . . . . . . . . . . . . . . . . . . . 171
7.3 Le Mod`ele . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
7.4 Codage du R´eseau . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
7.5 Un Algorithme d’´Enum´eration . . . . . . . . . . . . . . . . . . . . . . . . . 183
´Election dans les Familles de Diam`etre Born´e . . . . . . . . . . . . . . . . . 193
7.6
7.7 Des ´Etiquetages des Ports plus Faibles . . . . . . . . . . . . . . . . . . . . . 196
7.8 Conclusion et Perspectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201

8 Agents Mobiles

203
8.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
8.2 Le Mod`ele . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
. . . . . . . . . . . . . . . . . . . . . 208
8.3 Des Agents Mobiles vers les Messages
8.4 Des Messages vers les Agents Mobiles
. . . . . . . . . . . . . . . . . . . . . 210
8.5 R´esultat d’´Equivalence et Applications . . . . . . . . . . . . . . . . . . . . . 217
8.6 Conclusion et Perspectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218

9 Complexit´e

221
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
9.1
´Etiquetages Pseudo-R´eguliers . . . . . . . . . . . . . . . . . . . . . . . . . . 222
9.2
9.3 Colorations Semi-R´eguli`eres . . . . . . . . . . . . . . . . . . . . . . . . . . . 229
9.4 Colorations Connexes
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
9.5 Conclusion et Perspectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242

Conclusion et Perspectives

243

Chapitre 1

Pr´eliminaires

Sommaire

1.1.1 D´eﬁnitions
1.1.2 Graphes ´etiquet´es
1.1.3
1.1.4

1
1.1 Graphes non-dirig´es . . . . . . . . . . . . . . . . . . . . . . . . . .
1
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
. . . . . . . . . . . . . . . . . . . . . . . . . .
´Etiquetages particuliers . . . . . . . . . . . . . . . . . . . . . . .
4
´Etiquetage des ports . . . . . . . . . . . . . . . . . . . . . . . . .
5
5
1.2 Graphes dirig´es . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2.1 D´eﬁnitions
6
1.2.2 Graphes dirig´es ´etiquet´es
. . . . . . . . . . . . . . . . . . . . . .
7
1.2.3 Des Graphes non-dirig´es aux Graphes Dirig´es . . . . . . . . . . .
8
1.3 R´e´etiquetages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
1.3.1 D´eﬁnitions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
1.3.2 Relations de R´e´etiquetage sur les Arˆetes . . . . . . . . . . . . . .
1.3.3 Relations de R´e´etiquetage sur les ´Etoiles . . . . . . . . . . . . . .
10
12
1.3.4
S´erialisation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3.5 ViSiDiA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
´Election et Nommage . . . . . . . . . . . . . . . . . . . . . . . . . 13
1.4
1.5 Terminaison Implicite et Explicite . . . . . . . . . . . . . . . . . 14
1.6 Connaissances Initiales . . . . . . . . . . . . . . . . . . . . . . . . 15

Dans ce chapitre, on rappelle d’abord quelques d´eﬁnitions ´el´ementaires sur les graphes
non-dirig´es et dirig´es et on introduit les notations qu’on utilisera par la suite. On pr´esente
ensuite les relations de r´e´etiquetage de graphes et on explique comment elles permettent de
coder des algorithmes distribu´es. On pr´esente ﬁnalement les probl`emes que l’on consid`ere
dans ce m´emoire.

1.1 Graphes non-dirig´es

1.1.1 D´eﬁnitions

D´eﬁnition 1.1 Un graphe non-dirig´e sans boucle est d´eﬁni par un ensemble de sommets
V (G), un ensemble d’arˆetes E(G) et par une fonction ext qui associe `a chaque arˆete deux
´el´ements distincts de V (G), appel´es ses extr´emit´es.

1

2

Chapitre 1. Pr´eliminaires

Pour toute arˆete e ∈ E(G) et tous sommets u, v ∈ E(G) tels que ext(e) = {u, v}, on
dit que l’arˆete e est incidente `a u et `a v. Les sommets u et v sont dits adjacents ou voisins.

Par la suite, sauf pr´ecision contraire, le terme graphe d´esignera un graphe non-dirig´e

sans boucle.
D´eﬁnition 1.2 Un graphe simple non-dirig´e est un graphe non-dirig´e sans boucle tel
qu’il y ait au plus une arˆete entre deux sommets, i.e., pour tous sommets u, v ∈ V (G),
|{e ∈ E(G) | ext(e) ∈ {u, v}}| ≤ 1.
Chaque arˆete e ∈ E(G) peut alors ˆetre vue comme une paire de sommets distincts qui

sont ses extr´emit´es.

Par la suite, sauf pr´ecision contraire, le terme graphe simple d´esignera un graphe simple

non-dirig´e.
D´eﬁnition 1.3 Un graphe H est un sous-graphe partiel d’un graphe G si V (H) = V (G)
et E(H) ⊆ E(G).

Un graphe H est un sous-graphe de G si V (H) ⊆ V (G) et E(H) ⊆ E(G).
Un graphe H est un sous-graphe induit de G si V (H) ⊆ V (G) et E(H) est l’ensemble
des arˆetes de G dont les extr´emit´es sont dans V (H), i.e., ∀e ∈ E(G), ext(e) ⊆ V (H) ⇐⇒
e ∈ E(H). Pour tout graphe G et tout ensemble S ⊆ V (G), on note G[S] le sous-graphe
induit de G dont les sommets sont les ´el´ements de S.

D´eﬁnition 1.4 Dans un graphe G, le voisinage d’un sommet u, not´e NG(u), est l’en-
semble des voisins de u, i.e., NG(u) = {v ∈ V (G) | ∃e ∈ E(G) telle que ext(e) = {u, v}}.
On note IG(u) l’ensemble des arˆetes incidentes au sommet u, i.e., IG(u) = {e ∈ E(G) |
∃e ∈ E(G) telle que u ∈ ext(e)}.
Dans un graphe G, le degr´e d’un sommet u, not´e degG(u), est le nombre d’arˆetes
incidentes `a u, i.e., degG(u) = |IG(u)|. En particulier, si G est un graphe simple, alors le
degr´e de u est son nombre de voisins, i.e., degG(u) = |NG(u)|.

Un graphe G est d-r´egulier si tous les sommets de G sont de degr´e d ; on dit aussi
que G est r´egulier. Dans le cas particulier o`u tous les sommets ont un degr´e 0 (le graphe
ne contient pas d’arˆete), on dit que G est un stable. Un graphe G est biparti si on peut
partitionner les sommets de V (G) en deux ensembles V1 et V2 tels que G[V1] et G[V2]
sont des stables. Un graphe biparti G est (k, l)-semi-r´egulier si tous les sommets de V1
sont de degr´e k et tous les sommets de V2 sont de degr´e l ; on dit aussi que G est biparti
semi-r´egulier. Un graphe G admet un couplage parfait s’il existe un ensemble d’arˆetes
(cid:2) ∈ E(G) tel que chaque sommet v ∈ V (G) soit incident `a exactement une arˆete de E
(cid:2).
E
D´eﬁnition 1.5 ´Etant donn´es un graphe simple G et un sommet u ∈ V (G), l’´etoile de
centre u est le sous-graphe de G d´eﬁni par V (BG(u)) = NG(u) et E(BG(u)) = IG(u).

D´eﬁnition 1.6 Dans un graphe G, un chemin Γ entre deux sommets u et v de G est une
suite altern´ee (u0, e1, u1, e2, . . . , en, un) telle que :

– pour tout i ∈ [0, n], ui ∈ V (G),
– pour tout i ∈ [1, n], ei ∈ E(G),
– pour tout i ∈ [1, n], ext(ei) = {ui−1, ui},
– u0 = u et un = v.

1.1. Graphes non-dirig´es

3

Les sommets u0 et un sont les extr´emit´es du chemin Γ et les sommets u1, . . . , un−1
sont les sommets internes du chemin ; la longueur n du chemin est son nombre d’arˆetes.
Un chemin dont toutes les arˆetes sont distinctes est dit simple et un chemin qui ne

contient pas deux fois le mˆeme sommet est dit ´el´ementaire.

Lorsque les extr´emit´es d’un chemin simple Γ sont confondues, on dit que Γ est un

cycle. Un cycle ´el´ementaire est un cycle dont tous les sommets internes sont distincts.

Dans un graphe simple, un chemin sera g´en´eralement d´ecrit par la suite de ses sommets
(u0, u1, . . . , un), puisque pour tout i ∈ [1, n], l’arˆete ei est n´ecessairement l’arˆete {ui−1, ui}.
Ainsi, dans un graphe simple G, une suite de sommets (u0, u1, . . . , un) est un chemin si
pour tout i ∈ [1, n], {ui−1, ui} ∈ E(G).
D´eﬁnition 1.7 Un graphe G est connexe si pour tous sommets u, v ∈ V (G), il existe un
chemin entre u et v dans G.

Tous les graphes consid´er´es dans ce m´emoire seront connexes.
Un arbre est un graphe connexe sans cycle. Un anneau est un graphe constitu´e d’un
cycle simple. Un arbre couvrant A d’un graphe G est un arbre qui est un graphe partiel
de G.
D´eﬁnition 1.8 ´Etant donn´es un graphe connexe G et deux sommets u, v ∈ V (G), la
distance de u `a v dans G, not´ee distG(u, v), est la longueur du plus court chemin de u `a
v. Le diam`etre de G, not´e D(G), est la plus grande distance entre deux sommets de G,
i.e., D(G) = max{distG(u, v) | u, v ∈ V (G)}.
D´eﬁnition 1.9 Un homomorphisme ϕ d’un graphe G dans un graphe H est une appli-
cation de V (G) dans V (H) et de E(G) dans E(H) qui pr´eserve les relations d’incidence,
i.e., pour toute arˆete e ∈ E(G), ext(ϕ(e)) = ϕ(ext(e)).
D´eﬁnition 1.10 Un homomorphisme ϕ d’un graphe G dans un graphe H est un isomor-
phisme si ϕ est bijective.

On dit alors que G et H sont isomorphes et on note G (cid:9) H.
Une famille (ou classe) de graphes est un ensemble de graphes clos par isomorphisme.
Dans les d´eﬁnitions suivantes, on consid`ere les homomorphismes entre graphes simples.
Il est facile de voir que dans ce cas particulier, ces d´eﬁnitions sont ´equivalentes avec les
pr´ec´edentes.
D´eﬁnition 1.11 Un homomorphisme ϕ d’un graphe simple G dans un graphe simple
H est une application de V (G) dans V (H) qui pr´eserve les relations d’adjacence entre
sommets, i.e., pour toute arˆete {v, w} ∈ E(G), {ϕ(v), ϕ(w)} ∈ E(G).
D´eﬁnition 1.12 Un homomorphisme ϕ d’un graphe simple G dans un graphe simple H
est un isomorphisme si ϕ est bijective et si ϕ

−1 est aussi un isomorphisme.

1.1.2 Graphes ´etiquet´es

On travaille sur des graphes dont les sommets et les arˆetes sont ´etiquet´es par un
ensemble d’´etiquettes L, qui peut ˆetre ﬁni ou inﬁni. On supposera l’ensemble L muni d’un
ordre total, not´e <L.

4

Chapitre 1. Pr´eliminaires

Un graphe ´etiquet´e, not´e (G, λ), est un graphe G muni d’une fonction d’´etiquetage
λ : V (G) ∪ E(G) → L qui associe une ´etiquette `a chaque sommet v ∈ V (G) et `a chaque
arˆete e ∈ E(G). Lorsque la fonction d’´etiquetage n’aura pas `a ˆetre explicit´ee, les graphes
(G, λG), (H, λH), . . . seront d´enot´es G, H, . . . ; on dit que le graphe G est le graphe sous-
jacent de G.
On dit que l’´etiquetage d’un graphe (G, λ) est uniforme s’il existe deux ´etiquettes
α, β ∈ L telles que pour tout sommet v ∈ V (G), λ(v) = α et pour toute arˆete e ∈ E(G),
λ(v) = β.

Les notions de sous-graphes, sous-graphes induits, sous-graphes partiels s’´etendent aux

graphes ´etiquet´es en demandant que l’´etiquetage soit pr´eserv´e.
D´eﬁnition 1.13 Un graphe H = (H, η) est un graphe partiel (resp. sous-graphe, sous-
graphe induit) d’un graphe G = (G, λ) si H est un graphe partiel (resp. sous-graphe,
sous-graphe induit)de G et pour tout x ∈ V (H) ∪ E(H), λ(x) = η(x).

Un homomorphisme entre deux graphes ´etiquet´es est un homomorphisme entre les

graphes sous-jacents qui pr´eserve l’´etiquetage.
D´eﬁnition 1.14 Un homomorphisme ϕ d’un graphe ´etiquet´e G = (G, λ) dans un graphe
H = (H, η) est un homomorphisme de G dans H tel que pour tout x ∈ V (G) ∪ E(G),
λ(x) = η(ϕ(x)).

L’homomorphisme ϕ est un isomorphisme entre G et H si ϕ d´eﬁnit un isomorphisme

entre G et H.

Une occurence de G = (G, λ) dans G(cid:2) = (G
(cid:2)

(cid:2)) est un isomorphisme entre (G, λ) et

, λ

, λ

(cid:2)).

(cid:2)
un sous-graphe (H, η) de (G
Remarque 1.15 On peut assimiler tout graphe non-´etiquet´e G au graphe ´etiquet´e (G, λ)
o`u λ est un ´etiquetage tel que pour tout x ∈ V (G) ∪ E(G), λ(x) = , o`u  est le mot
vide. Par cons´equent, le terme « graphe » d´esignera indistinctement un graphe ´etiquet´e et
un graphe non-´etiquet´e.

1.1.3

´Etiquetages particuliers

Dans les Chapitres 2, 3, 4, 5, 6 et 7, on va introduire des notions d’´etiquetages et de
colorations qui vont nous permettre d’obtenir des r´esultats de complexit´e dans le Cha-
pitre 9.

Les fonctions d’´etiquetages consid´er´ees n’attribuent des ´etiquettes qu’aux sommets (les
arˆetes ne sont pas ´etiquet´ees). Une coloration d’un graphe simple G est un ´etiquetage tel
que deux sommets adjacents dans G ont deux couleurs distinctes.
D´eﬁnition 1.16 Une coloration (cid:8) d’un graphe simple G est un ´etiquetage de G tel que
pour toute arˆete {u, v} ∈ V (G), (cid:8)(u) (cid:12)= (cid:8)(v).

Les colorations et ´etiquetages qu’on introduit dans les chapitres suivants sont d´eﬁnies
par des propri´et´es que doivent v´eriﬁer les graphes induits par les sommets de chaque
couleur. On consid`ere un graphe simple G et un ´etiquetage (cid:8) de G. Pour toute couleur
i ∈ (cid:8)(V (G)), on note G[i] le graphe G[(cid:8)
−1(i)] qui est le graphe induit par tous les sommets
´etiquet´es i. De plus, pour toutes couleurs distinctes i, j ∈ (cid:8)(V (G)), on note G[i, j] le graphe
−1(j)] dans lequel on a supprim´e toutes
biparti obtenu `a partir du graphe induit G[(cid:8)
les arˆetes {u, v} telles que (cid:8)(u) = (cid:8)(v).

−1(i)∪(cid:8)

1.2. Graphes dirig´es

5

1

1

2

2

(G, δ)

2

1

1

2

Fig. 2 – Un graphe simple G avec un ´etiquetage de ports δ.

Par exemple, une coloration d’un graphe G est un ´etiquetage (cid:8) d’un graphe G telle que
pour toute couleur i ∈ (cid:8)(V (G)), G[i] est un stable, i.e., G[i] ne contient pas d’arˆetes. Un
graphe G est un couplage parfait s’il admet une coloration (cid:8) tel que (cid:8)(V (G)) = {1, 2} et
telle que G[1, 2] soit un graphe 1-r´egulier.

Un ´etiquetage est dit propre si au moins deux sommets du graphe ont la mˆeme couleur.
D´eﬁnition 1.17 Un ´etiquetage (cid:8) d’un graphe G est un ´etiquetage propre si |(cid:8)(V (G))| <
|V (G)|.

1.1.4

´Etiquetage des ports

Dans les chapitres suivants, un syst`eme distribu´e va ˆetre repr´esent´e par un graphe
´etiquet´e dont les sommets correspondent aux processus et les arˆetes aux liens de commu-
nication. Dans certains mod`eles, chaque processus peut distinguer ses voisins, i.e., il peut
distinguer les canaux de communication par lesquels il re¸coit ou envoie des messages. Pour
cela, on suppose que le graphe correspondant au syst`eme distribu´e a un ´etiquetage des
ports d´eﬁni de la mani`ere suivante.

Dans un graphe simple, un ´etiquetage des ports est un ensemble de fonctions locales

qui permettent `a chaque sommet de distinguer ses voisins.
D´eﬁnition 1.18 ´Etant donn´e un graphe simple G, un ´etiquetage des ports δ est un en-
semble de fonctions {δu | u ∈ V (G)} tel que pour tout sommet u, δu est une bijection entre
NG(u) et [1, degG(u)].
l’incidence entre le sommet u et l’arˆete {u, v} comme repr´esent´e sur la Figure 2.

On repr´esente un graphe G avec un ´etiquetage δ en repr´esentant le num´ero δu(v) sur

1.2 Graphes dirig´es

Les d´eﬁnitions et notations utilis´ees ici proviennent du travail de Boldi et Vigna sur

les ﬁbrations [BV02a].

1.2.1 D´eﬁnitions

D´eﬁnition 1.19 Un graphe dirig´e D est d´eﬁni par un ensemble de sommets V (D), un
ensemble d’ arcs A(D) et deux fonctions sD et tD de A(D) dans V (D).

6

Chapitre 1. Pr´eliminaires

Pour chaque arc a ∈ A(D), sD(a) est la source de l’arc a et tD(a) est la cible de a. On
dit que l’arc a est incident `a sD(a) et `a tD(a). Si sD(a) = tD(a), l’arc a est une boucle.
Pour tous sommets u, v ∈ V (D), s’il existe un arc a ∈ A(D) tel que sD(a) = u et

tD(a) = v, u est un pr´edecesseur de v et v est un successeur de u.

Lorsqu’il n’y aura pas d’ambiguit´e, les fonctions sD et tD seront respectivement not´ees

s et t.
D´eﬁnition 1.20 Dans un graphe dirig´e D, le voisinage sortant d’un sommet u, not´e
D (u) = {v ∈ V (D) | ∃a ∈ A(D) tel que
N +
D (u) est l’ensemble des successeurs de u, i.e., N +
s(a) = u et t(a) = v}. On note I +
D(u) =
{a ∈ A(D) | s(a) = u}. Le degr´e sortant de u, not´e d+
D(u) est le nombre d’arcs sortants
de u, i.e., d+

D(u) l’ensemble des arcs sortants de u, i.e., I +

D(u) = |I +

D(u)|.

Le voisinage entrant d’un sommet u dans un graphe dirig´e D not´e N

−
D(u) l’ensemble des arcs entrants de u, i.e., I

des pr´edecesseurs de u, i.e., N
u}. On note I
D(u) = |I
−
−
D(u) est le nombre d’arcs entrant de u, i.e., d
Le degr´e entrant de u, not´e d

−
D (u) est l’ensemble
D (u) = {v ∈ V (D) | ∃a ∈ A(D) tel que s(a) = v et t(a) =
−
D(u) = {a ∈ A(D) | t(a) = u}.
−
D(u)|.
−
D´eﬁnition 1.21 Dans un graphe dirig´e D, un chemin de u `a v est une suite d’arcs
(a0, a2, . . . , an) telle que s(a0) = u, t(an) = v et pour tout i ∈ [1, n], t(ai−1) = s(ai).
D´eﬁnition 1.22 Un graphe dirig´e D est fortement connexe si pour tous sommets u et v,
il existe un chemin de u `a v dans D.

D´eﬁnition 1.23 Un graphe dirig´e sym´etrique est un graphe dirig´e D muni d’une involu-
tion Sym : A(D) → A(D) qui `a chaque arc a ∈ A(D) associe son arc sym´etrique Sym(a)
tel que sD(Sym(a)) = tD(a).

(cid:2) est
D´eﬁnition 1.24 Un homomorphisme ϕ d’un graphe dirig´e D dans un graphe dirig´e D
(cid:2)) et de A(D) dans A(D) qui commute avec les fonctions
une application de V (D) dans V (D
source et cible, i.e., pour toute arc a ∈ A(D), sD(cid:2)(ϕ(a)) = ϕ(sD(a)) et sD(cid:2)(ϕ(a)) =
ϕ(sD(a)).

D´eﬁnition 1.25 Un homomorphisme ϕ d’un graphe dirig´e D dans un graphe dirig´e D
est un isomorphisme si ϕ est bijective.

On dit alors que D et D

(cid:2) sont isomorphes.

(cid:2)

1.2.2 Graphes dirig´es ´etiquet´es

Comme les graphes non-dirig´es, les graphes dirig´es que l’on consid`ere sont ´etiquet´es
par un ensemble d’´etiquettes L, qui peut ˆetre ﬁni ou inﬁni. On supposera l’ensemble L
muni d’un ordre total, not´e <L.
Comme pour les graphes non-dirig´es, un graphe dirig´e ´etiquet´e, not´e (D, λ) est un
graphe dirig´e D muni d’une fonction d’´etiquetage λ : V (D) ∪ A(D) → L qui associe une
´etiquette `a chaque sommet v ∈ V (D) et `a chaque arc a ∈ A(D). Comme dans le cas des
graphes non-dirig´es, lorsque les fonctions d’´etiquetages n’auront pas `a ˆetre explicit´ees, le
graphe (D, λ) sera d´enot´e D ; on dira que le graphe dirig´e D est le graphe dirig´e sous-jacent
de D.

Un homomorphisme entre deux graphes dirig´es ´etiquet´es est un homomorphisme entre

les graphes dirig´es sous-jacents qui pr´eserve l’´etiquetage.

1.2. Graphes dirig´es

7

D´eﬁnition 1.26 Un homomorphisme ϕ d’un graphe dirig´e ´etiquet´e D = (D, λ) dans
un graphe dirig´e D(cid:2) = (D
(cid:2) tel que pour tout
(cid:2)
(cid:2)) est un homomorphisme de D dans D
, λ
x ∈ V (D) ∪ A(D), λ(x) = λ
(cid:2)(ϕ(x)).
L’homomorphisme ϕ est un isomorphisme entre D et D(cid:2) si ϕ d´eﬁnit un isomorphisme

entre D et D

(cid:2).

Remarque 1.27 Comme pour les graphes non-dirig´es, on peut assimiler tout graphe di-
rig´e non-´etiquet´e D au graphe ´etiquet´e (D, λ) o`u λ est la fonction d’´etiquetage qui associe
`a chaque sommet et `a chaque arc de D l’´etiquette  qui est le mot vide.

On pr´esente maintenant quelques propri´et´es que peuvent avoir l’´etiquetage des arcs
d’un graphe dirig´e. Les termes employ´es sont similaires `a ceux utilis´es en th´eorie des
automates.
D´eﬁnition 1.28 ´Etant donn´e un graphe dirig´e D, on dit qu’une fonction d’´etiquetage λ
(cid:2) ∈ A(D) tels que s(a) = s(a
(cid:2))
est d´eterministe (resp. cod´eterministe), si pour tous arcs a, a
(resp. t(a) = t(a

(cid:2))), λ(a) (cid:12)= λ(a
(cid:2)).

Lorsqu’un graphe dirig´e est sym´etrique, l’´etiquetage des arcs peut reﬂ´eter cette pro-

pri´et´e.
D´eﬁnition 1.29 ´Etant donn´e un graphe dirig´e sym´etrique D, on dit qu’une fonction
d’´etiquetage λ est sym´etrique, s’il existe une fonction Sym : L → L telle que pour tout
arc a, Sym(λ(a)) = λ(Sym(a)).

Par la suite, lorsqu’on consid´erera des graphes dirig´es sym´etriques ayant un ´etiquetage
sym´etrique, on supposera que tout arc a a une ´etiquette de la forme (p, q) telle que
Sym(a) = (q, p). ´Etant donn´es un graphe dirig´e sym´etrique D et un ´etiquetage sym´etrique
(cid:2) de cette forme, en posant pour
λ de D, il est toujours possible d’obtenir un ´etiquetage λ
tout arc a ∈ A(D), λ

(cid:2)(a) = (λ(a), Sym(λ(a))).

1.2.3 Des Graphes non-dirig´es aux Graphes Dirig´es

`A partir d’un graphe G = (G, λ), on peut construire un graphe dirig´e sym´etrique, not´e
(cid:2)), d´eﬁni comme suit. L’ensemble des sommets de V (Dir(G)) est
Dir(G) = (Dir(G), λ
l’ensemble V (G) et pour chaque arˆete e ∈ E(G) dont les extr´emit´es sont u et v, il existe
deux arcs ae,u,v et ae,v,u dans A(Dir(G)) tels que s(ae,u,v) = t(ae,v,u) = u, s(ae,v,u) =
t(ae,u,v) = v et Sym(ae,u,v) = ae,v,u. Pour tout sommet u ∈ V (G) = V (Dir(G)), λ
(cid:2)(u) =
λ(u) et pour toute arˆete e ∈ E(G) dont les extr´emit´es sont u et v, λ
(cid:2)(ae,v,u) =
λ(e)

(cid:2)(ae,u,v) = λ

En g´en´eral, on manipulera les graphes dirig´es sym´etriques obtenus `a partir de graphes
simples. Dans ce cas l`a, pour tout graphe simple, G = (G, λ), on peut d´eﬁnir Dir(G) =
(cid:2)) de la mani`ere suivante. L’ensemble des sommets de V (Dir(G)) est l’ensemble
(Dir(G), λ
V (G) et pour chaque arˆete {u, v} ∈ E(G), il existe deux arcs au,v et av,u dans A(Dir(G))
tels que s(au,v) = t(av,u) = u, s(av,u) = t(au,v) = v et Sym(au,v) = av,u. Pour tout sommet
(cid:2)(av,u) = λ({u, v}). Il est
u ∈ V (G), λ
facile de voir que dans le cas des graphes simples, cette construction permet d’obtenir le
mˆeme graphe dirig´e sym´etrique que la pr´ec´edente.

(cid:2)(u) = λ(u) et pour toute arˆete {u, v}, λ

(cid:2)(au,v) = λ

Un exemple de cette construction est pr´esent´e sur la Figure 3.

8

Chapitre 1. Pr´eliminaires

2

a

G

1

b

b

1

a

2

2

a

a

1

b

b

b

b

1

a

a

Dir(G)

2

Fig. 3 – Un graphe simple G et le graphe dirig´e sym´etrique Dir(G) correspondant.

1.3 R´e´etiquetages

Dans les Chapitres 2, 3, 4, 5 et 6, on va mod´eliser des algorithmes distribu´es par des
relations de r´e´etiquetage de graphe. On pr´esente ici les mod`eles les plus g´en´eraux qu’on
consid`ere. Les mod`eles plus restrictifs sont introduits dans les chapitres o`u ils sont ´etudi´es.

1.3.1 D´eﬁnitions

´Etant donn´ee une relation binaire R sur les graphes ´etiquet´es, R d´eﬁnit une relation
de r´e´ecriture de graphes. On ne consid`ere que des relations closes par isomorphisme, i.e.,
si G R H et G (cid:9) G(cid:2), alors il existe un graphe H(cid:2) tel que G(cid:2) R H(cid:2) et H (cid:9) H(cid:2).

Par ailleurs, on ne consid`ere que des relations de r´e´etiquetage de graphes qui ne mo-

diﬁent pas la structure du graphe mais seulement son ´etiquetage.
D´eﬁnition 1.30 Une relation de r´e´ecriture de graphes R est une relation de r´e´etiquetage
de graphes si pour tout couple de graphes en relations, les graphes sous-jacents sont ´egaux,
i.e.,

(G, λ) R (G
(cid:2)

(cid:2)
, λ

) =⇒ G = G
(cid:2)

.

On note R∗ la fermeture r´eﬂexive et transitive de R. La relation R est noetherienne

s’il n’existe pas de chaˆıne inﬁnie (G, λ1) R (G, λ2) R . . . R (G, λi) R . . ..

Dans la suite de ce m´emoire, on ne consid`ere que des relations de r´e´etiquetage r´ecursives
et cela pour consid´erer des mod`eles de calcul ayant une puissance de calcul raisonnable.

1.3.2 Relations de R´e´etiquetage sur les Arˆetes

Une relation de r´e´etiquetage est localement engendr´ee sur les arˆetes si sa restriction

aux arˆetes d´etermine son comportement sur tout le graphe.
D´eﬁnition 1.31 Une relation de r´e´etiquetage R est localement engendr´ee sur les arˆetes
(cid:2)) et
si la condition suivante est satisfaite. Pour tous graphes (G, λ), (G, λ
toutes arˆetes e ∈ E(G) et f ∈ E(H) telles que ext(e) = {v1, v2} et ext(f) = {w1, w2}, si
les trois conditions suivantes sont v´eriﬁ´ees :

(cid:2)), (H, η), (H, η

1. λ(v1) = η(w1), λ(v2) = η(w2), λ(e) = η(f), λ

(cid:2)(v1) = η

(cid:2)(w1), λ

(cid:2)(v2) = η

(cid:2)(w2) et

(cid:2)(e) = η

(cid:2)(f),

λ

1.3. R´e´etiquetages

9

A

N0

A

A1

Fig. 4 – Une r`egle de r´e´etiquetage d’arˆete.

N

0

N

A

0

A

0

0

1

1

A

0

N

A

1

A

0

0

0

1

N

0

N

A

1

A

R

R

N

0

N

A

0

A

0

0

1

1

A

1

A

A

1

A

0

0

0

1

N

0

N

N

0

A

R

R

A

0

N

A

0

N

1

0

1

1

A

N

0

1

0

0
A
R
A

0

N

N

1

0

0

A

A

Fig. 5 – Une ex´ecution de l’algorithme d´ecrit par la r`egle de la Figure 4.

2. pour tout sommet v ∈ V (G) diﬀ´erent de v1 et de v2, λ(v) = λ
3. pour tout sommet w ∈ V (H) diﬀ´erent de w1 et de w2, λ(w) = λ

(cid:2) ∈ E(G) diﬀ´erente de e, λ(e
e

(cid:2)) = λ
(cid:2)(e
(cid:2) ∈ E(H) diﬀ´erente de f, λ(f

arˆete f

(cid:2)),

alors (G, λ) R (G, λ

(cid:2)),
(cid:2)) si et seulement si (H, η) R (H, η

(cid:2)) = λ

(cid:2)(f

(cid:2)).

(cid:2)(v) et pour toute arˆete

(cid:2)(w) et pour toute

Dans les Chapitres 3, 5 et 6, on consid`ere des relations de r´e´etiquetages sur les arˆetes
(avec parfois des contraintes suppl´ementaires).
´Etant donn´e une relation de r´e´etiquetage R, un pas de calcul sur le graphe G est la
modiﬁcation de l’´etiquetage d’une arˆete de G pour obtenir un graphe G(cid:2) tel que G R
G(cid:2). Une ex´ecution de R sur G est alors une suite G = G0 R G1 R . . . R Gi R
. . . Le graphe ´etiquet´e Gi est la conﬁguration du graphe `a l’´etape i de l’ex´ecution. Une
conﬁguration G est ﬁnale s’il n’existe aucun G(cid:2) tel que G R G(cid:2). On remarque que si R
est noeth´erienne, il n’existe pas d’ex´ecution inﬁnie de R sur G et toute ex´ecution atteint
donc une conﬁguration ﬁnale.

Une relation de r´e´etiquetage localement engendr´ee sur les arˆetes peut ˆetre d´ecrite par
un ensemble r´ecursif de r`egles de la forme pr´esent´ees sur la Figure 4. R´eciproquement,
un tel ensemble de r`egles induit une relation de r´e´etiquetage localement engendr´ee sur les
arˆetes. Ainsi, on notera R l’ensemble de r`egles de r´e´etiquetage aussi bien que la relation
de r´e´etiquetage correspondante.
Exemple 1.32 On pr´esente sur la Figure 5, une ex´ecution de l’algorithme d´ecrit par la
r`egle de r´e´etiquetage pr´esent´ee sur la Figure 4. Pour tout graphe connexe G dans lequel
il y a un unique sommet ´etiquet´e A et o`u tous les autres sommets sont ´etiquet´es N,
toute ex´ecution de cet algorithme sur G permet d’atteindre une conﬁguration ﬁnale G(cid:2) o`u
l’ensemble des arˆetes ´etiquet´ees 1 d´eﬁnit un arbre couvrant de G(cid:2).
Remarque 1.33 On sait que toute ex´ecution de l’algorithme d´eﬁni par la r`egle de la
Figure 4 termine sur tout graphe G o`u un seul sommet est ´etiquet´e A et o`u tous les autres
sommets sont ´etiquet´es N. Cependant, on remarque que dans la conﬁguration ﬁnale, aucun

10

Chapitre 1. Pr´eliminaires

sommet ne peut d´eduire `a partir de son ´etat que l’ex´ecution est termin´ee : la terminaison
de l’algorithme est dite implicite.

Lorsqu’un sommet peut d´etecter `a partir de son ´etat que le r´esultat global de l’ex´ecution
a ´et´e calcul´e, on parle de terminaison explicite. On reviendra sur ces diﬀ´erentes notions
de terminaison dans la Section 1.5.

1.3.3 Relations de R´e´etiquetage sur les ´Etoiles

Une relation de r´e´etiquetage R est localement engendr´ee sur les ´etoiles ferm´ees si sa

restriction aux ´etoiles d´etermine son comportement sur tout le graphe.
D´eﬁnition 1.34 Une relation de r´e´etiquetage R est localement engendr´ee sur les ´etoiles
(cid:2)),
si la condition suivante est satisfaite. Pour tous graphes (G, λ), (G, λ
pour tous sommets v ∈ V (G) et w ∈ V (H) tels qu’il existe un isomorphisme ϕ : BG(v) →
BG(w), si les conditions suivantes sont v´eriﬁ´ees :

(cid:2)), (H, η), (H, η

(cid:2)(x) = η

(cid:2)(ϕ(x)),

1. pour tout x ∈ V (BG(v)) ∪ E(BG(v)), λ(x) = η(ϕ(x)) et λ
2. pour tout x /∈ V (BG(v)) ∪ E(BG(v)), λ
3. pour tout x /∈ V (BH(v)) ∪ E(BH(v)), η

alors (G, λ) R (G, λ

(cid:2)) si et seulement si (H, η) R (H, η

(cid:2)(x) = λ(x),
(cid:2)(x) = η(x),
(cid:2)).

Dans les Chapitres 2, 3 et 4, on consid`ere des relations de r´e´etiquetages sur les ´etoiles
(avec parfois des contraintes suppl´ementaires).
´Etant donn´e une relation de r´e´etiquetage R, un pas de calcul sur le graphe G est la
modiﬁcation de l’´etiquetage d’une ´etoile de G pour obtenir un graphe G(cid:2) tel que G R G(cid:2).
Les notions, d’ex´ecution, de conﬁguration et de conﬁguration ﬁnale sont d´eﬁnies de la
mˆeme mani`ere que pour les relations de r´e´etiquetage localement engendr´ees sur les arˆetes.
Une relation de r´e´etiquetage localement engendr´ee sur les ´etoiles peut ˆetre d´ecrite par
un ensemble r´ecursif de r`egles de r´e´etiquetage o`u chaque r`egle permet de modiﬁer les
´etiquettes d’une ´etoile du graphe en fonction seulement des ´etiquettes apparaissant dans
l’´etoile. R´eciproquement, un tel ensemble de r`egles induit une relation de r´e´etiquetage
localement engendr´ee sur les ´etoiles. Ainsi, on notera R l’ensemble de r`egles de r´e´etiquetage
aussi bien que la relation de r´e´etiquetage correspondante.

Une relation de r´e´etiquetage localement engendr´ee sur les ´etoiles sera g´en´eralement
d´ecrite par un ensemble de r`egles «g´en´eriques». Une r`egle g´en´erique permet de d´ecrire
la r`egle de r´e´etiquetage d’une ´etoile, quel que soit le degr´e du centre de l’´etoile. En
g´en´eral, on consid`ere une boule g´en´erique (B(v0), λ) de centre v0 et la r`egle est d´ecrite par
une pr´econdition portant sur les ´etiquettes pr´esentes dans (B(v0), λ) et un r´e´etiquetage
(cid:2)). La r`egle peut ˆetre appliqu´ee dans un graphe G sur une ´etoile BG(u) de centre
(B(v0), λ
u si la pr´econdition est v´eriﬁ´ee par BG(u) et les ´etiquettes des sommets de BG(u) sont
(cid:2). En g´en´eral, on ne mentionne pas dans le
alors modiﬁ´ees en fonction du r´e´etiquetage λ
r´e´etiquetage les ´etiquettes des sommets qui ne sont pas modiﬁ´ees.
Par exemple, on consid`ere l’algorithme d´ecrit par les deux r`egles E1 et E2 pr´esent´ees
ci-dessous. Cet algorithme est un algorithme d’´election pour les arbres o`u tous les sommet
sont initialement ´etiquet´es A.

1.3. R´e´etiquetages

11

A

A

A

E1

A

E1

A

A

A

A

non-´elu

A

A

A

non-´elu

A

E1

non-´elu

non-´elu

non-´elu

non-´elu

non-´elu
E2

non-´elu
E1

A

non-´elu

non-´elu

non-´elu

´elu

non-´elu

A

non-´elu

A

non-´elu

Fig. 6 – Une ex´ecution de l’algorithme d´ecrit par les r`egles E1 et E2. Pour chaque conﬁgura-
tion, le centre de l’´etoile sur laquelle est appliqu´ee la r`egle Ei pour passer `a la conﬁguration
suivante est le sommet blanc.

E1: R`egle d’´Elagage
Pr´econdition :
– λ(v0) = A,
– ∃!v ∈ V (B(v0)) \ {v0} tel que λ(v) = A.
R´e´etiquetage :
– λ

(cid:2)(v0) := non-´elu.

E2: R`egle d’´Election

Pr´econdition :
– λ(v0) = A,
– (cid:2)v ∈ V (B(v0)) \ {v0} tel que λ(v) = A.
R´e´etiquetage :
– λ

(cid:2)(v0) := ´elu.

La r`egle E1 peut ˆetre appliqu´ee dans un graphe G sur une ´etoile BG(u) de centre u
si l’´etiquette de u est A et si u a un unique voisin ´etiquet´e A. Lorsque cette r`egle est
appliqu´ee, seule l’´etiquette de u est modiﬁ´ee et devient non-´elu.
La r`egle E2 peut ˆetre appliqu´ee dans un graphe G sur une ´etoile BG(u) de centre u si
l’´etiquette de u est A et si u n’a aucun voisin ´etiquet´e A. Lorsque cette r`egle est appliqu´ee,
seule l’´etiquette de u est modiﬁ´ee et devient ´elu.
Une ex´ecution de cet algorithme est pr´esent´ee sur la Figure 6. On va montrer que pour
tout arbre T = (T, λ) o`u tous les sommets sont ´etiquet´es A (i.e., ∀v ∈ V (T ), λ(v) = A),
toute ex´ecution de l’algorithme d´ecrit par les r`egles E1 et E2 permet de r´esoudre l’´election
dans T.

12

Chapitre 1. Pr´eliminaires

On consid`ere un arbre T et une ex´ecution de l’algorithme d´ecrit pr´ec´edemment sur T.
Pour chaque ´etape i de l’ex´ecution, on note λ(v) l’´etiquette du sommet v apr`es le i`eme
pas de r´e´etiquetage.

On observe qu’`a chaque application d’une des deux r`egles, le nombre de sommets qui
n’ont pas d’´etiquettes ﬁnales diminue strictement. On est donc assur´e que toute ex´ecution
de l’algorithme termine. On montre dans le lemme suivant un invariant qui permet de
prouver la correction de l’algorithme.
Lemme 1.35 Pour toute ´etape i, le graphe induit par l’ensemble des sommets ´etiquet´es
A est un arbre et s’il existe un sommet ´etiquet´e A alors aucun sommet n’a l’´etiquette ´elu.

Preuve : On montre ce lemme par r´ecurrence sur i. Initialement, tous les sommets sont
´etiquet´es A et puisque T est un arbre, la propri´et´e est bien v´eriﬁ´ee. On suppose que la
propri´et´e est v´eriﬁ´ee `a l’´etape i.
Si la r`egle E1 est appliqu´ee `a l’´etape i + 1 sur l’´etoile BT (v) de centre v, alors v est une
feuille de l’arbre induit par les sommets ´etiquet´es A `a l’´etape i. Par cons´equent, `a l’´etape
i + 1, le graphe induit par les sommets ´etiquet´es A est toujours un arbre et aucun sommet
n’a l’´etiquette ´elu.
Si la r`egle E2 est appliqu´ee `a l’´etape i+1 sur l’´etoile BT (v) de centre v, cela signiﬁe que
v n’a aucun voisin ´etiquet´e A et par cons´equent, l’arbre induit par les sommets ´etiquet´es
A `a l’´etape i ne contient que le sommet v. `A l’´etape i + 1, il n’y a aucun sommet ´etiquet´e
A et la propri´et´e est vraie.
2

On consid`ere la conﬁguration ﬁnale d’une ex´ecution de l’algorithme sur T. S’il existe
encore des sommets ´etiquet´es A, alors d’apr`es le Lemme 1.35, le graphe induit par les
sommets ´etiquet´es A est un arbre et ou bien, cet arbre est r´eduit `a un sommet v et la
r`egle E2 peut ˆetre appliqu´ee sur l’´etoile BT (v) de centre v, ou bien il existe un sommet v
qui est une feuille dans cet arbre et la r`egle T1 peut ˆetre appliqu´ee sur l’´etoile BT (v) de
centre v. Par cons´equent, dans la conﬁguration ﬁnale, tous les sommets ont l’´etiquette ´elu
ou non-´elu. De plus, puisqu’`a chaque ´etape, l’´etiquette d’un seul sommet est modiﬁ´e, le
dernier sommet qui a chang´e d’´etiquette a n´ecessairement pris l’´etiquette ´elu, et d’apr`es
le Lemme 1.35, les autres sommets ont l’´etiquette non-´elu.
L’algorithme d´ecrit par les r`egles E1 et E2 permet donc de r´esoudre le probl`eme de

l’´election dans la famille des arbres.

1.3.4 S´erialisation

Les notions d’ex´ecution introduites ci-dessus correspondent `a des ex´ecutions s´equen-
tielles des algorithmes. Cependant, il faut noter que si des r`egles de r´e´etiquetage peuvent
ˆetre appliqu´ees sur deux arˆetes (ou ´etoiles) disjointes, i.e., qui n’ont aucun sommet en
commun, alors ces r`egles peuvent ˆetre appliqu´ees simultan´ement. Ainsi, on peut d´eﬁnir
une ex´ecution distribu´ee en disant que deux pas de r´e´etiquetages cons´ecutifs appliqu´es `a
des arˆetes (ou des ´etoiles) disjointes peuvent ˆetre appliqu´es dans n’importe quel ordre. On
dit que de tels pas commutent et peuvent ˆetre appliqu´es de mani`ere concurrente.

Plus g´en´eralement, deux suites de r´e´etiquetage partant du mˆeme graphe ´etiquet´e et
telles qu’on peut obtenir l’une `a partir de l’autre par ce type de commutation aboutiront au
mˆeme r´esultat, i.e., au mˆeme graphe ´etiquet´e ﬁnal. Ainsi, la notion d’ex´ecution d´eﬁnie par

1.4. ´Election et Nommage

13

une suite de r´e´etiquetages peut ˆetre vue comme une s´erialisation [Maz87] d’une ex´ecution
distribu´ee donn´ee.

Pour l’analyse de nos algorithmes, on consid´erera des ex´ecutions s´equentielles, mais il

est important de se rappeler qu’elles peuvent ˆetre ex´ecut´ees de mani`ere distribu´ee.

1.3.5 ViSiDiA

Au LaBRI, sous la direction de Mohamed Mosbah, un projet logiciel pour la simula-
tion et la visualisation d’algorithmes distribu´es est en cours depuis quelques ann´ees. Ce
projet s’appelle ViSiDiA (Visualization and Simulation of Distributed Algorithms) et est
disponible sur le site http://www.labri.fr/projet/visidia.

Cet outil permet d’impl´ementer des algorithmes distribu´es dans diﬀ´erents mod`eles. Un
algorithme est g´en´eralement impl´ement´e dans un syst`eme asynchrone o`u les processus com-
muniquent en ´echangeant des messages. Cependant, il est aussi possible d’impl´ementer des
algorithmes cod´es par des relations de r´e´etiquetage de graphes ; pour cela, les m´ethodes de
synchronization locale probabilistes pr´esent´ees dans [MSZ02, MSZ03] sont utilis´ees. L’al-
gorithme de Mazurkiewicz pr´esent´e dans le Chapitre 2 a en particulier ´et´e impl´ement´e sous
ViSiDiA par Mosbah et Sellami [MS01]. On a aussi impl´ement´e l’algorithme d’´enum´eration
qu’on pr´esente dans le Chapitre 7 o`u les processus communiquent par ´echange de message.
Pour plus de d´etails sur l’outil ViSiDiA, on peut se r´ef´erer au Chapitre 5 de la th`ese

d’Aﬁf Sellami [Sel04] et au Chapitre 6 de la th`ese Bilel Derbel [Der06].

1.4

´Election et Nommage

Le probl`eme de l’´election est un probl`eme fondamental en algorithmique distribu´ee qui
a ´et´e pour la premi`ere fois ´etudi´e par Lelann [LeL77]. Un algorithme distribu´e permet de
r´esoudre le probl`eme de l’´election sur un graphe G si toute ex´ecution de l’algorithme sur
G termine et si dans la conﬁguration ﬁnale, il existe exactement un sommet v ∈ V (G) qui
est dans l’´etat ´elu, alors que tous les autres sommets de G sont dans l’´etat non-´elu. On
suppose par ailleurs, que les ´etats ´elu et non-´elu sont ﬁnaux, i.e., une fois qu’un sommet
est dans l’un de ces ´etats, alors son ´etat n’est plus modiﬁ´e jusqu’`a la ﬁn de l’ex´ecution
de l’algorithme. Le probl`eme de l’´election est important en algorithmique distribu´ee puis-
qu’une fois qu’un sommet a ´et´e ´elu, ce sommet peut ˆetre utilis´e pour centraliser ou diﬀuser
de l’information, pour initialiser l’ex´ecution d’un autre algorithme qui n´ecessite un som-
met distingu´e (comme par exemple, l’algorithme de calcul d’un arbre couvrant pr´esent´e
dans la Section 1.3.2), pour prendre une d´ecision de mani`ere centralis´ee, etc.

Le but d’un algorithme de nommage est d’arriver dans une conﬁguration ﬁnale o`u un
identiﬁant unique est associ´e `a chaque sommet. Ce probl`eme aussi est tr`es important en
algorithmique distribu´ee, puisque de nombreux algorithmes distribu´es fonctionnent correc-
tement sous l’hypoth`ese que tous les sommets ont des identiﬁants uniques. Le probl`eme
de l’´enum´eration est une variante du probl`eme de nommage. Le but d’un algorithme
d’´enum´eration pour un graphe G est d’attribuer `a chaque sommet de G un entier de
telle sorte que dans la conﬁguration ﬁnale, l’ensemble des num´eros des sommets de G soit
exactement [1,|V (G)|]. L’algorithme de Mazurkiewicz [Maz97] qu’on va pr´esenter dans le
Chapitre 2 est un algorithme d’´enum´eration cod´e par une relation de r´e´etiquetage locale-
ment engendr´ee sur les ´etoiles.

14

Chapitre 1. Pr´eliminaires

Les probl`emes du nommage et de l’´election sont ´equivalents dans certains mod`eles,
comme ceux ´etudi´es aux Chapitre 2, 3, 5 et 7. Il existe cependant des mod`eles o`u il existe
strictement plus de graphes admettant un algorithme d’´election que de graphes admettant
un algorithme de nommage ; c’est le cas pour les mod`eles ´etudi´es dans les Chapitres 4 et
6.

1.5 Terminaison Implicite et Explicite

On consid`ere un algorithme distribu´e A et un graphe G tel que toute ex´ecution de A
sur G termine. On va expliciter les diﬀ´erents types de terminaison qu’on consid`ere par la
suite.
La terminaison est implicite si toute ex´ecution de l’algorithme A termine, i.e., aucun
pas de calcul ne peut plus ˆetre eﬀectu´e sur le graphe G. Dans ce cas l`a, les sommets
du graphe ne peuvent pas forc´ement d´etecter `a partir de leurs ´etats que l’ex´ecution de
l’algorithme est globalement termin´ee.
Cependant, si on dispose d’un algorithme de nommage A et qu’on veut utiliser les
identit´es assign´ees `a chaque sommet par A pour pouvoir ex´ecuter un algorithme A(cid:2) qui
n´ecessite que tous les sommets aient des identiﬁants distincts, il faut que les sommets
puissent d´etecter qu’ils ont obtenus leurs num´eros ﬁnaux aﬁn de pouvoir les utiliser pour
ex´ecuter l’algorithme A(cid:2).
En g´en´eral, lorsqu’un algorithme distribu´e est ex´ecut´e sur un graphe G, chaque som-
met v ∈ V (G) utilise des variables pour stocker des informations qui sont n´ecessaires `a
l’ex´ecution de l’algorithme, mais qui ne font pas partie du «r´esultat» de l’algorithme (ni
de ses sp´eciﬁcations). Dans les mod`eles qu’on consid`ere, l’´etiquette de chaque sommet
repr´esente son ´etat et les valeurs de ces variables suppl´ementaires apparaissent dans son
´etiquette.
Ainsi, si un algorithme A utilisant un ensemble d’´etiquettes L r´esout un probl`eme
P sur un graphe G, on suppose qu’il existe un ensemble S d’´etiquettes et une fonction
res : L → S tels que pour toute ex´ecution ρ de A sur G termine et l’´etiquetage ﬁnal λρ
de G est tel que l’´etiquetage res ◦ λρ est une solution de P sur G.

Parfois, il n’est pas possible de d´etecter que les ´etiquettes de tous les sommets ne vont
plus ˆetre modiﬁ´ees, mais un sommet peut d´etecter que pour tout sommet v, res(v) ne
sera plus modiﬁ´ee dans la suite de l’ex´ecution. Dans ce cas l`a, on dit qu’on peut d´etecter
la terminaison de l’algorithme et on parle de terminaison explicite.

Dans les chapitres suivants, on va pr´esenter des algorithmes qui permettent de r´esoudre
des probl`emes (avec d´etection de la terminaison) sur des familles de graphes, i.e., l’algo-
rithme permet de r´esoudre (avec d´etection de la terminaison) le probl`eme sur tous les
graphes de la famille. La d´eﬁnition suivante pr´esente une d´eﬁnition formelle de la notion
de d´etection de la terminaison ´etendue aux familles de graphes.
D´eﬁnition 1.36 Un algorithme A utilisant un ensemble d’´etiquette L permet de r´esoudre
un probl`eme P sur une famille de graphes F avec d´etection de la terminaison s’il existe
un ensemble S, une fonction res : L → S et un ensemble Lf ⊆ L tels que les propri´et´es
suivantes sont toujours v´eriﬁ´ees pour tout graphe G ∈ F.
– Toute ex´ecution ρ de A sur G termine et l’´etiquetage ﬁnal λρ de G est tel que
l’´etiquetage res ◦ λρ est une solution de P sur G.

1.6. Connaissances Initiales

15

– Pour toute ex´ecution ρ de A sur G, il existe un sommet v et une ´etape i tels que
– Pour toute ex´ecution ρ de A sur G, s’il existe un sommet v ∈ V (G) et une ´etape i

λi(v) ∈ Lf (o`u λi(v) est l’´etiquette de v apr`es la i`eme ´etape de l’ex´ecution ρ).
telle que λi(v) ∈ Lf , alors pour tout i
(cid:2)

> i, res ◦ λi(cid:2) = res ◦ λi.

Remarque 1.37 Si un algorithme A permet de r´esoudre un probl`eme P sur une famille
de graphes F avec d´etection de la terminaison, alors pour toute ex´ecution de A sur un
graphe G ∈ F, un sommet peut d´etecter que tous les sommets ont calcul´e leurs valeurs
ﬁnales, mais il ne peut pas forc´ement d´etecter que l’ex´ecution est termin´ee. On assure
toutefois dans la D´eﬁnition 1.36 que toute ex´ecution de A sur un graphe G ∈ F termine.
Par ailleurs, si on veut ex´ecuter un second algorithme qui utilise le r´esultat du calcul de
A, un sommet peut commencer `a ex´ecuter le second algorithme une fois qu’il sait que tous
les sommets ont calcul´e leurs valeurs ﬁnales dans l’ex´ecution de A.

1.6 Connaissances Initiales

Dans les chapitres suivants, on va caract´eriser les graphes qui admettent des algo-
rithmes d’´election ou de nommage dans diﬀ´erents mod`eles. On va aussi ´etudier quelles
sont les connaissances sur le graphe dont on doit disposer aﬁn de pouvoir obtenir un
algorithme qui permet de r´esoudre ces probl`emes.

Exemple 1.38 Si on sait qu’un graphe G est un arbre, alors il existe un algorithme cod´e
par une relation de r´e´etiquetage localement engendr´ee sur les ´etoiles qui permet de r´esoudre
l’´election dans G : c’est l’algorithme pr´esent´e dans la Section 1.3.3.

Par la suite, on va distinguer deux types de connaissances initiales : les connaissances
globales et les connaissances locales. Une connaissance est globale si c’est une connaissance
qui porte sur le graphe G. Par exemple, savoir si le graphe G sur lequel est ex´ecut´e un
algorithme est un arbre est une connaissance globale. Un algorithme A permet de r´esoudre
un probl`eme P sur une famille avec une connaissance globale C si pour tout graphe G tel
que C est une propri´et´e de G (G est un arbre, par exemple), l’algorithme A permet de
r´esoudre le probl`eme P sur G.

Dans [Sak99], Sakamoto ´etudie diﬀ´erents types de connaissances initiales globales et
´etudie quelles sont les informations qui peuvent ˆetre d´eduites `a partir d’autres connais-
sances initiales. Dans les chapitres suivants, on va plus particuli`erement ´etudier les connais-
sances globales suivantes et ´etudier ce qu’elles permettent de calculer.

– la topologie du graphe : l’algorithme d´epend de la topologie du graphe ;
– la taille du graphe : l’algorithme d´epend de la taille du graphe ;
– une borne serr´ee B sur la taille du graphe : l’algorithme doit fonctionner pour tout

graphe G tel que |V (G)| ≤ B < 2|V (G)| ;
pour tout graphe G tels que |V (G)| ≤ B (ou D(G) ≤ B) ;

– une borne B sur la taille (ou le diam`etre) du graphe : l’algorithme doit fonctionner

– aucune connaissance globale, i.e., l’algorithme doit fonctionner sur tous les graphes.
Une connaissance est locale si chaque sommet v d’un graphe G dispose d’une infor-
mation qui d´epend de v. Par exemple, si initialement chaque sommet connaˆıt son degr´e,
alors on parle de connaissance initiale locale : un sommet v ne peut pas d´eduire quelles

16

Chapitre 1. Pr´eliminaires

sont les connaissances initiales des autres sommets `a partir de l’information dont il dis-
pose initialement. G´en´eralement, les connaissances initiales locales sont stock´es dans les
´etiquettes initiales de chaque sommet. Par exemple, si dans un graphe G = (G, λ), les som-
mets connaissent initialement leurs degr´es, on suppose que pour tout sommet v ∈ V (G),
(cid:2)(v)) o`u d(v) est le degr´e de v dans G. Par la suite, la seule connaissance
λ(v) = (d(v), λ
initiale locale dont on va ´etudier l’importance est la connaissance du degr´e.
´Etant donn´e un probl`eme P, on remarque qu’un algorithme A permet de r´esoudre
P sans connaissance initiale si et seulement si A permet de r´esoudre P sur la famille de
tous les graphes. De mˆeme, si A permet de r´esoudre P avec la connaissance initiale de
la taille, alors pour tout entier n, il existe un algorithme An qui permet de r´esoudre le
probl`eme P sur la famille des graphes de taille n. Par ailleurs, si A permet de r´esoudre
P avec la connaissance initiale de la topologie, alors pour tout graphe G, il existe un
algorithme (qui d´epend de G) qui permet de r´esoudre P sur G. Par la suite, on va donc
dire indistinctement qu’on peut r´esoudre un probl`eme P avec une connaissance initiale
ou qu’on peut r´esoudre P sur la famille des graphes disposant de la mˆeme connaissance
initiale (les graphes de taille donn´ee, par exemple).
Un algorithme A qui permet de r´esoudre l’´election (ou le nommage) sur tous les graphes
de la famille F est un algorithme universel d’´election (ou de nommage) pour F. Cependant,
dans les diﬀ´erents mod`eles qu’on consid`ere dans les chapitres suivants, il existe des graphes
qui n’admettent pas d’algorithme d’´election (ou de nommage). Parfois, on souhaite donc
pouvoir d´etecter si un graphe admet un algorithme d’´election (ou de nommage). Ainsi, un
algorithme A est un algorithme eﬀectif d’´election (ou de nommage) pour une famille F si
pour toute ex´ecution de A sur tout graphe G ∈ F, A r´esout l’´election (ou le nommage) sur
G, ou alors A d´etecte qu’il n’existe pas d’algorithme d’´election ou de nommage pour G.
Les termes employ´es sont tir´es de [BFFS03a] et la d´eﬁnition suivante rappelle les propri´et´es
souhait´ees pour ce type d’algorithme.
D´eﬁnition 1.39 Un algorithme A est un algorithme universel d’´election (resp. de nom-
mage) pour une famille F si pour tout graphe G ∈ F, toute ex´ecution de A sur G permet
de r´esoudre l’´election (resp. le nommage) sur G.
Un algorithme A est un algorithme eﬀectif d’´election (resp. de nommage) pour une
famille F si pour tout graphe G ∈ F, toute ex´ecution de A sur G permet ou bien de
r´esoudre l’´election (resp. le nommage) sur G, ou bien de d´etecter qu’il n’existe pas d’al-
gorithme d’´election (resp. de nommage) pour G.
Remarque 1.40 ´Etant donn´e un algorithme eﬀectif d’´election (ou de nommage) pour
une famille de graphes F, si lors d’une ex´ecution de A sur un graphe G ∈ F, un sommet
v ∈ V (G) est dans un ´etat indiquant qu’il n’existe pas d’algorithme d’´election (ou de
nommage) pour G, alors v ne modiﬁera pas son ´etat par la suite, i.e., les ´etats indiquant
qu’on ne peut pas r´esoudre l’´election (ou le nommage) sont ﬁnaux.

Chapitre 2

Calculs Locaux sur les ´Etoiles
Ferm´ees

Sommaire
2.1

2.4

Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
18
2.1.1 Caract´erisation . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1.2 Travaux Li´es
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
2.2 Revˆetements Simples . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.3 Calculs Locaux sur les ´Etoiles Ferm´ees
. . . . . . . . . . . . . . 23
23
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3.1 D´eﬁnitions
2.3.2 Revˆetements Simples et Calculs Locaux sur les ´Etoiles Ferm´ees .
24
´Enum´eration, Nommage et ´Election . . . . . . . . . . . . . . . . 24
25
2.4.1 R´esultats d’Impossibilit´e . . . . . . . . . . . . . . . . . . . . . . .
2.4.2 L’Algorithme de Mazurkiewicz . . . . . . . . . . . . . . . . . . .
25
2.4.3 Correction de l’Algorithme d’´Enum´eration . . . . . . . . . . . . .
27
2.4.4 Complexit´e . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
Importance de la Connaissance Initiale . . . . . . . . . . . . . . 32
33
2.5.1 L’Algorithme de Szymansky, Shi et Prywes . . . . . . . . . . . .
34
2.5.2 Une Adaptation de l’Algorithme de Mazurkiewicz
. . . . . . . .
2.5.3 Propri´et´es Satisfaites par l’Algorithme . . . . . . . . . . . . . . .
35
2.6 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

2.5

2.1

Introduction

Dans ce chapitre, on ´etudie les calculs locaux sur les ´etoiles ferm´ees qui correspondent
aux relations de r´e´etiquetage localement engendr´ees sur les ´etoiles introduites au Cha-
pitre 1 (Deﬁnition 1.34). Dans ce mod`ele, les graphes consid´er´es sont des graphes simples.
En un pas de calcul, un sommet peut observer l’´etat de ses voisins, l’´etat des arˆetes qui lui
sont incidentes et modiﬁer son ´etat ainsi que l’´etat de ses voisins et des arˆetes qui lui sont
incidentes. Dans ce chapitre, on ne pr´esente pas de r´esultats originaux, mais des r´esultats
obtenus par Mazurkiewicz [Maz97] et par Godard et M´etivier [GM02].

17

18

Chapitre 2. Calculs Locaux sur les ´Etoiles Ferm´ees

2.1.1 Caract´erisation

Dans le mod`ele des calculs locaux sur les ´etoiles ferm´ees, on pr´esente une caract´erisation
des graphes admettant un algorithme d’´election et de nommage obtenue par Mazurkie-
wicz [Maz97] (dans ce mod`ele, ´election et nommage peuvent ˆetre r´esolus sur les mˆemes
graphes). Cette caract´erisation est bas´e sur la notion de revˆetements simples (qui cor-
respondent aux homomorphismes de graphes simples localement bijectifs) et utilise un
r´esultat d’impossibilit´e d’Angluin [Ang80].

Un graphe admet un algorithme d’´election et de nommage utilisant des calculs lo-
caux sur les ´etoiles ferm´ees si et seulement si il est minimal pour les revˆetements simples
(Th´eor`eme 2.21).

On ´etudie ensuite les connaissances initiales n´ecessaires aﬁn de pouvoir r´esoudre l’´elec-
tion ou le nommage dans ce mod`ele. En fait, il suﬃt de connaˆıtre une borne sur le
diam`etre pour pouvoir ´elire ou nommer dans un graphe minimal pour les revˆetements
simples (Th´eor`eme 2.30). Cette condition suﬃsante est un cas particulier des r´esultats plus
g´en´eraux de Godard et M´etivier [GM02] qui caract´erisent les familles de graphes admet-
tant un algorithme universel d’´election. Par ailleurs, la connaissance d’une borne serr´ee sur
la taille permet d’obtenir un algorithme eﬀectif d’´election et de nommage (Th´eor`eme 2.31).
Dans la conclusion de ce chapitre, on pr´esente les extensions obtenues par Godard,
M´etivier, Muscholl et Tel [God02b, GM02, GM03, GMM04, MT00] dans lesquelles l’algo-
rithme de Mazurkiewicz est utilis´e.

2.1.2 Travaux Li´es

Dans [AG81], Angluin et Gardiner ´etudient des propri´et´es combinatoires des revˆete-
ments simples, et ils montrent que pour tous graphes G, H r´eguliers de mˆeme degr´e, il
existe un graphe K ﬁni qui est un revˆetement simple de G et de H. Dans [Lei82], Leighton
g´en´eralise ce r´esultat et montre que pour tous graphes G, H qui ont le mˆeme «raﬃnement
de degr´e», il existe un graphe K ﬁni qui est un revˆetement simple de G et de H. La
construction de Leighton est utilis´e dans [GMM04] pour caract´eriser les familles de graphes
reconnaissables par des calculs locaux sur les ´etoiles sans connaissance structurelle.

Dans [Bod89], Bodlaender ´etudie les revˆetements simples aﬁn de pouvoir «´emuler»
un r´eseau sur un r´eseau plus petit. Pour certaines classes de graphes, il pr´esente une
classiﬁcation des graphes qui sont des revˆetements d’autres graphes de la mˆeme classe. De
plus, Bodlaender ´etudie la complexit´e de d´ecider si un graphe G donn´e est un revˆetement
d’un graphe H donn´e. Depuis, de nombreux r´esultats ont ´et´e publi´es sur la complexit´e
de d´ecider si un graphe G donn´e est un revˆetement simple d’un graphe H ﬁx´e [AFS91,
Kra91, KPT94, KPT97, KPT98].

2.2 Revˆetements Simples

Dans ce chapitre, les homomorphismes localement bijectifs de graphe simples, i.e.,
les revˆetements simples, sont les homomorphismes qui permettent de donner des condi-
tions n´ecessaires que doivent v´eriﬁer les graphes admettant un algorithme de nommage ou
d’´election utilisant des calculs locaux sur les ´etoiles ferm´ees.

2.2. Revˆetements Simples

19

G

1

2

3

3

2

γ

1

3

1

H

2

Fig. 7 – Le graphe G est un revˆetement simple de H `a travers l’homomorphisme γ qui
envoie chaque sommet de G ´etiquet´e i sur l’unique sommet de H dont l’´etiquette est i.

D´eﬁnition 2.1 Un graphe simple G est un revˆetement d’un graphe simple H `a travers un
homomorphisme γ : G → H si pour tout sommet v ∈ V (G), γ induit une bijection entre
NG(u) et NH(ϕ(u)), i.e., si les conditions suivantes sont v´eriﬁ´ees :

– |NG(u)| = |NH(γ(u))|,
– γ(NG(u)) = NH(γ(u)).

On dit alors que l’homomorphisme γ est localement bijectif

Un graphe G est un revˆetement simple propre de H si γ n’est pas un isomorphisme
et G est minimal pour les revˆetements simples si G n’est un revˆetement propre d’aucun
autre graphe.

Naturellement, un graphe simple ´etiquet´e (G, λ) est un revˆetement simple d’un graphe
simple ´etiquet´e (H, η) `a travers γ si G est un revˆetement simple de H `a travers γ et si γ
conserve l’´etiquetage.

Exemple 2.2 Le graphe G de la Figure 7 est un revˆetement simple de H `a travers l’ho-
momorphisme γ.

Le graphe G est un revˆetement propre de H et n’est donc pas minimal pour les

revˆetements simples ; le graphe H est minimal pour les revˆetements simples.

−1(v). Pour tous sommets u

Dans le lemme suivant, on montre que si G est un revˆetement simple de H, pour tout
sommet v de V (H), l’image inverse de l’´etoile de H centr´ee en v est une union disjointe
d’´etoiles de G.
Lemme 2.3 On consid`ere des graphes simples G, H tels que G est un revˆetement simple
de H `a travers un homomorphisme γ. Soit v un sommet de V (H) et soient u1, u2 deux
1 ∈ NG(u1)∪{u1} et u
2 ∈ NG(u2)∪{u2},
(cid:2)
(cid:2)
sommets distincts de γ
1 (cid:12)= u
(cid:2)
(cid:2)
2.
u
Preuve : On consid`ere des graphes simples G, H tels que G est un revˆetement simple
de H `a travers un homomorphisme γ. Soit v un sommet de V (H) et soient u1, u2 deux
−1(v). Puisque H est un graphe simple, on sait que u2 /∈ NG(u1). S’il existe
sommets de γ
u ∈ NG(u1) ∩ NG(u2), alors γ n’est pas localement bijectif en u puisque u a deux voisins
qui ont la mˆeme image par γ.

2
La relation «ˆetre revˆetement simple» est une relation transitive comme le montre la

proposition suivante.
Proposition 2.4 Pour tous graphes simples G, H, K, si G est un revˆetement simple de
H a travers un homomorphisme γ et si H est un revˆetement simple de K `a travers un

20

Chapitre 2. Calculs Locaux sur les ´Etoiles Ferm´ees

homomorphisme ϕ, alors G est un revˆetement simple de K `a travers l’homomorphisme
ϕ ◦ γ.
Preuve : Il est clair que ϕ ◦ γ est un homomorphisme de G dans K. De plus, pour tout
(cid:2) ∈
sommet u ∈ V (G), pour tout voisin w
(cid:2) ∈ NG(u)
(cid:2)) = w
NH(γ(u)) telle que ϕ(v
(cid:2). Ainsi l’homomorphisme ϕ ◦ γ est localement bijectif et G est un
(cid:2))) = w
telle que ϕ(γ(u
revˆetement simple de K `a travers ϕ ◦ γ.

(cid:2) ∈ NK(ϕ(γ(u))), il existe un unique sommet v

(cid:2) et par cons´equent, il existe un unique sommet u

2

Puisqu’on ne consid`ere que des graphes simples connexes, tout homomorphisme loca-

lement bijectif est surjectif.
Proposition 2.5 Si un graphe simple G est un revˆetement simple d’un graphe simple
connexe H `a travers γ, alors γ est surjectif.

Preuve : Soit G un revˆetement simple d’un graphe simple connexe H `a travers un
homomorphisme γ.
On consid`ere un sommet v ∈ γ(V (G)). Il existe donc u ∈ V (G) tel que γ(u) = v.
(cid:2) ∈ NH(v), il
(cid:2) ∈ γ(V (G)). Ainsi, puisque H

Puisque γ induit une bijection entre NG(u) et NH(v), pour tout sommet v
existe un sommet u
est connexe, on sait que γ est un homomorphisme surjectif de G dans H.

(cid:2) ∈ NG(u) telle que γ(u

(cid:2) et donc v

(cid:2)) = v

2

Si un graphe simple G est un revˆetement simple d’un graphe simple H connexe, alors
tous les sommets de H ont le mˆeme nombre d’ant´ec´edents, qui est appel´e le nombre de
feuillets du revˆetement.
Proposition 2.6 Si un graphe simple G est un revˆetement simple d’un graphe simple
connexe H `a travers γ, alors il existe une constante q telle que pour tout v ∈ V (H),
−1(v)| = q.
|γ
Cette constante q est appel´ee le nombre de feuillets du revˆetement.

(cid:2) ∈ NH(v).

Puisque γ est un homomorphisme localement bijectif, pour tout sommet u ∈ γ

Preuve : On consid`ere un graphe simple G qui est un revˆetement simple d’un graphe
simple connexe H `a travers un homomorphisme γ. On consid`ere un sommet v ∈ V (H) et
un sommet v
−1(v), il
(cid:2). De plus, puisque γ est localement
(cid:2)(cid:2)) (cid:12)= γ(u). Par cons´equent,
−1(v)|. Ainsi, puisque le graphe H est
(cid:2))|.

existe un unique sommet u
bijectif en u
−1(v)| ≤ |γ
|γ
connexe, pour tout v, v

(cid:2), pour tout sommet u
−1(v
(cid:2) ∈ V (H), |γ

(cid:2)(cid:2) ∈ NG(u
−1(v)| = |γ

(cid:2))| et par sym´etrie, |γ

(cid:2) ∈ NG(u) tel que γ(u

−1(v)| = |γ
−1(v

(cid:2)) = v

(cid:2)) diﬀ´erent de u, γ(u

2

Exemple 2.7 On pr´esente ici quelques exemples de graphes connexes simples qui sont
minimaux pour les revˆetements simples.

– les graphes dont le nombre d’arˆetes et le nombre de sommets sont premiers entre

eux,

– les arbres,
– les anneaux de taille premi`ere.

Reidemeister a d´ecrit dans [Rei32] une m´ethode pour construire tous les revˆetements
d’un graphe simple H donn´e. ´Etant donn´e un arbre couvrant T de H, Reidemeister a
montr´e que tout revˆetement de H `a q feuillets peut ˆetre obtenu en prenant q copies de T

2.2. Revˆetements Simples

21

5

5

5

3

1

4

3

4

3

2

1

2

1

G

4

2

γ

5

3

1

H

4

2

Fig. 8 – Le graphe G est obtenu par la construction de Reidemeister d’un revˆetement
`a 3 feuillets de H. Les arˆetes de l’arbre couvrant de H sont repr´esent´es en gras et les
permutations associ´ees aux arˆetes {2, 4} et {4, 5} de H sont respectivement σ(2,4) = (1)(23)
et σ(4,5) = (123).

22

Chapitre 2. Calculs Locaux sur les ´Etoiles Ferm´ees

et en reliant les copies de T entre elles en fonction de permutations de [1, q] associ´ees `a
chaque arˆete de H qui n’est pas dans T .
Th´eor`eme 2.8 ([Rei32]) Soit H = (H, η) un graphe simple et T un arbre couvrant de
H. Un graphe simple G est un revˆetement simple de H si et seulement s’il existe un entier
q et un ensemble Σ = {σ(u,v) | {u, v} ∈ E(H) \ E(T )} de permutations de [1, q] (avec la
−1
(v,u)) tels que G est isomorphe au graphe HT,Σ = (HT,Σ, λ) d´eﬁni de
propri´et´e σ(u,v) = σ
la mani`ere suivante.

V (HT,Σ) = {(u, i) | v ∈ V (H) et i ∈ [1, q]},
E(HT,Σ) = {{(u, i), (v, i)} | {u, v} ∈ E(T )}∪

De plus,
pour tout (u, i) ∈ V (HT,Σ), λ((u, i)) = η(u) et pour tout {(u, i), (v, j))} ∈ E(HT,Σ),
λ({(u, i), (v, j)}) = η({u, v}).

{{(u, i), (v, σ(u,v)(i))} | {u, v} ∈ E(H) \ E(T ) et i ∈ [1, q]}.

Un exemple de construction de revˆetement en utilisant le th´eor`eme de Reidemeister

apparaˆıt sur la Figure 8.
Remarque 2.9 La construction de Reidemeister permet d’obtenir tous les revˆetements `a
q feuillets d’un graphe H. Cependant, certains des graphes obtenus ne sont pas connexes et
on peut obtenir plusieurs fois certains graphes, puisque certaines permutations produisent
des graphes isomorphes.

On pr´esente maintenant une carat´erisation des graphes simples minimaux pour les
revˆetements simples en terme de coloration. Cette coloration a ´et´e introduite par Ma-
zurkiewicz [Maz97] pour caract´eriser les graphes admettant un algorithme d’´enum´eration
utilisant des calculs locaux sur les ´etoiles ferm´ees. Dans [Maz97], la coloration que nous
allons d´ecrire porte le nom de coloration localement bijective, mais nous pr´ef´ererons le
terme de coloration r´eguli`ere parfaite. Un ´etiquetage (cid:8) d’un graphe simple non-´etiquet´e
est une coloration r´eguli`ere parfaite si deux sommets voisins ont des couleurs distinctes et
si le graphe induit par deux classes de couleurs adjacentes est un couplage parfait.
D´eﬁnition 2.10 Une coloration r´eguli`ere parfaite d’un graphe simple G est un ´etiquetage
(cid:8) de G tel que

– pour tout i ∈ (cid:8)(V (G)), G[i] est un stable,
– pour tout i, j ∈ (cid:8)(V (G)) avec i (cid:12)= j, G[i, j] est un stable, ou alors G[i, j] est un

couplage parfait.

Dans la proposition suivante, on caract´erise les graphes simples qui sont minimaux pour
les revˆetements simples `a l’aide de la notion de coloration r´eguli`ere parfaite. On rappelle
qu’une coloration (cid:8) est dite propre si |(cid:8)(V (G))| < |V (G)|. Ce lien entre les revˆetements
et les colorations r´eguli`eres parfaites a ´et´e montr´e par Godard, M´etivier et Muscholl dans
[GMM04].
Proposition 2.11 ([GMM04]) Un graphe simple non-´etiquet´e G est minimal pour les
revˆetements simples si et seulement si G n’admet aucune coloration r´eguli`ere parfaite
propre.

Preuve : On consid`ere un graphe simple non-´etiquet´e G qui est un revˆetement simple
propre d’un graphe simple H `a travers un homomorphisme γ. On va montrer que γ est
une coloration r´eguli`ere parfaite de G et que l’ensemble des couleurs utilis´es est V (H).
Puisque H est un graphe simple, pour toute arˆete {u, u
(cid:2)). Pour

(cid:2)} ∈ E(G), γ(u) (cid:12)= γ(u

2.3. Calculs Locaux sur les ´Etoiles Ferm´ees

23

(cid:2)} ∈ E(H), pour tout sommet u ∈ γ
(cid:2)) (resp. u ∈ NG(u
(cid:2) ∈ NG(u)∩γ
−1(v) et u

toute arˆete {v, v
(cid:2))), il existe un
−1(v)) et par cons´equent, G[v, v
(cid:2)]
unique sommet u
est un couplage parfait. De plus, puisque γ est un homomorphisme, pour tous sommets
(cid:2)} /∈ E(H), alors
(cid:2) ∈ V (H) et pour tous sommets u ∈ γ
−1(v
v, v
(cid:2)} /∈ E(G). Ainsi, puisque G est un revˆetement simple propre de H, |V (H)| < |V (G)|
{u, u
et γ est une coloration r´eguli`ere parfaite propre.

−1(v) (resp. u
(cid:2))∩γ
(cid:2) ∈ γ

(cid:2)), si {v, v

(cid:2) ∈ γ

−1(v

−1(v

(cid:2)} ∈ E(H) si et seulement si G[v, v

On consid`ere maintenant une coloration r´eguli`ere parfaite propre (cid:8) d’un graphe simple
G. On consid`ere un graphe H d´eﬁni de la mani`ere suivante : V (H) = (cid:8)(V (G)) et pour tous
(cid:2) ∈ V (H), {v, v
(cid:2)] n’est pas un stable. Ainsi, pour
v, v
toute arˆete {u, u
(cid:2))] n’est pas un stable et {γ(u), γ(u
(cid:2))} ∈ E(H) : (cid:8)
est donc un homomorphisme de G dans H. De plus, pour tout sommet u ∈ V (G), pour
(cid:2)] est un couplage parfait et il existe donc un unique
tout sommet v
(cid:2)) ∩ NG(u). Ainsi l’homomorphisme (cid:8) est localement bijectif et puisque
(cid:2) ∈ (cid:8)
sommet u
|V (H)| = |(cid:8)(V (G))| < |V (G)|, G est un revˆetement propre de H `a travers (cid:8).

(cid:2)} ∈ E(G), G[(cid:8)(u), (cid:8)(u
(cid:2) ∈ NH((cid:8)(u)), G[(cid:8)(u), v
−1(v

2

2.3 Calculs Locaux sur les ´Etoiles Ferm´ees

Dans cette partie, on montre que les calculs locaux sur les ´etoiles ferm´ees correspondent
aux relations de r´e´etiquetage localement engendr´ees sur les ´etoiles, puis on ´etudie leurs
relations avec les revˆetements simples.

2.3.1 D´eﬁnitions

On rappelle qu’informellement, les calculs locaux sur les ´etoiles ferm´ees permettent en
un pas de calcul `a un sommet de modiﬁer son ´etiquette, les ´etiquettes de ses voisins et
et les ´etiquettes des arˆetes qui lui sont incidentes. L’application d’un tel pas de calcul ne
d´epend que de son ´etiquette, des ´etiquettes de ses voisins et des ´etiquettes qui lui sont
incidentes.

On rappelle la d´eﬁnition des relations de r´e´etiquetage localement engendr´ee sur les

´etoiles (D´eﬁnition 1.34).
D´eﬁnition 2.12 Une relation de r´e´etiquetage R est localement engendr´ee sur les ´etoiles
(cid:2)),
si la condition suivante est satisfaite. Pour tous graphes (G, λ), (G, λ
pour tous sommets v ∈ V (G) et w ∈ V (H) tels qu’il existe un isomorphisme ϕ : BG(v) →
BG(w), si les conditions suivantes sont v´eriﬁ´ees :

(cid:2)), (H, η), (H, η

(cid:2)(x) = η

(cid:2)(ϕ(x)),

1. pour tout x ∈ V (BG(v)) ∪ E(BG(v)), λ(x) = η(ϕ(x)) et λ
2. pour tout x /∈ V (BG(v)) ∪ E(BG(v)), λ
3. pour tout x /∈ V (BH(v)) ∪ E(BH(v)), η

alors (G, λ) R (G, λ

(cid:2)) si et seulement si (H, η) R (H, η

(cid:2)(x) = λ(x),
(cid:2)(x) = η(x),
(cid:2)).

Par d´eﬁnition, les calculs locaux sur les ´etoiles ferm´ees correspondent aux relations de

r´e´etiquetage localement engendr´ees sur les ´etoiles.

24

Chapitre 2. Calculs Locaux sur les ´Etoiles Ferm´ees

2.3.2 Revˆetements Simples et Calculs Locaux sur les ´Etoiles Ferm´ees

On pr´esente maintenant le lemme qui met en ´evidence le lien entre les calculs locaux
sur les ´etoiles ferm´ees et les revˆetements simples. Ce lemme a ´et´e prouv´e par Angluin
[Ang80].

Lemme 2.13 (Lemme de rel`evement [Ang80]) On consid`ere un graphe simple G qui
est un revˆetement simple d’un graphe simple H `a travers un homomorphisme γ et une
relation R de r´e´etiquetage localement engendr´ee sur les ´etoiles. Si H R∗ H(cid:2), alors il existe
G(cid:2) tel que G R∗ G(cid:2) et G(cid:2) est un revˆetement simple de H(cid:2) `a travers γ.

Preuve : Il suﬃt de prouver ce lemme pour un pas de calcul. On consid`ere deux graphes
simples (G, λ) et (H, η) tels que (G, λ) est un revˆetement simple de (H, η) `a travers γ.
On consid`ere un pas de r´e´etiquetage qui modiﬁe les ´etiquettes d’une ´etoile BH(v) pour un
sommet v ∈ V (H). On note η
(cid:2) l’´etiquetage de H obtenu apr`es l’application de ce pas de
r´e´etiquetage.
u ∈ γ
que pour tous u, u
appliquer le pas de r´e´etiquetage sur chacune des ´etoiles BG(u) pour tout u ∈ γ
telle sorte que tout sommet u
(cid:2)). On note λ
γ(u
Le graphe (G, λ

Puisque γ est un homomorphisme localement bijectif, on sait que pour tout sommet
−1(v), (BG(u), λ) est isomorphe `a (BH(v), η). De plus, d’apr`es le Lemme 2.3, on sait
(cid:2)) sont disjointes. On peut donc
−1(v) de
(cid:2) ∈ V (BG(u)) soit r´e´etiquet´e avec la mˆeme ´etiquette que
(cid:2) l’´etiquetage de G obtenu apr`es l’application de tous ces r´e´etiquetages.
(cid:2)) ainsi obtenu est un revˆetement de (H, η

−1(v), les ´etoiles BG(u) et BG(u

(cid:2)) `a travers γ.

(cid:2) ∈ γ

2

Le diagramme suivant repr´esente la propri´et´e du Lemme 2.13.

revˆetement simple

R∗−−−−→ G(cid:2)

G

⏐⏐(cid:3)
H −−−−→

R∗ H(cid:2)

⏐⏐(cid:3)revˆetement simple

2.4

´Enum´eration, Nommage et ´Election

On s’int´eresse maintenant aux probl`emes d’´election et de nommage dans le cadre des
calculs locaux sur les ´etoiles ferm´ees. On va montrer que les graphes o`u on peut r´esoudre
l’´election, le nommage et l’´enum´eration dans ce mod`ele sont les graphes minimaux pour les
revˆetements simples. Le fait que les graphes admettant un algorithme d’´election admettent
un algorithme de nommage est li´e `a la Proposition 2.6 : si on arrive `a ´elire un sommet,
i.e., `a donner `a un sommet une ´etiquette qui n’apparaˆıt qu’une fois, alors on peut donner
des ´etiquettes uniques `a tous les sommets.

On donne d’abord le r´esultat d’impossibilit´e d’Angluin [Ang80] qui a montr´e qu’il ne
peut pas exister d’algorithme d’´election ou de nommage pour un graphe simple G qui n’est
pas minimal pour les revˆetements simples. On pr´esente ensuite l’algorithme d’´enum´eration
de Mazurkiewicz [Maz97] qui permet de r´esoudre l’´enum´eration sur les graphes simples
minimaux pour les revˆetements simples.

2.4. ´Enum´eration, Nommage et ´Election

25

2.4.1 R´esultats d’Impossibilit´e

Proposition 2.14 ([Ang80]) Soit G un graphe simple ´etiquet´e qui n’est pas minimal
pour les revˆetements simples. Il n’existe pas d’algorithme de nommage, d’´enum´eration ou
d’´election pour le graphe G utilisant des calculs locaux sur les ´etoiles ferm´ees.

Preuve : On consid`ere un graphe simple ´etiquet´e H qui n’est pas isomorphe `a G et tel
que G soit un revˆetement simple de H `a travers un un homomorphisme γ. ´Etant donn´e un
algorithme R utilisant des calculs locaux sur les ´etoiles ferm´ees, on consid`ere une ex´ecution
de R sur H. Si cette ex´ecution est inﬁnie sur H, alors d’apr`es le Lemme 2.13, il existe une
ex´ecution inﬁnie de R sur G ; auquel cas, R n’est ni un algorithme d’´enum´eration, ni de
nommage, ni d’´election.
On suppose maintenant qu’il existe une ex´ecution ﬁnie de R sur H et on consid`ere
la conﬁguration ﬁnale H(cid:2). D’apr`es le Lemme 2.13, il existe une ex´ecution de R sur G
qui permet d’atteindre une conﬁguration G(cid:2) telle que G(cid:2) est un pseudo-revˆetement de
H(cid:2) `a travers γ. Si G(cid:2) n’est pas une conﬁguration ﬁnale de R, alors il existe un sommet
u ∈ V (G) tel qu’on puisse appliquer une r`egle de r´e´etiquetage sur l’´etoile BG(cid:2)(u). Dans ce
cas l`a, on peut aussi appliquer cette mˆeme r`egle de r´e´etiquetage sur l’´etoile BH(cid:2)(γ(u)) et
la conﬁguration H(cid:2) n’est pas une conﬁguration ﬁnale de R. Par cons´equent, G(cid:2) est une
conﬁguration ﬁnale de R. Mais puisque G(cid:2) n’est pas isomorphe `a H(cid:2), on sait d’apr`es la
Proposition 2.6 que chaque ´etiquette de H(cid:2) apparaˆıt au moins deux fois dans G(cid:2) et par
cons´equent, R n’est ni un algorithme de nommage, ni un algorithme d’´enum´eration, ni un
algorithme d’´election.

2

2.4.2 L’Algorithme de Mazurkiewicz

On va maintenant d´ecrire l’algorithme d’´enum´eration M de Mazurkiewicz [Maz97] qui
permet de r´esoudre le probl`eme de l’´enum´eration sur les graphes simples minimaux pour
les revˆetements simples.
Durant l’ex´ecution de l’algorithme, chaque sommet v essaie d’obtenir une identit´e qui
est un num´ero entre 1 et |V (G)|. `A chaque fois qu’un sommet modiﬁe son num´ero, il en
informe imm´ediatement ses voisins. Chaque sommet v peut donc tenir `a jour la liste des
num´eros de ses voisins, qui sera appel´ee la vue locale de v. Lorsqu’un sommet v modiﬁe son
num´ero ou sa vue locale, il diﬀuse dans le r´eseau son num´ero accompagn´e de son ´etiquette
initiale et de sa vue locale.

Si un sommet u d´ecouvre qu’un autre sommet v a le mˆeme num´ero que lui, alors le
sommet u doit d´ecider s’il modiﬁe son identit´e. Pour cela, il compare son ´etiquette λ(u) et
sa vue locale avec l’´etiquette λ(v) et la vue locale de v : si l’´etiquette de u est plus faible
que l’´etiquette de v ou si les deux sommets ont la mˆeme ´etiquette et que la vue locale de u
est plus «faible» (pour un ordre qu’on expliquera par la suite), alors le sommet u choisit un
nouveau num´ero (sa nouvelle identit´e temporaire) et informe ses voisins de ce changement
de num´ero. Ensuite, les num´eros et les vues locales qui ont ´et´e modiﬁ´ees sont diﬀus´es `a
nouveau dans le graphe. Lorsque l’ex´ecution est termin´ee, si le graphe G est minimal pour
les revˆetements simples, alors chaque sommet a un num´ero unique : l’algorithme permet
de r´esoudre le probl`eme du nommage.

Chapitre 2. Calculs Locaux sur les ´Etoiles Ferm´ees

26

´Etiquettes

On consid`ere un graphe G = (G, λ) o`u λ: V (G) ∪ E(G) → L est un ´etiquetage
initial, qui ne sera pas modiﬁ´e par l’algorithme. Lors de l’ex´ecution, les ´etiquettes des
arˆetes ne vont pas ˆetre modiﬁ´ees et chaque sommet va obtenir une ´etiquette de la forme
(λ(v), n(v), N(v), M(v)) qui repr´esente les informations suivantes :

l’ex´ecution.

– la premi`ere composante λ(v) est l’´etiquette initiale et ne sera pas modiﬁ´ee lors de
– n(v) ∈ N est le num´ero courant du sommet v qui est modiﬁ´e lors de l’ex´ecution de
l’algorithme,
– N(v) ∈ Pﬁn(L× N)1 est la vue locale du sommet v qui contient des informations sur
les voisins de v ; c’est un ensemble ﬁni de couples ((cid:8), n) ∈ L × N. `A tout moment de
(cid:2)) (cid:12)= 0, la vue locale de v contient
l’ex´ecution, pour chaque voisin v
le couple (λ({v, v
– M(v) ⊆ N × L × Pﬁn(L × N) est la boˆıte-aux-lettres de v. Elle va contenir toute
l’information re¸cue par v lors de l’ex´ecution de l’algorithme, i.e., les couples de
num´eros et de vues locales qui auront ´et´e diﬀus´ees par tous les sommets du graphe.
Initialement, chaque sommet a une ´etiquette de la forme (λ(v), 0,∅,∅) qui signiﬁe qu’au
d´ebut de l’algorithme, v n’a pas choisi de num´ero et qu’il n’a aucune information `a propos
de ses voisins, ni `a propos des autres sommets du graphe.

(cid:2) de v tel que n(v

(cid:2)}), n(v

(cid:2))).

Un Ordre sur les Vues Locales

Les bonnes propri´et´es de l’algorithme de Mazurkiewicz sont bas´ees sur un ordre total
sur les vues locales. Cet ordre permet `a un sommet u de modiﬁer son num´ero s’il d´ecouvre
qu’il existe un autre sommet avec le mˆeme num´ero, la mˆeme ´etiquette et une vue locale
«plus forte». Aﬁn d’´eviter des ex´ecutions inﬁnies, il faut que lorsque la vue locale d’un
sommet est modiﬁ´ee, elle ne puisse pas devenir plus faible, et ce pour ´eviter qu’un sommet
ne modiﬁe son num´ero `a cause d’un message qu’il ait lui mˆeme envoy´e lors d’une ´etape
pr´ec´edente.
On d´eﬁnit donc un ordre total sur les ensembles ﬁnis de couples de L×N. Pour cela, on
consid`ere que L × N est muni de l’ordre lexicographique usuel : ((cid:8), n) ≤ ((cid:8)
(cid:2),
(cid:2)) si (cid:8) <L (cid:8)
ou si (cid:8) = (cid:8)
Ensuite, ´etant donn´ees deux ensembles N1, N2 ∈ Pﬁn(L × N) distincts, on dit que
N1 ≺ N2 si le maximum pour l’ordre lexicographique sur L×N de la diﬀ´erence sym´etrique
N1 (cid:17) N2 = (N1 \ N2) ∪ (N2 \ N1) appartient `a N2.

(cid:2) et n ≤ n

, n

(cid:2).

(cid:2)

On peut aussi voir cet ordre comme l’ordre lexicographique usuel sur les ensembles
(cid:2)
(cid:2)
(cid:2)
2), . . . , ((cid:8)
ordonn´es N1 et N2. On note ((cid:8)1, n1), ((cid:8)2, n2), . . . , ((cid:8)k, nk) et ((cid:8)
l) les
l, n
´el´ements respectifs de N1 et de N2 dans l’ordre d´ecroissant (pour l’ordre lexicographique
sur L × N) : ((cid:8)1, n1) ≥ ((cid:8)2, n2) ≥ ··· ≥ ((cid:8)k, nk) et ((cid:8)
1) ≥ ((cid:8)
(cid:2)
(cid:2)
(cid:2)
l). Alors
1, n
N1 ≺ N2 si l’une des conditions suivantes est v´eriﬁ´ee :

(cid:2)
1), ((cid:8)
2) ≥ ··· ≥ ((cid:8)
(cid:2)

– k < l et pour tout i ∈ [1, k], ((cid:8)i, ni) = ((cid:8)
– ((cid:8)i, ni) < ((cid:8)
Si N(u) ≺ N(v), alors on dit que la vue locale N(v) de v est plus forte que celle de u
et que N(u) est plus faible que N(v). En utilisant l’ordre total <L de L, on ´etend l’ordre

i, ni) o`u i est le plus petit indice pour lequel ((cid:8)i, ni) (cid:12)= ((cid:8)
(cid:2)

(cid:2)
1, n
(cid:2)
2, n

(cid:2)
i, ni).

(cid:2)
2, n

(cid:2)
i, n

(cid:2)
l, n

(cid:2)
i),

1Pour tout ensemble S, on note Pﬁn(S) l’ensemble des parties ﬁnies de S.

2.4. ´Enum´eration, Nommage et ´Election

≺ pour obtenir un ordre total sur L × Pﬁn(L × N) : ((cid:8), N) ≺ ((cid:8)
(cid:8) = (cid:8)

, N
(cid:2). Par la suite, on notera (cid:19) la clˆoture r´eﬂexive de ≺.

(cid:2) et N ≺ N

(cid:2)

(cid:2)) si (cid:8) <L (cid:8)

27

(cid:2) ou bien si

Les R`egles de R´e´etiquetage

On d´ecrit maintenant l’algorithme d’´enum´eration grˆace `a des r`egles de r´e´etiquetage.
La premi`ere r`egle M0 est une r`egle sp´eciale qui permet `a chaque sommet v de modiﬁer
son ´etiquette λ(v) pour obtenir l’´etiquette (λ(v), 0,∅,∅).
Les r`egles sont d´ecrites pour une ´etoile B(v0) de centre v0. L’´etiquette d’un sommet v ∈
NG(v0) ∪ {v0} avant l’application de la r`egle est not´ee (λ(v), n(v), N(v), M(v)) et on note
(cid:2)(v)) l’´etiquette de v apr`es l’application de la r`egle de r´e´etiquetage.
(λ(v), n
Par ailleurs, aﬁn de rendre plus lisible les r`egles, on ne mentionne pas les diﬀ´erents champs
des ´etiquettes qui ne sont pas modiﬁ´es.

(cid:2)(v), M

(cid:2)(v), N

La premi`ere r`egle permet aux sommets d’une mˆeme ´etoile d’´echanger les informa-
tions dont ils disposent (i.e., contenues dans leur boˆıte-aux-lettres) `a propos des ´etiquettes
pr´esentes dans le graphe. Cette r`egle ne peut ˆetre appliqu´ee que si un tel ´echange d’infor-
mation est n´ecessaire (i.e., tous les sommets de B(v0) n’ont pas la mˆeme boˆıte-aux-lettres).
M1: R`egle de Diﬀusion

Pr´econdition :
– ∃v ∈ NG(v0) tel que M(v) (cid:12)= M(v0).
R´e´etiquetage :
– ∀v ∈ V (B(v0)), M

(cid:2)(v) :=

(cid:4)

M(w).

w∈V (B(v0))

La deuxi`eme r`egle permet `a un sommet v0 de changer de num´ero s’il n’a pas encore de
num´ero (i.e., n(v0) = 0) ou s’il sait qu’il existe un sommet dans le graphe qui a le mˆeme
num´ero que lui et qui a une ´etiquette ou une vue locale plus forte que la sienne. Dans
ce cas l`a, v0 choisit un nouveau num´ero et modiﬁe la vue locale de ses voisins. Toutes
les boˆıtes-aux-lettres des sommets de l’´etoile B(v0) sont modiﬁ´ees : on ajoute `a chaque
(cid:2) de l’´etoile
boˆıte-aux-lettres tous les couples (n
B(v0).
M2: R`egle de Renommage

(cid:2)(v)) pour tous les sommets v

(cid:2)(v), λ(v), N

Pr´econdition :
– ∀v ∈ NG(v0), M(v) = M(v0),
– n(v0) = 0 ou

∃(n(v0), (cid:8), N) ∈ M(v0) tel que (λ(v0), N(v0)) ≺ ((cid:8), N)
R´e´etiquetage :
(cid:2)(v0) := 1 + max{n
– n
– ∀v ∈ NG(v0), N
– ∀v ∈ V (B(v0)), M

(cid:2) | ∃(n
(cid:2)(v) := N(v) \ {(λ({v0, v}), n(v0))} ∪ {(λ({v0, v}), n
(cid:2)(v) := M(v) ∪ (cid:5)
(w))}.

(cid:2)) ∈ M(v0)} ;
{(n

(w), λ(w), N

, N

, (cid:8)

(cid:2)

(cid:2)

(cid:2)(v0))} ;

(cid:2)

(cid:2)

w∈V (B(v0))

2.4.3 Correction de l’Algorithme d’´Enum´eration

On consid`ere un graphe simple ´etiquet´e G. Pour tout sommet v ∈ V (G), on note
(λ(v), ni(v), Ni(v), Mi(v)) l’´etiquette du sommet v apr`es la i`eme ´etape de r´e´etiquetage

28

Chapitre 2. Calculs Locaux sur les ´Etoiles Ferm´ees

de l’algorithme M d´ecrit ci-dessus. On pr´esente d’abord quelques propri´et´es qui sont
satisfaites par n’importe quelle ex´ecution de l’algorithme.

Propri´et´es Satisfaites lors de l’Ex´ecution

Le lemme suivant, qui peut ˆetre facilement prouv´e par une r´ecurrence sur le nombre
d’´etapes, rappelle quelque propri´et´es simples qui sont toujours satisfaites par l’´etiquetage.
Lemme 2.15 Pour tout sommet v ∈ V (G

(cid:2)), et pour toute ´etape i,

1. ni(v) (cid:12)= 0 =⇒ (ni(v), λ(v), Ni(v)) ∈ Mi(v),
2. ∃((cid:8)e, n) ∈ Ni(v) ⇐⇒ ∃v
(cid:2) ∈ NG(v) tel que ni(v
3. ∀((cid:8)e, n) ∈ Ni(v), n (cid:12)= ni(v) et ∃(n, (cid:8), N) ∈ Mi(v),
4. ∀v
L’algorithme M a des propri´et´es de monotonicit´e int´eressantes qui sont donn´ees dans

(cid:2)(cid:2) ∈ NG(v), ni(v), ni(v

(cid:2)) = n > 0 et λ({v, v

(cid:2)) > 0 =⇒ ni(v

(cid:2)) (cid:12)= ni(v

(cid:2)}) = (cid:8)e,

(cid:2)(cid:2)).

(cid:2)

, v

le lemme suivant.
Lemme 2.16 Pour chaque sommet v et chaque ´etape i,

– ni(v) ≤ ni+1(v),
– Ni(v) (cid:19) Ni+1(v),
– Mi(v) ⊆ Mi+1(v).

De plus, `a chaque ´etape i, il existe un sommet v telle qu’au moins une de ces in´egalit´es
(ou inclusions) est stricte pour v.

Preuve : La propri´et´e est trivialement vraie pour les sommets qui ne sont pas r´e´etiquet´es
lors de la (i + 1)`eme ´etape. De plus, il est facile de voir que quelque soit la r`egle appliqu´ee
`a l’´etape i + 1, on a toujours Mi(v) ⊆ Mi+1(v) pour tout sommet v ∈ V (G).
Pour chaque sommet v tel que ni(v) (cid:12)= ni+1(v), alors la r`egle M2 a ´et´e appliqu´ee sur
l’´etoile B(v) et on sait que ni+1(v) = 1 + max{n
(cid:2)) ∈ Mi(v)}. De plus, ou bien
ni(v) = 0 < ni+1(v), ou alors d’apr`es le Lemme 2.15, (ni(v), λ(v), Ni(v)) ∈ Mi(v) et donc
ni(v) < ni+1(v).
Pour chaque sommet v tel que Ni(v) (cid:12)= Ni+1(v), alors la r`egle M2 a ´et´e appliqu´ee sur
une ´etoile B(v0) telle que v0 ∈ NG(v). On sait que Ni+1(v) = Ni(v)\{(λ({v0, v}), ni(v0))}∪
{(λ({v0, v}), ni+1(v0))} et que pour tout (n, (cid:8), N) ∈ Mi(v), ni+1(v0) > n. Ainsi, on a
max Ni+1(v)(cid:17)Ni(v) = (λ({v0, v}), ni+1(v0)) ∈ Ni+1(v). Par cons´equent, Ni(v) ≺ Ni+1(v).
Puisque chaque application d’une r`egle modiﬁe l’´etiquette d’au moins un sommet v,
2

on sait que l’une de ces in´egalit´es est stricte pour v.

(cid:2) | ∃(n

, N

, (cid:8)

(cid:2)

(cid:2)

Les informations dont dispose chaque sommet v dans sa boˆıte-aux-lettres permettent
d’obtenir des informations v´eriﬁ´ees par la conﬁguration globale du graphe. Les deux
lemmes suivants permettent de prouver que si un sommet v connaˆıt un num´ero m `a
(cid:2) ≤ m, il
une ´etape i (i.e., il existe (cid:8), N tels que (m, (cid:8), N) ∈ Mi(v)), alors pour chaque m
existe un sommet w tel que ni(w) = m. On montre d’abord que si v connaˆıt un num´ero
m, alors il existe un sommet w tel que ni(w) = m.
Lemme 2.17 Pour chaque sommet v ∈ V (G) et chaque ´etape i, pour tout (m, (cid:8), N) ∈
Mi(v), il existe un sommet w ∈ V (G) tel que ni(w) = m.

2.4. ´Enum´eration, Nommage et ´Election

29

, j

(cid:4)

v∈V (G)

(cid:2)) ∈ U, (λ(u

Preuve : On remarque d’abord qu’un triplet (m, (cid:8), N) est ajout´e `a une ´etape i dans
Mi(v) seulement s’il existe un sommet v tel que ni(v) = m, λ(v) = (cid:8) et Ni(v) = N.
´Etant donn´e un sommet v, une ´etape i et un triplet (m, (cid:8), N) ∈ Mi(v), on note U =
{(u, j) ∈ V (G)× N | j ≤ i, nj(u) = m}. On consid`ere ensuite l’ensemble U
(cid:2) = {(u, j) ∈ U |
(cid:2) ≤
∀(u
(cid:2)
j}. Puisque (m, (cid:8), N) ∈ Mi(v), U et U
(cid:2) sont deux ensembles non-vides. On remarque
ais´ement qu’il existe i0 tel que pour tout (u, j) ∈ U

(cid:2))) ≺ (λ(u), Nj(u)) ou (λ(u

(cid:2)), Nj(cid:2)(u
(cid:2), j = i0.

(cid:2))) = (λ(u), Nj(u)) et j

Si i0 < i, il existe exactement un ´el´ement (u, i0) ∈ U

(cid:2) puisqu’`a chaque ´etape, le num´ero
d’au plus un sommet peut ˆetre modiﬁ´e. Le num´ero ni0(u) = m a donc ´et´e modiﬁ´e `a l’´etape
i0 + 1, mais par maximalit´e de (λ(u), Ni0(u)), la r`egle M2 n’a pas pu ˆetre appliqu´ee `a u
`a l’´etape i0. Par cons´equent, i0 = i et il existe donc un sommet w tel que ni(w) = m. 2

(cid:2)), Nj(cid:2)(u

Dans le lemme suivant, on montre que si un sommet v connaˆıt un num´ero m, alors il

connaˆıt tous les num´eros inf´erieurs `a m.
Lemme 2.18 Pour chaque sommet v et chaque ´etape i, pour tout (m, (cid:8), N) ∈ Mi(v), pour
tout m

(cid:2) ∈ [1, m], il existe (m

(cid:2)) ∈ Mi(v).

, N

, (cid:8)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

, (cid:8)

, (cid:8)

, N

, N

(cid:2)) ∈ Mi(v

(cid:2)) et Mi(v

< m, il existe (m

(cid:2) tel que (m, (cid:8), N) ∈ Mi(v

Preuve : On montre ce lemme par r´ecurrence sur i. Initialement, la propri´et´e est tri-
vialement vraie. On suppose que la propri´et´e est v´eriﬁ´ee pour i ≥ 0. La propri´et´e est
trivialement vraie `a l’´etape i + 1 pour tout sommet w ∈ V (G) dont l’´etiquette n’est pas
modiﬁ´ee `a l’´etape i + 1. Soit v un sommet dont l’´etiquette est modiﬁ´ee `a l’´etape i + 1.
Si la r`egle M1 a ´et´e appliqu´ee `a l’´etape i + 1, alors pour tout (m, (cid:8), N) ∈ Mi+1(v), il
(cid:2)) ⊆ Mi+1(v). Par cons´equent, par hypoth`ese
existe v
(cid:2)) ⊆ Mi+1(v). On suppose
(cid:2)) ∈ Mi(v
de r´ecurrence, pour tout m
maintenant que la r`egle M2 a ´et´e appliqu´ee `a l’´etape i+1 sur une ´etoile B(v0) qui contient
(cid:2) | ∃(m
(cid:2)) ∈ Mi(v)},
v. Soit (m, (cid:8), N) ∈ Mi+1(v)\Mi(v). Si m = ni+1(v0) = 1+max{m
(cid:2)) ∈ Mi(v) ⊆ Mi+1(v). Si m (cid:12)= ni+1(v0), alors il existe
< m, il existe (m
pour tout m
(cid:2) ∈ NG(v0) tel que m = ni(v
(cid:2)) et d’apr`es le Lemme 2.15, on sait qu’il existe
v
(m, (cid:8)

(cid:2)) = Mi(v). Ainsi la propri´et´e est v´eriﬁ´ee `a l’´etape i + 1.

, N
On veut maintenant montrer que toute ex´ecution de l’algorithme M termine sur G.
D’apr`es les Lemmes 2.17 et 2.18, on voit qu’`a chaque ´etape de l’ex´ecution, les num´eros des
sommets forment un ensemble [1, k] ou un ensemble [0, k] avec k ≤ |V (G)|. Par cons´equent,
d’apr`es le Lemme 2.16, on sait qu’il existe une ´etape i0 telle que pour tout sommet v et
toute ´etape i ≥ i0, ni+1(v) = ni(v).

(cid:2)
, (cid:8)
(cid:2)) = ni+1(v

(cid:2) ∈ NG(v) tel que ni(v

(cid:2)),
De plus, pour chaque sommet v et chaque ´etape i, si Ni(v) contient un couple ((cid:8)e, n
(cid:2)}) = (cid:8)e. Par cons´equent N(v)
alors il existe v
ne peut prendre qu’un nombre ﬁni de valeurs et il en est de mˆeme pour M(v). Ainsi le
nombre de valeurs diﬀ´erentes que peut prendre l’´etiquette de chaque sommet est ﬁni (mais
d´epend de la taille du graphe). Par ailleurs, les ´etiquettes cons´ecutives de chaque sommet v
forment une suite croissante et puisqu’`a chaque ´etape i, l’´etiquette d’au moins un sommet
est modiﬁ´ee, toute ex´ecution de l’algorithme termine : la relation M est noeth´erienne.

(cid:2) et λ({v, v

(cid:2)) = n

, N

2

30

Chapitre 2. Calculs Locaux sur les ´Etoiles Ferm´ees

Propri´et´es Satisfaites par l’´Etiquetage Final

Puisqu’on sait que l’algorithme termine toujours, on s’int´eresse maintenant aux pro-

pri´et´es satisfaites par l’´etiquetage ﬁnal.
Lemme 2.19 Toute ex´ecution ρ de l’algorithme M sur un graphe simple ´etiquet´e G =
(G, λ) termine et l’´etiquetage ﬁnal (λ, nρ, Nρ, Mρ) v´eriﬁe les propri´et´es suivantes :

1. il existe un entier k ≤ |V (G)| tel que {nρ(v) | v ∈ V (G)} = [1, k],

et pour tous sommets v, v

(cid:2) :

(cid:2)),

2. Mρ(v) = Mρ(v
3. (nρ(v), λ(v), Nρ(v)) ∈ Mρ(v
4. si nρ(v) = nρ(v
5. ∀w, w
6. ((cid:8)e, n) ∈ Nρ(v) si et seulement s’il existe w ∈ NG(v) tel que nρ(w) = n et λ({v, w}) =

(cid:2) ∈ NG(v), nρ(w) (cid:12)= nρ(w

(cid:2)), alors λ(v) = λ(v

(cid:2)) et Nρ(v) = Nρ(v

(cid:2)),

(cid:2)),

(cid:2)),

(cid:8)e ; auquel cas, ((cid:8)e, nρ(v)) ∈ Nρ(w).

Preuve :

1. D’apr`es les Lemmes 2.17 et 2.18 et puisque la r`egle M2 ne peut pas ˆetre appliqu´ee.
2. Dans le cas contraire, la r`egle M1 peut ˆetre appliqu´ee.
3. C’est une cons´equence directe de la propri´et´e pr´ec´edente d’apr`es le Lemme 2.15.
4. Dans le cas contraire, la r`egle M2 peut ˆetre appliqu´ee `a v ou `a v
5. D’apr`es le Lemme 2.15 et puisque la r`egle M2 ne peut pas ˆetre appliqu´ee.
6. D’apr`es le Lemme 2.15.

(cid:2).

Grˆace au Lemme 2.19, on peut prouver que l’´etiquetage ﬁnal permet de construire un

graphe H tel que G est un revˆetement de H.
Proposition 2.20 ´Etant donn´e un graphe simple G, on peut construire, `a partir de
l’´etiquetage ﬁnal obtenu apr`es une ex´ecution ρ de M, un graphe simple H tel qu’il existe
un homomorphisme localement bijectif de G dans H.

2

(cid:2) et {v, v

(cid:2)} | ∃v, v

(cid:2)) = m
(cid:2)} ∈ E(G) telle que nρ(v) = nρ(v

Preuve : On utilise les notations du Lemme 2.19.
On consid`ere le graphe H d´eﬁni par V (H) = {m ∈ N | ∃v ∈ V (G), nρ(v) = m} et
(cid:2) ∈ V (G); nρ(v) = m, nρ(v
(cid:2)} ∈ E(G)}. D’apr`es le
E(H) = {{m, m
Lemme 2.15, on sait qu’il n’existe pas d’arˆete {v, v
(cid:2)) : le
graphe H ne contient donc pas de boucle. De plus, de par la d´eﬁnition de E(H), on sait
que H ne contient pas d’arˆetes multiples. Ainsi le graphe H est bien un graphe simple. On
d´eﬁnit un ´etiquetage η de H en posant η(nρ(v)) = λ(v) et pour toute arˆete {v, v
(cid:2)} ∈ E(H),
(cid:2)}). D’apr`es le Lemme 2.19, si deux sommets v, v
(cid:2) ∈ V (G) ont
η({nρ(v), nρ(v
(cid:2)} ∈ E(G)
(cid:2)},{w, w
le mˆeme num´ero, alors λ(v) = λ(v
(cid:2)) = n
(cid:2), on sait d’apr`es le Lemme 2.19
telles que nρ(v) = nρ(w) = n et nρ(v
(cid:2)) ∈ Nρ(w). Puisque nρ(v) = nρ(w), on
que (λ({v, v
(cid:2))
(cid:2)), ((cid:8)2, n
a Nρ(w) = Nρ(v). Ainsi, puisqu’il ne peut exister deux couples distincts ((cid:8)1, n

(cid:2)). De plus, pour toutes arˆetes {v, v

(cid:2)) ∈ Nρ(v) et que (λ({w, w

(cid:2)) = nρ(w
(cid:2)}), n

(cid:2))}) = λ({v, v

(cid:2)}), n

2.4. ´Enum´eration, Nommage et ´Election

31

(cid:2)}) = λ({v, v

(cid:2)} ∈ E(G), alors {nρ(v), nρ(v

dans Nρ(v) = Nρ(w), λ({w, w
(cid:2)}). Par cons´equent, l’´etiquetage η de H est
bien d´eﬁni.
On consid`ere maintenant la fonction nρ : V (G) → V (H). Par d´eﬁnition de H, on sait
(cid:2)}) . De
que si {v, v
plus, pour tout v ∈ V (G), η(nρ(v)) = λ(v) et par cons´equent, nρ est un homomorphisme
de G dans H. D’apr`es le Lemme 2.19, pour tout sommet v, si m ∈ NH(nρ(v)), alors il
existe w ∈ NG(v) tel que nρ(w) = m et par cons´equent, nρ(NG(v)) = NH(nρ(v)). De plus,
(cid:2)) et on a donc |NG(v)| = |NH(nρ(v))|. Ainsi,
pour tous w, w
l’homomorphisme nρ est localement bijectif et G est un revˆetement de H.

(cid:2) ∈ NG(v), nρ(w) (cid:12)= nρ(w

(cid:2))} ∈ E(G) et η({nρ(v), nρ(v

(cid:2))}) = λ({v, v

2

On consid`ere maintenant un graphe simple G qui est minimal pour les revˆetements
simples. Pour chaque ex´ecution ρ de M sur G, le graphe obtenu `a partir de l’´etiquetage
ﬁnal est isomorphe `a G. Par cons´equent, l’ensemble des num´eros des sommets est exacte-
ment [1,|V (G)|] : chaque sommet a un identiﬁant unique. L’algorithme M permet de
r´esoudre le nommage et l’´enum´eration sur la famille des graphes minimaux pour les
revˆetements simples, mais si aucune information `a propos de G n’est disponible, les som-
mets ne peuvent pas d´etecter la terminaison.

Cependant, il est possible de d´etecter la terminaison pour un graphe simple G donn´e
(l’algorithme d´epend alors de G). En eﬀet, une fois qu’un sommet a obtenu le num´ero
|V (G)|, d’apr`es les Lemmes 2.17 et 2.18, il sait que tous les sommets de G ont un num´ero
unique qui ne va plus ˆetre modiﬁ´e. Dans ce cas l`a, on peut aussi r´esoudre le probl`eme de
l’´election, puisque ce sommet peut prendre l’´etiquette ´elu et diﬀuser ensuite l’information
qu’un sommet a ´et´e ´elu.

Par ailleurs, d’apr`es la Proposition 2.14, on sait que pour tout graphe simple G qui
n’est pas minimal pour les revˆetements simples, il n’existe aucun algorithme utilisant des
calculs locaux sur les ´etoiles ferm´ees qui permettent de r´esoudre les probl`emes du nommage
ou de l’´election sur G. On a donc prouv´e le th´eor`eme suivant.
Th´eor`eme 2.21 ([Maz97]) Pour tout graphe simple ´etiquet´e G, les assertions suivantes
sont ´equivalentes :

1. il existe un algorithme de nommage (ou d’´enum´eration) pour G utilisant des calculs

locaux sur les ´etoiles ferm´ees,

2. il existe un algorithme d’´election et un algorithme de nommage (ou d’´enum´eration)
avec d´etection de la terminaison pour G utilisant des calculs locaux sur les ´etoiles
ferm´ees,

3. G est minimal pour les revˆetements simples.

Remarque 2.22 ´Etant donn´e un graphe simple G minimal pour les revˆetements simples,
pour d´etecter que l’algorithme M a attribu´e un identiﬁant unique `a chaque sommet, il
suﬃt de connaˆıtre le nombre de sommets de G. Ainsi, l’algorithme M permet de r´esoudre
l’´election ainsi que le nommage avec d´etection de la terminaison sur les graphes minimaux
pour les revˆetements simples de taille donn´ee.

2.4.4 Complexit´e

On s’int´eresse `a la complexit´e de l’algorithme de Mazurkiewicz. Dans le cadre des
calculs locaux, on s’int´eresse au nombre de pas de r´e´etiquetages eﬀectu´ees lors d’une

32

Chapitre 2. Calculs Locaux sur les ´Etoiles Ferm´ees

ex´ecution. La proposition suivante, qui a ´et´e montr´ee par Godard [God02a], donne une
borne sup´erieure sur le nombre de pas de r´e´etiquetages de toute ex´ecution de l’algorithme
M sur un graphe `a n sommets.
Proposition 2.23 ([God02a]) Pour tout graphe G `a n sommets, durant toute ex´ecution
de l’algorithme de Mazurkiewicz, O(n3) r`egles sont appliqu´ees.
Preuve : On consid`ere un graphe G `a n sommets et une ex´ecution ρ de M sur G.
D’apr`es les Lemmes 2.17 et 2.18, on sait que la r`egle M2 ne peut pas ˆetre appliqu´ee plus
de n(n−1)
(cid:2)(i, v) l’ensemble
de triplets (n, (cid:8), N) ajout´es `a M(v) `a l’´etape i + 1, i.e., Mi+1(v) = Mi(v) ∪ M
(cid:2)(i, v).
On remarque qu’il existe au plus n ´etapes j lors desquelle la r`egle M1 est appliqu´ee et
(cid:2)(i, v) ⊆ Mj−1(w). Par
modiﬁe l’´etiquette d’un sommet w tel que M
cons´equent, puisque la r`egle est appliqu´ee O(n2) fois lors de l’ex´ecution durant l’ex´ecution
ρ, la r`egle M1 est appliqu´ee O(n3) fois.
2

Si la r`egle M2 est appliqu´ee `a l’´etape i+1 sur un sommet v, on note M

(cid:2)(i, v) (cid:3) Mj−1(w) et M

fois durant l’ex´ecution ρ.

2

Remarque 2.24 Dans sa th`ese [God02a], Godard a montr´e qu’il existait des graphes
admettant des ex´ecutions de M n´ecessitant Ω(n3) pas de r´e´etiquetages.

On peut aussi s’int´eresser `a l’espace n´ecessaire `a chaque sommet pour stocker son
´etiquette. On suppose que l’´etiquetage initial λ du graphe G est tel que chaque ´etiquette
initiale (cid:8) a une taille en O(log |V (G)|) bits (ce qui est suﬃsant pour attribuer des ´etiquettes
diﬀ´erentes `a tous les sommets et `a toutes les arˆetes de G).
Proposition 2.25 Pour tout graphe G `a n sommets de degr´e maximal Δ, l’algorithme
de Mazurkiewicz n´ecessite O(Δn log n) bits de m´emoire par sommet.

Preuve : On consid`ere un graphe G `a n sommets dont le degr´e maximal est Δ. 0n sait
que la vue locale de chaque sommet contient au plus Δ couples ((cid:8)e, n0) qui peuvent ˆetre
repr´esent´es avec O(log n) bits. Ainsi, pour chaque sommet v, N(v) peut ˆetre repr´esent´e
avec O(Δ log n) bits.

On remarque que durant l’ex´ecution de l’algorithme, la boˆıte-aux-lettres de chaque
sommet v contient de plus en plus d’informations. Cependant, elle contient des informa-
tions inutiles qui peuvent ˆetre ´elimin´ees `a chaque ´etape. En eﬀet, pour tout (n0, (cid:8), N) ∈
(cid:2)), on peut supprimer le couple
M(v), s’il existe (n0, (cid:8)
(n0, (cid:8), N) de M(v) sans perturber l’ex´ecution de l’algorithme. Ainsi, `a chaque ´etape, chaque
(cid:2)) ∈
sommet v peut remplacer sa boˆıte aux lettres M(v) par {(n0, (cid:8), N) ∈ M(v) | ∀(n0, (cid:8)
M(v), ((cid:8)

(cid:2)) ∈ M(v) tel que ((cid:8), N) ≺ ((cid:8)

(cid:2)) (cid:19) ((cid:8), N)}.

, N

, N

(cid:2)

, N

(cid:2)

(cid:2)

, N

(cid:2)

Par cons´equent, dans la boˆıte-aux-lettres de chaque sommet, il existe au plus n triplets
(n0, (cid:8), N) dont la taille est en O(Δ log n) bits. Ainsi, on peut repr´esenter la boˆıte-aux-lettres
de chaque sommet avec O(Δn log n) bits.
2

2.5

Importance de la Connaissance Initiale

Dans la partie pr´ec´edente, on a montr´e que l’algorithme de Mazurkiewicz permettait
de r´esoudre le probl`eme de l’´election et du nommage avec d´etection de la terminaison sur
la famille des graphes minimaux pour les revˆetements simples de taille donn´ee. Cependant,

2.5. Importance de la Connaissance Initiale

33

´etant donn´e un graphe G minimal pour les revˆetements simples, l’algorithme de Mazur-
kiewicz `a lui seul ne permet pas de r´esoudre l’´election sur G si on ne connaˆıt qu’une borne
sur la taille de G. Par ailleurs, ´etant donn´e un graphe G qui n’est pas minimal pour les
revˆetements, l’algorithme de Mazurkiewicz ne permet pas de d´etecter qu’on ne peut pas
´elire dans G si on ne connait que la taille de G.

Cependant, il n’est pas forc´ement n´ecessaire de connaˆıtre la taille pour pouvoir ´elire ;
d’autres types de connaissance initiales permettent de r´esoudre le probl`eme de l’´election,
ou du nommage avec d´etection de la terminaison. Par exemple, si on sait que le graphe G
est un arbre, on peut toujours ´elire un sommet, sans connaˆıtre d’autre information sur G.
En eﬀet, l’algorithme d’´election pour la famille des arbres pr´esent´e dans le Chapitre 1 peut
ˆetre impl´ement´e avec des calculs locaux sur les ´etoiles ferm´ees et on a donc le th´eor`eme
suivant.
Th´eor`eme 2.26 Il existe un algorithme d’´election pour la famille des arbres utilisant des
calculs locaux sur les ´etoiles ferm´ees.

On va maintenant pr´esenter une extension de l’algorithme de d´etection de la terminai-
son de Szymansky, Shi et Prywes [SSP85] qui permet d’obtenir un algorithme d’´election
pour des classes de graphes minimaux pour les revˆetements simples qui n’ont pas tous la
mˆeme taille. Cette extension a ´et´e introduite dans [MT00, GM03]. Dans [GM02], cet outil
a assi ´et´e utilis´e pour caract´eriser les classes de graphes admettant un algorithme universel
d’´election dans ce mod`ele. On va pr´esenter ici une version plus faible de ce r´esultat.

2.5.1 L’Algorithme de Szymansky, Shi et Prywes

Cet algorithme a ´et´e initialement d´ecrit pour d´etecter la terminaison d’un algorithme
dans un mod`ele o`u les processus o`u les sommets communiquent en ´echangeant des mes-
sages. ´Etant donn´e un algorithme o`u chaque processus sait qu’il a calcul´e sa valeur ﬁnale,
l’algorithme de Szymansky, Shi et Prywes [SSP85] (not´e SSP) permet aux processus de
d´etecter, sous certaines conditions, un instant o`u tous les sommets ont calcul´e leurs valeurs
ﬁnales : le calcul est globalement termin´e.
´Etant donn´e un graphe G, on associe `a chaque sommet v ∈ V (G) un pr´edicat P (v)
et un entier a(v), son niveau de conﬁance. Initialement P (v) est Faux et a(v) est ´egal `a
−1. Lorsqu’un processus a calcul´e sa valeur ﬁnale, il modiﬁe la valeur de P (v) qui devient
Vrai (et qui ne changera plus). `A chaque fois qu’un processus modiﬁe la valeur de a(v),
il en informe ses voisins.
La modiﬁcation de la valeur de a(v0) d’un sommet v0 d´epend seulement de la valeur
de P (v0) et des informations dont v0 dispose `a propos des valeurs {a(v1), . . . , a(vd)} de
ses voisins :

– Si P (v0) =Faux, alors a(v0) = −1 ;
– si P (v0) =Vrai, alors a(v0) = 1 + min{a(vk) | 0 ≤ k ≤ d}.
Le principe de l’algorithme de SSP g´en´eralis´e (not´e GSSP) introduite et utilis´ee dans
[MT00, GM03] est le suivant. Au lieu de consid´erer que la fonction P est un pr´edicat
qui ne peut changer qu’une fois de valeur pour passer de Faux `a Vrai, la fonction P
peut prendre une valeur quelconque et peut ˆetre modiﬁ´ee un nombre arbitraire de fois.
Cependant, on suppose que pour tout sommet v, si P (v) a une valeur α qui est modiﬁ´ee
par la suite, alors P (v) ne pourra plus jamais ˆetre ´egal `a α. Autrement dit, entre deux

34

Chapitre 2. Calculs Locaux sur les ´Etoiles Ferm´ees

moments o`u un sommet v est tel que P (v) = α, la fonction P (v) est constante. On dit
alors que la fonction P est connexe par valeurs.

2.5.2 Une Adaptation de l’Algorithme de Mazurkiewicz

On va utiliser l’algorithme GSSP pour v´eriﬁer que tous les sommets du graphe ont la
mˆeme boˆıte-aux-lettres et qu’aucun d’eux ne peut appliquer la r`egle M2 de l’algorithme
de Mazurkiewicz, i.e., changer de num´ero. Si on peut s’assurer que ces deux propri´et´es
sont vraies, alors on sait que l’ex´ecution de l’algorithme est termin´ee et on sait que les
propri´et´es du Lemme 2.19 et de la Proposition 2.20 sont v´eriﬁ´ees. D’apr`es le Lemme 2.16,
on sait que les boˆıtes aux lettres des sommets ne peuvent qu’augmenter pour l’inclusion
et M : v (cid:20)→ M(v) est donc une fonction connexe par valeurs.

L’´etiquette des sommets de G = (G, λ) sont alors de la forme (λ(v), n(v), N(v), M(v),
a(v)) o`u la seule diﬀ´erence avec l’algorithme de Mazurkiewicz est le champ a(v) qui
est le rayon de conﬁance du sommet v. Initialement, tous les sommets ont l’´etiquette
(λ(v), 0,∅,∅,−1).

Les deux premi`eres r`egles de l’algorithme de Mazurkiewicz sont adapt´ees de telle sorte
qu’`a chaque fois que la boˆıte-aux-lettres d’un sommet est modiﬁ´ee, alors son rayon de
conﬁance est r´einitialis´e `a −1 puisque le sommet a modiﬁ´e sa boˆıte-aux-lettres.
M(cid:2)

1: R`egle de Diﬀusion

Pr´econdition :
– ∃v ∈ NG(v0) tel que M(v) (cid:12)= M(v0).
R´e´etiquetage :
– ∀v ∈ V (B(v0)), M
– ∀v ∈ V (B(v0)), a

(cid:2)(v) :=
(cid:2)(v) := −1.

w∈V (B(v0))

(cid:4)

M(w) ;

M(cid:2)

2: R`egle de Renommage

Pr´econdition :
– ∀v ∈ NG(v0), M(v) = M(v0),
– n(v0) = 0 ou

∃(n(v0), (cid:8), N) ∈ M(v0) tel que (λ(v0), N(v0)) ≺ ((cid:8), N)
R´e´etiquetage :
(cid:2)(v0) := 1 + max{n
– n
– ∀v ∈ NG(v0), N
– ∀v ∈ V (B(v0)), M
– ∀v ∈ V (B(v0)), a

(cid:2) | ∃(n
(cid:2)(v) := N(v) \ {(λ({v0, v}), n(v0))} ∪ {(λ({v0, v}), n
(cid:2)(v) := M(v) ∪ (cid:5)
(cid:2)(v) := −1.

(cid:2)) ∈ M(v0)} ;

(w), λ(w), N

w∈V (B(v0))

(w)) ;

(n

, (cid:8)

, N

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)(v0))} ;

Une troisi`eme r`egle est ajout´e qui permet `a un sommet v qui ne peut pas modiﬁer
son num´ero d’augmenter son rayon de conﬁance si tous ses voisins ont la mˆeme boˆıte-
aux-lettres que v et si leurs rayons de conﬁances sont tous sup´erieurs ou ´egaux `a celui de
v.
M(cid:2)

3: R`egle GSSP

Pr´econdition :

2.5. Importance de la Connaissance Initiale

35

– ∀v ∈ NG(v0), M(v) = M(v0),
– n(v0) > 0 et ∀(n(v0), (cid:8), N) ∈ M(v0), ((cid:8), N) (cid:19) (λ(v0), N(v0)),
– ∀v ∈ NG(v0), a(v) ≥ a(v0)
R´e´etiquetage :
– a

(cid:2)(v0) := 1 + min{a(v) | v ∈ NG(v0)}.

2.5.3 Propri´et´es Satisfaites par l’Algorithme

Comme pr´ecedemment, on consid`ere une ex´ecution de l’algorithme M(cid:2) sur un graphe
simple ´etiquet´e G. Pour tout sommet v ∈ V (G), on note (λ(v), ni(v), Ni(v), Mi(v), ai(v))
l’´etiquette du sommet v apr`es la i`eme ´etape de r´e´etiquetage.

Le lemme suivant qui peut ˆetre facilement prouv´e par induction sur le nombre d’´etapes
montre que le rayon de conﬁance d’un sommet ne peut qu’augmenter tant que sa boˆıte-
aux-lettres n’est pas modiﬁ´ee.
Lemme 2.27 Pour tout sommet v et toute ´etape i, si Mi(v) = Mi+1(v), alors ai+1(v) ≥
ai(v). De plus, si ai(v) ≥ 0, alors la r`egle M(cid:2)
2 ne peut ˆetre appliqu´ee sur l’´etoile de centre
v.

Dans le lemme suivant, on montre que le rayon de conﬁance d’un sommet permet d’ob-
tenir des informations sur le contenu des boˆıtes-aux-lettres d’autres sommets du graphe
lors d’´etapes pr´ec´edentes de l’ex´ecution.
Lemme 2.28 Pour tout sommet v ∈ V (G) et toute ´etape i, pour tout sommet w ∈ V (G)
tel que distG(v, w) ≤ ai(v), il existe une ´etape j ≥ i telle que aj(w) ≥ ai(v) − distG(v, w)
et Mj(v) = Mi(v).

Preuve : On fait une d´emonstration par r´ecurrence sur la distance k entre v et w. Si
k = 0, la propri´et´e est trivialement vraie. On suppose maintenant que la propri´et´e est
vraie pour tous sommets v, w tels que distG(v, w) ≤ k.
On consid`ere deux sommets v, w et une ´etape i tels que ai(v) ≥ k + 1 et distG(v, w) =
k + 1. Il existe un sommet u ∈ NG(v) tels que distG(u, w) = k. On consid`ere la derni`ere
3 a ´et´e appliqu´ee au sommet v. On sait que aj(cid:2)(u) ≥ aj(cid:2)(v) − 1 =
´etape j
ai(v) − 1 et Mj(cid:2)(u) = Mj(cid:2)(v) = Mi(v). Par hypoth`ese de r´ecurrence, on sait qu’il existe
(cid:2) telle que aj(w) ≥ aj(cid:2)(u)− k ≥ ai(v)−(k+1) et Mj(w) = Mj(cid:2)(u) = Mi(v).
une ´etape j < j
Ainsi, la propri´et´e est v´eriﬁ´ee pour tous sommets v, w `a distance k + 1.

(cid:2) o`u la r`egle M(cid:2)

2

Dans le lemme suivant, on montre que si `a un moment donn´e, un sommet a un rayon
de conﬁance sup´erieur au diam`etre du graphe, alors tous les sommets du graphe ont la
mˆeme boˆıte-aux-lettres et ont tous un rayon de conﬁance sup´erieur `a 0.
Lemme 2.29 S’il existe un sommet v et une ´etape i telle que ai(v) ≥ D(G), alors pour
tout w ∈ V (G), Mi(w) = Mi(v) et ai(v) ≥ 0.
Preuve : Puisque ai(v) > D(G), on sait d’apr`es le Lemme 2.28 que pour tout sommet
w ∈ V (G), il existe une ´etape iw < i telle que aiw ≥ 0 et Miw(w) = Mi(v).
Supposons qu’il existe un sommet w tel que Mi(w) (cid:12)= Miw(w). Soit j l’´etape de
l’ex´ecution lors de laquelle pour la premi`ere fois, la boˆıte-aux-lettres d’un sommet w
qui valait Mi(v) a ´et´e modiﬁ´ee. Autrement dit, pour tout sommet w ∈ V (G), il existe
(cid:2) ≥ j − 1 telle que Mj(cid:2)(w) = Mi(v) et il existe un sommet w tel que
une ´etape j

36

Chapitre 2. Calculs Locaux sur les ´Etoiles Ferm´ees

1 ou M(cid:2)

Mj−1(w) = Mi(v) (cid:4) Mj(w). Cela signiﬁe que la r`egle M(cid:2)
2 a ´et´e appliqu´ee lors de
l’´etape j ; on note v0 le centre de l’´etoile sur laquelle cette r`egle a ´et´e appliqu´ee.
On sait que pour tout sommet w ∈ V (BG(V0)), Mj−1(w) = Mi(v) (cid:4) Mj(w) et qu’il
existe une ´etape iw ≤ j−1 telle que Miw(w) = Mi(v) et aiw(w) ≥ 0. D’apr`es le Lemme 2.27,
on sait que pour tout sommet w ∈ V (B(V0)), Mj−1(w) = Mi(v) et aj−1(w) ≥ 0. Par
cons´equent, puisque tous les sommets de BG(v0) ont la mˆeme boˆıte-aux-lettres `a l’´etape
j − 1, la r`egle M(cid:2)
1 ne peut pas ˆetre appliqu´ee sur l’´etoile BG(v0) lors de l’´etape j. De plus,
aj(v0) ≥ 0 et d’apr`es le Lemme 2.27, on sait que la r`egle M(cid:2)
2 ne peut pas ˆetre appliqu´ee
sur l’´etoile de centre v0. Par cons´equent, pour tout sommet w ∈ V (G), Mi(w) = Mi(v). 2

Ainsi, si on connaˆıt une borne B sur le diam`etre de G, l’algorithme M(cid:2) permet de
d´etecter que l’ex´ecution de l’algorithme de Mazurkiewicz sous-jacent est termin´e. En eﬀet,
une fois qu’un sommet a un rayon de conﬁance sup´erieur ou ´egal `a B, il sait que tous les
sommets de G ont la mˆeme boˆıte-aux-lettres et qu’ils ont leurs num´eros et vues locales
ﬁnaux.

Si on sait que le graphe G est minimal pour les revˆetements simples, on sait alors
d’apr`es la Proposition 2.20 que tous les sommets ont un identiﬁant unique et dans ce cas l`a,
le sommet dont le num´ero est 1 peut prendre l’´etiquette ´elu et diﬀuser l’information. On a
par cons´equent montr´e le th´eor`eme suivant, qui est un cas particulier de la caract´erisation
des familles de graphes admettant un algorithme d’´election pr´esent´e dans [GM02].
Th´eor`eme 2.30 ([GM02]) Pour tout entier B, il existe un algorithme d’´election et un
algorithme de nommage avec d´etection de la terminaison utilisant des calculs locaux sur
les ´etoiles ferm´ees pour la famille des graphes minimaux pour les revˆetements simples dont
le diam`etre est born´ee par B.

Ainsi, il n’est pas n´ecessaire de connaˆıtre la taille pour pouvoir ´elire dans un graphe G
que l’on sait minimal pour les revˆetements simples : une borne sur la taille ou le diam`etre
est suﬃsante.

De plus, Angluin [Ang80] a montr´e qu’on ne pouvait pas r´esoudre l’´election si les
sommets ne disposaient d’aucune information `a propos de G, i.e., il n’existe pas d’algo-
rithme d’´election universel pour la famille des graphes minimaux pour les revˆetements
simples. Godard et M´etivier [GM02] ont g´en´eralis´e ce r´esultat en montrant qu’il n’existait
pas d’algorithme universel d’´election pour toute famille de graphes minimaux contenant
strictement la famille des arbres.

Cependant, on ne sait pas n´ecessairement si le graphe G est minimal pour les revˆete-
ments simples. On peut donc souhaiter avoir un algorithme qui permet ou bien de r´esoudre
l’´election sur G, ou bien de d´etecter que le graphe G n’est pas minimal pour les revˆetements
simples. On va montrer que l’algoritme M(cid:2) permet de r´esoudre ce probl`eme si on a une
borne serr´ee sur la taille de G.
Th´eor`eme 2.31 Pour tout entier B, il existe un algorithme eﬀectif d’´election et de nom-
mage avec d´etection de la terminaison utilisant des calculs locaux sur les ´etoiles ferm´ees
pour la classe des graphes G tels que V (G) ≤ B < 2|V (G)|.
Preuve : On sait d’apr`es la Proposition 2.20 et le Lemme 2.29 qu’avec la connaissance
d’une borne serr´ee B sur la taille d’un graphe G, toute ex´ecution de M(cid:2) sur G permet de
construire un graphe H tel que G est un revˆetement simple de H. Si G est un revˆetement

2.6. Conclusion

37

simple propre de H, on sait d’apr`es la Proposition 2.6 que 2|V (H)| ≤ |V (G)|. Puisque
|V (G)| ≤ B < 2|V (G)|, on sait que si G est un revˆetement simple propre de H, 2|V (H)| ≤
B. Au contraire, si G est isomorphe `a H, alors B < 2|V (G)| = 2|V (H)|. Par cons´equent,
il suﬃt de tester si la taille du graphe H construit `a partir de l’´etiquetage ﬁnal obtenu
apr`es l’ex´ecution de M(cid:2) sur G v´eriﬁe l’in´egalit´e 2|V (H)| ≤ B. Si l’in´egalit´e est v´eriﬁ´ee,
alors le graphe G n’est pas minimal pour les revˆetements simples, et dans le cas contraire,
le graphe H est isomorphe `a G et on peut donc r´esoudre l’´election et le nommage avec
d´etection de la terminaison sur G.
2

On remarque que si on ne connait qu’une borne sur la taille de G et que cette borne
n’est pas serr´ee, on ne peut pas trouver d’algorithme utilisant des calculs locaux sur les
´etoiles ferm´ees qui permet de r´esoudre le probl`eme de l’´election sur G ou de d´etecter que
G n’est pas minimal pour les revˆetements simples. En eﬀet, il suﬃt de consid´erer deux
graphes G et H de telle sorte que G soit un revˆetement simple `a deux feuillets de H
(ce qui est toujours possible d’apr`es le Th´eor`eme de Reidemeister), comme par exemple
les graphes de la Figure 7. Si la borne fournie `a l’algorithme est |V (G)| et qu’elle n’est
pas serr´ee, l’algorithme doit r´esoudre le probl`eme de l’´election sur H et par cons´equent,
d’apr`es le Lemme 2.13, il existe une ex´ecution de l’algorithme sur G telle que dans la
conﬁguration ﬁnale, l’´etiquette ´elu apparaˆıt deux fois dans G.

2.6 Conclusion

Dans ce chapitre, on a pr´esent´e une caract´erisation des graphes admettant un algo-
rithme d’´election (ou de nommage) utilisant des calculs locaux sur les ´etoiles ferm´ees.
Cette caract´erisation s’exprime de mani`ere ´el´egante `a l’aide des revˆetements simples. La
condition n´ecessaire est un r´esultat d’Angluin [Ang80] et la condition suﬃsante est obtenue
grˆace `a l’algorithme de Mazurkiewicz [Maz97].

On remarque que permettre `a un algorithme de pouvoir modiﬁer ou non les ´etiquettes
des arˆetes des ´etoiles r´e´etiquet´ees ne permet pas de r´esoudre ´election ou nommage dans
des graphes diﬀ´erents. En eﬀet, le r´esultat d’impossibilit´e de la Proposition 2.14 est vrai
lorsque les arˆetes peuvent ˆetre r´e´etiquet´ees alors que le r´esultat de possibilit´e (l’algorithme
de Mazurkiewicz) n’utilise pas cette possibilit´e. On verra que les mod`eles ´etudi´es dans les
chapitres suivants n’ont pas cette propri´et´e.

Dans [God02b], Godard a pr´esent´e une version auto-stabilisante de l’algorithme d’´enu-
m´eration de Mazurkiewicz. Dans [GMM04], Godard, M´etivier et Muscholl caract´erisent les
classes de graphes reconnaissables dans ce mod`ele sans connaissance initiale ; ils consid`erent
des syst`emes de reconnaissance `a terminaison implicite. Ils montrent qu’une classe de
graphes est reconnaissable dans ce cadre si cette classe est close pour la fermeture sym´e-
trique, r´eﬂexive et transitive de la relation «ˆetre revˆetement». Dans [GM03] Godard et
M´etivier caract´erisent les classes de graphes qui peuvent ˆetre reconnues dans ce mod`ele
en fonction de la connaissance initiale disponible.

Dans la Section 2.5, on a ´etudi´e l’importance des connaissances initiales pour pou-
voir ´elire dans un graphe minimal pour les revˆetements. Les r´esultats pr´esent´es sont
des cas particuliers des r´esultats obtenus par Godard et M´etivier dans [GM02], o`u une
caract´erisation des classes de graphes admettant un algorithme universel d’´election est

38

Chapitre 2. Calculs Locaux sur les ´Etoiles Ferm´ees

pr´esent´ee. Pour obtenir des conditions n´ecessaires, les travaux pr´esent´es dans [GM02] re-
posent sur le lemme de rel`evement d’Angluin [Ang80] et sur la notion de quasi-revˆetements
introduite dans [MMW97]. Les conditions suﬃsantes sont obtenues `a partir d’une ´etude
ﬁne des propri´et´es de l’algorithme de Mazurkiewicz [Maz97] et de l’algorithme de Szy-
mansky, Shi et Prywes [SSP85].

Dans la Section 2.5, on a aussi pr´esent´e un algorithme eﬀectif d’´election n´ecessitant la
connaissance d’une borne serr´ee sur la taille du graphe. Ce r´esultat est li´e aux travaux de
M´etivier et Tel [MT00] o`u ils ´etudient sous quelles conditions un algorithme `a terminaison
implicite utilisant des calculs locaux sur les ´etoiles ferm´ees peut ˆetre transform´e en un
algorithme `a terminaison explicite.

Chapitre 3

Calculs Locaux sur les Arˆetes
´Etiquet´ees

Sommaire
3.1

67
69

3.3.1 D´eﬁnitions
3.3.2 Revˆetements et Calculs Locaux sur les Arˆetes ´Etiquet´ees

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
3.1.1 R´esultats
41
41
3.1.2 Travaux Li´es
3.2 Revˆetements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
3.3 Calculs Locaux (Cellulaires) sur les Arˆetes ´Etiquet´ees . . . . . 44
45
45
3.4 Un R´esultat d’´Equivalence . . . . . . . . . . . . . . . . . . . . . . 46
47
3.4.1 Principe de l’ Algorithme . . . . . . . . . . . . . . . . . . . . . .
´Etiquettes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
48
3.4.2
48
3.4.3 R`egles de R´e´etiquetage
. . . . . . . . . . . . . . . . . . . . . . .
3.4.4 Correction de l’Algorithme de Simulation . . . . . . . . . . . . .
50
´Enum´eration, Nommage et ´Election . . . . . . . . . . . . . . . . 57
3.5.1 R´esultats d’Impossibilit´e pour l’´Enum´eration et le Nommage . .
57
3.5.2 Un Algorithme d’´Enum´eration . . . . . . . . . . . . . . . . . . .
58
3.5.3 Correction de l’Algorithme d’´Enum´eration . . . . . . . . . . . . .
61
3.5.4 Complexit´e . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
65
Importance de la Connaissance du Degr´e . . . . . . . . . . . . . 66
3.6.1 Relations avec le Mod`ele D’Angluin et le Mod`ele de Communica-
tion Synchrone . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.6.2 Calculs Locaux sur les ´Etoiles Ouvertes . . . . . . . . . . . . . .
´Equivalence entre les Calculs Locaux sur les Arˆetes ´Etiqu´eet´ees
3.6.3
avec Connaissance Initiale du Degr´e et les Calculs Locaux sur les
´Etoiles Ouvertes
. . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
´Election dans les Familles de Diam`etre Born´e . . . . . . . . . . .

70
75
77
3.7 Conclusion et Perspectives . . . . . . . . . . . . . . . . . . . . . . 83

3.5

3.6

3.6.4 Un Mod`ele Strictement plus Puissant
3.6.5

39

40

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

X

Y

α

(cid:2)

X

(cid:2)
α

(cid:2)

Y

Fig. 9 – Forme g´en´erique d’un r`egle de calcul pour les calculs locaux sur les arˆetes
´etiquet´ees.

X

Y

α

(cid:2)

X

(cid:2)
α

Y

Fig. 10 – Forme g´en´erique d’un r`egle de calcul pour les calculs locaux cellulaires sur les
arˆetes ´etiquet´ees.

3.1

Introduction

Dans ce chapitre, on ´etudie les calculs locaux sur les arˆetes ´etiquet´ees qui correspondent
aux relations de r´e´etiquetage localement engendr´ees sur les arˆetes introduites au Chapitre 1
(Deﬁnition 1.31). Dans ce mod`ele, on consid`ere des graphes qui peuvent avoir des arˆetes
multiples mais qui n’ont pas de boucle. Un pas de calcul est d´ecrit par une r`egle de
r´e´etiquetage de la forme pr´esent´ee sur la Figure 9. Si dans un graphe G, il existe une arˆete
e ´etiquet´ee α dont les extr´emit´es sont ´etiquet´ees X et Y , alors lors de l’application de
(cid:2). Les ´etiquettes de tous les
cette r`egle sur e, on remplace α par α
autres sommets et arˆetes de G ne sont pas prises en compte lors de l’application de la r`egle
et ne sont pas modiﬁ´ees. Les sommets et l’arˆete de G dont les ´etiquettes sont modiﬁ´ees
sont dits actifs et les autres sommets et arˆetes de G sont dits inactifs. Les calculs r´ealis´es
en utilisant uniquement ce type de r`egles de r´e´etiquetage sont appel´es calculs locaux sur
les arˆetes ´etiquet´ees. Il faut noter que si une r`egle de calcul est appliqu´ee sur une arˆete
dont les deux extr´emit´es ont la mˆeme ´etiquette, les nouvelles ´etiquettes des deux sommets
peuvent ˆetre diﬀ´erentes. Autrement dit, les r`egles ne sont pas sym´etriques.

(cid:2) et Y par Y

(cid:2), X par X

On consid`ere aussi une restriction de ce mod`ele o`u en un pas de calcul, l’´etiquette
d’au plus un sommet peut ˆetre modiﬁ´ee. Les r`egles sont donc de la forme pr´esent´ee sur la
Figure 10. Si dans un graphe G il existe une arˆete e ´etiquet´ee α dont les extr´emit´es sont
(cid:2) et
´etiquet´ees X et Y , alors lors de l’application de cette r`egle sur e, on remplace α par α
(cid:2). Les ´etiquettes de tous les autres sommets et arˆetes de G ne sont pas prises en
X par X
compte pour l’application de la r`egle de r´e´etiquetage et restent inchang´ees. Le sommet de
G dont l’´etiquette est modiﬁ´ee est dit actif (et est repr´esent´e en noir sur les ﬁgures), le
voisin du sommet actif qui est impliqu´e dans l’application de la r`egle est dit passif (et est
repr´esent´e en blanc sur les ﬁgures). Tous les autres sommets de G qui ne participent pas
`a l’application de la r`egle sont dits inactifs. L’arˆete dont l’´etiquette est modiﬁ´ee est dite
active et toutes les autres arˆetes de G sont dites inactives. Les calculs r´ealis´es en utilisant
uniquement ce type de r´e´etiquetage sont appel´es calculs locaux cellulaires sur les arˆetes
´etiquet´ees.

On consid`ere enﬁn un mod`ele o`u en un pas de calcul, un sommet peut observer l’´etat
de ses voisins, l’´etat des arˆetes qui lui sont incidentes et modiﬁer son ´etat ainsi que l’´etat
des arˆetes qui lui sont incidentes. La diﬀ´erence avec les calculs locaux sur les ´etoiles
ferm´ees ´etudi´es au Chapitre 2 est que le sommet qui ex´ecute ce pas de calcul ne peut pas
modiﬁer les ´etiquettes de ses voisins. Les calculs r´ealis´es en utilisant uniquement ce type
de r´e´etiquetage sont appel´es calculs locaux sur les ´etoiles ouvertes.

3.1. Introduction

3.1.1 R´esultats

41

Dans ce chapitre, on montre d’abord que les calculs locaux cellulaires sur les arˆetes
´etiquet´ees ont la mˆeme puissance de calcul que les calculs locaux sur les arˆetes ´etiquet´ees
(Proposition 3.20).

Dans ces deux mod`eles, on caract´erise les graphes admettant un algorithme d’´election
et de nommage (dans ce mod`ele, ´election et nommage peuvent ˆetre r´esolus sur les mˆemes
graphes). Cette caract´erisation est bas´ee sur la notion de revˆetements (qui correspondent
aux homomorphismes de graphes localement bijectifs) et utilise un r´esultat d’impossibilit´e
d’Angluin [Ang80].

On montre qu’un graphe admet un algorithme d’´election ou de nommage utilisant
des calculs locaux (cellulaire) sur les arˆetes ´etiquet´ees si et seulement s’il est minimal
pour les revˆetements (Th´eor`eme 3.29). L’algorithme d’´enum´eration qu’on pr´esente dans
la Section 3.5.2 est une adpatation de l’algorithme de Mazurkiewicz. Cependant, dans
le mod`ele consid´er´e ici, un sommet ne peut pas consulter l’´etat de tous ses voisins pour
mettre `a jour son ´etiquette. Aﬁn de permettre `a chaque sommet de distinguer ses voisins,
un identiﬁant va ˆetre attribu´e `a chaque arˆete du graphe de telle sorte que deux arˆetes
incidentes `a un mˆeme voisin aient des identiﬁants diﬀ´erents.

On ´etudie ensuite l’inﬂuence de la connaissance initiale du degr´e et on montre que si
initialement, chaque sommet connaˆıt son degr´e, alors les calculs locaux (cellulaires) sur
les arˆetes ´etiquet´ees avec connaissance initiale du degr´e ont la mˆeme puissance de calcul
que les calculs locaux sur les ´etoiles ouvertes (Proposition 3.42). On montre ensuite que
la connaissance initiale du degr´e permet d’obtenir un mod`ele de calcul strictement plus
puissant, bien que les graphes dans lesquels on peut ´elire en utilisant des calculs locaux
sur les ´etoiles ouvertes sont les mˆemes que ceux qui admettent un algorithme d’´election
utilisant des calculs locaux (cellulaires) sans connaissance initiale du degr´e.

On montre par ailleurs que si chaque sommet connaˆıt initialement son degr´e, il suﬃt de
connaˆıtre une borne sur le diam`etre pour pouvoir nommer ou ´elire dans un graphe minimal
pour les revˆetements (Th´eor`eme 3.49) et que la connaissance d’une borne serr´ee sur la taille
permet d’obtenir un algorithme eﬀectif d’´election et de nommage (Th´eor`eme 3.50).

Les r´esultats pr´esent´es dans ce chapitre ont ´et´e obtenus en collaboration avec Yves

M´etiver et une partie de ces r´esultats a ´et´e publi´ee dans [CM04].

3.1.2 Travaux Li´es

Dans [Ang80], Angluin a pour la premi`ere fois donn´e un r´esultat d’impossibilit´e pour
le probl`eme de l’´election dans les r´eseaux anonymes. Ce r´esultat est bas´e sur la notion
de revˆetement et le r´esultat d’impossibilit´e qu’on pr´esente dans ce Chapitre (Proposi-
tion 3.22) est tr`es proche du r´esultat d’Angluin. Le mod`ele consid´er´e par Angluin est
proche des mod`eles ´etudi´es dans ce chapitre et on montre dans la Section 3.6.1 que le
mod`ele d’Angluin a une puissance de calcul ´equivalent aux calculs locaux sur les arˆetes
´etiquet´es avec connaissance initiale du degr´e. On obtient de cette mani`ere la premi`ere
caract´erisation des graphes dans lesquels on peut r´esoudre le probl`eme de l’´election dans
le mod`ele d’Angluin (Th´eor`eme 3.35).

Dans un r´eseau globalement asynchrone, le mode de communication synchrone a ´et´e
´etudi´e par Charron-Bost et al. [CBMT96]. Dans ce mod`ele, lorsqu’une communication
a lieu entre deux processeurs, l’´emetteur et le destinataire du message se synchronisent

42

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

lors de la transmission. On montre dans la Section 3.6.1 que ce mod`ele est ´equivalent
aux mod`eles consid´er´es dans ce chapitre lorsque chaque sommet connaˆıt initialement son
degr´e et on en d´eduit donc une caract´erisation des r´eseaux admettant un algorithme
d’´election dans ce mod`ele (Th´eor`eme 3.36). Le langage CSP (Communicating Sequential
Processes) introduit par Hoare [Hoa78] et le π-calcul introduit par Milner [Mil99] sont
des exemples de langages o`u les processus communiquent de mani`ere synchrone. Boug´e a
´etudi´e dans [Bou88] le probl`eme de l’´election sym´etrique dans le cadre de CSP ; les r´esultats
qu’il a obtenu reposent sur la notion d’automorphisme et sont diﬀ´erents des r´esultats
pr´esent´es dans ce chapitre puisque dans le mod`ele qu’il consid`ere, chaque sommet connaˆıt
initialement le graphe et sa position dans ce graphe. Palamidessi a ´etudi´e dans [Pal03] le
mˆeme probl`eme dans le cadre du π-calcul aﬁn de montrer qu’il existe une hi´erarchie stricte
entre diﬀ´erents mod`eles du π-calcul.

3.2 Revˆetements

Dans ce chapitre, les homomorphismes localement bijectifs, i.e., les revˆetements, sont
les homomorphismes qui permettent de donner des conditions n´ecessaires que doivent
v´eriﬁer les graphes admettant un algorithme de nommage ou d’´election. Il faut noter que
contrairement au Chapitre 2, les graphes consid´er´es dans ce chapitre peuvent avoir des
arˆetes multiples (mais pas de boucle).

D´eﬁnition 3.1 Un graphe G est un revˆetement d’un graphe H `a travers un homomor-
phisme γ : G → H si pour tout sommet v ∈ V (G), γ induit une bijection entre IG(u) et
IH(ϕ(u)), i.e., si les conditions suivantes sont v´eriﬁ´ees :

– |IG(u)| = |IH(γ(u))|,
– γ(IG(u)) = IH(γ(u)).

On dit alors que l’homomorphisme γ est localement bijectif.

Un graphe G est un revˆetement propre de H si γ n’est pas un isomorphisme et G est

minimal pour les revˆetements si G n’est un revˆetement propre d’aucun autre graphe.

Naturellement, un graphe ´etiquet´e (G, λ) est un revˆetement d’un graphe ´etiquet´e (H, η)

`a travers γ si G est un revˆetement de H `a travers γ et si γ conserve l’´etiquetage.

Remarque 3.2 Si les deux graphes G et H sont simples, on remarque que la notion de
revˆetement correspond `a la notion de revˆetement simple.

Exemple 3.3 Le graphe G de la Figure 11 est un revˆetement de H `a travers l’homomor-
phisme γ.

Le graphe G est un revˆetement propre de H et n’est donc pas minimal pour les

revˆetements ; le graphe H est minimal pour les revˆetements.

Puisqu’on ne consid`ere que des graphes connexes, tout homomorphisme localement

bijectif est surjectif.

Proposition 3.4 Si un graphe G est un revˆetement d’un graphe connexe H `a travers γ,
alors γ est surjectif.

Preuve : Soit G un revˆetement d’un graphe H `a travers un homomorphisme γ.

3.2. Revˆetements

43

2

a

1

b

b
G

1

a

2

γ

1

2

a

b

H

Fig. 11 – Le graphe G est un revˆetement de H `a travers l’homomorphisme γ qui envoie
chaque sommet (resp. chaque arˆete) de G ´etiquet´e i sur l’unique sommet (resp. arˆete) de
H dont l’´etiquette est i.

On consid`ere un sommet v ∈ γ(V (G)). Il existe donc u ∈ V (G) tel que γ(u) = v.
Puisque γ induit une bijection entre IG(u) et IH(v), pour toute arˆete f ∈ IH(v), il existe
une arˆete e ∈ IG(u) telle que γ(e) = f et donc f ∈ γ(E(G)).
De mˆeme pour toute arˆete f ∈ γ(E(G)), il existe e ∈ E(G) telle que γ(e) = f. Puisque
γ est un homomorphisme, ext(f) = γ(ext(e)) et ainsi pour tout v ∈ ext(f), v ∈ γ(V (G)).
Ainsi, puisque H est connexe et que γ(V (G) est non-vide, on sait que γ est un homo-
2

morphisme surjectif de G dans H.

Comme pour les revˆetements simples, si un graphe G est un revˆetement d’un graphe
H connexe, alors tous les sommets et les arˆetes de H ont le mˆeme nombre d’ant´ec´edents,
qui est appel´e le nombre de feuillets du revˆetement.
Proposition 3.5 Si un graphe G est un revˆetement d’un graphe connexe H `a travers γ,
alors il existe une constante q telle que pour tout x ∈ V (H) ∪ E(H), |γ
Cette constante q est appel´ee le nombre de feuilletsdu revˆetement.

−1(x)| = q.

Puisque γ est localement bijectif, pour tout sommet u ∈ γ

Preuve : On consid`ere un graphe G qui est un revˆetement d’un graphe connexe H `a
travers un homomorphisme γ. On consid`ere un sommet v ∈ V (H) et une arˆete f ∈ IH(v).
−1(v), il existe une unique
arˆete e ∈ IG(u) telle que γ(e) = f. De plus, puisque H ne contient pas de boucle, on sait
que |γ(ext(e))| = |ext(f)| = 2 et par cons´equent, e a une seule extr´emit´e dont l’image est
v. Ainsi |γ
−1(f), il existe un unique sommet u ∈ ext(e)
(cid:2) ∈ IG(u)
−1(f)| ≤ |γ
−1(x)| =

tel que γ(u) = v. Puisque γ est localement bijectif, on sait que pour toute arˆete e
diﬀ´erente de e, γ(e
(cid:2) ∈ V (H) ∪ E(H), |γ
Ainsi, puisque le graphe H est connexe, pour tout x, x
|γ
−1(x

R´eciproquement, pour toute arˆete e ∈ γ
(cid:2)) (cid:12)= f. Par cons´equent, |γ

−1(u)|.

2

−1(f)| ≥ |γ

−1(v)|.

(cid:2))|.

Exemple 3.6 On pr´esente ici quelques exemples de graphes connexes simples qui sont
minimaux pour les revˆetements.

– les graphes dont le nombre d’arˆetes et le nombre de sommets sont premiers entre

eux,

– les arbres,
– les anneaux de taille premi`ere.

44

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

La notion de coloration r´eguli`ere permet de caract´eriser les graphes simples non-
´etiquet´es minimaux pour les revˆetements en termes de colorations de graphes. Un ´etique-
tage (cid:8) d’un graphe simple non-´etiquet´e est une coloration r´eguli`ere si deux sommets voisins
ont des couleurs distinctes et si le graphe induit par deux classes de couleurs adjacentes
est un graphe biparti r´egulier.
D´eﬁnition 3.7 Une coloration r´eguli`ere d’un graphe simple G est un ´etiquetage (cid:8) de G
tel que

– pour tout i ∈ (cid:8)(V (G)), G[i] est un stable,
– pour tout i, j ∈ (cid:8)(V (G)) avec i (cid:12)= j, G[i, j] est un stable, ou alors G[i, j] est un

graphe biparti r´egulier.

Dans la proposition suivante, on caract´erise les graphes qui sont minimaux pour les
revˆetements `a l’aide de la notion de coloration r´eguli`ere. On rappelle qu’une coloration (cid:8)
est propre si |(cid:8)(V (G))| < |V (G)|.
Proposition 3.8 Un graphe simple non-´etiquet´e G est minimal pour les revˆetements si
et seulement si G n’admet aucune coloration r´eguli`ere propre.

(cid:2)). Pour tous v, v

Preuve : On consid`ere un graphe simple non-´etiquet´e G qui est un revˆetement propre
d’un graphe H `a travers un homomorphisme γ.
utilis´es est V (H). Puisque H ne contient pas de boucle, pour toute arˆete {u, u
γ(u) (cid:12)= γ(u
que ext(f) = {v, v
−1(v) ∪ γ
−1(v
de γ
−1(v) (resp. γ
sommet de γ
(resp. γ
puisque |V (H)| < |V (G)|, γ est une coloration r´eguli`ere propre de G.

On va montrer que γ est une coloration r´eguli`ere de G et que l’ensemble des couleurs
(cid:2)} ∈ E(G),
(cid:2) ∈ V (H), on note d{v,v(cid:2)} le nombre d’arˆetes f ∈ E(H) telles
(cid:2)}, tout sommet
−1(f). Par cons´equent, tout
(cid:2))) est adjacent `a exactement d{v,v(cid:2)} sommets de γ
(cid:2))
−1(v
(cid:2)] est donc un graphe biparti d{v,v(cid:2)}-r´egulier. Finalement,

(cid:2)}. Pour chaque arˆete f ∈ E(H) telles que ext(f) = {v, v
(cid:2)) est incident `a exactement une arˆete de γ

−1(v
−1(v)). Le graphe G[v, v

(cid:2) ∈ V (H), il existe un entier d{v,v(cid:2)} tel que G[v, v

R´eciproquement, ´etant donn´ee une coloration r´eguli`ere propre (cid:8) d’un graphe G, on va
d´eﬁnir un graphe H tel que G soit un revˆetement de H. On pose V (H) = (cid:8)(V (G)). Pour
(cid:2)] est un graphe biparti d{v,v(cid:2)}-
tous v, v
(cid:2) ∈ E(H),
r´egulier et alors, on d´eﬁnit E(H) de la mani`ere suivante, pour tous sommets v, v
il existe d{v,v(cid:2)} arˆetes f1,{v,v(cid:2)}, . . . , fd{v,v(cid:2)},{v,v(cid:2)} ∈ E(H) dont les extr´emit´es sont v et v
(cid:2).
D’apr`es le th´eor`eme des mariages de Hall [Hal35], on sait qu’il existe un couplage parfait
(cid:2)] en d{v,v(cid:2)} couplages parfaits
dans G[v, v
M1,{v,v(cid:2)}, . . . , Md{v,v(cid:2)},{v,v(cid:2)}. Ainsi, on peut d´eﬁnir γ de la mani`ere suivante. pour tout som-
met u ∈ V (G), γ(u) = (cid:8)(u) et pour toute arˆete e ∈ E(G), γ(e) = fi,{v,v(cid:2)} si e ∈ Mi,{v,v(cid:2)}.
−1(v) est
Puisque chaque Mi,{v,v(cid:2)} est un couplage parfait de G[v, v
incident `a exactement une arˆete e ∈ γ
−1(fi,{v,v(cid:2)}) et γ est donc un homomorphisme loca-
lement bijectif de G dans H. Puisque |V (H)| = |(cid:8)(V (G))| < |V (G)|, G et H ne sont pas
isomorphes et G n’est donc pas minimal pour les revˆetements.

(cid:2)] et on peut donc partitionner les arˆetes de G[v, v

(cid:2)], tout sommet u ∈ γ

2

3.3 Calculs Locaux (Cellulaires) sur les Arˆetes ´Etiquet´ees

Dans cette partie, on pr´esente les d´eﬁnitions formelles des calculs locaux sur les arˆetes
´etiquet´ees et des calculs locaux cellulaires sur les arˆetes ´etiquet´ees puis on ´etudie leurs

(cid:2)(f)

(cid:2)(e) = η
λ
(cid:2) ∈ E(G) diﬀ´erente de e, λ(e
e

1. λ(v1) = η(w1), λ(v2) = η(w2), λ(e) = η(f), λ
2. pour tout sommet v ∈ V (G) diﬀ´erent de v1 et de v2, λ(v) = λ
3. pour tout sommet w ∈ V (H) diﬀ´erent de w1 et de w2, λ(w) = λ

(cid:2)) = λ
(cid:2)(e
(cid:2) ∈ E(H) diﬀ´erente de f, λ(f

arˆete f

(cid:2)),
(cid:2)) si et seulement si (H, η) R (H, η

(cid:2)) = λ

(cid:2)(f

alors (G, λ) R (G, λ

(cid:2)).

(cid:2)),

(cid:2)(v) et pour toute arˆete

(cid:2)(w) et pour toute

3.3. Calculs Locaux (Cellulaires) sur les Arˆetes ´Etiquet´ees

45

relations avec les revˆetements.

3.3.1 D´eﬁnitions

On rappelle qu’informellement, les calculs locaux sur les arˆetes ´etiquet´ees sont les
calculs r´ealis´es en utilisant uniquement des r`egles de la forme pr´esent´ee sur la Figure 9 :
`a chaque pas de calcul, l’´etiquette d’une arˆete et de ses extr´emit´es sont modiﬁ´ees par
l’application d’une r`egle qui ne d´epend que des ´etiquettes de l’arˆete et de ses extr´emit´es.
On pr´esente maintenant un d´eﬁnition plus formelle du mod`ele.

On rappelle la d´eﬁnition des relations de r´e´etiquetage localement engendr´ee sur les

arˆetes (Deﬁnition 1.31).
D´eﬁnition 3.9 Une relation de r´e´etiquetage R est localement engendr´ee sur les arˆetes
(cid:2)) et
si la condition suivante est satisfaite. Pour tous graphes (G, λ), (G, λ
toutes arˆetes e ∈ E(G) et f ∈ E(H) telles que ext(e) = {v1, v2} et ext(f) = {w1, w2}, si
les trois conditions suivantes sont v´eriﬁ´ees :

(cid:2)), (H, η), (H, η

(cid:2)(v1) = η

(cid:2)(w1), λ

(cid:2)(v2) = η

(cid:2)(w2) et

Une relation de r´e´etiquetage R localement engendr´ee sur les arˆetes est cellulaire si lors

de l’application d’une r`egle de r´e´etiquetage, l’´etiquette d’un seul sommet est modiﬁ´ee.
D´eﬁnition 3.10 Une relation de r´e´etiquetage R localement engendr´ee sur les arˆetes est
(cid:2)) alors il existe un sommet v ∈ V (G) tel que ∀w ∈
cellulaire si lorsque (G, λ) R (G, λ
V (G), w (cid:12)= v =⇒ λ(w) = λ

(cid:2)(w).

Par d´eﬁnition, les calculs locaux sur les arˆetes ´etiquet´ees correspondent aux relations
de r´e´etiquetage localement engendr´ees sur les arˆetes et les calculs locaux cellulaires sur
les arˆetes ´etiquet´ees correspondent aux relations de r´e´etiquetage cellulaires localement
engendr´ees sur les arˆetes.

Comme indiqu´e dans le Chapitre 1, une relation de r´e´etiquetage localement engendr´ee
sur les arˆetes peut ˆetre d´ecrite par un ensemble r´ecursif de r`egles de la forme pr´esent´ees sur
la Figure 9. R´eciproquement, un tel ensemble de r`egles induit une relation de r´e´etiquetage
localement engendr´ee sur les arˆetes. De mˆeme, une relation de r´e´etiquetage cellulaire lo-
calement engendr´ee sur les arˆetes peut ˆetre d´ecrite par un ensemble r´ecursif de r`egles de
la forme pr´esent´ees sur la Figure 10 et un tel ensemble de r`egles induit une relation de
r´e´etiquetage cellulaire localement engendr´ee sur les arˆetes. Ainsi, on notera R l’ensemble
de r`egles de r´e´etiquetage aussi bien que la relation de r´e´etiquetage correspondante.

3.3.2 Revˆetements et Calculs Locaux sur les Arˆetes ´Etiquet´ees

On pr´esente maintenant le lemme qui met en ´evidence le lien entre les calculs locaux
sur les arˆetes ´etiquet´ees et les revˆetements. Ce lemme de rel`evement est le lemme de

46

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

rel`evement d’Angluin [Ang80] adapt´e aux revˆetements de graphes qui peuvent avoir des
arˆetes multiples.

Lemme 3.11 (Lemme de rel`evement [Ang80]) On consid`ere un graphe G qui est un
revˆetement d’un graphe H `a travers un homomorphisme γ et une relation R de r´e´etiquetage
localement engendr´ee sur les arˆetes. Si H R∗ H(cid:2), alors il existe G(cid:2) tel que G R∗ G(cid:2) et G(cid:2)
est un revˆetement de H(cid:2) `a travers γ.

(cid:2)) = η(w

Preuve : Il suﬃt de prouver ce lemme pour un pas de calcul. On consid`ere deux graphes
(G, λ) et (H, η) tels que (G, λ) est un revˆetement de (H, ν) `a travers γ. On consid`ere un
(cid:2)
(cid:2) et on note η
pas de r´e´etiquetage sur H sur une arˆete f dont les extr´emit´es sont w et w
le nouvel ´etiquetage de H obtenu apr`es ce pas de r´e´etiquetage.
Puisque γ est un homomorphisme qui pr´eserve l’´etiquetage, pour chaque arˆete e ∈
(cid:2)) = w
(cid:2), λ(v) = η(w)
−1(f), λ(e) = η(f) et il existe v, v
γ
(cid:2)). Il est donc possible d’appliquer un pas de r´e´etiquetage sur e de telle
et λ(v
(cid:2))). De plus, puisque
sorte que l’´etiquette de e (resp. v, v
−1(f), il n’existe pas de
γ est localement bijectif, on sait que pour toutes arˆetes e, e
sommet v ∈ ext(e) ∩ ext(e
(cid:2)). En eﬀet, dans le cas contraire, γ ne serait pas localement
bijectif en v. Par cons´equent, on peut appliquer la r`egle de r´e´etiquetage sur chaque arˆete
e ∈ γ
−1(f) et on note λ
(cid:2) l’´etiquetage de G obtenu. Ainsi, puisque γ est localement bijectif,
pour tout sommet v ∈ γ
−1(w) (resp v
−1(f) incidente
(cid:2))). Par cons´equent, le graphe
(cid:2)(v) = η
`a v (resp. v
G(cid:2) = (G, λ

(cid:2) ∈ γ
−1(w
(cid:2)) et on a donc λ
(cid:2)(w) (resp. λ
(cid:2)) est un revˆetement de H(cid:2) = (H, λ

(cid:2) ∈ ext(e) tels que γ(v) = w, γ(v
(cid:2)) devienne η(f) (resp. η(w), η(w

(cid:2))), il existe une arˆete e ∈ γ
(cid:2)(w
(cid:2)(v
(cid:2)) `a travers γ.

(cid:2)) = η

(cid:2) ∈ γ

On note que chaque pas de r´e´etiquetage dans H est simul´e par plusieurs pas de
2

r´e´etiquetage dans G o`u la mˆeme r`egle de r´e´etiquetage est appliqu´ee.

Le diagramme suivant repr´esente la propri´et´e du Lemme 3.11.

revˆetement

⏐⏐(cid:3)revˆetement

R∗−−−−→ G(cid:2)

G

⏐⏐(cid:3)
H −−−−→

R∗ H(cid:2)

Puisqu’une relation de r´e´etiquetage cellulaire sur les arˆetes ´etiquet´ees est aussi une
relation de r´e´etiquetage sur les arˆetes ´etiquet´ees, le Lemme 3.11 est aussi vrai si la relation
R est une relation de r´e´etiquetage cellulaire sur les arˆetes ´etiquet´ees.

3.4

´Equivalence entre les Calculs Locaux Cellulaires sur les
Arˆetes ´Etiquet´ees et les Calculs Locaux sur les Arˆetes
´Etiquet´ees

Dans cette partie, on montre que les calculs locaux cellulaires sur les arˆetes ´etiquet´ees

ont la mˆeme puissance de calcul que les calculs locaux sur les arˆetes ´etiquet´ees.

On s’int´eresse seulement aux algorithmes qui terminent et on d´eﬁnit maintenant la

notion de simulation qu’on utilise par la suite.

3.4. Un R´esultat d’ ´Equivalence

47

D´eﬁnition 3.12 On consid`ere deux algorithmes R1 et R2 utilisant respectivement des
ensembles d’´etiquettes L1 et L2 et une fonction π : L1 → L2.
On consid`ere un graphe G = (G, λ) sur lequel toute ex´ecution de R1 termine. Si toute
ex´ecution de R2 sur G termine et si de plus, pour tout conﬁguration ﬁnale (G, λ
(cid:2)
2) atteinte
par une ex´ecution de R2 sur G, il existe une conﬁguration ﬁnale (G, λ
(cid:2)
1) atteinte par une
ex´ecution de R1 sur G telle que π ◦ λ
1, alors on dit que R2 simule R1 sur G `a
(cid:2)
(cid:2)
2 = λ
travers π.
Si pour tout graphe G sur lequel toute ex´ecution de R1 termine, R2 simule R1 `a travers
π, alors on dit que R2 simule R1.

Dans cette partie, on montre que tout algorithme utilisant des calculs locaux sur les
arˆetes ´etiquet´ees peut ˆetre simul´e par un algorithme utilisant des calculs locaux cellulaires
sur les arˆetes ´etiquet´ees et r´eciproquement. Dans la d´eﬁnition pr´ec´edente, on ne consid`ere
pas le probl`eme de d´etection de la terminaison, i.e., les propri´et´es qui sont conserv´ees par
la simulation ne portent que sur l’´etiquetage ﬁnal. Cependant, on va aussi montrer qu’il
existe un algorithme utilisant des calculs locaux sur les arˆetes ´etiquet´ees permettant de
r´esoudre un probl`eme P sur une famille de graphes F avec d´etection de la terminaison si
et seulement s’il existe un algorithme utilisant des calculs locaux cellulaires sur les arˆetes
´etiquet´ees permettant de r´esoudre P sur F avec d´etection de la terminaison.

Il est ´evident qu’un algorithme utilisant des calculs locaux cellulaires sur les arˆetes
´etiquet´ees est un algorithme utilisant des calculs locaux sur les arˆetes ´etiquet´ees. On
s’int´eresse donc `a montrer qu’on peut obtenir un algorithme utilisant des calculs locaux
cellulaires sur les arˆetes ´etiquet´ees `a partir d’un algorithme utilisant des calculs locaux sur
les arˆetes ´etiquet´ees.

3.4.1 Principe de l’ Algorithme

Le principe de l’algorithme de simulation est le suivant. Chaque sommet et chaque
arˆete a un statut qui peut ˆetre free, ask, acc, ack qui correspondent aux diﬀ´erentes
´etapes de la simulation d’une ´etape de r´e´etiquetage de R. Initialement, tous les sommets
et toutes les arˆetes ont le statut free.
(cid:2) d’une arˆete e sont libres (leurs statuts sont free) et qu’une
r`egle de l’algorithme R peut ˆetre appliqu´ee sur e, alors le sommet v prend le statut ask
et il modiﬁe aussi le statut de e qui devient ask pour signiﬁer que v veut appliquer une
r`egle sur l’arˆete e, et non sur une autre arˆete incidente. De plus, on stocke dans l’´etiquette
de e le pas de calcul de R qui peut ˆetre simul´e sur e.

Si les deux extr´emit´es v et v

Si un sommet v est libre et qu’une arˆete e incidente `a v a le statut ask, alors si v n’a
pas modiﬁ´e son ´etiquette depuis que e a le statut ask, v prend le statut acc pour signiﬁer
qu’il accepte de simuler un pas de calcul de R sur e. Dans ce cas l`a, le statut de e devient
acc et les ´etiquettes λ(v) et λ(e) sont modiﬁ´ees selon la r`egle simul´ee.
Un sommet v dont le statut est ask et qui est incident `a une arˆete dont le statut est
acc modiﬁe son ´etiquette λ(v) selon la r`egle de R qui est simul´e et il redevient libre. Le
statut de e devient alors ack. Un sommet v dont le statut est acc et qui est incident `a
une arˆete dont le statut est ack peut prendre le statut free seulement si l’autre extr´emit´e
de e a le statut free.

Aﬁn d’´eviter tout inter-blocage lors de l’ex´ecution, on permet `a un sommet v dont le
(cid:2) avec lequel v voulait simuler une r`egle de

statut est ask de redevenir libre si le voisin v

48

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

R a modiﬁ´e son ´etiquette λ(v

(cid:2)) et si v

(cid:2) est libre.

Remarque 3.13 L’int´erˆet de ne pas permettre `a un sommet de redevenir libre d`es qu’il
accepte de simuler un pas de calcul est de s’assurer que si un sommet a le statut free, alors
pour toutes les r`egles qu’il a simul´ees, les ´etiquettes λ(x) de tous les sommets et arˆetes qui
ont ´et´e impliqu´ees dans l’application de ces r`egles ont bien ´et´e modiﬁ´ees.

3.4.2

´Etiquettes

On d´ecrit les ´etiquettes utilis´ees pour obtenir un algorithme utilisant des calculs locaux
cellulaires sur les arˆetes ´etiquet´ees `a partir d’un algorithme R utilisant des calculs locaux
sur les arˆetes. On suppose que l’´etiquette ⊥ n’apparaˆıt pas dans les ´etiquettes utilis´ees par
R.

signiﬁcations suivantes :

Chaque sommet v a une ´etiquette (λ(v), status(v)) dont les diﬀ´erents champs ont les
– λ(v) est l’´etiquette de v dans l’algorithme R simul´e,
– status(v) ∈ {free, ask, acc} est le statut de v et correspond aux diﬀ´erentes ´etapes

de la simulation,

L’´etiquette initiale de chaque sommet v est de la forme (λ(v), free) : cela signiﬁe que le
sommet v peut simuler une r`egle avec n’importe quel voisin.

tion suivante :

Chaque arˆete e a une ´etiquette (λ(e), status(e), r(e)) dont les champs ont la signiﬁca-
– λ(e) est l’´etiquette de e dans l’algorithme R simul´e,
– status(e) ∈ {free, ask, acc, ack} est le statut de e et correspond aux diﬀ´erentes

– r(e) = ((cid:8)1, (cid:8)e, (cid:8)2, (cid:8)

´etapes de la simulation,
(cid:2)
(cid:2)
2) est le pas de r´e´etiquetage qui est en cours de simulation
e, (cid:8)
sur e ; si le statut de e est free, alors r(e) = r⊥ = (⊥,⊥,⊥,⊥,⊥,⊥) puisqu’aucune
r`egle n’est simul´ee sur e.

(cid:2)
1, (cid:8)

Initialement, chaque arˆete e `a l’´etiquette (λ(e), free, r⊥) puisqu’aucune r`egle n’est simul´ee
sur e.

3.4.3 R`egles de R´e´etiquetage

On pr´esente ici les r`egles de r´e´etiquetage qui permettent de simuler les calculs locaux
sur les arˆetes ´etiquet´ees `a l’aide de calculs locaux cellulaires sur les arˆetes ´etiquet´ees.
Les r`egles suivantes correspondent aux diﬀ´erentes ´etapes ´evoqu´ees dans la description
informelle de l’algorithme.
Si les deux extr´emit´es d’une arˆete ont le statut free et qu’une r`egle de R peut ˆetre
appliqu´ee sur cette arˆete, la premi`ere r`egle permet `a une des extr´emit´es de modiﬁer son
statut et celui de l’arˆete aﬁn d’essayer de simuler la r`egle de R. Dans ce cas l`a les statuts
de l’arˆete et du sommet passent `a ask et on stocke dans l’´etiquette de l’arˆete le pas de
r´e´etiquetage qui peut ˆetre simul´e.

3.4. Un R´esultat d’ ´Equivalence

49

S1(R) :

((cid:8)1, free)

((cid:8)e, free, r⊥)

((cid:8)2, free)

((cid:8)1, ask)

((cid:8)e, ask, r

(cid:2))

((cid:8)2, free)

Cette r`egle est applicable si on peut appliquer une r`egle de R sur une arˆete ´etiquet´ee
(cid:2)
2).
((cid:8)1, (cid:8)e, (cid:8)2) pour obtenir l’´etiquetage ((cid:8)

(cid:2)
2), auquel cas r

(cid:2) = ((cid:8)1, (cid:8)e, (cid:8)2, (cid:8)

(cid:2)
1, (cid:8)

(cid:2)
e, (cid:8)

(cid:2)
1, (cid:8)

(cid:2)
e, (cid:8)

Si un sommet v a un voisin v

(cid:2) qui a appliqu´e la r`egle S1(R), si le statut de v est free
et que l’´etiquette λ(v) n’a pas ´et´e modiﬁ´ee entre-temps, v peut appliquer la deuxi`eme
(cid:2). Les statuts de v et de e deviennent alors acc et les
r`egle le long de l’arˆete e reliant v `a v
´etiquettes λ(v) et λ(e) sont modiﬁ´ees selon la r`egle simul´ee.

S2(R) :

((cid:8)1, free)

((cid:8)e, ask, r)

((cid:8)2, ask)

(cid:2)
1, acc)

((cid:8)

(cid:2)
e, acc, r)

((cid:8)

((cid:8)2, ask)

Cette r`egle est applicable si r = ((cid:8)2, (cid:8)e, (cid:8)1, (cid:8)

(cid:2)
2, (cid:8)

(cid:2)
e, (cid:8)

(cid:2)
1).

La troisi`eme r`egle peut ˆetre appliqu´ee par un sommet v qui avait appliqu´e la r`egle
S1(R) en fonction d’un voisin v
(cid:2) a accept´e de simuler la r`egle
le long de e. Dans ce cas l`a, le sommet v modiﬁe son ´etiquette λ(v) et retrouve le statut
(cid:2) que la simulation a bien
free. Le statut de l’arˆete devient ack pour signiﬁer au sommet v
´et´e eﬀectu´ee.

(cid:2) le long d’une arˆete e si v

S3(R) :

((cid:8)1, ask)

(cid:2)
e, acc, r)

((cid:8)

(cid:2)
2, acc)

((cid:8)

(cid:2)
1, free)

((cid:8)

(cid:2)
e, ack, r)

((cid:8)

(cid:2)
2, acc)

((cid:8)

Cette r`egle est applicable si r = ((cid:8)1, (cid:8)e, (cid:8)2, (cid:8)

(cid:2)
1, (cid:8)

(cid:2)
e, (cid:8)

(cid:2)
2).

La quatri`eme r`egle permet `a un sommet v qui a accept´e de simuler une r`egle de
retrouver le statut free s’il existe une arˆete e incidente `a v dont le statut est ack et dont
(cid:2) a le statut free. Dans ce cas l`a, l’arˆete e retrouve aussi son statut
l’autre extr´emit´e v
free.

S4(R) :
(cid:2)
((cid:8)
1, acc)

(cid:2)
e, ack, r)

((cid:8)

((cid:8), free)

(cid:2)
1, free)

((cid:8)

(cid:2)
e, free, r⊥)

((cid:8)

((cid:8), free)

Cette r`egle est applicable si r = ((cid:8)2, (cid:8)e, (cid:8)1, (cid:8)

(cid:2)
2, (cid:8)

(cid:2)
e, (cid:8)

(cid:2)
1).

La cinqui`eme r`egle a pour rˆole d’´eviter tout inter-blocage lors de l’ex´ecution de l’algo-
rithme de simulation. Si un sommet v avait ex´ecut´e la r`egle S1(R) avec un voisin v
(cid:2) le long
(cid:2) a r´eussi a
d’une arˆete e et qu’entre temps, l’´etiquette λ(v
simuler une r`egle avec un autre de ses voisins, alors la cinqui`eme r`egle permet au sommet
v de retrouver le statut free.

(cid:2)) a ´et´e modiﬁ´ee, parce que v

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

50

S5(R) :

((cid:8)1, ask)

((cid:8)e, ask, r)

((cid:8), free)

((cid:8)1, free)

((cid:8)e, free, r⊥)

((cid:8), free)

Cette r`egle est applicable si r = ((cid:8)1, (cid:8)e, (cid:8)2, (cid:8)

(cid:2)
1, (cid:8)

(cid:2)
e, (cid:8)

2) et (cid:8) (cid:12)= (cid:8)2.
(cid:2)

3.4.4 Correction de l’Algorithme de Simulation

On consid`ere un graphe ´etiquet´e G et une ex´ecution de S(R) sur G. On note (λ(v),
statusi(v)) l’´etiquette du sommet v et (λ(e), statusi(e), ri) l’´etiquette de l’arˆete e apr`es
la i`eme ´etape de l’ex´ecution. On pr´esente d’abord quelques propri´et´es qui sont satisfaites
par n’importe quelle ex´ecution de l’algorithme.
Aﬁn de simpliﬁer les preuves, on va associer un graphe simple orient´e Di `a chaque
´etape de l’ex´ecution de S(R) sur G. `A tout moment, l’ensemble des sommets de D est
l’ensemble des arˆetes et des sommets de G, i.e., V (Di) = {ue | e ∈ E(G)}∪{uv | v ∈ V (G)}.
Initialement, D ne contient aucun arc, i.e., A(D0) = ∅.
Pour construire le graphe Di+1 `a partir de Di, on consid`ere le pas de r´e´etiquetage
eﬀectu´e `a l’´etape i sur le graphe G. Si la r`egle S1(R) ou S2(R) est appliqu´ee sur une
arˆete e et modiﬁe l’´etat d’un sommet v, on ajoute un arc orient´e de uv `a ue ´etiquet´e v et
(cid:2) (cid:12)= e incidente `a v dans G, i.e., E(Di+1) =
un arc orient´e de u
(cid:2) (cid:12)= e}.
E(Di) ∪ {(uv, ue)} ∪ {(ue(cid:2), uv) | e
Si la r`egle S3(R), S4(R) ou S5(R) est appliqu´ee lors de l’´etape i sur une arˆete e et
modiﬁe l’´etat d’un sommet v, on supprime toutes les arˆetes incidentes `a uv, E(Di+1) =
E(Di) \ ({(uv, ue) ∈ E(D)} ∪ {(ue(cid:2), uv) ∈ E(D)}).
On remarque que le sommet ue ∈ V (Di) correspondant `a une arˆete e ∈ E(G) ne peut

(cid:2)
e `a uv pour toute arˆete e
(cid:2) ∈ IG(v) et e

ˆetre voisin que des sommets uv, uv(cid:2) correspondant aux extr´emit´es de e dans G.

Dans le lemme suivant, on montre comment le graphe Di est li´e `a l’´etat des sommets

et des arˆetes de G `a l’´etape i.
Lemme 3.14 Pour toute ´etape i, toute arˆete e ∈ E(G) et tout sommet v ∈ V (G), les
propri´et´es sont satisfaites.
(1) Le graphe Di est un graphe simple orient´e qui ne contient pas de circuit.
(2) Si statusi(e) = free, alors il n’existe aucun arc (uv, ue) ∈ A(Di).
(3) Si statusi(e) = ask, alors il existe exactement un arc (uv, ue) ∈ A(Di) et de plus,
(cid:2) ∈ ext(e) tels que (uv, ue), (uv(cid:2) , ue) ∈ A(Di),
(4) Si statusi(e) = acc, alors il existe v, v
(cid:2)
1, λi(e), λi(v)).
(5) Si statusi(e) = ack, alors il existe exactement un arc (uv, ue) ∈ A(Di) et de plus,

v ∈ ext(e), statusi(v) = ask et ri(e) = (λi(v), λi(e), (cid:8)2, (cid:8)

statusi(v) = acc et statusi(v
v ∈ ext(e), statusi(v) = acc et ri(e) = ((cid:8)1, (cid:8)e, (cid:8)2, (cid:8)

(cid:2)) = ask. De plus, ri(e) = (λi(v

(cid:2)
1, λi(e), λi(v)).

(cid:2)), (cid:8)e, (cid:8)2, (cid:8)

(cid:2)
1, (cid:8)

(cid:2)
e, (cid:8)

(cid:2)
2).

(6) Si statusi(v) = free, alors uv n’est incident `a aucun arc dans Di.
(7) Si statusi(v) = ask, alors il existe une arˆete e ∈ IG(v) telle que (uv, ue) ∈ A(Di) et
(8) si statusi(v) = acc, alors il existe une arˆete e ∈ IG(v) telle que (uv, ue) ∈ A(Di) et

statusi(e) ∈ {ask, acc}. De plus, pour tout e
statusi(e) ∈ {acc, ack}. De plus, pour tout e

(cid:2) ∈ IG(v), (ue(cid:2), uv) ∈ A(Di).
(cid:2) ∈ IG(v), (ue(cid:2), uv) ∈ A(Di).

3.4. Un R´esultat d’ ´Equivalence

51

(cid:2)(cid:2)}.

(cid:2) (cid:12)= e.

(cid:2) et que l’´etiquette de v est modiﬁ´ee.

Si la r`egle S1(R) est appliqu´ee lors de l’´etape i+1, alors statusi(v

Preuve : On va montrer le lemme par r´ecurrence sur le nombre d’´etapes i. Initialement,
E(D0) = ∅ et pour tout x ∈ V (G) ∪ E(G), status(x) = free : les propri´et´es sont donc
v´eriﬁ´ees. On suppose maintenant que les propri´et´es sont vraies `a l’´etape i. On suppose
qu’`a l’´etape i+1 une r`egle de r´e´etiquetage est appliqu´ee sur une arˆete e dont les extr´emit´es
sont v et v
Si la r`egle S1(R) ou S2(R) est appliqu´ee `a l’´etape i + 1, alors statusi(v) = free et
puisque tous les arcs ajout´es `a A(Di) pour construire Di+1 sont incidents `a uv, on sait
que le graphe Di reste simple. On sait que les seuls voisins que ue peut avoir dans Di sont
uv et uv(cid:2). Si la r`egle S1(R) est appliqu´ee, alors puisque statusi(v) = statusi(v
(cid:2)) = free,
ue n’a pas de voisins dans Di et Di+1 ne contient donc pas de circuit. Si la r`egle S2(R)
est appliqu´ee alors on sait que (uv(cid:2), ue) ∈ A(Di) et par cons´equent, il n’existe aucun arc
(ue, uv(cid:2)(cid:2)) ∈ A(Di+1). Ainsi la propri´et´e (1) est v´eriﬁ´ee `a l’´etape i + 1. Si la r`egle S3(R),
S4(R) ou S5(R) est appliqu´ee `a l’´etape i + 1, on supprime des arcs de Di pour construire
Di+1 et la propri´et´e (1) est donc conserv´ee.
(cid:2)}, aucun
/∈ {v, v
(cid:2)(cid:2)
Quelle que soit la r`egle appliqu´ee `a l’´etape i + 1, pour tout sommet v
(cid:2)(cid:2)
(cid:2)(cid:2) n’est ajout´e ou supprim´e et les ´etiquettes des arˆetes e
(cid:2) incidentes `a v
arc incident `a v
ne sont pas modiﬁ´ees. Ainsi, les propri´et´es (6,7,8) sont conserv´ees pour tous les sommets
/∈ {v, v
(cid:2)(cid:2)
v
Si la r`egle S1(R) ou S2(R) est appliqu´ee lors de l’´etape i + 1, alors pour toute arˆete
(cid:12)= e, aucun arc (uv(cid:2)(cid:2) , ue(cid:2)) n’est ajout´e `a l’ensemble A(Di) pour construire Di+1. Par
(cid:2)
e
cons´equent, puisqu’aucun arc n’est supprim´e, les propri´et´es (2,3,4,5) sont conserv´ees pour
toutes les arˆetes e
(cid:2)) =
(cid:2) n’est ajout´e, la propri´et´e (6) est conserv´ee pour
free et puisqu’aucun arc incident `a v
(cid:2). Par ailleurs, on sait que uv est un sommet isol´e dans Di, qu’il n’existe aucun arc
v
(uv(cid:2)(cid:2) , ue) ∈ A(Di) , et que ri+1(e) = (λi+1(v), λi+1(e), λi+1(v
(cid:2)
2). Ainsi, de par la
construction de A(Di+1), la propri´et´e (3) est vraie pour e et la propri´et´e (7) est vraie pour
v.
(cid:2)) =
(cid:2)) = ask, statusi(v) = free et statusi+1(v) = statusi+1(e) = acc. Puis-
statusi+1(v
qu’aucun arc de Di n’est incident `a v, on sait que (uv(cid:2) , ue) ∈ A(Di). Par cons´equent, la
(cid:2). Par construction et puisqu’on peut
propri´et´e (7) est conserv´ee `a l’´etape i + 1 pour v
appliquer la r`egle S2(R), on sait aussi qu’`a l’´etape i + 1, la propri´et´e (4) est vraie pour e
et la propri´et´e (8) est vraie pour v.
Si la r`egle S3(R) est appliqu´ee lors de l’´etape i+1, alors statusi(v) = ask, statusi(e) =
(cid:2)) = acc, statusi+1(v) = free et statusi+1(e) = ack. Par
statusi(v
hypoth`ese de r´ecurrence, on sait que (uv, ue), (uv(cid:2) , ue) ∈ A(Di) et ainsi pour toute arˆete
(cid:2) (cid:12)= e, aucun arc (uv(cid:2)(cid:2) , ue(cid:2)) n’est supprim´e de l’ensemble A(Di) pour construire Di+1. Par
e
cons´equent, puisqu’aucun arc n’est ajout´e, les propri´et´es (2,3,4,5) sont conserv´ees pour
(cid:2) (cid:12)= e. De plus, puisqu’on supprime l’arc (uv, ue) et que la r`egle S3(R)
toutes les arˆetes e
peut ˆetre appliqu´ee, la propri´et´e (5) est vraie pour e et la propri´et´e (8) est vraie pour
(cid:2). Puisque tous les arcs incidents `a v sont supprim´es de A(Di) pour construire Di+1, la
v
propri´et´e (6) est vraie pour v.
(cid:2)) =
(cid:12)= e, on ne
statusi+1(v) = free et donc (uv, ue) ∈ A(Di). Ainsi, pour toute arˆete e
(cid:2)
supprime aucun arc (uv(cid:2)(cid:2) , ue(cid:2)) et puisque l’arc (uv, ue) est supprim´e, les propri´et´es (2,3,4,5)

Si la r`egle S2(R) est appliqu´ee lors de l’´etape i + 1, alors statusi(e) = statusi(v

Si la r`egle S4(R) ou la r`egle S5(R) est appliqu´ee, on a statusi(v

(cid:2)) = statusi+1(v

(cid:2)) = statusi+1(v

(cid:2)), (cid:8)

(cid:2)
1, (cid:8)

(cid:2)
e, (cid:8)

(cid:2)) = statusi+1(v

52

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

sont conserv´ees. Puisqu’on supprime tous les arcs incidents `a v dans Di, la propri´et´e (6)
est vraie pour v et v

(cid:2).

Par cons´equent, pour toute ´etape i, les propri´et´es (1,2,3,4,5,6,7,8) sont toujours vraies.

2

(cid:2)) (cid:12)= free, alors il existe un arc (uv(cid:2) , ue(cid:2)) ∈ A(D) et e

On peut donc montrer facilement que dans toute conﬁguration ﬁnale de l’algorithme,
tous les sommets et toutes les arˆetes ont le statut free, i.e., l’algorithme de simulation ne
cr´ee pas d’inter-blocage.
Lemme 3.15 Dans toute conﬁguration ﬁnale de S(R) sur G, pour tout x ∈ V (G)∪E(G),
status(x) = free
Preuve : On consid`ere une conﬁguration ﬁnale de S(R) sur G et on note D le graphe
orient´e associ´e. On suppose qu’il existe un sommet ou une arˆete dont le statut est diﬀ´erent
de free. D’apr`es le Lemme 3.14, puisque D ne contient pas de circuit, on sait qu’il existe une
arˆete e ∈ E(G) telle que status(e) (cid:12)= free et telle qu’il n’existe pas d’arc (ue, uv) ∈ A(D).
Si status(e) = ask, alors d’apr`es le Lemme 3.14, il existe v ∈ ext(e) tel que (uv, ue) ∈
(cid:2) l’autre extr´emit´e de
A(D), status(v) = ask et ri(e) = (λ(v), λ(e), (cid:8)2, (cid:8)
(cid:2) (cid:12)= e puisque (uv, ue) ∈
e. Si status(v
A(D) et qu’il existe exactement un arc (uv(cid:2)(cid:2) , ue) ∈ A(D). Mais d’apr`es le Lemme 3.14, si
(cid:2), alors (ue(cid:2)(cid:2), uv(cid:2)) ∈ A(D). Cela
(uv(cid:2) , ue(cid:2)) ∈ A(D), alors pour tout e
implique alors que (ue, uv(cid:2)) ∈ A(D), ce qui est impossible de par notre choix de e. Par
cons´equent, si λ(v) = (cid:8)2, on peut appliquer la r`egle S2(R) sur e et sinon, on peut appliquer
la r`egle S5(R) sur e. Dans les deux cas, l’ex´ecution de S(R) n’est pas termin´ee.
(cid:2) ∈ ext(e) tels que
(cid:2)
1, λ(e), λ(v)). Par cons´equent,
Si status(e) = ack, alors d’apr`es le Lemme 3.14, il existe v ∈ ext(e) tel que (uv, ue) ∈
(cid:2) l’autre extr´emit´e
A(D), status(v) = acc, et r(e) = ((cid:8)1, (cid:8)e, (cid:8)2, (cid:8)
(cid:2)) =
de e, on peut montrer comme pr´ec´edemment que de par notre choix de v, status(v
free. Par cons´equent, la r`egle S4(R) peut ˆetre appliqu´ee sur e et l’ex´ecution de S(R) n’est
pas termin´ee.
Ainsi, pour toute ex´ecution de S(R) qui termine, tous les sommets et toutes les arˆetes

status(v) = acc, statusi(v
la r`egle S3(R) peut ˆetre appliqu´ee sur e et l’ex´ecution de S(R) n’est pas termin´ee.

Si status(e) = acc, alors d’apr`es le Lemme 3.14, il existe v, v

(cid:2)
1, λ(e), λ(v)). Si on note v

(cid:2)) = ask et r(e) = (λ(v

(cid:2)), (cid:8)e, (cid:8)2, (cid:8)

(cid:2)
1, (cid:8)

(cid:2)
e, (cid:8)

(cid:2)
2). On note v

(cid:2)(cid:2) ∈ IG(v

(cid:2)), si e
(cid:2)(cid:2)

(cid:12)= e

ont le statut free dans la conﬁguration ﬁnale.

2

Dans les trois lemmes suivants, on montre que l’algorithme de simulation ne permet
de simuler que des r`egles de R. Dans le lemme suivant, on montre que si un sommet v a
le statut ask et qu’on peut appliquer la r`egle S2(R) ou S5(R) sur une arˆete e incidente `a
v, alors pr´ec´edemment la r`egle S1(R) a ´et´e appliqu´ee sur e et entre-temps l’´etiquette de v
n’a pas ´et´e modiﬁ´ee.
(cid:2). On consid`ere une
Lemme 3.16 On consid`ere une arˆete e dont les extr´emit´es sont v et v
´etape i1 +1 lors de laquelle, ou bien la r`egle S2(R) est appliqu´ee sur e et modiﬁe l’´etiquette
(cid:2), ou bien la r`egle S5(R) est appliqu´ee sur e et modiﬁe l’´etiquette de v. Soit i2 ≤ i1 la
de v
derni`ere ´etape lors de laquelle la r`egle S1(R) a ´et´e appliqu´ee sur e. Alors lors de l’´etape i2,
l’´etiquette de v a ´et´e modiﬁ´ee et pour tout i ∈ [i2, i1], statusi(v) = ask et λi(v) = λi2(v).
(cid:2)
Preuve : On consid`ere une arˆete e dont les extr´emit´es sont v1 et v
1. On consid`ere une
´etape i1 +1 lors de laquelle, ou bien la r`egle S2(R) est appliqu´ee sur e et modiﬁe l’´etiquette

3.4. Un R´esultat d’ ´Equivalence

53

1, ou bien la r`egle S5(R) est appliqu´ee sur e et modiﬁe l’´etiquette de v1. On sait que
(cid:2)
de v
statusi1(e) = ask et on consid`ere la derni`ere ´etape i2 ≤ i1 lors de laquelle la r`egle S1(R)
a ´et´e appliqu´ee sur e. On note v2 le sommet dont l’´etiquette a ´et´e modiﬁ´ee lors de l’´etape
i2 et on va montrer que pour tout i ∈ [i1, i2], statusi(v2) = ask et λi(v2) = λi2(v2) et que
v2 = v1.
On sait que (uv2 , ue) ∈ A(Di2) et que pour toute ´etape i ∈ [i2, i1], statusi(e) = ask et
donc il existe exactement un arc (uv, ue) ∈ A(Di). De plus, il n’existe aucune ´etape i lors
de laquelle, on ajoute ou on supprime un arc (uv(cid:2)(cid:2) , ue) de A(Di) pour construire Di+1. Par
cons´equent, aucune r`egle qui modiﬁe l’´etiquette de v2 n’a pu ˆetre appliqu´ee `a une ´etape
i ∈ [i2, i1]. Ainsi, pour toute ´etape i ∈ [i2, i1], (ue, uv2) ∈ A(Di), statusi(v2) = ask et
λi(v2) = λi2(v2). En particulier, on a (ue, uv2) ∈ A(Di1). Mais statusi1(v
(cid:2)
1) = free et donc
1) /∈ A(Di1). Puisque les seuls voisins de ue dans Di1 ne peuvent ˆetre que uv1 et uv(cid:2)
1,
(ue, uv(cid:2)
cela signiﬁe que v1 = v2.
2

Dans le lemme suivant, on montre que si on applique la r`egle S3(R) sur une arˆete e,
alors pr´ec´edemment la r`egle S2(R) a ´et´e appliqu´ee sur e et entre-temps, les ´etiquettes des
extr´emit´es de e n’ont pas ´et´e modiﬁ´ees.
(cid:2). On consid`ere une
Lemme 3.17 On consid`ere une arˆete e dont les extr´emit´es sont v et v
´etape i1 + 1 lors de laquelle la r`egle S3(R) est appliqu´ee sur e et modiﬁe l’´etiquette de v
(cid:2).
Soit i2 ≤ i1 la derni`ere ´etape lors de laquelle la r`egle S2(R) a ´et´e appliqu´ee sur e. Alors
lors de l’´etape i2, l’´etiquette de v a ´et´e modiﬁ´ee et pour tout i ∈ [i2, i1], statusi(v) = ask,
statusi(v

(cid:2)) = acc, λi(v) = λi2(v) et λi(v

(cid:2)) = λi2(v

(cid:2)).

(cid:2)
1. On consid`ere une
Preuve : On consid`ere une arˆete e dont les extr´emit´es sont v1 et v
´etape i1 + 1 lors de laquelle la r`egle S3(R) est appliqu´ee sur e et modiﬁe l’´etiquette de v
(cid:2)
1.
On sait que statusi1(e) = acc et on consid`ere la derni`ere ´etape i2 ≤ i1 lors de laquelle
la r`egle S2(R) a ´et´e appliqu´ee sur e. On note v2 le sommet dont l’´etiquette a ´et´e modiﬁ´ee
(cid:2)
2 l’autre extr´emit´e de e. On va montrer qu’aucune r`egle n’a pu
lors de l’´etape i2 et v
modiﬁer les ´etiquettes de v2 et de v
(cid:2)) =
acc et que pour toute ´etape i ∈ [i2, i1], statusi(e) = acc. Ainsi, d’apr`es le Lemme 3.14,
2 , ue) ∈ A(Di). Si une r`egle est appliqu´ee
pour tout i ∈ [i2, i1], on sait que (uv2, ue), (uv(cid:2)
2} lors d’une ´etape i ∈ [i2, i1], alors statusi(v) =
et modiﬁe l’´etiquette de v ∈ {v2, v
(cid:2)
free et (ue, uv) /∈ A(Di), ce qui est impossible. Par cons´equent, pour tout i ∈ [i1, i2],
(cid:2)
2) et on a donc
statusi(v2) = ask, statusi(v
v1 = v2 et v
2

2 , ue) ∈ A(Di2), que statusi2(v) = ask, que statusi2(v

(cid:2)
2) = acc, λi(v2) = λi2(v2) et λi(v

(cid:2)
2 et que v1 = v2 et v

On sait que (uv2 , ue), (uv(cid:2)

(cid:2)
2) = λi2(v

(cid:2)
1 = v

(cid:2)
2.

(cid:2)
1 = v

(cid:2)
2.

Dans le lemme suivant, on montre que si la r`egle S4(R) est appliqu´ee sur une arˆete e
dont une extr´emit´e v a le statut acc, alors pr´ec´edemment la r`egle S3(R) a ´et´e appliqu´ee
sur e et entre-temps, l’´etiquette de v n’a pas ´et´e modiﬁ´ee.
(cid:2). On consid`ere une
Lemme 3.18 On consid`ere une arˆete e dont les extr´emit´es sont v et v
´etape i1 + 1 lors de laquelle la r`egle S4(R) est appliqu´ee sur e et modiﬁe l’´etiquette de v.
Soit i2 ≤ i1 la derni`ere ´etape lors de laquelle la r`egle S3(R) a ´et´e appliqu´ee sur e. Alors
(cid:2) a ´et´e modiﬁ´ee et pour tout i ∈ [i2, i1], statusi(v) = acc,
lors de l’´etape i2, l’´etiquette de v
et λi(v) = λi2(v).

Preuve : On consid`ere une arˆete e dont les extr´emit´es sont v1 et v

(cid:2)
1. On consid`ere

54

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

une ´etape i1 + 1 lors de laquelle la r`egle S4(R) est appliqu´ee sur e et modiﬁe l’´etiquette
de v1. On sait que statusi1(e) = ack, que statusi1(v1) = acc et que statusi1(v1) =
1) = statusi1+1(v1) = free. On consid`ere la derni`ere ´etape i2 ≤ i1 lors de
(cid:2)
statusi1+1(v
laquelle la r`egle S3(R) a ´et´e appliqu´ee sur e. On note v
(cid:2)
2 le sommet dont l’´etiquette a ´et´e
modiﬁ´ee lors de l’´etape i2 et v2 l’autre extr´emit´e de e. On sait que statusi2(v2) = acc et
(cid:2)
2) = free. On va montrer qu’aucune r`egle n’a pu modiﬁer l’´etiquette de v2 et
statusi2(v
que v1 = v2.
On sait que (ue, uv2) ∈ A(Di2) et que pour toute ´etape i ∈ [i2, i1], statusi(e) = ack
et donc il existe exactement un arc (uv, ue) ∈ A(Di). Si une r`egle est appliqu´ee et modiﬁe
l’´etiquette de v2 lors d’une ´etape i ∈ [i2, i1], alors statusi(v2) = free et (uv2, ue) /∈ A(Di).
Mais puisque (uv2, ue) ∈ A(Di−1), cela signiﬁe qu’il n’existe pas d’arc (uv, ue) ∈ A(Di),
ce qui est impossible. Par cons´equent, pour tout i ∈ [i1, i2], statusi(v2) = acc, λi(v2) =
λi2(v2) et on a donc v1 = v2.

2

On montre dans le lemme suivant que la r`egle S1(R) ne peut pas ˆetre appliqu´ee inﬁ-

niment souvent sans que les r`egles S2(R),S3(R) soient appliqu´ees.
Lemme 3.19 Pour toute ex´ecution de S(R) sur G, si la r`egle S1(R) est appliqu´ee |V (G)|
+ 1 fois entre deux ´etapes i1 et i2, alors il existe une ´etape i ∈ [i1, i2] lors de laquelle la
r`egle S2(R) (resp. S3(R)) a ´et´e appliqu´ee.
Preuve : L’´etiquette λ(v) d’un sommet v ∈ V (G) ne peut ˆetre modiﬁ´ee que si l’une des
r`egles S2(R),S3(R) est appliqu´ee sur v.
Puisque la r`egle S1(R) est appliqu´ee |V (G)| + 1 fois entre deux ´etapes i1 et i2, alors il
existe un sommet v et deux ´etapes j1 < j2 entre i1 et i2 tels que la r`egle S1(R) modiﬁe
deux fois l’´etiquette de v. On note e l’arˆete sur laquelle la r`egle S1(R) est appliqu´ee lors
(cid:2) l’extr´emit´e de e diﬀ´erente de v. Si la r`egle S1(R) peut ˆetre appliqu´ee
de l’´etape j1 et v
lors de l’´etape j2, cela signiﬁe que la r`egle S3(R) ou S5(R) a ´et´e appliqu´ee entre les ´etapes
j1 et j2 et l’application de cette r`egle a modiﬁ´ee l’´etiquette de v.
Si la r`egle S3(R) est appliqu´ee lors d’une ´etape j ∈ [j1, j2] et que l’´etiquette de v est
modiﬁ´ee lors de cette ´etape j, on sait d’apr`es les Lemmes 3.16 et 3.17 que la r`egle S2(R)
(cid:2) a ´et´e modiﬁ´ee lors de
a ´et´e appliqu´ee lors d’une ´etape j
cette ´etape.
Si la r`egle S5(R) est appliqu´ee lors d’une ´etape j ∈ [j1, j2] et que l’´etiquette de v est
(cid:2) a ´et´e
modiﬁ´ee lors de cette ´etape j, on sait d’apr`es le Lemme 3.16 que l’´etiquette de v
modiﬁ´ee entre-temps et donc, une des r`egles S2(R),S3(R) a ´et´e appliqu´ee lors d’une ´etape
(cid:2) ∈ [j1, j] et a modiﬁ´ee l’´etiquette de v
j
(cid:2), puisque
, j] lors de laquelle la r`egle S4(R) a ´et´e
statusj(v
(cid:2). D’apr`es les Lemmes 3.17 et 3.18, la r`egle S3(R) a
appliqu´ee et a modiﬁ´e l’´etiquette de v
(cid:2)(cid:2)(cid:2) ∈ [j
(cid:2)
donc ´et´e appliqu´ee `a une ´etape j
, j
(cid:2), alors
(cid:2) et a modiﬁ´e l’´etiquette de v
d’apr`es les Lemmes 3.16 et3.17, on sait que la r`egle S1(R) a ´et´e appliqu´ee sur une arˆete
(cid:2) a ´et´e modiﬁ´ee lors de cette ´etape.
(cid:2) lors d’une ´etape j
e
De plus, on sait aussi que la r`egle S2(R) a du ˆetre appliqu´ee lors d’une ´etape j
(cid:2)]
, j
(cid:2).
sur l’arˆete e
Ainsi, si la r`egle S1(R) est appliqu´ee |V (G)| + 1 fois entre deux ´etapes i1 et i2, alors

Si la r`egle S3(R) a ´et´e appliqu´ee lors de l’´etape j
(cid:2)] et que l’´etiquette de v

(cid:2) ∈ [j1, j] et que l’´etiquette de v

Si la r`egle S2(R) a ´et´e appliqu´ee lors de l’´etape j

(cid:2).
(cid:2)) = free, il existe une ´etape j

(cid:2)

(cid:2)(cid:2) ∈ [j1, j

(cid:2) et a modiﬁ´e l’´etiquette de v

(cid:2)(cid:2) ∈ [j
(cid:2)(cid:2)].

(cid:2)(cid:2)(cid:2) ∈ [j

(cid:2)(cid:2)

3.4. Un R´esultat d’ ´Equivalence

les deux r`egles S2(R) et S3(R) sont appliqu´ees entre les ´etapes i1 et i2.

55

2

(cid:2) a ´et´e modiﬁ´ee lors de l’´etape ij et que rij(e) = ((cid:8)1, (cid:8)e, (cid:8)2, (cid:8)

(cid:2)
1, (cid:8)

(cid:2)
e, (cid:8)

Dans la proposition suivante, on montre que l’algorithme S(R) simule l’algorithme R,
ce qui prouve l’´equivalence entre les calculs locaux cellulaires sur les arˆetes ´etiquet´ees et
les calculs locaux sur les arˆetes ´etiquet´ees.
Proposition 3.20 Pour tout algorithme R utilisant des calculs locaux sur les arˆetes
´etiquet´ees, l’algorithme S(R) utilise des calculs locaux cellulaires sur les arˆetes ´etiquet´ees
et simule l’algorithme R.
Preuve : On consid`ere la fonction π telle que π(((cid:8), status)) = (cid:8) et π(((cid:8), status, r)) = (cid:8).
On veut montrer que pour tout graphe G telle que toute ex´ecution de R sur G termine,
S(R) simule R sur G `a travers π.
´Etant donn´ee une ex´ecution ρ de S(R) sur G, on va construire une ex´ecution valide
(cid:2) de R sur G. Par la suite, pour tout sommet v ∈ V (G) (resp. toute arˆete e ∈ E(G)),
ρ
(λi(v), statusi(v)) (resp. (λi(e), statusi(e), ri(e))) est l’´etiquette de v apr`es la i`eme ´etape
de l’ex´ecution ρ de S(R) sur G et λ
(cid:2)
(cid:2)
j(v) (resp. λ
j(e)) est l’´etiquette de v apr`es la j`eme
(cid:2) de R sur G.
´etape de l’ex´ecution ρ
On note i1, i2, . . . , ip, . . . les ´etapes de ρ o`u la r`egle S3(R) est appliqu´ee. L’ex´ecution ρ
(cid:2)
de R est l’ex´ecution construite de la mani`ere suivante. On consid`ere l’arˆete e sur laquelle la
r`egle S3(R) a ´et´e appliqu´ee lors de l’´etape ij de ρ. On note v et v
(cid:2) les extr´emit´es de e, on sup-
(cid:2)
2).
pose que l’´etiquette de v
(cid:2) de R sur G est alors le r´e´etiquetage de l’arˆete de
Le j`eme pas de calcul de l’ex´ecution ρ
(cid:2)
(cid:2)
(cid:2)) = (cid:8)
(cid:2)
1, λ
j(v
e.
la mani`ere suivante : λ
(cid:2)) a le
> ij) de ρ o`u v (resp. v
(cid:2)
statut free, on sait d’apr`es les Lemmes 3.16, 3.17 et 3.18 que λi(v) = (cid:8)1 et λi(e) = (cid:8)
(cid:2) de R ainsi construite est une
e
(resp. λi(cid:2)(v
ex´ecution valide. Par ailleurs, on note que pour toute ´etape i ∈ [ij, ij+1 − 1] o`u pour tout
x ∈ V (G) ∪ E(G), statusij (x) = free, alors pour tout x ∈ V (G) ∪ E(G), λi(x) = λ
(cid:2)
j(x),
De plus, si l’´etiquette λ(v) d’un sommet v est modiﬁ´ee, une des r`egles S2(R),S3(R)
est appliqu´ee sur une arˆete incidente `a v. On sait d’apr`es les Lemmes 3.16, 3.17 et 3.18
que si la r`egle S2(R) est appliqu´ee sur une arˆete e dont les extr´emit´es sont v et v
(cid:2), les
(cid:2))) ne peuvent ˆetre modiﬁ´ees que si la r`egle
´etiquettes (λ(v), status(v)) et (λ(v
S3(R) est appliqu´ee. Ainsi, si l’´etiquette de v est modiﬁ´ee par une application de la r`egle
S2(R), ou bien la r`egle de R simul´ee sur l’arˆete e apparaˆıtra dans ρ
(cid:2), ou alors l’ex´ecution
(cid:2) est inﬁnie.
ρ
Par ailleurs, si l’ex´ecution ρ est inﬁnie, alors la r`egle S1(R) est appliqu´ee inﬁniment
souvent, et d’apr`es le Lemme 3.19, on sait que la r`egle S3(R) est appliqu´ee inﬁniment
(cid:2) est donc inﬁnie, ce qui est impossible puisque toute ex´ecution de
souvent, et l’ex´ecution ρ
R termine sur G.
De plus, dans la conﬁguration ﬁnale, on sait d’apr`es le Lemme 3.15 que pour tout
sommet v ∈ V (G) (resp. toute arˆete e ∈ E(G)), status(v) = free (resp. status(e) =
free). Ainsi, si aucune r`egle de S(R) ne peut ˆetre appliqu´ee dans la conﬁguration ﬁnale
de ρ, alors aucune r`egle de R ne peut ˆetre appliqu´ee dans la conﬁguration ﬁnale de ρ
(cid:2). Par
cons´equent, S(R) simule R sur G `a travers la projection π.

(cid:2)
(cid:2)
j(e) = (cid:8)
2 et λ
(cid:2)
Si on consid`ere la premi`ere ´etape i > ij (resp. i

(cid:2)
e). Ainsi, l’ex´ecution ρ

(cid:2)) = (cid:8)2 et λi(cid:2)(e) = (cid:8)

On montre dans la proposition suivante que si l’algorithme R r´esout un probl`eme avec
d´etection de la terminaison, alors l’algorithme S(R) permet aussi de r´esoudre ce probl`eme

2

(cid:2)
j(v) = (cid:8)

(cid:2)), status(v

56

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

– Pour toute ex´ecution ρ

f}.
(cid:2)

(cid:2) lors de laquelle λ

(cid:2)
f , alors pour tout j

(cid:2)

> j, res(cid:2) ◦ λ
j(cid:2) = res(cid:2) ◦ λ
(cid:2)
(cid:2)
j.

avec d´etection de la terminaison.
Proposition 3.21 Pour tout algorithme R utilisant des calculs locaux sur les arˆetes
´etiquet´ees, si l’algorithme R r´esout un probl`eme P sur une famille de graphes F avec
d´etection de la terminaison, alors l’algorithme S(R) utilise des calculs locaux cellulaires
sur les arˆetes ´etiquet´ees et r´esout le probl`eme P sur la famille F avec d´etection de la
terminaison.
Preuve : On suppose que l’algorithme R permet de r´esoudre un probl`eme P sur une
famille de graphes F avec d´etection de la terminaison. Il existe donc une fonction res(cid:2) et
(cid:2)
f tels que les propri´et´es suivantes sont toujours v´eriﬁ´ees pour tout graphe
un ensemble L
G ∈ F.

(cid:2)
f .
j(v) ∈ L
(cid:2)
telle que λ

(cid:2) de R sur G termine et l’´etiquetage ﬁnal λ
– Toute ex´ecution ρ
l’´etiquetage res(cid:2) ◦ λ
ρ(cid:2) est une solution de P sur G.
(cid:2)
j(v) ∈ L
(cid:2)
λ

(cid:2)
ρ(cid:2) de G est tel que
(cid:2) de R sur G, il existe un sommet v et une ´etape j tels que
(cid:2) de R sur G, s’il existe un sommet v ∈ V (G) et une ´etape j
– Pour toute ex´ecution ρ
On veut montrer que l’algorithme S(R) permet aussi de r´esoudre le probl`eme P sur F
avec d´etection de la terminaison. Pour cela, il faut d´eﬁnir une fonction res et un ensemble
Lf . La fonction res qu’on va consid´erer est res(cid:2) ◦ π, o`u π est telle que π(((cid:8), status)) = (cid:8)
et π(((cid:8), status, r)) = (cid:8). L’ensemble Lf est l’ensemble {((cid:8), free) | (cid:8) ∈ L
D’apr`es la Proposition 3.20, on sait que pour tout graphe G ∈ F, toute ex´ecution de
S(R) termine sur G puisque toute ex´ecution de R termine sur G.
On consid`ere un graphe G ∈ F. Pour toute ex´ecution ρ de S(R) sur G, on consid`ere
(cid:2) de R sur G que dans la preuve de la Proposition 3.20. On sait qu’il
la mˆeme ex´ecution ρ
j(v) (cid:12)= λ
(cid:2)
(cid:2)
j−1(v).
existe une ´etape j de ρ
On note e ∈ E(G) l’arˆete sur laquelle un pas de r´e´etiquetage est eﬀectu´e lors de l’´etape j
(cid:2). On sait que v ∈ ext(e) et d’apr`es les Lemmes 3.16, 3.17 et 3.18, il existe
de l’ex´ecution ρ
j(v) ∈ L
(cid:2)
(cid:2)
f et statusi(v) = free. Par cons´equent, il
une ´etape i > ij telle que λi(v) = λ
existe une ´etape i de l’ex´ecution ρ et un sommet v tels que (λi(v), statusi(v)) ∈ Lf .
On consid`ere maintenant un sommet v ∈ V (G) et une ´etape i de ρ telle que λi(v) ∈
f . On suppose que (λi(v), statusi(v)) (cid:12)= (λi−1(v), statusi−1(v)). On consid`ere l’arˆete
(cid:2)
L
e ∈ E(G) sur laquelle un pas de r´e´etiquetage est eﬀectu´e lors de l’´etape i de l’ex´ecution
ρ. On sait que v ∈ ext(e) et qu’une des deux r`egles S3(R),S4(R) a ´et´e appliqu´ee lors de
(cid:2) ≤ i lors de laquelle la r`egle
l’´etape i. D’apr`es les Lemmes 3.17 et 3.18, il existe une ´etape i
S3(R) a ´et´e appliqu´ee sur e. Il existe donc une ´etape j ∈ ρ
(cid:2) = ij et d’apr`es
(cid:2) telle que i
(cid:2)
(cid:2) l’autre extr´emit´e de e,
les Lemmes 3.17 et 3.18, on sait que λi(v) = λ
j(v). Si on note v
(cid:2)) d’apr`es les Lemmes 3.17 et 3.18. On sait que pour toute
on sait aussi que λi(v
> j, et pour tout x ∈ V (G) ∪ E(G), res(cid:2)(λ
(cid:2)
(cid:2)
j(cid:2)(x)) = res(cid:2)(λ
j(x)).
´etape j
Pour tout e ∈ E(G), si λij(e) (cid:12)= λ
j(e), cela signiﬁe que la r`egle S2(R) a ´et´e appliqu´ee
(cid:2)
sur e avant l’´etape ij et que la r`egle S3(R) n’a pas encore ´et´e appliqu´ee sur e. Cependant,
(cid:2)
l’ex´ecution ρ est ﬁnie et d’apr`es les Lemmes 3.15 et 3.17, il existe donc une ´etape i
> ij
lors de laquelle la r`egle S3(R) est appliqu´ee sur e. Par cons´equent, il existe une ´etape
(cid:2) = ij(cid:2). Ainsi res(λi(cid:2)(e)) = res(cid:2)(λ
(cid:2)
(cid:2)
j(cid:2)(e)) = res(cid:2)(λ
(cid:2)
> j telle que i
j(e)) = res(λij (e)).
j
Pour tout sommet v ∈ V (G), si λij (v) (cid:12)= λ
j(v), cela signiﬁe que la r`egle S2(R) a
(cid:2)
´et´e appliqu´ee sur une arˆete e incidente `a v avant l’´etape ij et que la r`egle S3(R) n’a

j(v) ∈ L
(cid:2)

(cid:2)
f et on suppose que λ

(cid:2)

(cid:2)
(cid:2)) = λ
j(v

3.5. ´Enum´eration, Nommage et ´Election

57

Pour toute ´etape i

(cid:2) sur e. Pour toute ´etape i

pas encore ´et´e appliqu´ee sur e. Cependant, comme pr´ec´edemment, on peut montrer que
res(λi(cid:2)(v)) = res(λij (v)).
(cid:2) ≥ i et toute arˆete e ∈ E(G) tel que λi(cid:2)+1(e) (cid:12)= λi(cid:2)(e), cela signiﬁe
(cid:2) ≥ i et tout sommet
que la r`egle S2(R) a ´et´e appliqu´ee `a l’´etape i
v ∈ V (G) tel que λi(cid:2)+1(v) (cid:12)= λi(cid:2)(v), cela signiﬁe qu’une des r`egles S2(R),S3(R) a ´et´e
(cid:2) sur une arˆete e incidente `a v. Si la r`egle S2(R) a ´et´e appliqu´ee `a l’´etape
appliqu´ee `a l’´etape i
(cid:2) lors de laquelle la r`egle S3(R) est
(cid:2) sur une arˆete e, on sait qu’il existe une ´etape i
(cid:2)(cid:2)
i
(cid:2) lors
appliqu´ee sur l’arˆete e. Par cons´equent, dans les deux cas, il existe une ´etape j
(cid:2) de ρ est appliqu´ee sur e. Par cons´equent,
de laquelle la r`egle simul´ee sur l’arˆete e `a l’´etape i
pour tout x ∈ {e} ∪ ext(e), res(λi(cid:2)(x)) = res(cid:2)(λ
(cid:2)
(cid:2)
j(cid:2)(x)) = res(cid:2)(λ
j(x)) = res(λij (x)).
Ainsi, si l’algorithme R permet de r´esoudre P sur la famille F, l’algorithme S(R)
r´esout aussi P sur la famille F.

2

> i

(cid:2)

> j de ρ

On a donc montr´e qu’on pouvait transformer tout algorithme utilisant des calculs
locaux sur les arˆetes ´etiquet´ees en un algorithme utilisant des calculs locaux cellulaires sur
les arˆetes ´etiquet´ees, au sens o`u l’´etiquetage ﬁnal d’un graphe obtenu par toute ex´ecution
du nouvel algorithme sur ce graphe est un ´etiquetage ﬁnal du graphe qui peut ˆetre obtenu
par une ex´ecution de l’algorithme initial. De plus, on a montr´e que la transformation
permettait de conserver la propri´et´e de d´etection de la terminaison.

3.5

´Enum´eration, Nommage et ´Election

On s’int´eresse aux probl`emes d’´election, d’´enum´eration et du nommage dans le cadre
des calculs locaux sur les arˆetes ´etiquet´ees. On montre d’abord que le r´esultat d’impos-
sibilit´e d’Angluin [Ang80] reste valide dans ces mod`eles : il est impossible de trouver un
algorithme d’´election, d’´enum´eration ou de nommage pour un graphe G qui n’est pas
minimal pour les revˆetements. On donne ensuite un algorithme d’´enum´eration pour les
graphes minimaux pour les revˆetements qui est inspir´e de l’algorithme de Mazurkiewicz
[Maz97].

3.5.1 R´esultats d’Impossibilit´e pour l’´Enum´eration et le Nommage
Proposition 3.22 ([Ang80]) Soit G un graphe simple ´etiquet´e qui n’est pas minimal
pour les revˆetements. Il n’existe pas d’algorithme d’´election, d’´enum´eration ou de nommage
pour le graphe G utilisant des calculs locaux sur les arˆetes ´etiquet´ees.

Preuve : Soit H un graphe ´etiquet´e non-isomorphe `a G et tel qu’il existe un homomor-
phisme localement bijectif γ de G dans H. ´Etant donn´e un algorithme R utilisant des
calculs locaux cellulaires sur les arˆetes ´etiquet´ees, on consid`ere une ex´ecution de R sur H.
Si cette ex´ecution est inﬁnie sur H, alors d’apr`es le Lemme 3.11, il existe une ex´ecution
inﬁnie de R sur G ; auquel cas, R n’est ni un algorithme d’´enum´eration, ni de nommage,
ni d’´election.
On suppose maintenant qu’il existe une ex´ecution ﬁnie de R sur H et on consid`ere la
conﬁguration ﬁnale H(cid:2). D’apr`es le Lemme 3.11, il existe une ex´ecution de R sur G qui
permet d’atteindre une conﬁguration G(cid:2) telle que G(cid:2) est un revˆetement de H(cid:2) `a travers γ.
Si G(cid:2) n’est pas une conﬁguration ﬁnale de R, alors il existe une arˆete e ∈ E(G) telle qu’on
puisse appliquer une r`egle de r´e´etiquetage sur l’arˆete e. Dans ce cas l`a, on peut appliquer

58

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

la mˆeme r`egle dans H(cid:2) sur l’arˆete γ(e), ce qui est impossible. Par cons´equent, G(cid:2) est une
conﬁguration ﬁnale de R. Mais puisque G(cid:2) n’est pas isomorphe `a H(cid:2), cela implique d’apr`es
la Proposition 3.5 que chaque ´etiquette apparaissant sur un sommet de H(cid:2) apparaˆıt au
moins deux fois dans G(cid:2). Par cons´equent, R ne permet ni d’attribuer de noms distincts `a
tous les sommets de G, ni de distinguer un sommet. Ainsi R ne r´esout ni le nommage, ni
l’´enum´eration, ni l’´election sur G.

2

3.5.2 Un Algorithme d’´Enum´eration

On va maintenant d´ecrire un algorithme d’´enum´eration M pour les graphes minimaux

pour les revˆetements. Cet algorithme s’inspire de l’algorithme de Mazurkiewicz.
Durant l’ex´ecution de l’algorithme, chaque sommet v essaie d’obtenir une identit´e qui
est un num´ero entre 1 et |V (G)|. Chaque sommet va ensuite ´echanger son num´ero avec ses
voisins. Un num´ero p va ˆetre associ´e `a chaque arˆete de telle sorte que deux arˆetes incidentes
`a un mˆeme sommet aient des num´eros diﬀ´erents. Grˆace `a ces ´echanges de num´eros, chaque
(cid:2) de v, la vue locale de
sommet peut construire sa vue locale, telle que pour chaque voisin v
(cid:2), λ(e) est
v contient le triplet (p, λ(e), n) o`u p est le num´ero donn´e `a l’arˆete e reliant v `a v
(cid:2) lors de la derni`ere synchronisation
l’´etiquette initiale de e et n est le num´ero qu’avait v
(cid:2). Ensuite, chaque sommet va diﬀuser dans tout le graphe son num´ero et sa vue
entre v et v
locale. Si un sommet u d´ecouvre qu’un autre sommet v a le mˆeme num´ero que lui, alors le
sommet u doit d´ecider s’il modiﬁe son identit´e. Pour cela, il compare son ´etiquette initiale
λ(u) et sa vue locale avec l’´etiquette initiale λ(v) et la vue locale de v : si l’´etiquette
de u est plus faible que l’´etiquette de v ou si les deux sommets ont la mˆeme ´etiquette
et que la vue locale de u est plus «faible» (pour un ordre proche de l’ordre utilis´e dans
l’algorithme de Mazurkiewicz), alors le sommet u choisit un nouveau num´ero (sa nouvelle
identit´e temporaire) et le diﬀuse `a nouveau avec sa vue locale. Lorsque l’ex´ecution est
termin´ee, si le graphe G est minimal pour les revˆetements, alors chaque sommet a un
num´ero unique : l’algorithme permet de r´esoudre le probl`eme du nommage.

´Etiquettes

On consid`ere un graphe G = (G, λ) o`u λ: V (G) ∪ E(G) → L est un ´etiquetage initial,
qui ne sera pas modiﬁ´e par l’algorithme. Lors de l’ex´ecution, chaque arˆete e va obtenir
une ´etiquette de la forme (λ(e), p(e)) qui repr´esente les informations suivantes :

– la premi`ere composante λ(e) est l’´etiquette initiale et ne sera pas modiﬁ´ee lors de
l’ex´ecution.
– p(e) ∈ N est un entier associ´e `a chaque arˆete de telle sorte que deux arˆetes e et
(cid:2) incidentes `a un mˆeme sommet vont avoir des num´eros non-nuls distincts. Cette
e
valeur sera ﬁx´ee par une r`egle de r´e´etiquetage sur e et ne sera plus modiﬁ´ee par la
suite.

Initialement, chaque arˆete e est ´etiquet´e (λ(e), 0) puisqu’aucun num´ero n’a encore ´et´e
attribu´e `a e.

Lors de l’ex´ecution, chaque sommet va obtenir une ´etiquette de la forme (λ(v), n(v),

N(v), M(v)) qui repr´esente les informations suivantes :

– la premi`ere composante λ(v) est l’´etiquette initiale et ne sera pas modiﬁ´ee lors de

l’ex´ecution.

3.5. ´Enum´eration, Nommage et ´Election

59

l’algorithme,

– n(v) ∈ N est le num´ero courant du sommet v qui est modiﬁ´e lors de l’ex´ecution de
– N(v) ∈ Pﬁn(N × L × N) est la vue locale du sommet v. Informellement, la vue
locale contient l’information la plus r´ecente que v a de ses voisins. Si le sommet
(cid:2), un pas de
v est incident `a une arˆete e dont l’autre extr´emit´e est un sommet v
(cid:2))) `a la vue locale
r´e´etiquetage sur e va permettre d’ajouter le triplet (p(e), λ(e), n(v
de v. Ainsi N(v) est toujours un ensemble ﬁni de triplets de N × L × N.
– M(v) ⊆ N × L × Pﬁn(N × L × N) est la boˆıte-aux-lettres de v. Elle va contenir
toute l’information re¸cue par v lors de l’ex´ecution de l’algorithme, i.e., les couples de
num´eros et de vues locales qui auront ´et´e diﬀus´ees par tous les sommets du graphe.
Initialement, chaque sommet a une ´etiquette de la forme (λ(v), 0,∅,∅) qui signiﬁe qu’au
d´ebut de l’algorithme, v n’a pas choisi de num´ero et qu’il n’a aucune information `a propos
de ses voisins, ni `a propos des autres sommets du graphe.

La diﬀ´erence principale entre les ´etiquettes utilis´ees ici et les ´etiquettes utilis´es dans
l’algorithme de Mazurkiewicz est la pr´esence de num´eros sur les arˆetes. Dans l’algorithme
de Mazurkiewicz, les voisins d’un sommet qui ont des num´eros non-nuls ont toujours des
num´eros diﬀ´erents, ce qui permet `a tout sommet de distinguer ses voisins. Les num´eros
associ´es aux arˆetes vont permettre ici `a chaque sommet de distinguer ses voisins.

Un Ordre sur les Vues Locales

(cid:2)

(cid:2)

, (cid:8)

, n

(cid:2)) si p < p

(cid:2), ou si p = p

Comme pour l’algorithme de Mazurkiewicz [Maz97], les bonnes propri´et´es de l’algo-
rithme reposent sur un ordre sur les vues locales, i.e., sur les ensembles ﬁnis de triplets
de N × L × N. Pour cela, on consid`ere que N × L × N est muni de l’ordre lexicographique
(cid:2) et n < n
(cid:2).
usuel : (p, (cid:8), n) < (p
Ensuite, on utilise le mˆeme ordre sur les ensembles que Mazurkiewicz : ´etant donn´es
deux ensembles N1, N2 ∈ Pﬁn(N × L × N) distincts, on dit que N1 ≺ N2 si le maximum
pour l’ordre lexicographique sur N × L × N de la diﬀ´erence sym´etrique N1 (cid:17) N2 = (N1 \
N2) ∪ (N2 \ N1) appartient `a N2.
Si N(u) ≺ N(v), alors on dit que la vue locale N(v) de v est plus forte que celle de u
et que N(u) est plus faible que N(v). En utilisant l’ordre total <L de L, on ´etend l’ordre
≺ pour obtenir un ordre total sur L×Pﬁn(N× L× N) : ((cid:8), N) ≺ ((cid:8)
(cid:2) ou bien
si (cid:8) = (cid:8)

, N
(cid:2). Par la suite, on notera (cid:19) la clˆoture r´eﬂexive de ≺.

(cid:2) et N ≺ N

(cid:2) et (cid:8) <L (cid:8)

(cid:2), ou si p = p

(cid:2), (cid:8) = (cid:8)

(cid:2)) si (cid:8) <L (cid:8)

(cid:2)

Les R`egles de R´e´etiquetage

On d´ecrit maintenant l’algorithme d’´enum´eration grˆace `a des r`egles de r´e´etiquetage. Il
y a deux r`egles sp´eciales M0 et M(cid:2)
0 qui permettent d’initialiser l’´etiquetage. La r`egle M0
permet `a chaque sommet de modiﬁer son ´etiquette initiale λ(v) pour obtenir l’´etiquette
(λ(v), 0,∅,∅). La r`egle M(cid:2)
0 permet de modiﬁer l’´etiquette λ(e) d’une arˆete e qui de-
vient l’´etiquette (λ(e), 0). Cette r`egle est applicable quelles que soient les ´etiquettes des
extr´emit´es de e.
Les deux premi`eres r`egles M1 et M2 sont proches des deux r`egles de l’algorithme de
(cid:2) de partager les
Mazurkiewicz. La premi`ere r`egle permet `a deux sommets voisins v et v
informations contenues dans leurs boˆıtes-aux-lettres `a propos des ´etiquettes apparaissant
dans le graphe.

60

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

M1 :
((cid:8)1, n1, N1, M1)
M1 (cid:12)= M2
1 ∪ M
(cid:2)
(cid:2) := M
(cid:2)
2.

Si
alors M

((cid:8)e, p)

((cid:8)2, n2, N2, M2)

((cid:8)1, n1, N1, M

(cid:2))

((cid:8)e, p)

((cid:8)2, n2, N2, M

(cid:2))

Les r`egles M2 et M3 permettent `a un sommet v de modiﬁer son num´ero s’il existe un
autre sommet dans le graphe qui a le mˆeme num´ero. La deuxi`eme r`egle ne d´epend que de
l’´etiquette d’un seul sommet v. Elle permet `a v de modiﬁer son num´ero si v n’a pas encore
choisi de num´ero (son num´ero courant est 0), ou si la boˆıte-aux-lettres de v contient un
message indiquant qu’il existe un autre sommet dans le graphe ayant le mˆeme num´ero que
v et qui a une ´etiquette sup´erieure `a celle de v ou qui a une vue locale plus forte que celle
de v.

M2 :

Si
alors

((cid:8), k, N, M

((cid:8), n, N, M)
(cid:2)) ∈ M tel que ((cid:8), N) ≺ ((cid:8)

(cid:2)

(cid:2))

, N

(cid:2))

n = 0 ou ∃(n, (cid:8)
(cid:2)
k := 1 + max{n
M

, N
(cid:2) | ∃(n
(cid:2)
, (cid:8)
(cid:2) := M ∪ {(k, (cid:8), N)}.

(cid:2)

(cid:2)) ∈ M} ;

, N

(cid:2)
La troisi`eme r`egle permet `a un sommet v de modiﬁer son num´ero s’il a un voisin v
(cid:2)), N(v
(cid:2)),
(cid:2))). Cette r`egle ne peut ˆetre appliqu´ee que si on ne peut pas appliquer la r`egle M2 `a

qui est exactement dans le mˆeme ´etat, i.e., (λ(v), n(v), N(v), M(v)) = (λ(v
M(v
v ou `a v

(cid:2)), n(v

(cid:2).

M3 :

((cid:8), n, N, M)

((cid:8)e, p)

((cid:8), n, N, M)

((cid:8), k, N, M

(cid:2))

((cid:8)e, p)

((cid:8), n, N, M

(cid:2))

Si

alors

(cid:2)

(cid:2)) ∈ M, ((cid:8)

n > 0 et
∀(n, (cid:8)
, N
k := 1 + max{n
M

(cid:2)) (cid:19) ((cid:8), N)
(cid:2)
, N
(cid:2) | ∃(n
(cid:2)
(cid:2)
, (cid:8)
, N
(cid:2) := M ∪ {(k, (cid:8), N)}.

(cid:2)) ∈ M} ;

(cid:2)
La quatri`eme r`egle peut ˆetre appliqu´ee sur une arˆete e dont les extr´emit´es sont v et v
si e n’a pas encore de num´ero, i.e., p(e) = 0. Un num´ero p est alors g´en´er´e de telle sorte
(cid:2) dont le num´ero est p. Les vues locales et
qu’il n’existe aucune arˆete e
(cid:2) sont alors mises `a jour. Cette r`egle ne peut ˆetre appliqu´ee
les boˆıtes-aux-lettres de v et v
sur l’arˆete e seulement si les r`egles M1,M2 et M3 ne peuvent pas ˆetre appliqu´ee sur e.

(cid:2) incidente `a v ou v

3.5. ´Enum´eration, Nommage et ´Election

61

M4 :
((cid:8)1, n1, N1, M)

((cid:8)e, 0)

((cid:8)2, n2, N2, M)

((cid:8)1, n1, N

(cid:2)
1, M

(cid:2))

((cid:8)e, p)

((cid:8)2, n2, N

(cid:2)
2, M

(cid:2))

Si

alors

(cid:2)
1, N
(cid:2)
2, N

n1 > 0, n2 > 0, n1 (cid:12)= n2,
1) (cid:19) ((cid:8)1, N1) et
1) ∈ M, ((cid:8)
∀(n1, (cid:8)
(cid:2)
(cid:2)
(cid:2)
1, N
2) ∈ M, ((cid:8)
2) (cid:19) ((cid:8)2, N2)
∀(n2, (cid:8)
(cid:2)
(cid:2)
(cid:2)
2, N
(cid:2) | ∃(p
(cid:2)) ∈ N1 ∪ N2} ;
p := 1 + max{p
(cid:2)
(cid:2)
, n
, (cid:8)
1 := N1 ∪ {(p, (cid:8)e, n2)} ;
(cid:2)
N
2 := N2 ∪ {(p, (cid:8)e, n1)} ;
(cid:2)
N
(cid:2) = M ∪ {(n1, N
M

(cid:2)
1), (n2, N

2)}.
(cid:2)

La cinqui`eme r`egle peut ˆetre appliqu´ee sur une arˆete e dont les extr´emit´es sont v et v

(cid:2) si
(cid:2))) /∈ N(v)
une mise `a jour de la vue locale de v ou de v
ou (p(e), λ(e), n(v)) /∈ N(v
(cid:2)). Cette r`egle ne peut pas ˆetre appliqu´ee si une des quatre
r`egles pr´ec´edentes peut ˆetre appliqu´ees sur e. Dans ce cas l`a les vues locales et les boˆıtes-
aux-lettres de v et v

(cid:2) est n´ecessaire, i.e., (p(e), λ(e), n(v

(cid:2) sont mises `a jour.

M5 :
((cid:8)1, n1, N1, M)

((cid:8)e, p)

Si

(cid:2)
1, M

(cid:2))

((cid:8)e, p)

((cid:8)2, n2, N

(cid:2)
2, M

(cid:2))

((cid:8)1, n1, N

((cid:8)2, n2, N2, M)
p > 0, n1 > 0, n2 > 0, n1 (cid:12)= n2,
1) ∈ M, ((cid:8)
∀(n1, (cid:8)
(cid:2)
(cid:2)
1, N
2) ∈ M, ((cid:8)
∀(n2, (cid:8)
(cid:2)
(cid:2)
2, N
(p, (cid:8)e, n2) /∈ N1
1 := N1 \ {(p
2) | p
(cid:2)
(cid:2)
(cid:2)
(cid:2)
alors N
e, n
2 := N2 \ {(p
1) | p
(cid:2)
(cid:2)
(cid:2)
(cid:2)
e, n
N
(cid:2) := M ∪ {(n1, (cid:8)1, N
1)} ∪ {(n2, (cid:8)2, N
(cid:2)
M

1) (cid:19) ((cid:8)1, N1),
(cid:2)
2) (cid:19) ((cid:8)2, N2) et
(cid:2)
(cid:2) = p}) ∪ {(p, (cid:8)e, n2} ;
(cid:2) = p}) ∪ {(p, (cid:8)e, n1} ;

(cid:2)
1, N
(cid:2)
2, N

2)}.
(cid:2)

, (cid:8)
, (cid:8)

3.5.3 Correction de l’Algorithme d’´Enum´eration

On consid`ere un graphe simple ´etiquet´e G. Pour tout sommet v ∈ V (G) et toute
arˆete e ∈ E(G), on note (λ(v), ni(v), Ni(v), Mi(v)) l’´etiquette du sommet v et (λ(e), pi(e))
l’´etiquette de l’arˆete e apr`es la i`eme ´etape de r´e´etiquetage de l’algorithme M d´ecrit ci-
dessus. On pr´esente d’abord quelques propri´et´es qui sont satisfaites par n’importe quelle
ex´ecution de l’algorithme.

Propri´et´es Satisfaites lors de l’Ex´ecution

Le lemme suivant, qui peut ˆetre facilement prouv´e par une r´ecurrence sur le nombre
d’´etapes, rappelle quelque propri´et´es simples qui sont toujours satisfaites par l’´etiquetage.
(cid:2)), et pour toute
Lemme 3.23 Pour toutes arˆetes e, e
´etape i,
1. pi(e) (cid:12)= 0 =⇒ pi+1(e) = pi(e),
2. ∃(p, (cid:8)e, n) ∈ Ni(v) ⇐⇒ ∃e ∈ IG(v) telle que pi(e) = p > 0 et λ(e) = (cid:8)e,

(cid:2) ∈ E(G), pour tout sommet v ∈ V (G

62

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

(cid:2)) =⇒ pi(e) (cid:12)= pi(e
(cid:2)),

(cid:2)) (cid:12)= 0, v ∈ ext(e) ∩ ext(e

3. pi(e) (cid:12)= 0, pi(e
4. ni(v) (cid:12)= 0 =⇒ (ni(v), λ(v), Ni(v)) ∈ Mi(v),
5. ∀(p, (cid:8)e, n) ∈ Ni(v), n (cid:12)= 0, p (cid:12)= 0 et ∃(n, (cid:8)
, N
6. (cid:2)(p, (cid:8)e, ni(v)) ∈ Ni(v),
7. ∀(p, (cid:8)e, n), (p
L’algorithme M a des propri´et´es de monotonicit´e int´eressantes qui sont donn´ees dans

(cid:2)) ∈ Ni(v), p (cid:12)= p

(cid:2)) ∈ Mi(v),

(cid:2)
e, n

(cid:2).

, (cid:8)

(cid:2)

(cid:2)

le lemme suivant.
Lemme 3.24 Pour chaque sommet v et chaque ´etape i,

– ni(v) ≤ ni+1(v),
– Ni(v) (cid:19) Ni+1(v),
– Mi(v) ⊆ Mi+1(v).

De plus, `a chaque ´etape i, il existe un sommet v telle qu’au moins une de ces in´egalit´es
(ou inclusions) est stricte pour v.

(cid:2)

(cid:2)

, (cid:8)

, N

(cid:2) | ∃(n

Preuve : La propri´et´e est trivialement vraie pour les sommets qui ne sont pas r´e´etiquet´es
lors de la (i + 1)`eme ´etape. De plus, il est facile de voir que quelque soit la r`egle appliqu´ee
`a l’´etape i + 1, on a toujours Mi(v) ⊆ Mi+1(v) pour tout sommet v ∈ V (G).
Pour chaque sommet v tel que ni(v) (cid:12)= ni+1(v), alors la r`egle M2 ou M3 a ´et´e appliqu´ee
`a v et ni+1(v) = 1 + max{n
(cid:2)) ∈ Mi(v)}. De plus, ou bien ni(v) = 0 < ni+1(v),
ou alors d’apr`es le Lemme 3.23, (ni(v), λ(v), Ni(v)) ∈ Mi(v) et donc ni(v) < ni+1(v).
Pour chaque sommet v tel que Ni(v) (cid:12)= Ni+1(v), la r`egle M4 ou M5 a ´et´e ap-
(cid:2). Si la r`egle M4 a ´et´e appliqu´ee,
pliqu´ee sur une arˆete e incidente `a v et a un sommet v
Ni+1(v) = Ni(v) ∪ {(pi(e), λ(e), ni(v
(cid:2))) /∈ Ni(v) ; par cons´equent
Ni(v) ≺ Ni+1(v). Si la r`egle M5 est appliqu´ee, alors d’apr`es le Lemme 3.23, il existe
(pi(e), λ(e), n) ∈ Ni(v). De plus, on sait que cela signiﬁe que la r`egle M4 ou M5 a ´et´e
< i sur l’arˆete e et n = ni(cid:2)(v). Ainsi, puisque ni(cid:2)(v) ≤ ni(v),
(cid:2)
appliqu´ee `a une ´etape i
ou bien Ni+1(v) = Ni(v) ou max Ni+1(v) (cid:17) Ni(v) = (pi(e), λ(e), ni(v)) ∈ Ni+1(v) et donc
Ni(v) (cid:19) Ni+1(v).

(cid:2)))} et (pi(e), λ(e), ni(v

Puisque chaque application d’une r`egle modiﬁe l’´etiquette d’au moins un sommet v,
2

on sait que l’une de ces in´egalit´es est stricte pour v.

(cid:2)) = m

(cid:2) tel que ni(v

Les informations dont dispose chaque sommet v dans sa boˆıte-aux-lettres permettent
d’obtenir des informations v´eriﬁ´ees par la conﬁguration globale du graphe. Les deux
lemmes suivants permettent de prouver que si un sommet v connaˆıt un num´ero m `a
(cid:2) ≤ m, il
une ´etape i (i.e., il existe (cid:8), N tels que (m, (cid:8), N) ∈ Mi(v)), alors pour chaque m
(cid:2). On montre d’abord que si v connaˆıt un num´ero
existe un sommet v
m, alors il existe un sommet v
Lemme 3.25 Pour chaque sommet v ∈ V (G) et chaque ´etape i, pour tout (m, (cid:8), N) ∈
Mi(v), il existe un sommet w ∈ V (G) tel que ni(w) = m.
Preuve : On remarque d’abord qu’un triplet (m, (cid:8), N) est ajout´e `a une ´etape i dans
(cid:4)
Mi(v) seulement s’il existe un sommet v tel que ni(v) = m, λ(v) = (cid:8) et Ni(v) = N.
´Etant donn´e un sommet v, une ´etape i et un triplet (m, (cid:8), N) ∈ Mi(v), on note U =
(cid:2) = {(u, j) ∈ U |

v∈V (G)
{(u, j) ∈ V (G)× N | j ≤ i, nj(u) = m}. On consid`ere ensuite l’ensemble U

(cid:2) tel que ni(v

(cid:2)) = m

(cid:2).

3.5. ´Enum´eration, Nommage et ´Election

63

, j

(cid:2)), Nj(cid:2)(u

(cid:2)) ∈ U, (λ(u

(cid:2))) = (λ(u), Nj(u)) et j

(cid:2))) ≺ (λ(u), Nj(u)) ou (λ(u

Si i0 < i, il existe exactement un ´el´ement (u, i0) ∈ U

∀(u
(cid:2)
j}. Puisque (m, (cid:8), N) ∈ Mi(v), U et U
ais´ement qu’il existe i0 tel que pour tout (u, j) ∈ U

(cid:2) ≤
(cid:2) sont deux ensembles non-vides. On remarque
(cid:2) puisqu’`a chaque ´etape, le num´ero
d’au plus un sommet peut ˆetre modiﬁ´e. Le num´ero ni0(u) = m a donc ´et´e modiﬁ´e `a l’´etape
i0 + 1, mais puisque `a cette ´etape, le sommet u n’avait aucun voisin avec le mˆeme num´ero
m, la r`egle M3 n’a pas pu ˆetre appliqu´ee, et par maximalit´e de (λ(u), Ni0(u)), la r`egle
M2 n’a pas non plus pu ˆetre appliqu´ee `a u `a l’´etape i0. Par cons´equent, i0 = i et il existe
donc un sommet w tel que ni(w) = m.

(cid:2)), Nj(cid:2)(u
(cid:2), j = i0.

2

Dans le lemme suivant, on montre que si un sommet v connaˆıt un num´ero m, alors il

connaˆıt tous les num´eros inf´erieurs `a m.
Lemme 3.26 Pour chaque sommet v et chaque ´etape i, pour tout (m, (cid:8), N) ∈ Mi(v), pour
tout m

(cid:2) ∈ [1, m], il existe (m

(cid:2)) ∈ Mi(v).

, N

, (cid:8)

(cid:2)

(cid:2)

Si la r`egle M1 est appliqu´ee `a l’´etape i+1 `a v et `a un de ses voisins v

Preuve : On montre ce lemme par r´ecurrence sur i. Initialement, la propri´et´e est tri-
vialement vraie. On suppose que la propri´et´e est v´eriﬁ´ee pour i ≥ 0. La propri´et´e est
trivialement vraie `a l’´etape i + 1 pour tout sommet w ∈ V (G) dont l’´etiquette n’est pas
modiﬁ´ee `a l’´etape i + 1. Soit v un sommet dont l’´etiquette est modiﬁ´ee `a l’´etape i + 1.
(cid:2), alors Mi+1(v) =
Mi(v) ∪ Mi(v
(cid:2)) et la propri´et´e est v´eriﬁ´ee `a l’´etape i + 1 puisqu’elle ´etait vraie pour v et
(cid:2) `a l’´etape i.
v
Si la r`egle M2 ou M3 est appliqu´ee `a v `a l’´etape i + 1, alors Mi+1(v) = Mi(v) ∪ {1 +
max{m | (m, (cid:8), N) ∈ Mi(v)}, λ(v), Ni(v))}, et par cons´equent pour chaque m ∈ Mi+1(v),
la propri´et´e reste vraie.
Si la r`egle M4 ou M5 est appliqu´ee `a v `a l’´etape i + 1, pour tout (m, (cid:8), N) ∈ Mi+1(v),

il existe (m, (cid:8), N

(cid:2)) ∈ Mi(v) et la propri´et´e reste donc vraie.

2

On veut maintenant montrer que toute ex´ecution de l’algorithme M termine sur G.
D’apr`es les Lemmes 3.25 et 3.26, on voit qu’`a chaque ´etape de l’ex´ecution, les num´eros des
sommets forment un ensemble [1, k] ou un ensemble [0, k] avec k ≤ |V (G)|. Par cons´equent,
d’apr`es le Lemme 3.24, on sait qu’il existe une ´etape i0 telle que pour tout sommet v et
toute ´etape i ≥ i0, ni+1(v) = ni(v). De plus, on sait que la r`egle M4 ne peut ˆetre appliqu´ee
qu’une seule fois sur chaque arˆete et par cons´equent, pour tout sommet v, Ni(v) et Mi(v)
ne peuvent prendre qu’un nombre ﬁni de valeurs. Ainsi, d’apr`es le Lemme 3.24, on sait
que toute ex´ecution de M sur G termine.

Propri´et´es Satisfaites par l’´Etiquetage Final

Puisqu’on sait que l’algorithme termine toujours, on s’int´eresse maintenant aux pro-

pri´et´es satisfaites par l’´etiquetage ﬁnal.
Lemme 3.27 Toute ex´ecution ρ de l’algorithme M sur un graphe simple ´etiquet´e G =
(G, λ) termine et l’´etiquetage ﬁnal (λ, nρ, Nρ, Mρ) des sommets et (λ, pρ) des arˆetes v´eriﬁe
les propri´et´es suivantes :

1. il existe un entier k ≤ |V (G)| tel que {nρ(v) | v ∈ V (G)} = [1, k],

et pour tous sommets v, v

(cid:2) :

64

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

(cid:2)),

(cid:2)),

2. Mρ(v) = Mρ(v
3. (nρ(v), λ(v), Nρ(v)) ∈ Mρ(v
4. si nρ(v) = nρ(v
5. pour toutes arˆetes e, e
6. (p, (cid:8), n) ∈ Nρ(v) si et seulement s’il existe une arˆete e incidente `a v telle que pρ(e) =
p et λ(e) = (cid:8). De plus, si ext(e) = {v, w}, alors nρ(w) = n et (p, (cid:8), nρ(v)) ∈ Nρ(w).

(cid:2) ∈ IG(v), pρ(e) > 0, pρ(e

(cid:2)) > 0 et pρ(e) (cid:12)= pρ(e
(cid:2)).

(cid:2)), alors λ(v) = λ(v

(cid:2)) et Nρ(v) = Nρ(v

(cid:2)),

Preuve :

1. D’apr`es les Lemmes 3.25 et 3.26 et puisque la r`egle M2 ne peut pas ˆetre appliqu´ee.
2. Dans le cas contraire, la r`egle M1 peut ˆetre appliqu´ee.
3. C’est une cons´equence directe de la propri´et´e pr´ec´edente d’apr`es le Lemme 3.23.
4. Dans le cas contraire, la r`egle M2 peut ˆetre appliqu´ee `a v ou `a v
5. D’apr`es le Lemme 3.23 et puisque la r`egle M4 ne peut plus ˆetre appliqu´ee.
6. D’apr`es le Lemme 3.23 et puisque les r`egles M3, M4 et M5 ne peuvent plus ˆetre

(cid:2).

appliqu´ees.

Grˆace au Lemme 3.27, on peut prouver que l’´etiquetage ﬁnal permet de construire un

graphe H tel que G est un revˆetements de H.
Proposition 3.28 ´Etant donn´e un graphe G, on peut construire, `a partir de l’´etiquetage
ﬁnal obtenu apr`es une ex´ecution ρ de M, un graphe H tel qu’il existe un homomorphisme
localement bijectif de G dans H.

2

Preuve : On utilise les notations du Lemme 3.27.
On consid`ere le graphe H d´eﬁni par V (H) = {m ∈ N | ∃v ∈ V (G), nρ(v) = m},
(cid:2)}} et pour toute arˆete
E(H) = {fpρ(e),λ(e),{nρ(v),nρ(v(cid:2))} | ∃e ∈ E(G) telle que ext(e) = {v, v
(cid:2)}. On d´eﬁnit un ´etiquetage η de H en posant
fp,(cid:5),{m,m(cid:2)} ∈ E(H), ext(fp,(cid:5),{m,m(cid:2)}) = {m, m
(cid:2) ∈ V (G)
η(nρ(v)) = λ(v) et η(fp,(cid:5),{m,m(cid:2)}) = (cid:8). D’apr`es le Lemme 3.27, si deux sommets v, v
(cid:2)) et par cons´equent, cet ´etiquetage est bien d´eﬁni.
ont le mˆeme num´ero, alors λ(v) = λ(v
D’apr`es le Lemme 3.27, on sait qu’il n’existe pas d’arˆete e ∈ E(G) telle que ext(e) =
(cid:2)} et nρ(v) = nρ(v
{v, v
(cid:2)). Par cons´equent, le graphe H est un graphe ´etiquet´e qui ne
contient pas de boucles.
On d´eﬁnit maintenant un homomorphisme γ de G dans H de la mani`ere suivante : pour
tout sommet v ∈ V (G), γ(v) = nρ(v) et pour toute arˆete e ∈ E(G) dont les extr´emit´es
(cid:2) , γ(e) = fpρ(e),λ(e),{nρ(v),nρ(v(cid:2))}. De par la d´eﬁnition de H, il est clair que γ est
sont v et v
un homomorphisme de G dans H.
(cid:2) ∈ IG(v), on sait d’apr`es le
Lemme 3.27 que pρ(e) (cid:12)= pρ(e
(cid:2)). Par cons´equent, pour tout sommet
v ∈ V (G), |γ(IG(v))| = |IG(v)|. De plus, pour tout sommet n ∈ V (H), si fp,(cid:5),{n,n(cid:2)} ∈ IH(n),
(cid:2)) ∈ Nρ(v).
on sait d’apr`es le Lemme 3.27 qu’il existe un sommet v ∈ γ
(cid:2)) telle que
Puisque, pour tout v
(cid:2)) = fp,(cid:5),{n,n(cid:2)}. Ainsi, pour tout v ∈ V (G), γ(IG(v)) = IH(γ(v)) et par cons´equent, γ
γ(e
est un homomorphisme localement bijectif de G dans H.

Pour tout sommet v ∈ V (G), pour toutes arˆetes e, e

−1(n) tel que (p, (cid:8), n
(cid:2) ∈ IG(v

(cid:2)) et ainsi, γ(e) (cid:12)= γ(e

(cid:2)), il existe une arˆete e

−1(n), Nρ(v) = Nρ(v

(cid:2) ∈ γ

Le graphe G est donc un revˆetement du graphe H `a travers γ.

2

3.5. ´Enum´eration, Nommage et ´Election

65

On consid`ere maintenant un graphe G qui est minimal pour les revˆetements. Pour
chaque ex´ecution ρ de M sur G, le graphe obtenu `a partir de l’´etiquetage ﬁnal est
isomorphe `a G. Par cons´equent, l’ensemble des num´eros des sommets est exactement
[1,|V (G)|] : chaque sommet a un identiﬁant unique. L’algorithme M permet de r´esoudre
le nommage sur la famille des graphes minimaux pour les revˆetements, mais si aucune
information `a propos de G n’est disponible, les sommets ne peuvent pas d´etecter la ter-
minaison.
Cependant, il est possible de d´etecter la terminaison pour un graphe G donn´e (l’algo-
rithme d´epend alors de G). En eﬀet, une fois qu’un sommet a obtenu le num´ero |V (G)|,
d’apr`es les Lemmes 3.25 et 3.26, il sait que tous les sommets de G ont un num´ero unique qui
ne va plus ˆetre modiﬁ´e. Dans ce cas l`a, on peut aussi r´esoudre le probl`eme de l’´election,
puisque ce sommet peut prendre l’´etiquette ´elu et diﬀuser ensuite l’information qu’un
sommet a ´et´e ´elu.
Par ailleurs, d’apr`es la Proposition 3.20, on sait qu’il existe un algorithme M(cid:2) utilisant
des calculs locaux cellulaires sur les arˆetes ´etiquet´ees qui simule M. Il existe donc un
algorithme de nommage (sans d´etection de la terminaison) utilisant des calculs locaux
cellulaires pour la famille des graphes minimaux pour les revˆetements. De plus, d’apr`es la
Proposition 3.21, on sait aussi que pour tout graphe G minimal pour les revˆetements, il
existe un algorithme d’´election pour G et un algorithme d’´enum´eration avec d´etection de
la terminaison pour G qui utilisent des calculs locaux cellulaires sur les arˆetes ´etiquet´ees.
Par ailleurs, d’apr`es la Proposition 3.22, on sait que pour tout graphe G qui n’est
pas minimal pour les revˆetements, il n’existe aucun algorithme utilisant des calculs locaux
(cellulaires) sur les arˆetes ´etiquet´ees qui permette de r´esoudre les probl`emes du nommage
ou de l’´election sur G. On a donc prouv´e le th´eor`eme suivant.
Th´eor`eme 3.29 Pour tout graphe ´etiquet´e G, les assertions suivantes sont ´equivalentes :
1. il existe un algorithme de nommage (ou d’´enum´eration) pour G utilisant des calculs

locaux (cellulaires) sur les arˆetes ´etiquet´ees,

2. il existe un algorithme d’´election et un algorithme de nommage (ou d’´enum´eration)
avec d´etection de la terminaison pour G utilisant des calculs locaux (cellulaires) sur
les arˆetes ´etiquet´ees,

3. G est minimal pour les revˆetements.

Remarque 3.30 ´Etant donn´e un graphe G minimal pour les revˆetements, pour d´etecter
que l’algorithme M a attribu´e un identiﬁant unique `a chaque sommet, il suﬃt de connaˆıtre
le nombre de sommets de G. Ainsi, l’algorithme M permet de r´esoudre l’´election ainsi
que le nommage avec d´etection de la terminaison sur les graphes minimaux pour les
revˆetements de taille donn´ee.

3.5.4 Complexit´e

On s’int´eresse `a la complexit´e de l’algorithme M pr´esent´e ci-dessus. Dans le cadre
des calculs locaux, on s’int´eresse au nombre de pas de r´e´etiquetages eﬀectu´ees lors d’une
ex´ecution. La proposition suivante donne une borne sup´erieure sur le nombre de pas de
r´e´etiquetages de toute ex´ecution de l’algorithme M sur un graphe `a n sommets de degr´e
maximal Δ.

66

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

2

fois durant l’ex´ecution ρ.

Proposition 3.31 Pour tout graphe G `a n sommets de degr´e maximal Δ, durant toute
ex´ecution de l’algorithme M utilisant des calculs locaux sur les arˆetes ´etiquet´ees, O(Δn3)
r`egles sont appliqu´ees.
Preuve : On consid`ere un graphe G `a n sommets et une ex´ecution ρ de M sur G.
D’apr`es les Lemmes 3.25 et 3.26, on sait que les r`egles M2 et M3 ne peuvent pas ˆetre
appliqu´ees plus de n(n−1)
Entre deux ´etapes o`u une des r`egles M2,M3 est appliqu´ee, les r`egles M4 et M5 sont
appliqu´ees au plus Δ fois (une fois pour chaque voisin du sommet dont le num´ero a ´et´e
modiﬁ´e). Les r`egles M4 et M5 sont donc appliqu´ees O(Δn2) fois.
`A chaque fois qu’un sommet v modiﬁe son num´ero ou sa vue locale, un couple (n0, (cid:8), N)
est ajout´e `a M(v). Pour chacun de ces couples, la r`egle M1 est appliqu´ee au plus n fois.
Ainsi, durant toute ex´ecution ρ de M sur G, O(Δn3) r`egles sont appliqu´ees.
Le facteur Δ qui diﬀ`ere entre la borne de la Proposition 2.23 et celle de la Proposi-
tion 3.31 est du au fait que dans le mod`ele de calculs locaux sur les ´etoiles ferm´ees, si
un sommet modiﬁe son num´ero, il en informe imm´ediatement ses voisins, ce qui n’est pas
possible dans le cadre des calculs locaux sur les arˆetes ´etiquet´ees.

2

On s’int´eresse `a la m´emoire n´ecessaire `a chaque sommet pour stocker son ´etiquette. On
suppose que l’´etiquetage initial λ du graphe G est tel que chaque ´etiquette initiale (cid:8) a une
taille en O(log |V (G)|) bits (ce qui est suﬃsant pour attribuer des ´etiquettes diﬀ´erentes `a
tous les sommets et `a toutes les arˆetes de G).
Proposition 3.32 Pour tout graphe G `a n sommets de degr´e maximal Δ, l’algorithme M
utilisant des calculs locaux sur les arˆetes ´etiquet´ees n´ecessite O(Δn log n) bits de m´emoire
par sommet.

Preuve : On consid`ere un graphe G `a n sommets et m arˆetes dont le degr´e maximal
est Δ. L’´etiquette de chaque arˆete est modiﬁ´ee exactement une fois par toute ex´ecution
de l’algorithme, et chaque arˆete e a un num´ero p(e) compris entre 1 et m. 0n sait que
la vue locale de chaque sommet contient au plus Δ couples (p, (cid:8)e, n0) qui peuvent ˆetre
repr´esent´es avec O(log n) bits. Ainsi, pour chaque sommet v, N(v) peut ˆetre repr´esent´e
avec O(Δ log n) bits.
Chaque sommet peut ne conserver dans sa boˆıte-aux-lettres que l’information utile,
(cid:2)) (cid:19) ((cid:8), N)}. Ainsi, dans
i.e., l’ensemble {(n0, (cid:8), N) ∈ M(v) | ∀(n0, (cid:8)
la boˆıte-aux-lettres de chaque sommet, il existe au plus n triplets (n0, (cid:8), N) qu’on peut
repr´esenter avec O(Δ log n) bits. Par cons´equent, on peut repr´esenter la boˆıte-aux-lettres
de chaque sommet avec O(Δn log n) bits.
2

(cid:2)) ∈ M(v), ((cid:8)

, N

(cid:2)

(cid:2)

, N

3.6

Importance de la Connaissance du Degr´e

Dans cette partie, on suppose qu’initialement, chaque sommet v d’un graphe G =
(G, λ) connaˆıt son degr´e, i.e., son degr´e fait partie de son ´etiquette initiale λ(v). On montre
d’abord le lien entre le mod`ele des calculs locaux sur les arˆetes ´etiquet´ees avec connaissance
initiale du degr´e, le mod`ele d’Angluin et le mod`ele de communication synchrone. On d´eﬁnit
ensuite formellement les calculs locaux sur les ´etoiles ouvertes et on montre que tout
algorithme utilisant des calculs locaux sur les ´etoiles ouvertes peut ˆetre simul´e sur par un

3.6. Importance de la Connaissance du Degr´e

67

algorithme utilisant des calculs locaux sur les arˆetes ´etiquet´ees avec connaissance initiale du
degr´e. On montre enﬁn que le mod`ele de calcul ainsi obtenu est strictement plus puissant
que les calculs locaux sans connaissance initiale du degr´e. Pour cela, on va consid´erer le
probl`eme de l’´election sur les familles de graphes minimaux pour les revˆetements dont le
diam`etre est born´ee.

3.6.1 Relations avec le Mod`ele D’Angluin et le Mod`ele de Communica-

tion Synchrone

Le Mod`ele d’Angluin

Dans [Ang80], Angluin consid`ere des graphes simples disposant d’un ´etiquetage des
ports. Un pas de calcul permet `a deux sommets voisins d’´echanger leurs ´etats, puis
chaque sommet modiﬁe son ´etat en fonction de son propre ´etat et de l’´etat de ses voi-
sins. Aﬁn de briser certaines sym´etries, Angluin suppose que lors d’un tel pas de calcul,
deux sommets voisins qui sont dans le mˆeme ´etat peuvent obtenir des ´etats diﬀ´erents
(les sommets peuvent par exemple briser cette sym´etrie par un tirage au sort). Angluin
cherche a caract´eriser les graphes G qui admettent un algorithme d’´election quel que soit
l’´etiquetage des ports. Elle montre en particulier que si un graphe n’est pas minimal pour
les revˆetements simples, alors il n’existe pas d’algorithme d’´election pour ce graphe.

Puisque dans le mod`ele d’Angluin, chaque sommet v connaˆıt les num´eros des ports
incident `a v, chaque sommet connaˆıt son degr´e. Par ailleurs, les sommets peuvent distinguer
les arˆetes qui leurs sont incidentes grˆace aux num´eros de ports. Ainsi, il est facile de simuler
dans ce mod`ele un algorithme utilisant des calculs locaux sur les arˆetes ´etiquet´es avec
connaissance initiale du degr´e : on stocke l’´etiquette d’une arˆete e dans les ´etiquettes des
extr´emit´es de e. Ainsi, le mod`ele d’Angluin permet de simuler tout algorithme utilisant
des calculs locaux sur les arˆetes ´etiquet´ees avec connaissance initiale du degr´e.

R´eciproquement, on va montrer que le r´esultat d’impossibilit´e pr´esent´e dans la Propo-
sition 3.22 reste vrai dans le mod`ele d’Angluin. ´Etant donn´e un graphe simple G avec un
´etiquetage des ports δ, on va montrer que si G est un revˆetement d’un graphe H, alors il
(cid:2) de H de telle sorte que pour tout algorithme A, il existe
existe un ´etiquetage des ports δ
une ex´ecution de A sur (G, δ) qui est relev´ee d’une ex´ecution de A sur (H, δ).

Puisqu’on doit ´etendre la notion d’´etiquetage des ports `a des graphes qui peuvent avoir

des arˆetes multiples, on utilise la d´eﬁnition suivante.
D´eﬁnition 3.33 ´Etant donn´e un graphe G, un ´etiquetage des ports δ est un ensemble de
fonctions {δu | u ∈ V (G)} tel que pour tout sommet u, δu est une bijection entre IG(u) et
[1, degG(u)].
Ainsi, un ´etiquetage des ports permet `a chaque sommet d’attribuer un num´ero `a chacune
des arˆetes qui lui sont incidentes et non `a chacun de ses voisins. On remarque que dans le
cas des graphes simples, les deux d´eﬁnitions sont ´equivalentes.

On dit qu’un graphe G avec un ´etiquetage des ports δ est un revˆetement d’un graphe
(cid:2) `a travers γ si G est un revˆetement de H `a travers γ et

H avec un ´etiquetage des ports δ
si pour toute arˆete e ∈ E(G) et pour tout sommet u ∈ ext(e), δu(e) = δγ(u)(γ(e)).
Proposition 3.34 Pour tous graphes G, H tels que G est un revˆetement de H, pour tout
(cid:2), il existe un ´etiquetage des ports δ tel que (G, δ) est un revˆetement
´etiquetage des ports δ
de (H, δ

(cid:2))

68

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

Preuve : On consid`ere un graphe G qui est un revˆetement d’un graphe H `a travers γ et
(cid:2) de H. Pour tout sommet u ∈ V (G), pour toute arˆete e ∈ IG(u),
un ´etiquetage des ports δ
on sait que γ(e) ∈ IH(γ(e)) et on d´eﬁnit alors δu(e) = δ
(cid:2)
γ(u)(γ(e)). Il suﬃt de montrer que
la fonction δ ainsi obtenu est bien un ´etiquetage des ports de G. On consid`ere un sommet
u ∈ V (G). Puisque γ|IG(u) induit une bijection entre IG(u) et IH(γ(u)) et que δ
(cid:2)
γ(u) induit
γ(u) ◦ γ|IG(u) induit une bijection
(cid:2)
une bijection entre IH(γ(u)) et [1, degH(γ(u))], δu = δ
entre IG(u) et [1, degH(γ(u)) = degG(u)]. Ainsi, δ est bien un ´etiquetage des ports de G.
2

Avec la mˆeme preuve que pour la Proposition 3.22, il est facile de voir que si un graphe
G avec un ´etiquetage des ports δ est un revˆetement d’un graphe H avec un ´etiquetage des
(cid:2), alors dans le mod`ele d’Angluin, pour tout algorithme A, il existe une ex´ecution de
ports δ
A sur (G, δ) qui est relev´ee d’une ex´ecution sur (H, δ
(cid:2)). Par cons´equent, pour tout graphe
G qui n’est pas minimal pour les revˆetements, il existe un ´etiquetage des ports de G tel
qu’on ne peut pas r´esoudre le nommage ou l’´election sur (G, δ) dans le mod`ele d’Angluin.
R´eciproquement, puisqu’on peut simuler l’Algorithme M dans le mod`ele d’Angluin, on
obtient le th´eor`eme suivant. On rappelle qu’un algorithme d’´election pour un graphe G
permet de r´esoudre l’´election sur G quel que soit l’´etiquetage des ports.
Th´eor`eme 3.35 Pour tout graphe simple ´etiquet´e G, il existe un algorithme de nommage
et un algorithme d’´election pour G dans le mod`ele d’Angluin si et seulement si G est
minimal pour les revˆetements.

Le Mod`ele de Communication Synchrone

Dans un syst`eme o`u les processus communiquent par ´echange de messages, on peut
consid´erer le mod`ele o`u une ´etape de transmission de message n´ecessite une synchronisation
entre l’exp´editeur et le destinataire du message. Autrement dit, en un pas de calcul, deux
(cid:2) (qui peut
sommets voisins v et v
(cid:2) modiﬁe son ´etat en fonction de son propre ´etat et du message re¸cu, et
ˆetre son ´etat), v
(cid:2). Dans ce mod`ele, on suppose que le
v modiﬁe son ´etat ind´ependemment de l’´etat de v
r´eseau dispose d’un ´etiquetage des ports pour permettre `a chaque sommet de distinguer
ses voisins.

(cid:2) se synchronisent, le sommet v envoie un message `a v

Il faut noter qu’on parle de communication synchrone, puisque toute transmission
de message n´ecessite une synchronisation, mais que le comportement global du syst`eme
distribu´e est asynchrone. En g´en´eral, pour ´eviter les inter-blocages, on suppose que les
processus peuvent faire des choix non-d´eterministes sur les actions qu’ils eﬀectuent (par
exemple, un processus peut choisir de mani`ere non-d´eterministe s’il doit d’abord envoyer
un message ou recevoir un message). Pour des d´eﬁnitions formelles, on peut se r´ef´erer au
livre de Tel [Tel00] (pp. 47-49). Charron-Bost et al. [CBMT96] ont ´etudi´e les diﬀ´erences
entre les modes de communication synchrone et asynchrone (le mod`ele asynchrone est
´etudi´e au Chapitre 7 de ce m´emoire).

Il est clair que le mod`ele d’Angluin est plus puissant que le mod`ele de communication
synchrone puisque dans le mod`ele d’Angluin, les deux sommets ont acc`es `a l’´etat de leur
voisin. Par ailleurs, comme indiqu´e pour le mod`ele d’Angluin, on peut stocker l’´etiquette
de chaque arˆete dans les ´etiquettes de ses extr´emit´es. Ainsi, il est facile de voir qu’on peut
simuler tout algorithme utilisant des calculs locaux cellulaires sur les arˆetes ´etiquet´ees

3.6. Importance de la Connaissance du Degr´e

69

dans le mode de communication synchrone. D’apr`es les Th´eor`emes 3.29 et 3.35, on a donc
le th´eor`eme suivant.

Th´eor`eme 3.36 Pour tout graphe simple ´etiquet´e G, il existe un algorithme de nommage
et un algorithme d’´election pour G dans le mod`ele de communication synchrone si et
seulement si G est minimal pour les revˆetements.

Remarque 3.37 Les autres r´esultats pr´esent´es dans cette section sont bas´es sur l’hy-
poth`ese suppl´ementaire que chaque sommet connaˆıt initialement son degr´e. Puisque dans
les deux mod`eles consid´er´es ici, cette propri´et´e est assur´ee, tous les r´esultats pr´esent´es
dans la suite de cette section restent vrais dans ces mod`eles.

3.6.2 Calculs Locaux sur les ´Etoiles Ouvertes

On rappelle qu’informellement, les calculs locaux sur les ´etoiles ouvertes permettent
en un pas de calcul `a un sommet de modiﬁer son ´etiquette et les ´etiquettes des arˆetes qui
lui sont incidentes. L’application d’un tel pas de calcul ne d´epend que de son ´etiquette,
des ´etiquettes de ses voisins et des ´etiquettes des arˆetes qui lui sont incidentes.

On d´eﬁnit maintenant les relations de r´e´etiquetage localement engendr´ees sur les ´etoiles

ouvertes.
D´eﬁnition 3.38 Une relation de r´e´etiquetage R est localement engendr´ee sur les ´etoiles
(cid:2)),
ouvertes si la condition suivante est satisfaite. Pour tous graphes simples (G, λ), (G, λ
(cid:2)), pour tout sommets v ∈ V (G) et w ∈ V (H) tels qu’il existe un isomorphisme
(H, η), (H, η
ϕ : BG(v) → BG(w), si les conditions suivantes sont v´eriﬁ´ees :

(cid:2)(v) = η

(cid:2)(ϕ(v)),

1. λ(v) = η(ϕ(v)) et λ
2. pour toute arˆete e ∈ IG(v), λ(e) = η(ϕ(e)) et λ
3. pour tout v
4. pour tout x /∈ {v} ∪ IG(v), λ
5. pour tout x /∈ {w} ∪ IH(w), η

(cid:2) ∈ NG(v), λ(v) = η(ϕ(v)),

(cid:2)(x) = λ(x),
(cid:2)(x) = η(x),

(cid:2)(e) = η

(cid:2)(ϕ(e)),

alors (G, λ) R (G, λ

(cid:2)) si et seulement si (H, η) R (H, η

(cid:2)).

On consid`ere seulement des relations de r´e´etiquetages r´ecursives et cela pour consid´erer
des mod`eles de calcul ayant une puissance de calcul raisonnable. Par d´eﬁnition, les calculs
locaux sur les ´etoiles ouvertes correspondent aux relations de r´e´etiquetage localement
engendr´ees sur les ´etoiles ouvertes.

Une relation de r´e´etiquetage localement engendr´ee sur les ´etoiles ouvertes peut ˆetre
d´ecrite par un ensemble r´ecursif de r`egles de r´e´etiquetage o`u chaque r`egle permet de
modiﬁer les ´etiquettes d’un sommet et des arˆetes incidentes `a ce sommet en fonction
des ´etiquettes apparaissant dans l’´etoile centr´ee en ce sommet. R´eciproquement, un tel
ensemble de r`egles induit une relation de r´e´etiquetage localement engendr´ee sur les ´etoiles
ouvertes. Ainsi, on notera R l’ensemble de r`egles de r´e´etiquetage aussi bien que la relation
de r´e´etiquetage correspondante.

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

70

3.6.3

´Equivalence entre les Calculs Locaux sur les Arˆetes ´Etiqu´eet´ees
avec Connaissance Initiale du Degr´e et les Calculs Locaux sur les
´Etoiles Ouvertes

On dit qu’un algorithme R r´esout un probl`eme P sur une famille de graphe F en
utilisant des calculs locaux sur les arˆetes ´etiquet´ees avec connaissance initiale du degr´e
si R utilise des calculs locaux sur les arˆetes ´etiquet´ees et que la propri´et´e suivante est
v´eriﬁ´ee. Pour tout graphe (G, λ) ∈ F, toute ex´ecution de R sur le graphe (G, (λ, d))
r´esout le probl`eme P o`u pour tout v ∈ V (G), d(v) est le degr´e de v dans le graphe G.
Ainsi un algorithme utilisant des calculs locaux sur les arˆetes ´etiquet´ees avec connaissance
initiale du degr´e est un algorithme qui peut utiliser le fait que chaque sommet connaˆıt son
degr´e.

On montre maintenant que les calculs locaux sur les ´etoiles ouvertes ont la mˆeme
puissance de calcul que les calculs locaux sur les arˆetes ´etiquet´es avec connaissance initiale
du degr´e.
´Etant donn´e un algorithme R utilisant des calculs locaux sur les ´etoiles ouvertes, `a
chaque pas de r´e´etiquetage, le sommet qui modiﬁe son ´etiquette peut calculer son degr´e.
Puisqu’il est ´evident qu’on peut simuler un algorithme utilisant des calculs locaux cellu-
laires sur les arˆetes ´etiquet´ees en utilisant des calculs locaux sur les ´etoiles ouvertes, on
sait d’apr`es la Proposition 3.20 que tout algorithme utilisant des calculs locaux sur les
arˆetes ´etiquet´ees avec connaissance initiale du degr´e peut ˆetre simul´e par un algorithme
utilisant des calculs locaux sur les ´etoiles ouvertes.
On consid`ere maintenant un algorithme R utilisant des calculs locaux sur les ´etoiles
ouvertes et on va montrer qu’il existe un algorithme utilisant des calculs locaux sur les
arˆetes ´etiquet´ees avec connaissance initiale du degr´e qui simule R.

Un Processus d’Initialisation

Pour cela, on va commencer par d´ecrire un processus d’initialisation qui va permettre
`a chaque sommet d’obtenir de l’information `a propos de ses voisins et d’´etablir un ordre
entre les extr´emit´es de chaque arˆete.

L’´etiquette de chaque arˆete e est de la forme (λ(e), p(e)) o`u λ(e) est l’´etiquette initiale
de e, qui ne sera pas modiﬁ´ee par le processus d’initialisation et p(e) est un num´ero attribu´e
`a chaque arˆete par l’algorithme de telle sorte que deux arˆetes incidentes `a un mˆeme sommet
ont des num´eros diﬀ´erents. Initialement, chaque arˆete est ´etiquet´e (λ(e), 0).

L’´etiquette de chaque sommet v est de la forme (λ(v), d(v), n(v), N(v)) dont la signiﬁ-

cation est la suivante :

d’initialisation,

– λ(v) est l’´etiquette initiale de v et n’est pas modiﬁ´ee par le processus d’initialisation,
– d(v) ∈ N est le degr´e de v dans le graphe et n’est pas modiﬁ´e par le processus
– n(v) ∈ N est un num´ero associ´e `a chaque sommet qui est modiﬁ´e de telle sorte que
dans la conﬁguration ﬁnale, deux sommets adjacents ont deux num´eros diﬀ´erents,
– N(v) ∈ Pﬁn(N3) est un ensemble de triplets d’entiers qui contient les informations
dont v dispose `a propos de ses voisins. Si un triplet (p, m, n) ∈ N(v), cela signiﬁe
que lors du dernier pas de r´e´etiquetage eﬀectu´ee sur l’arˆete e incidente `a v dont le
num´ero est p, le num´ero de v ´etait n et le num´ero de l’autre extr´emit´e de e ´etait m.

Initialement, chaque sommet est ´etiquet´e (λ(v), d(v), 0,∅).

3.6. Importance de la Connaissance du Degr´e

71

La premi`ere r`egle de r´e´etiquetage I1 permet `a deux sommets voisins v et v

(cid:2) de donner
un num´ero `a l’arˆete e les reliant si celle-ci n’en a pas encore. Dans ce cas l`a, le couple
(cid:2)). Ainsi, `a tout moment de l’ex´ecution, si un couple
(p(e), 0, 0) est ajout´e `a N(v) et N(v
(p, m, n) ∈ N(v), cela signiﬁe qu’il existe une arˆete incidente `a v dont le num´ero est p. De
cette mani`ere, en raison du choix du num´ero attribu´e `a chaque arˆete lors de l’application
de la r`egle I1, on sait que deux arˆetes incidentes `a un mˆeme sommet qui ont des num´eros
non-nuls ont toujours des num´eros diﬀ´erents.

I1 :

((cid:8)1, d1, 0, N1)
((cid:8)e, 0)
o`u p := 1 + max{p

(cid:2) | ∃(p
(cid:2)
1 := N1 ∪ {(p, 0, 0)},
(cid:2)
2 := N2 ∪ {(p, 0, 0)}.
(cid:2)

N
N

((cid:8)2, d2, 0, N2)

((cid:8)1, d1, 0, N

(cid:2)
1)

((cid:8)e, p)

((cid:8)2, d2, 0, N

(cid:2)
2)

, 0, 0) ∈ N1 ∪ N2},

La deuxi`eme r`egle permet `a un sommet v qui sait qu’il ne peut plus appliquer la r`egle
I1 de prendre le num´ero 1. Si N(v) contient d(v) triplets, cela signiﬁe que le sommet v a
appliqu´e d(v) fois la r`egle I1 et par cons´equent, puisque d(v) est le degr´e de v, on sait que
toutes les arˆetes incidentes `a v ont des num´eros non-nuls qui sont tous diﬀ´erents. Ainsi, si
un sommet v a un num´ero non-nul, cela signiﬁe que toutes les arˆetes incidentes `a v ont des
num´eros diﬀ´erents et v connaˆıt ces num´eros (i.e., il peut les retrouver `a partir de N(v)).

I2 :

((cid:8), d, 0, N)

((cid:8), d, 1, N)

Cette r`egle est applicable si |N| = d.
La r`egle I3 permet `a deux sommets voisins v et v

(cid:2) reli´ees par une arˆete e qui ont
le mˆeme num´ero n de briser cette sym´etrie, i.e., le sommet v prend un nouveau num´ero
k lorsque cette r`egle est appliqu´ee. Cette r`egle ne peut ˆetre appliqu´ee que si les deux
sommets ont des num´eros non-nuls, i.e., toutes les arˆetes incidentes aux deux sommets
ont des num´eros non-nuls. De plus, le triplet (p(e), n, k) est ajout´e `a N(v) et le triplet
(cid:2)), puisque le but de N(v) est de stocker le num´ero de chaque
(p(e), k, n) est ajout´e `a N(v
(cid:2) de v ainsi que le num´ero qu’avait v lors du dernier ´echange de num´eros entre v et
voisin v
(cid:2). On remarque que le num´ero k g´en´er´e est plus grand que tous les num´eros que v connait
v
dans son voisinage. Ainsi, si l’information que v a `a propos de son voisinage est correcte,
v a un num´ero diﬀ´erent de tous ses voisins.

I3 :

((cid:8)1, d1, n, N1)

((cid:8)e, p)

((cid:8)2, d2, n, N2)

((cid:8)1, d1, k, N

(cid:2)
1)

((cid:8)2, d2, n, N

(cid:2)
2)

((cid:8)e, p)

Si
alors

p > 0 et n > 0
(cid:2) | ∃(p
k := 1 + max{n
1 := N1 \ {(p
(cid:2)
(cid:2)
(cid:2)
, m
, n
N
2 := N2 \ {(p
(cid:2)
(cid:2)
(cid:2)
, n
, m
N

(cid:2)

(cid:2)
, n
, m
(cid:2)) | p = p
(cid:2)) | p = p

(cid:2)) ∈ N1},
(cid:2)} ∪ {(p, n, k)},
(cid:2)} ∪ {(p, k, n)}.

72

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

La quatri`eme r`egle sert `a mettre `a jour l’information dont disposent les sommets `a
(cid:2) reli´e `a v par une arˆete e et si
(cid:2) n’ont pas ´echang´e leurs num´eros depuis

propos de leurs voisins. Si un sommet v a un voisin v
(p(e), n(v
que v ou v

(cid:2)), n(v)) /∈ N(v), cela signiﬁe que v et v
(cid:2) a modiﬁ´e son num´ero.

((cid:8)e, p)

((cid:8)2, d2, n2, N2)

((cid:8)1, d1, n1, N

(cid:2)
1)

((cid:8)e, p)

((cid:8)2, d2, n2, N

(cid:2)
2)

I4 :
((cid:8)1, d1, n1, N1)

Si

alors N
N

p, n1, n2 > 0, n1 (cid:12)= n2 et
(p, n2, n1) /∈ N1 ou (p, n1, n2) /∈ N2
1 := N1 \ {(p
(cid:2)
2 := N2 \ {(p
(cid:2)

(cid:2)) | p = p
(cid:2)) | p = p

, m
, m

(cid:2)
(cid:2)

(cid:2)
(cid:2)

, n
, n

(cid:2)} ∪ {(p, n2, n1)},
(cid:2)} ∪ {(p, n1, n2)}.

(cid:2), pour toute ´etape i, les propri´et´es suivantes sont satisfaites :

On consid`ere un graphe G et une ex´ecution de l’algorithme d’initialisation I sur G.
Pour chaque ´etape i de l’ex´ecution, on note (λ(v), d(v), ni(v), Ni(v)) l’´etiquette du som-
met v et (λ(e), pi(e)) l’´etiquette de l’arˆete e apr`es le i`eme pas de r´e´etiquetage. On peut
facilement prouver le lemme suivant par r´ecurrence sur le nombre d’´etapes.
(cid:2) ∈ V (G) et toute arˆete e ∈ E(G) dont les extr´emit´es
Lemme 3.39 Pour tous sommets v, v
sont v et v
– pi(e) > 0 =⇒ pi+1(e) = pi(e),
– pi(e) (cid:12)= 0 =⇒ ∃(pi(e), n, m) ∈ Ni(v),
– ni(v) > 0 =⇒ pi(e) > 0,
– ni(v) > 0 =⇒ ∀(p, m, n) ∈ Ni(v), m (cid:12)= ni(v),
– (pi(e), m, n) ∈ Ni(v) ⇐⇒ (pi(e), n, m) ∈ Ni(v
On montre maintenant qu’un sommet peut d´etecter que son num´ero ne sera plus
modiﬁ´e lors de la suite de l’ex´ecution.
Lemme 3.40 Pour tout sommet v ∈ V (G) et pour toute ´etape i, si ni(v) > 0 et si pour
(cid:2) ≥ i, ni(cid:2)(v) = ni(v).
tout (p, n, m) ∈ Ni(v), m = ni(v), alors pour toute ´etape i
Preuve : Pour tout sommet v ∈ V (G) et pour toute ´etape i, si ni(v) > 0 et si pour tout
(cid:2) ∈ NG(v), il
(p, n, m) ∈ Ni(v), m = ni(v), on sait d’apr`es le Lemme 3.39, que pour tout v
(cid:2)) ∈ Ni(v
(cid:2)). Par cons´equent, d’apr`es le Lemme 3.39, on sait que pour tout
, ni(v), m
existe (p
(cid:2)) (cid:12)= ni(v). De plus, la seule r`egle qui permet `a un sommet de changer
(cid:2) ∈ NG(v), ni(v
v
de num´ero est la r`egle I3 et de par la d´eﬁnition de cette r`egle, on sait que pour tout
(cid:2) ∈ NG(v), si v
(cid:2) modiﬁe son num´ero `a une ´etape i
(cid:2)
> i , ni(cid:2)(v(cid:2)) > ni(v). Par cons´equent,
v
(cid:2) ∈ NG(v), ni(cid:2)(v
(cid:2)) (cid:12)= ni(v). Ainsi, le num´ero de v ne peut pas
(cid:2) ≥ i, pour tout v
pour tout i
(cid:2) ≥ i puisque v n’a pas de voisin avec le mˆeme num´ero que lui.
ˆetre modiﬁ´ee `a une ´etape i
2

(cid:2)).

(cid:2)

Par cons´equent, chaque sommet v sait quand le num´ero qui lui est attribu´e est son
num´ero d´eﬁnitif. De plus, si tous les voisins de v ont aussi leurs num´eros d´eﬁnitifs, la
r`egle I4 ne peut plus ˆetre appliqu´ee qu’une seule fois entre le sommet v et chacun de ses
voisins. Une fois que v a son num´ero d´eﬁnitif, il lui suﬃt de s’assurer que chaque sommet
(cid:2) ∈ NG(v) (qu’il distingue grˆace aux num´eros des arˆetes) a son num´ero d´eﬁnitif et que
v
(cid:2) est correcte. Ainsi, il est possible pour chaque
l’information dont dispose v a propos de v
sommet de d´etecter qu’il a calcul´e son num´ero d´eﬁnitif, de s’assurer que ses voisins ont

3.6. Importance de la Connaissance du Degr´e

73

aussi leurs num´eros d´eﬁnitifs et que la valeur de N(v) est d´eﬁnitive. Le sommet v peut
ensuite observer et stocker dans N(v) les ´etiquettes initiales de toutes les arˆetes qui lui
sont incidentes et de ses voisins correspondants.

L’Algorithme de Simulation

Une fois qu’un sommet v s’est assur´e que les valeurs n(v) et N(v) ne seront plus
modiﬁ´ees, il va utiliser ces valeurs pour essayer de simuler des r`egles de l’algorithme R
utilisant des calculs locaux sur les arˆetes ouvertes.

Le principe de la simulation est le suivant : on va utiliser un m´ecanisme classique
de synchronisation pr´esent´e par Rosenstiehl et al. [RFH72]. La simulation va ˆetre divis´ee
en phases de telle sorte que l’´ecart entre les phases de deux voisins est d’au plus 1. La
m´ethode est la suivante, chaque sommet qui a termin´e la p´eriode d’initialisation (i.e., n(v)
a sa valeur d´eﬁnitive N(v) contient les ´etiquettes initiales des arˆetes incidentes `a v et des
voisins de v) passe `a la phase 1. Pour passer `a la phase i + 1, chaque sommet consulte
d’abord ses voisins (qu’il distingue grˆace aux num´eros attribu´es aux arˆetes) et s’assure
qu’ils sont tous `a une phase sup´erieure ou ´egale `a i. Il est montr´e dans [RFH72] qu’au lieu
d’utiliser un compteur non-born´e, on peut se contenter d’un compteur `a trois valeurs et
on additionne alors modulo 3, mais pour simpliﬁer l’explication, on ne consid`ere pas cette
version de l’algorithme de synchronisation ici.
On utilise maintenant le m´ecanisme de synchronisation pour simuler R. Le principe
est qu’`a chaque phase, chaque sommet v v´eriﬁe s’il peut simuler une r`egle de R sur l’´etoile
centr´ee en v. Ensuite, on utilise les num´eros des sommets pour g´erer les conﬂits entre les
sommets voisins aﬁn que seulement un ensemble ind´ependant de sommets simule une r`egle
de R.

Une ´etape de simulation se d´eroule sur deux phases de synchronisation. Dans les phases
impaires, `a partir de l’information (qui est `a jour) dont dispose un sommet v `a propos des
´etiquettes des arˆetes qui lui sont incidentes et de ses voisins, le sommet v observe si une
r`egle de R peut ˆetre appliqu´ee sur l’´etoile de centre v. Si une telle r`egle peut ˆetre appliqu´ee,
il prend un statut ask et sinon, il prend un statut idle. Ensuite, chaque sommet v consulte
(cid:2) dont le statut
l’´etat de chacun de ses voisins. Si v a le statut ask et s’il a un voisin v
(cid:2)),
(cid:2)) qu’on sait diﬀ´erents. Si n(v) < n(v
est ask, alors on compare les num´eros n(v) et n(v
(cid:2) prend alors le statut idle).
alors v prend le statut idle et sinon v garde le statut ask (v
Si on consid`ere l’ensemble A2i+1 ⊆ V (G) des sommets qui avaient le statut ask au d´ebut
(cid:2)) ≤ n(v)}
de la phase 2i + 1, on sait que chaque sommet de {v ∈ A2i+1 | ∀v
a conserv´e le statut ask `a la ﬁn de la phase 2i + 1. Un sommet qui a conserv´e le statut
ask `a la ﬁn de cette phase (on sait qu’il en existe au moins un) est autoris´e `a simuler une
r`egle de r´e´etiquetage de R.

(cid:2) ∈ A2i+1, n(v

Dans les phases paires de la synchronisation, chaque sommet v observe l’´etat de chacun
(cid:2) reli´ees par une arˆete e se synchronisent
de ses voisins. Lorsque deux sommets voisins v et v
et que le statut de v est ask (cela signiﬁe que v a ´et´e autoris´e `a simuler une r`egle de R),
l’´etiquette λ(e) de l’arˆete e est mise `a jour si n´ecessaire (si l’application de la r`egle simul´ee
(cid:2) connaisse l’´etat de v
modiﬁe l’´etiquette de e) et N(v
et de l’arˆete e pour la phase suivante. Une fois qu’un sommet dont le statut est idle a
vu tous ses voisins durant cette phase, il peut passer `a la phase suivante. Une fois qu’un
sommet dont le statut est ask a vu tous ses voisins, il met `a jour son ´etiquette λ(v) ainsi

(cid:2)) est modiﬁ´ee de fa¸con `a ce que v

74

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

que N(v) (en fonction de la r`egle qu’il a simul´e) et il reprend la statut idle avant de passer
`a la phase de synchronisation suivante.
L’algorithme ainsi d´ecrit assure que dans chaque ´etape de simulation, constitu´ee de
deux phases de synchronisation, une r`egle de R est eﬀectivement simul´ee si l’ex´ecution de
R n’est pas termin´ee.

Pour assurer la terminaison de l’algorithme d´ecrit pr´ec´edemment, on le modiﬁe de la
mani`ere suivante. Un sommet v est autoris´e `a passer `a la phase 2i + 1 seulement si une
r`egle de R peut ˆetre simul´e sur l’´etoile de centre v, ou si v a un voisin v
(cid:2) qui est `a l’´etape
2i + 1.

Propri´et´es de l’Algorithme

Ainsi, si l’ex´ecution ρ ne termine pas, l’ex´ecution ρ

On consid`ere maintenant un graphe G = (G, λ) sur lequel toute ex´ecution de R termine
et une ex´ecution ρ de l’algorithme de simulation sur G. Pour toute x ∈ V (G)∪ E(G), pour
toute ´etape i, on note λi(x) la partie de l’´etiquette de x apr`es le i`eme pas de r´e´etiquetage de
ρ qui correspond `a l’´etiquette de x dans l’algorithme simul´e. On va maintenant construire
une ex´ecution valide de R sur G qui correspond `a l’ex´ecution ρ. Soient i1, i2, . . . , ij, . . . les
´etapes de ρ lors desquelles un sommet v modiﬁe son ´etiquette λ(v). Cela signiﬁe qu’une
(cid:2) de R sur G
r`egle de R a ´et´e simul´ee sur l’´etoile de centre v. On consid`ere l’ex´ecution ρ
o`u `a l’´etape j, on applique sur un sommet v la r`egle qui a ﬁni d’ˆetre simul´ee `a l’´etape
ij sur le sommet v dans l’ex´ecution ρ. En raison de la proc´edure de synchronisation, il
(cid:2) est une ex´ecution valide de R sur G. Par la suite, pour tout
est clair que l’ex´ecution ρ
x ∈ V (G) ∪ E(G) et pour toute ´etape j de ρ
(cid:2)
(cid:2), on note λ
j(x) l’´etiquette de x apr`es le j`eme
(cid:2).
pas de r´e´etiquetage de ρ
(cid:2) ne termine pas, ce qui est impos-
(cid:2)
sible. Si on note λf l’´etiquetage de G obtenu `a partir de la conﬁguration ﬁnale de ρ et λ
(cid:2), il est clair que pour tout x ∈ V (G) ∪ E(G),
f
l’´etiquetage de la conﬁguration ﬁnale de ρ
(cid:2)
λf (x) = λ
f (x) et que dans la conﬁguration ﬁnale de l’algorithme de simulation, tous
les sommets de G ont le statut idle et sont rendus `a la mˆeme phase de simulation. Par
cons´equent, on a bien r´eussi `a trouver un algorithme utilisant des calculs locaux sur les
arˆetes ´etiquet´ees avec connaissance initiale du degr´e qui permet de simuler R.
On suppose maintenant que R permet de r´esoudre un probl`eme P avec d´etection de
la terminaison. On note L l’ensemble d’´etiquettes utilis´es par R et on sait qu’il existe un
ensemble S, une fonction res : L → S et un ensemble Lf ⊆ L tels que les propri´et´es
suivantes sont toujours v´eriﬁ´ees pour tout ex´ecution ρ
f est une solution de P sur G.
(cid:2)

– L’´etiquetage res ◦ λ
– Il existe un sommet v et une ´etape j tels que λj(v)(cid:2) ∈ Lf .
j(v) ∈ Lf , alors pour tout
– S’il existe un sommet v ∈ V (G) et une ´etape j telle que λ
(cid:2)

(cid:2) de R sur G.

(cid:2)

j

j(cid:2) = res ◦ λ
> j, res ◦ λ
(cid:2)
(cid:2)
j.

Pour montrer que l’algorithme de simulation permet de d´etecter la terminaison, on
consid`ere le mˆeme ensemble Lf et la mˆeme fonction res, modulo la projection pour obtenir
λ(v) `a partir de l’´etiquette de v dans l’algorithme de simulation.
Puisqu’on sait que l’algorithme de simulation simule R, on sait que dans la conﬁgura-
tion ﬁnale λf de ρ, res ◦ λf = res ◦ λ
f est une solution de P sur G. De plus, puisque ρ
(cid:2)
(cid:2)
est une ex´ecution valide de R sur G, il existe un sommet v ∈ V (G) et une ´etape j telle
j(v) ∈ Lf et par cons´equent, il existe un sommet v et une ´etape ij lors de laquelle
(cid:2)
que λ

3.6. Importance de la Connaissance du Degr´e

75

j(v) ∈ Lf .
(cid:2)
λij (v) = λ

> j lors de laquelle λ

(cid:2), pour tout sommet v
(cid:2)) (cid:12)= λi(cid:2)(v

(cid:2) ∈ V (G), λij (v

> j telle que λi(cid:2)+1(v

(cid:2) ≥ i et pour tout x ∈ V (G) ∪ E(G), res(λi(cid:2)(x)) = res(λi(x)).

On prouve dans le lemme suivant la derni`ere propri´et´e qui permet d’assurer que l’al-
gorithme de simulation permet de d´etecter la terminaison.
Lemme 3.41 S’il existe un sommet v et une ´etape i telle que λ(i) ∈ Lf , alors pour toute
´etape i
Preuve : On consid`ere un sommet v et une ´etape i lors de laquelle λi(v) ∈ Lf . On
consid`ere la derni`ere ´etape o`u l’´etiquette de v a ´et´e modiﬁ´ee. De part la d´eﬁnition de
j(v) = λij (v) ∈ Lf . D’apr`es
(cid:2), on sait que cela a eu lieu lors d’une ´etape ij et que λ
(cid:2)
ρ
(cid:2)) et pour toute ´etape
la d´eﬁnition de ρ
(cid:2) ≥ ij, si λi(cid:2)+1(v
(cid:2)) = λ
(cid:2)
j(cid:2)(v) et par
i
cons´equent, pour tout i
j(e) (cid:12)= λij (e), cela signiﬁe que e est incidente `a
(cid:2)
(cid:2) dont le statut est ask et qui est en train d’ex´ecuter une phase paire de
un sommet v
l’algorithme de simulation. Puisque toute ex´ecution de l’algorithme de simulation ter-
(cid:2) terminera cette phase. Ainsi,
mine, il existe une ´etape ij(cid:2) > ij de ρ lors de laquelle v
(cid:2)
(cid:2)
j(cid:2)(e) = λij(cid:2) (e) = λij (e) et par cons´equent,
il existe une ´etape j
(cid:2)
(cid:2)
j(e)). Pour les mˆemes raisons que pr´ec´edemment, pour
res(λij (e)) = res(λ
j(cid:2)(e)) = res(λ
(cid:2) ≥ ij et toute arˆete e ∈ E(G) telle que λi(cid:2)+1(e) (cid:12)= λi(cid:2)(e), il existe une ´etape
toute ´etape i
(cid:2) ≥ ij, res(λi(cid:2)(e)) =
(cid:2)
j
res(λ

(cid:2)
(cid:2)) = λ
j(v
(cid:2)
(cid:2)), il existe une ´etape j
(cid:2) ≥ ij, res(λi(cid:2)(v)) = res(λ
(cid:2)
(cid:2)
j(cid:2)(v)) = res(λ
j(v)) = res(λij (v)).

(cid:2)
> j telle que λi(cid:2)+1(e) = λ
j(cid:2)(e) et par cons´equent, pour tout i

(cid:2)
(cid:2)
j(cid:2)(e)) = res(λ
j(e)) = res(λij (e)).

Pour toute arˆete e ∈ E(G), si λ

2

On a donc montr´e la proposition suivante.

Proposition 3.42 Pour tout algorithme R utilisant des calculs locaux sur les ´etoiles
ouvertes, il existe un algorithme utilisant des calculs locaux (cellulaires) sur les arˆetes
´etiquet´ees avec connaissance initiale du degr´e qui simule R.
De plus, si R permet de r´esoudre un probl`eme P sur une famille de graphes F avec
d´etection de la terminaison, alors il existe un algorithme utilisant des calculs locaux (cellu-
laires) sur les arˆetes ´etiquet´ees avec connaissance initiale du degr´e qui permet de r´esoudre
le probl`eme P sur la famille F avec d´etection de la terminaison.

3.6.4 Un Mod`ele Strictement plus Puissant

On va montrer ici que la connaissance initiale du degr´e permet d’obtenir un mod`ele
strictement plus puissant lorsqu’on consid`ere les calculs locaux sur les arˆetes ´etiquet´ees.
Il faut toutefois noter qu’il n’existe pas de graphe G qui n’est pas minimal pour les
revˆetements et qui admette un algorithme d’´election utilisant des calculs locaux sur les
arˆetes ´etiquet´ees avec connaissance du degr´e. Cela est du au fait que si un graphe G est
un revˆetement d’un graphe H `a travers un homomorphisme γ, alors γ pr´eserve le degr´e.
Autrement dit, mˆeme si les sommets connaissent initialement leur degr´e, le lemme de
rel`evement est toujours valide ainsi que le r´esultat d’impossibilit´e de la Proposition 3.22.
On a donc d’apr`es le Th´eor`eme 3.29 et la Proposition 3.42 le th´eor`eme suivant.
Th´eor`eme 3.43 Pour tout graphe simple ´etiquet´e G, les assertions suivantes sont ´equi-
valentes :

1. il existe un algorithme de nommage (ou d’´enum´eration) pour G utilisant des calculs

locaux sur les ´etoiles ouvertes,

76

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

u1

u2

u

(cid:2)
u
1

(cid:2)
u
2

v1

v2

T1

T2

Fig. 12 – Les graphes T1 et T2 sont tous les deux minimaux pour les revˆetements, mai sil
n’existe pas d’algorithme utilisant les calculs locaux sur les arˆetes ´etiquet´ees permettant
de r´esoudre l’´election dans ces deux graphes.

2. il existe un algorithme d’´election et un algorithme de nommage (ou d’´enum´eration)
avec d´etection de la terminaison pour G utilisant des calculs locaux sur les ´etoiles
ouvertes,

3. G est minimal pour les revˆetements.

On va cependant montrer que si on consid`ere le probl`eme de l’´election sur des familles
de graphes, on peut r´esoudre avec la connaissance initiale du degr´e le probl`eme de l’´election
dans des familles de graphes n’admettant pas d’algorithme universel d’´election utilisant
des calculs locaux sur les arˆetes ´etiquet´ees sans connaissance initiale du degr´e.

On consid`ere les deux arbres non-´etiquet´es T1 et T2 de la Figure 12. On sait que ces deux
arbres sont tous les deux minimaux pour les revˆetements. On montre dans la proposition
suivante qu’il n’existe pas d’algorithme utilisant des calculs locaux sur les arˆetes ´etiquet´ees
qui permette de r´esoudre le probl`eme de l’´election sur la famille constitu´ee de ces deux
graphes.
Proposition 3.44 Il n’existe pas d’algorithme R utilisant des calculs locaux sur les arˆetes
´etiquet´ees (sans connaissance initiale du degr´e) qui permette de r´esoudre le probl`eme de
l’´election sur T1 et sur T2.
Preuve : Soit R un algorithme utilisant des calculs locaux sur les arˆetes ´etiquet´ees qui
permet de r´esoudre le probl`eme de l’´election sur l’arbre T2. On consid`ere une ex´ecution ρ
de R sur T2 et on suppose, sans perte de g´en´eralit´e que le sommet v1 a l’´etiquette ´elu et
(cid:2)) de
le sommet v2 l’´etiquette non-´elu. On consid`ere maintenant le sous graphe T (resp. T
(cid:2)) est isomorphe `a
(cid:2)
(cid:2)
T1 induit par les sommets u1 et u2 (resp. u
2). Puisque T (resp. T
1 et u
T2, il existe une ex´ecution de R sur T (resp. T
(cid:2)) tel que u1 (resp. u
(cid:2)
1) obtienne l’´etiquette
2) l’´etiquette non-´elu. On peut donc construire une ex´ecution de R sur
(cid:2)
´elu et u2 (resp. u
T1 de telle sorte que cette ex´ecution atteigne une conﬁguration o`u les deux sommets u1 et
1 ont l’´etiquette ´elu. Puisque l’´etiquette ´elu est une ´etiquette ﬁnale, cela signiﬁe que R
(cid:2)
u
n’est pas un algorithme d’´election pour T1.

2

Cependant, l’algorithme d’´election pour la famille des arbres pr´esent´e dans le Cha-
pitre 1 peut ˆetre impl´ement´e avec des calculs locaux sur les ´etoiles ouvertes et d’apr`es la
Proposition 3.42, on a donc le th´eor`eme suivant.
Th´eor`eme 3.45 Il existe un algorithme d’´election pour la famille des arbres utilisant des
calculs locaux sur les arˆetes ´etiquet´ees avec connaissance initiale du degr´e.

Ainsi, les calculs locaux sur les arˆetes ´etiquet´ees avec connaissance initiale du degr´e
d´eﬁnissent un mod`ele de calcul strictement plus puissant que les calculs locaux sur les
arˆetes ´etiquet´ees sans connaissance initiale du degr´e.

3.6. Importance de la Connaissance du Degr´e

77

3.6.5

´Election dans les Familles de Diam`etre Born´e

On montre dans cette partie que pour pouvoir ´elire dans un graphe G minimal pour
les revˆetements, il n’est pas n´ecessaire de connaˆıtre la taille de G, mais qu’une borne sur
le diam`etre suﬃt si chaque sommet connaˆıt initialement son degr´e. Pour cela, on explique
comment impl´ementer l’algorithme GSSP d´ecrit dans le Chapitre 2 utilisant des calculs
locaux sur les arˆetes ´etiquet´ees avec connaissance du degr´e.

Comme dans le Chapitre 2, l’algorithme qu’on va d´ecrire maintenant va permettre de
v´eriﬁer si tous les sommets du graphe sont d’accord sur la mˆeme boˆıte-aux-lettres. Cet
algorithme utilise des calculs locaux sur les arˆetes ´etiquet´ees et il va donc ˆetre n´ecessaire
que chaque sommet stocke l’information qu’il a `a propos du rayon de conﬁance de ses
voisins. C’est la m´ethode utilis´e dans l’algorithme SSP original [SSP85]. Il faut cependant
faire attention `a r´einitialiser toutes ces informations `a chaque fois qu’un sommet v modiﬁe
sa boˆıte-aux-lettres.
On modiﬁe l’algorithme M pr´esent´e pr´ec´edemment de telle sorte que si l’algorithme
est ex´ecut´e sur un graphe G = (G, λ), l’´etiquette de chaque arˆete est la mˆeme que dans M
et l’´etiquette de chaque sommet v ∈ V (G) est (λ(v), d(v), n(v), N(v), M(v), a(v), A(v)) o`u
les champs λ(v), n(v), N(v) et M(v) ont le mˆeme rˆole que dans l’algorithme M. L’entier
d(v) est le degr´e du sommet v dans le graphe G et sa valeur ne sera pas modiﬁ´ee lors de
l’ex´ecution lors de l’ex´ecution de l’algorithme. L’entier a(v) est le rayon de conﬁance du
sommet v et va jouer le mˆeme rˆole que dans l’algorithme GSSP. L’ensemble A(v) est un
ensemble de couples d’entiers de la forme (p, a) et il va contenir l’information dont dispose
(cid:2)} est
v a propos du rayon de conﬁance de ses voisins : si le num´ero associ´e `a l’arˆete {v, v
p et si (p, a) ∈ A(v) cela signiﬁe que la derni`ere fois que v et v
(cid:2) ont ´echang´e leurs rayons
de conﬁance, la valeur de a(v
Initialement, l’´etiquette de chaque arˆete e ∈ E(G) est (λ(e), 0) comme dans l’algo-
rithme M et l’´etiquette de chaque sommet v ∈ V (G) est (λ(v), d(v), 0,∅,∅,−1,∅).
Les r`egles M1, M2, M3 restent les mˆemes que dans l’algorithme M a la seule diﬀ´erence
que si la boˆıte-aux-lettres d’un sommet v est modiﬁ´ee par l’application d’une de ces r`egles,
alors a(v) est r´einitialis´e `a −1 et la nouvelle valeur de A(v) est {(p,−1) | ∃(p, a) ∈ A(v)}.
En eﬀet, puisque le rˆole de A(v) est de stocker le rayon de conﬁance des voisins de v
par rapport `a la valeur de M(v), il faut r´einitialiser ces informations devenues obsol`etes
`a chaque fois que la boˆıte aux lettres de v est modiﬁ´ee. On note M(cid:2)
3 les r`egles
ainsi obtenues.

(cid:2)) ´etait a.

1, M(cid:2)

2, M(cid:2)

M(cid:2)
1 :

((cid:8)1, d1, n1, N1,

M1, a1, A1)

((cid:8)e, p)

((cid:8)2, d2, n2, N2,
M2, a2, A2)

M2 \ M1 (cid:12)= ∅
Si
1 ∪ M
(cid:2)
(cid:2) := M
(cid:2)
2 ;
alors M
1 := −1 ;
(cid:2)
a
1 := {(p
,−1) | ∃(p
(cid:2)
(cid:2)
A

(cid:2)

, a) ∈ A1}.

((cid:8)1, d1, n1, N1,

M

(cid:2)

(cid:2)
(cid:2)
1)
1, A
, a

((cid:8)2, d2, n2, N2,
M2, a2, A2)

((cid:8)e, p)

78

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

M(cid:2)
2 :

Si
alors

M(cid:2)
3 :

((cid:8), d, n, N, M, a, A)

((cid:8), d, k, N, M

(cid:2)

(cid:2)
, a

(cid:2))
, A

(cid:2)) ∈ M tel que ((cid:8), N) ≺ ((cid:8)

(cid:2)

(cid:2))

, N

(cid:2)) ∈ M} ;

, N

n = 0 ou ∃(n, (cid:8)
(cid:2)
, N
(cid:2) | ∃(n
k := 1 + max{n
(cid:2)
, (cid:8)
(cid:2) := M ∪ {(k, (cid:8), N)} ;
M
(cid:2) := −1 ;
a
(cid:2) := {(p
(cid:2)
A

,−1) | ∃(p

(cid:2)

(cid:2)

, a1) ∈ A}.

((cid:8), d1, n, N,
M, a1, A1)

((cid:8)e, p)

((cid:8), d2, n, N,
M, a2, A2)

((cid:8), d1, k, N,
(cid:2)
(cid:2)
1)
1, A
, a
M

(cid:2)

((cid:8)e, p)

((cid:8), d2, n, N,
(cid:2)
(cid:2)
2)
2, A
, a
M

(cid:2)

Si

alors

(cid:2)) ∈ M} ;

(cid:2)

(cid:2)) ∈ M, ((cid:8)

n > 0 et
(cid:2)) (cid:19) ((cid:8), N)
∀(n, (cid:8)
(cid:2)
, N
, N
(cid:2) | ∃(n
k := 1 + max{n
(cid:2)
(cid:2)
, (cid:8)
, N
(cid:2) := M ∪ {(k, (cid:8), N)} ;
M
1 := −1 ;
(cid:2)
a
1 := {(p
(cid:2)
(cid:2)
A
2 := −1 ;
(cid:2)
a
2 := {(p
(cid:2)
(cid:2)
A

,−1) | ∃(p, a) ∈ A1} ;
,−1) | ∃(p, a) ∈ A2} ;

La r`egle M4 est modiﬁ´ee de telle sorte que si deux sommets voisins v et v

r`egle M4, le couple (p,−1) est ajout´e `a A(v) et A(v
de a(v) et a(v
On note M(cid:2)

(cid:2)) sont r´einitialis´ees ainsi que les informations contenues dans A(v) et A(v
4 la r`egle ainsi obtenue.

(cid:2) appliquent la
(cid:2)). Comme pr´ec´edemment, les valeurs
(cid:2)).

M(cid:2)
4 :

((cid:8)1, d1, n1, N1,

M, a1, A1)

((cid:8)e, 0)

((cid:8), d2, n2, N2,
M, a2, A2)

(cid:2)
1,

((cid:8)1, d1, n1, N
(cid:2)
(cid:2)
1)
1, A
, a

M

(cid:2)

(cid:2)
((cid:8), d2, n2, N
2,
(cid:2)
(cid:2)
2)
2, A
, a
M

(cid:2)

((cid:8)e, p)

Si

alors

(cid:2)
1, N
(cid:2)
2, N

n1 (cid:12)= n2, n1 > 0, n2 > 0,
1) ∈ M, ((cid:8)
1) (cid:19) ((cid:8)1, N1),
∀(n1, (cid:8)
(cid:2)
(cid:2)
(cid:2)
1, N
2) (cid:19) ((cid:8)2, N2) et
2) ∈ M, ((cid:8)
∀(n2, (cid:8)
(cid:2)
(cid:2)
(cid:2)
2, N
(cid:2) | ∃(p
(cid:2)) ∈ N1 ∪ N2} ;
p := 1 + max{p
(cid:2)
(cid:2)
, n
, (cid:8)
1 := N1 ∪ {(p, (cid:8)e, n2)} ;
(cid:2)
N
2 := N2 ∪ {(p, (cid:8)e, n1)} ;
(cid:2)
N
(cid:2) = M ∪ {(n1, N
M
1 := −1 ;
(cid:2)
a
,−1) | ∃(p
1 := {(p
(cid:2)
(cid:2)
A
2 := −1 ;
(cid:2)
a
2 := {(p
,−1) | ∃(p
(cid:2)
(cid:2)
A

, a) ∈ A1} ∪ {(p,−1)} ;
, a) ∈ A2} ∪ {(p,−1)} ;

(cid:2)
1), (n2, N

2)} ;
(cid:2)

(cid:2)

(cid:2)

La r`egle M5 est modiﬁ´ee de la mˆeme mani`ere que les r`egles M1,M2 et M3.

3.6. Importance de la Connaissance du Degr´e

79

M(cid:2)
5 :

((cid:8)1, d1, n1, N1,

M, a1, A1)

((cid:8)e, p)

((cid:8), d2, n2, N2,
M, a2, A2)

(cid:2)
1,

((cid:8)1, d1, n1, N
(cid:2)
(cid:2)
1)
, a
1, A

M

(cid:2)

(cid:2)
((cid:8), d2, n2, N
2,
(cid:2)
(cid:2)
2)
, a
2, A
M

(cid:2)

((cid:8)e, p)

Si

(cid:2)
1, N
(cid:2)
2, N

1) (cid:19) ((cid:8)1, N1),
(cid:2)
2) (cid:19) ((cid:8)2, N2) et
(cid:2)

p > 0, n1 > 0, n2 > 0, n1 (cid:12)= n2,
1) ∈ M, ((cid:8)
∀(n1, (cid:8)
(cid:2)
(cid:2)
1, N
2) ∈ M, ((cid:8)
∀(n2, (cid:8)
(cid:2)
(cid:2)
2, N
(p, (cid:8)e, n2) /∈ N1
2) ∈ N1}) ∪ {(p, (cid:8)e, n2} ;
1 := N1 \ {(p, (cid:8)e, n
(cid:2)
(cid:2)
alors N
2 := N2 \ {(p, (cid:8)e, n
1) ∈ N2}) ∪ {(p, (cid:8)e, n1} ;
(cid:2)
(cid:2)
N
(cid:2) := M ∪ {(n1, (cid:8)1, N
1)} ∪ {(n2, (cid:8)2, N
2)} ;
(cid:2)
(cid:2)
M
1 := −1 ;
(cid:2)
a
, a) ∈ A1} ;
,−1) | ∃(p
1 := {(p
(cid:2)
(cid:2)
(cid:2)
A
2 := −1 ;
(cid:2)
a
2 := {(p
,−1) | ∃(p
, a) ∈ A2} ;
(cid:2)
(cid:2)
A

(cid:2)

Comme dans l’algorithme GSSP pr´esent´e dans le chapitre pr´ec´edent, il faut une r`egle
qui permette `a un sommet d’augmenter son rayon de conﬁance. Un sommet v peut augmen-
ter son rayon de conﬁance s’il ne peut pas appliquer la r`egle M(cid:2)
2, s’il connaˆıt exactement
d(v) voisins (i.e., il existe exactement d(v) couples (p, a) dans A(v)) et si chacun de ses
voisins a un rayon de conﬁance sup´erieur ou ´egal au sien.

M(cid:2)
6 :

((cid:8), d, n, N, M, a, A)

((cid:8), d, k, N, M, a + 1, A)

Cette r`egle est applicable si n > 0,
∀(n, (cid:8)
(cid:2)
, N
|A| = d et
(cid:2)) ∈ A, a
∀(p
(cid:2)
, a

(cid:2)) ∈ M, ((cid:8)
(cid:2) ≥ a.

(cid:2)

, N

(cid:2)) (cid:19) ((cid:8), N)

Il faut enﬁn une derni`ere r`egle qui permette `a deux sommets d’´echanger leurs rayons
de conﬁance une fois que ceux ci ont ´et´e modiﬁ´es par la r`egle pr´ec´edente. Cette r`egle ne
peut ˆetre appliqu´ee sur une arˆete e que si aucune des r`egles M(cid:2)
5 ne
peut ˆetre appliqu´ee sur e.

4,M(cid:2)

2,M(cid:2)

3,M(cid:2)

1,M(cid:2)

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

80

M(cid:2)
7 :

((cid:8)1, d1, n1, N1,

M, a1, A1)

((cid:8)e, p)

((cid:8), d2, n2, N2,
M, a2, A2)

(cid:2)
1,

((cid:8)1, d1, n1, N
(cid:2)
1)
M, a1, A

((cid:8)e, p)

(cid:2)
2,

((cid:8), d2, n2, N
(cid:2)
2)
M, a2, A

Si

1) (cid:19) ((cid:8)1, N1),
(cid:2)
2) (cid:19) ((cid:8)2, N2),
(cid:2)

(cid:2)
1, N
(cid:2)
2, N

1) ∈ M, ((cid:8)
(cid:2)
(cid:2)
1, N
2) ∈ M, ((cid:8)
(cid:2)
(cid:2)
2, N

p > 0, n1 > 0, n2 > 0, n1 (cid:12)= n2,
∀(n1, (cid:8)
∀(n2, (cid:8)
(p, (cid:8)e, n2) ∈ N1, (p, (cid:8)e, n1) ∈ N2 et
(p, a1) /∈ A2 ou (p, a2) /∈ A1
1 := A1 \ {(p, a)} ∪ {(p, a2)} ;
(cid:2)
alors A
2 := A2 \ {(p, a)} ∪ {(p, a1)} ;
(cid:2)
A

On s’int´eresse maintenant aux propri´et´es satisfaites par toute ex´ecution de l’algorithme
M(cid:2). Comme pr´ec´edemment, on consid`ere une ex´ecution de l’algorithme M(cid:2) sur un graphe
´etiquet´e G. Pour tout sommet v ∈ V (G), on note (λ(v), d(v), ni(v), Ni(v), Mi(v), ai(v),
Ai(v)) l’´etiquette du sommet v apr`es la i`eme ´etape de r´e´etiquetage.

Le lemme suivant qui peut ˆetre facilement prouv´e par r´ecurrence sur le nombre d’´etapes
montre que le rayon de conﬁance d’un sommet ne peut qu’augmenter tant que sa boˆıte-
aux-lettres n’est pas modiﬁ´ee.
Lemme 3.46 Pour tout sommet v et toute ´etape i, si Mi(v) = Mi+1(v), alors ai+1(v) ≥
ai(v) et pour tout (p, a) ∈ Ai(v), il existe (p, a
(cid:2) ≥ a ≥ ai+1(v) − 1. De
plus, si ai(v) ≥ 0, alors la r`egle M(cid:2)

2 ne peut ˆetre appliqu´ee sur le sommet v.

(cid:2)) ∈ Ai+1(v) et a

Dans le lemme suivant, on montre que le rayon de conﬁance d’un sommet permet d’ob-
tenir des informations sur le contenu des boˆıtes-aux-lettres d’autres sommets du graphe
lors d’´etapes pr´ec´edentes de l’ex´ecution. Cette propri´et´e est la mˆeme que la propri´et´e de
l’algorithme du Chapitre 2.
Lemme 3.47 Pour tout sommet v ∈ V (G) et toute ´etape i, pour tout sommet w ∈ V (G)
tel que distG(v, w) ≤ ai(v), il existe une ´etape j ≥ i telle que aj(w) ≥ ai(v) − distG(v, w)
et Mj(v) = Mi(v).

Preuve : On fait une d´emonstration par r´ecurrence sur la distance k entre v et w dans
G. Si k = 0, la propri´et´e est trivialement vraie. On suppose maintenant que la propri´et´e
est vraie pour tous sommets v, w tels que distG(v, w) ≤ k.
On consid`ere deux sommets v, w et une ´etape i tels que ai(v) ≥ k + 1 ≥ 1 et
distG(v, w) = k + 1. Il existe un sommet u ∈ NG(v) tels que distG(u, w) = k. On note
e l’arˆete reliant u `a v. On sait que pi(e) > 0 et qu’il existe (pi(e), a) ∈ Ai(v) tel que
a ≥ ai(v) − 1 ≥ 0.
7 a ´et´e appliqu´ee sur l’arˆete e. Lors
de cette ´etape Mj(cid:2)(u) = Mj(cid:2)(v) = Mi(v) et aj(cid:2)(u) = a ≥ ai(v) − 1. Par hypoth`ese de
(cid:2) telle que aj(w) ≥ aj(cid:2)(u)−k ≥ ai(v)−(k+1)
r´ecurrence, on sait qu’il existe une ´etape j < j
et Mj(w) = Mj(cid:2)(u) = Mi(v). Ainsi, la propri´et´e est v´eriﬁ´ee pour tous sommets v, w `a
distance k + 1 dans G.
2

On consid`ere la derni`ere ´etape j

(cid:2) o`u la r`egle M(cid:2)

Comme dans l’algorithme GSSP du Chapitre 2, on montre que si `a un moment donn´e,
un sommet a un rayon de conﬁance sup´erieur au diam`etre du graphe, alors tous les sommets

3.6. Importance de la Connaissance du Degr´e

81

du graphe ont la mˆeme boˆıte-aux-lettres et ont tous un rayon de conﬁance sup´erieur `a 0.
Lemme 3.48 S’il existe un sommet v et une ´etape i telle que ai(v) ≥ D(G) + 1, alors
pour tout w ∈ V (G), Mi(w) = Mi(v) et ai(v) ≥ 0.
Preuve : Puisque ai(v) > D(G), on sait d’apr`es le Lemme 3.47 que pour tout sommet
w ∈ V (G), il existe une ´etape iw < i telle que aiw ≥ 1 et Miw(w) = Mi(v).
Supposons qu’il existe un sommet w tel que Mi(w) (cid:12)= Miw(w). Soit j l’´etape de
l’ex´ecution lors de laquelle pour la premi`ere fois, la boˆıte-aux-lettres d’un sommet w
qui valait Mi(v) a ´et´e modiﬁ´ee. Autrement dit, pour tout sommet w ∈ V (G), il existe
(cid:2) ≥ j − 1 telle que Mj(cid:2)(w) = Mi(v) et il existe un sommet w tel que
une ´etape j
Mj−1(w) = Mi(v) (cid:4) Mj(w). Cela signiﬁe qu’une des r`egles M(cid:2)
4,M(cid:2)
5 a
´et´e appliqu´ee lors de l’´etape j. Soit w un sommet tel que Mj−1(w) (cid:4) Mj(w) ; on sait que
Mj−1(w) = Mi(v) et aj−1(w) ≥ 0. Par cons´equent, d’apr`es le Lemme 3.46, la r`egle M(cid:2)
2
n’a pas pu ˆetre appliqu´ee sur le sommet w.
(cid:2)
On note e l’arˆete sur laquelle une r`egle a ´et´e appliqu´ee lors de l’´etape j et on note w et w
ses extr´emit´es. On suppose que l’´etiquette de w a ´et´e modiﬁ´ee lors de l’´etape j. En raison du
choix de j, on sait que la r`egle M(cid:2)
1 n’a pas pu ˆetre appliqu´ee sur e `a l’´etape j. Par ailleurs,
on sait que aj−1(w) ≥ 1 et par cons´equent, il existe (pj−1(e), a) ∈ Aj−1(e) tel que a ≥
aj−1(v) − 1 ≥ 0. Par cons´equent, cela signiﬁe qu’il existe une ´etape j
< j lors de laquelle
la r`egle M(cid:2)
7 a ´et´e appliqu´ee sur l’arˆete e et de plus, pj(cid:2)(e) = pj−1(e), nj(cid:2)(w) = nj−1(w),
(cid:2)) =
(cid:2)), Nj(cid:2)(w) = Nj−1(w), Nj(cid:2)(w
nj(cid:2)(w
Mj−1(v). Ainsi, on sait qu’aucune des r`egles M(cid:2)
5 ne peut ˆetre appliqu´ee
sur l’arˆete e `a l’´etape j. Par cons´equent, pour tout sommet w ∈ V (G), Mi(w) = Mi(v). 2

(cid:2)) et Mj(cid:2)(w) = Mj(cid:2)(w
4,M(cid:2)

(cid:2)) = nj−1(w

(cid:2)) = Nj−1(w
1,M(cid:2)
3,M(cid:2)

2,M(cid:2)

(cid:2)

1,M(cid:2)

2,M(cid:2)

3,M(cid:2)

Ainsi, si on connaˆıt une borne B sur le diam`etre de G, l’algorithme M(cid:2) permet de
d´etecter que l’ex´ecution de l’algorithme M sous-jacent est termin´e. En eﬀet, une fois qu’un
sommet a un rayon de conﬁance sup´erieur ou ´egal `a B + 1, il sait que tous les sommets de
G ont la mˆeme boˆıte-aux-lettres et qu’ils ont leurs num´eros et vues locales ﬁnaux.

Si on sait que le graphe G est minimal pour les revˆetements, on sait alors d’apr`es
la Proposition 3.28 que tous les sommets ont un identiﬁant unique et dans ce cas l`a, le
sommet dont le num´ero est 1 peut prendre l’´etiquette ´elu et diﬀuser l’information. On a
par cons´equent montr´e le th´eor`eme suivant.
Th´eor`eme 3.49 Pour tout entier B, il existe un algorithme d’´election et un algorithme
de nommage avec d´etection de la terminaison utilisant des calculs locaux sur les arˆetes
´etiquet´ees avec connaissance initiale du degr´e pour la famille des graphes minimaux pour
les revˆetements dont le diam`etre est born´ee par B.

Ainsi, comme dans le mod`ele consid´er´e dans le Chapitre 2, il n’est pas n´ecessaire de
connaˆıtre la taille pour pouvoir ´elire dans un graphe G que l’on sait minimal pour les
revˆetements : une borne sur la taille ou le diam`etre est suﬃsante.

Algorithme Eﬀectif d’´Election

On montre ici qu’en connaissant une borne serr´ee sur la taille d’un graphe G, l’algo-
rithme M(cid:2) permet ou bien de r´esoudre le probl`eme de l’´election sur G, ou bien de d´etecter
que G n’est pas minimal pour les revˆetements.

82

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

C6

(cid:2)
C
6

Fig. 13 – Le graphe C6 qui n’est pas minimal pour les revˆetements est un sous-graphe du
graphe C

(cid:2)
6 qui est minimal pour les revˆetements.

Th´eor`eme 3.50 Pour tout entier B, il existe un algorithme eﬀectif d’´election et de nom-
mage avec d´etection de la terminaison utilisant des calculs locaux sur les arˆetes ´etiquet´ees
avec connaissance initiale du degr´e pour la classe des graphes G tels que V (G) ≤ B <
2|V (G)|.
Preuve : On sait d’apr`es la Proposition 3.28 et le Lemme 3.48 qu’avec la connaissance
d’une borne serr´ee B sur la taille d’un graphe G, toute ex´ecution de M(cid:2) sur G permet
de construire un graphe H tel que G est un revˆetement de H. Si G est un revˆetement
propre de H, on sait d’apr`es la Proposition 3.5 que 2|V (H)| ≤ |V (G)|. Puisque |V (G)| ≤
B < 2|V (G), on sait que si G est un revˆetement propre de H, 2|V (H)| ≤ B et que si G
est isomorphe `a H, B < 2|V (G)| = 2|V (H)|. Par cons´equent, il suﬃt de tester si la taille
du graphe H construit `a partir de l’´etiquetage ﬁnal obtenu apr`es l’ex´ecution de M(cid:2) sur
G v´eriﬁe l’in´egalit´e 2|V (H)| ≤ B. Si l’in´egalit´e est v´eriﬁ´ee, alors le graphe G n’est pas
minimal pour les revˆetements, et dans le cas contraire, le graphe H est isomorphe `a G et
on peut donc r´esoudre l’´election et le nommage avec d´etection de la terminaison sur G. 2

Comme dans le cas des calculs locaux sur les ´etoiles ferm´ees, on remarque que si
la borne sur la taille de G n’est pas serr´ee, il n’existe pas d’algorithme utilisant des
calculs locaux sur les arˆetes ´etiquet´ees avec connaissance initiale du degr´e qui permet de
r´esoudre le probl`eme de l’´election sur G ou de d´etecter que G n’est pas minimal pour les
revˆetements.

On montre maintenant que si initialement les sommets ne connaissent pas leurs degr´es,
mˆeme en connaissant la taille n du graphe G, si celle-ci n’est pas un nombre premier (sinon,
d’apr`es la Remarque 3.30, on peut ´elire dans la famille des graphes de taille n puisque
ceux-ci sont tous minimaux pour les revˆetements), il n’existe pas d’algorithme utilisant
des calculs locaux sur les arˆetes ´etiquet´ees qui permet de r´esoudre le probl`eme de l’´election
sur G ou de d´etecter que G n’est pas minimal pour les revˆetements.

Pour tout entier n qui n’est pas premier, soit Cn le cycle de taille n et C

(cid:2)
n le graphe
obtenu en choisissant un sommet quelconque du cycle de taille n et en le reliant `a tous les
autres sommets. Sur la Figure 13, on a repr´esent´e les graphes C6 et C

(cid:2)
6.

3.7. Conclusion et Perspectives

83

On suppose qu’il existe un algorithme eﬀectif d’´election R pour la classe des graphes
de taille n utilisant des calculs locaux sur les arˆetes ´etiquet´ees sans connaissance initiale
du degr´e. Puisque Cn n’est pas minimal pour les revˆetements, il existe une ex´ecution ρ de
R sur Cn telle que dans la conﬁguration ﬁnale de ρ, chaque sommet de Cn a un ´etiquette
ﬁnale indiquant que Cn n’est pas minimal pour les revˆetements. Cependant, Cn est un
(cid:2)
(cid:2) sur C
n dont le
sous-graphe de C
(cid:2)
(cid:2)
n ont une
n, tous les sommets de C
pr´eﬁxe est ρ. Puisqu’une fois que ρ est ex´ecut´ee sur C
´etiquette ﬁnale, ces ´etiquettes ne sont pas modiﬁ´ees par la suite et par cons´equent, il existe
une ex´ecution de R sur C
(cid:2)
(cid:2)
n telle que dans la conﬁguration ﬁnale, tous les sommets de C
n
(cid:2)
ont conclu que le graphe C
n n’est pas minimal pour les revˆetements, ce qui est faux.

(cid:2)
n et par cons´equent on peut trouver une ex´ecution ρ

Dans le Th´eor`eme 3.50, on suppose que chaque sommet connaˆıt initialement son degr´e
ainsi qu’une borne serr´ee sur la taille du graphe. On a donc montr´e qu’on ne pouvait pas
aﬀaiblir le th´eor`eme en ne conservant qu’une seule de ces hypoth`eses.

3.7 Conclusion et Perspectives

Dans ce chapitre, on a montr´e l’´equivalence entre les calculs locaux sur les arˆetes
´etiquet´ees et les calculs locaux cellulaires sur les arˆetes ´etiquet´ees (Proposition 3.20). Notre
algorithme de simulation utilise le fait que les arˆetes du graphe peuvent ˆetre ´etiquet´ees et
r´e´etiquet´ees. On va voir dans les chapitres suivants qu’il n’existe pas de th´eor`eme similaire
lorsqu’on ne peut pas modiﬁer les ´etiquettes des arˆetes.

On a ensuite pr´esent´e une caract´erisation des graphes admettant un algorithme d’´elec-
tion (ou de nommage) utilisant des calculs locaux (cellulaires) sur les arˆetes ´etiquet´ees
(Th´eor`eme 3.29). Cette caract´erisation s’exprime `a l’aide des revˆetements de graphes pou-
vant avoir des arˆetes multiples.

Ce r´esultat nous permet de penser qu’il est possible d’utiliser les techniques pr´esent´ees
dans [GM03, GMM04] aﬁn de caract´eriser les classes de graphes qui peuvent ˆetre recon-
nues par des calculs locaux (cellulaires) sur les arˆetes ´etiquet´ees avec ou sans connaissance
initiale (la terminaison est alors implicite). Il semble que lorsqu’aucune connaissance ini-
tiale n’est disponible, les classes de graphes simples reconnaissables dans ce mod`ele doivent
v´eriﬁer les mˆemes propri´et´es que celles pr´esent´ees dans [GMM04]. En revanche, lorsqu’on
dispose d’une connaissance initiale, on peut reconnaˆıtre strictement moins de classes de
graphes en utilisant des calculs locaux (cellulaires) sur les arˆetes ´etiquet´ees qu’avec des
calculs locaux sur les ´etoiles ferm´ees.

Dans la Section 3.6, on a ´etudi´e l’importance de la connaissance initiale du degr´e.
On a montr´e que le mod`ele des calculs locaux (cellulaires) avec connaissance initiale du
degr´e avait la mˆeme puissance de calcul que les calculs locaux sur les ´etoiles ouvertes
(Proposition 3.42), que le mod`ele d’Angluin et que le mod`ele o`u la communication entre
deux processus est synchrone (Section 3.6.1). On a aussi montr´e qu’avec la connaissance
initiale du degr´e, la connaissance initiale d’une borne sur le diam`etre du graphe per-
mettait de r´esoudre ´election et nommage dans un graphe minimal pour les revˆetements
(Th´eor`eme 3.49) et que la connaissance d’une borne serr´ee sur la taille du graphe permet-
tait d’obtenir un algorithme eﬀectif de nommage et d’´election (Th´eor`eme 3.50).

Ces r´esultats nous permettent de penser que les techniques utilis´ees dans [GM02,
MT00] peuvent ˆetre ´etendus aux calculs locaux (cellulaires) sur les arˆetes ´etiquet´ees avec

84

Chapitre 3. Calculs Locaux sur les Arˆetes ´Etiquet´ees

connaissance initiale du degr´e aﬁn de caract´eriser les classes de graphes qui admettent
un algorithme universel d’´election dans ce mod`ele et plus g´en´eralement de caract´eriser
les fonctions qui peuvent ˆetre calcul´ees avec d´etection de la terminaison. En revanche, il
ne semble pas possible d’obtenir des caract´erisations aussi ´el´egantes que celles pr´esent´ees
dans [GM02, MT00] si les sommets ne connaissent pas initialement leur degr´e.

Par ailleurs, mˆeme si chaque sommet connaˆıt initialement son degr´e, l’algorithme
d’´enum´eration auto-stabilisant de Godard pr´esent´e dans [God02b] ne semble pas pou-
voir ˆetre ´etendu aux mod`eles consid´er´es dans ce chapitre. Contrairement au mod`ele ´etudi´e
dans le Chapitre 2, dans le mod`ele des calculs locaux sur les arˆetes ´etiquet´ees, un sommet
ne peut pas forc´ement se rendre compte que l’information dont il dispose `a propos de ses
voisins (sa vue locale) est erronn´ee.

Chapitre 4

Calculs Locaux Cellulaires sur les
´Etoiles

Sommaire
4.1

. . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.3.1 D´eﬁnitions
4.3.2 Fibrations et Calculs Locaux Cellulaires sur les ´Etoiles . . . . . .

Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
86
4.1.1 Caract´erisations
4.1.2 Travaux Li´es
86
4.2 Fibrations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
4.3 Calculs Locaux Cellulaires sur les ´Etoiles . . . . . . . . . . . . . 91
91
94
4.4 Nommage et ´Enum´eration . . . . . . . . . . . . . . . . . . . . . . 94
4.4.1 R´esultats d’Impossibilit´e pour l’´Enum´eration et le Nommage . .
94
4.4.2 Un Algorithme d’´Enum´eration . . . . . . . . . . . . . . . . . . .
95
4.4.3 Correction de l’Algorithme d’´Enum´eration . . . . . . . . . . . . .
97
4.4.4 Complexit´e . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
4.4.5
. . . . . . . . . . . . . . 102
´Election . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
4.5.1 R´esultats d’Impossibilit´e . . . . . . . . . . . . . . . . . . . . . . . 103
4.5.2 Un Algorithme d’´Election . . . . . . . . . . . . . . . . . . . . . . 104
4.5.3 Des Algorithmes Eﬀectifs de Nommage et d’´Election . . . . . . . 106
4.6 Conclusions et Perspectives . . . . . . . . . . . . . . . . . . . . . 107

Importance des Connaissances Initiales

4.5

4.1

Introduction

Dans ce chapitre, on ´etudie les calculs locaux cellulaires sur les ´etoiles. Contrairement
aux mod`eles ´etudi´es dans les Chapitres 2 et 3, dans les graphes consid´er´es dans ce chapitre,
seuls les sommets peuvent ˆetre ´etiquet´es. Dans ce mod`ele, en un pas de calcul, un sommet
peut modiﬁer son ´etat en fonction de son propre ´etat et de l’´etat de ses voisins. Les
calculs r´ealis´es en utilisant uniquement ce type de r´e´etiquetage sont appel´es calculs locaux
cellulaires sur les ´etoiles. La diﬀ´erence avec les calculs locaux sur les ´etoiles ouvertes est
que les arˆetes du graphe ne peuvent pas ˆetre ´etiquet´ees (et r´e´etiquet´ees) et on va voir

85

86

Chapitre 4. Calculs Locaux Cellulaires sur les ´Etoiles

que le mod`ele obtenu a une puissance de calcul strictement plus faible que le mod`ele des
calculs locaux sur les ´etoiles ouvertes.

Dans ce chapitre, on pr´esente principalement des r´esultats obtenus par Boldi et al.
[BCG+96]. Il faut cependant noter que les m´ethodes utilis´ees dans ce chapitre sont diﬀ´e-
rentes de celles de Boldi et al. Les m´ethodes d´evelopp´ees ici sont inspir´ees des r´esultats
de Mazurkiewicz [Maz97] ainsi que des r´esultats de Godard et M´etivier [GM02]. L’int´erˆet
de cette ´etude est de pr´esenter dans ce m´emoire une pr´esentation compl`ete des r´esultats
existants pour les diﬀ´erents mod`eles de calculs locaux. Il faut aussi noter que l’algorithme
d’´enum´eration qu’on pr´esente dans la Section 4.4 n´ecessite que chaque sommet ait une
m´emoire de taille polynomiale en la taille du graphe, alors que l’algorithme de Boldi et
al. n´ecessite une m´emoire de taille exponentielle. Par ailleurs, les r´esultats portant sur les
familles de graphes dans la Section 4.5 utilisent le fait que le graphe sur lequel est ex´ecut´e
l’algorithme est un graphe simple, alors que dans [BCG+96], Boldi et al. ne font pas cette
hypoth`ese : les m´ethodes et r´esultats pr´esent´es sont donc l´eg`erement diﬀ´erents.

4.1.1 Caract´erisations

Dans le mod`ele des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees, on pr´esente la
caract´erisation de Boldi et al. [BCG+96] des graphes admettant un algorithme de nommage
et des graphes admettant un algorithme d’´election. Contrairement aux mod`eles ´etudi´es
dans les Chapitres 2 et 3, les deux probl`emes ne sont pas ´equivalents dans le mod`ele
consid´er´e dans ce chapitre. Ces caract´erisations sont bas´ees sur la notion de ﬁbrations
dont les propri´et´es ont ´et´e ´etudi´ees par Boldi et Vigna dans [BV02a].

Dans le mod`ele ´etudi´e dans ce chapitre, un graphe admet un algorithme de nommage
si et seulement s’il est minimal pour les ﬁbrations discr`etes (Th´eor`eme 4.22). L’algorithme
d’´enum´eration qu’on pr´esente dans la Section 4.4 est adapt´e de l’algorithme de Mazurkie-
wicz et est tr`es diﬀ´erent de l’algorithme de Boldi et al. utilis´e dans [BCG+96]. Dans ce
mod`ele, un graphe admet un algorithme d’´election si et seulement s’il est minimal pour
les ﬁbrations discr`etes non-triviales (Th´eor`eme 4.33).

On ´etudie ensuite l’importance des connaissances initiales dans ce mod`ele. On montre
qu’il suﬃt de connaˆıtre une borne sur le diam`etre pour pouvoir nommer dans un graphe
minimal pour les ﬁbrations discr`etes (Th´eor`eme 4.28). De mˆeme, la connaissance d’une
borne sur le diam`etre est suﬃsante pour pouvoir ´elire dans un graphe minimal pour les
ﬁbrations discr`etes non-triviales (Th´eor`eme 4.34). Par ailleurs, la connaissance d’une borne
serr´ee sur la taille permet d’obtenir des algorithmes eﬀectifs de nommage et d’´election
(Th´eor`emes 4.36 et 4.37).

4.1.2 Travaux Li´es

Les r´esultats pr´esent´es dans ce chapitre correspondent aux r´esultats obtenus par Boldi
et al [BCG+96] et par Boldi et Vigna [BV99, BV01] dans le mod`ele entrelac´e, i.e., deux
sommets voisins ne peuvent pas modiﬁer leurs ´etats simultan´ement. Ces auteurs ont aussi
´etudi´e une variante synchrone, o`u lors d’une ´etape de calcul, tous les sommets du graphe
modiﬁent leurs ´etats en fonction de l’´etat de tous leurs voisins.

Dans [RFH72], Rosenstiehl et al. ont introduit ce type de mod`ele synchrone sous le nom
de graphes intelligents. Leur mod`ele est assez proche du mod`ele des automates cellulaires,

4.2. Fibrations

87

puisqu’il est synchrone et que chaque processus est une machine `a ´etat ﬁni ; cependant,
le syst`eme de communication est mod´elis´e par un graphe ﬁni et non par une structure
r´eguli`ere inﬁnie. Le probl`eme de l’´election a ´et´e ´etudi´e dans ce cadre pour certaines classes
de graphes planaires par Nichitiu et al. [NMR01, NPR04].

4.2 Fibrations

Dans ce chapitre, on a besoin de consid´erer des graphes dirig´es sans boucle aﬁn de
pouvoir exprimer des conditions n´ecessaires et suﬃsantes pour qu’un graphe admette un
algorithme de nommage ou d’´election utilisant des calculs locaux cellulaires sur les ´etoiles
non-´etiquet´ees.

Les ﬁbrations sont les homomorphismes de graphes dirig´es qui pr´eservent le voisinage
sortant de chaque sommet. Les ﬁbrations ont ´et´e introduites par Boldi et al. [BCG+96]
pour ´etudier le probl`eme de l’´election dans plusieurs mod`eles, dont le mod`ele consid´er´e
dans ce chapitre. Les d´eﬁnitions et propri´et´es pr´esent´ees ici sont dues `a Boldi et Vigna
[BV02a].

Une ﬁbration est un homomorphisme de graphe ´etiquet´e qui induit une bijection entre

les arcs entrants d’un sommet et les arcs entrants de son image.
D´eﬁnition 4.1 Un graphe dirig´e D est ﬁbr´e sur un graphe dirig´e D
morphisme γ : D → D
existe un unique arc a ∈ A(D) tel que t(a) = v et ϕ(a) = a
(cid:2).

(cid:2) si pour tout arc a

(cid:2) ∈ A(D

(cid:2)) et pour tout sommet v ∈ γ

On dit alors que l’homomorphisme γ est une ﬁbration de D dans D

(cid:2) `a travers un homo-
(cid:2))), il
(cid:2). Un graphe dirig´e

−1(t(a

D est ﬁbr´e proprement sur D

(cid:2) si γ n’est pas un isomorphisme.

(cid:2)

(D

(cid:2)) `a travers γ si D est ﬁbr´e sur D

Naturellement, un graphe dirig´e ´etiquet´e (D, λ) est ﬁbr´e sur un graphe dirig´e ´etiquet´e
, λ
Puisqu’on ne consid`ere que des graphes dirig´es fortement connexes, toute ﬁbration est

(cid:2) `a travers γ et si γ conserve l’´etiquetage.

un homomorphisme surjectif.
Proposition 4.2 Si un graphe dirig´e D est ﬁbr´e sur un graphe dirig´e D(cid:2) fortement
connexe `a travers un homomorphisme γ, alors γ est surjectif.
Preuve : On consid`ere deux graphes dirig´es fortement connexes D et D(cid:2) tels que D soit
ﬁbr´e sur D(cid:2) `a travers une ﬁbration γ.
(cid:2). Puisque γ est
(cid:2)). Ainsi, pour tout arc
un homomorphisme, on sait que γ(s(a)) = s(a
(cid:2) ∈ γ(A(D)), s(a
a
(cid:2)) tel que
On consid`ere maintenant un sommet v
(cid:2). On consid`ere un sommet v ∈ γ
(cid:2)) = v
(cid:2)). Puisque γ est une ﬁbration, il existe un
t(a
(cid:2) ∈ A(D), si
arc a ∈ A(D) tel que t(a) = v et ϕ(a) = a
(cid:2)) ∈ γ(V (D)), alors a
t(a
Puisque le graphe dirig´e D(cid:2) est fortement connexe, l’homomorphisme γ est donc sur-

(cid:2) ∈ γ(V (D)) et un arc a
−1(v
(cid:2). Par cons´equent, pour tout arc a

(cid:2) ∈ A(D
(cid:2)) appartiennent `a γ(V (D)).

On consid`ere un arc a
(cid:2)) et t(a

(cid:2)) et un arc a ∈ A(D) tels que γ(a) = a

(cid:2)) et γ(t(a)) = t(a

(cid:2) ∈ γ(A(D)).

(cid:2) ∈ A(D

jectif.

2

On ne consid`ere dans ce chapitre que des graphes dirig´es sans boucle fortement con-
nexes. En particulier si un graphe dirig´e D est ﬁbr´e sur un graphe dirig´e sans boucle D(cid:2),

88

Chapitre 4. Calculs Locaux Cellulaires sur les ´Etoiles

pour tout arc a ∈ A(D), on sait que γ(s(a)) (cid:12)= γ(t(a)) et cela implique que D ne contient
pas de boucle. On d´eﬁnit maintenant les graphes minimaux pour les ﬁbrations discr`etes.
D´eﬁnition 4.3 Un graphe dirig´e fortement connexe sans boucle D est minimal pour les
ﬁbrations discr`etes si D n’est ﬁbr´e proprement sur aucun autre graphe dirig´e sans boucle
fortement connexe.

Un graphe simple G est minimal pour les ﬁbrations discr`etes si Dir(G) est minimal

pour les ﬁbrations discr`etes.

On d´eﬁnit maintenant les ﬁbrations non-triviales qui sont les ﬁbrations telles que

l’image inverse de chaque sommet n’est pas r´eduite `a un singleton.
D´eﬁnition 4.4 Si un graphe dirig´e D est ﬁbr´e sur un graphe dirig´e fortement connexe D(cid:2)
`a travers une ﬁbration γ, pour tout sommet v ∈ V (D
−1(v) est la ﬁbre de
−1(v)| = 1
v. La ﬁbre d’un sommet v est triviale si elle est r´eduite `a un singleton, i.e., |γ
et non-triviale sinon.
D est non-trivialement ﬁbr´e sur D(cid:2).

La ﬁbration γ est non-triviale si toutes ses ﬁbres sont non-triviales. On dit alors que

(cid:2)), l’ensemble γ

Les graphes dirig´es minimaux pour les ﬁbrations discr`etes non-triviales sont les graphes

qui ne sont pas ﬁbr´es non-trivialement sur un autre graphe dirig´e.
D´eﬁnition 4.5 Un graphe dirig´e fortement connexe sans boucle D est minimal pour les
ﬁbrations discr`etes non-triviales si D n’est ﬁbr´e non-trivialement sur aucun autre graphe
dirig´e sans boucle fortement connexe.

Un graphe simple G est minimal pour les ﬁbrations discr`etes non-triviales si Dir(G)

est minimal pour les ﬁbrations discr`etes non-triviales.

Dans la proposition suivante, on montre le lien entre les revˆetements et les ﬁbrations.
On remarque que si G et H sont deux graphes non-dirig´es, ils ne contiennent pas de boucle
et par cons´equent, ni Dir(G), ni Dir(H) ne contient de boucle.
Proposition 4.6 Pour tous graphes ´etiquet´es G, H, si G est un revˆetement de H, alors
Dir(G) est ﬁbr´e sur Dir(H).

Preuve : On consid`ere deux graphes G = (G, λ), H = (H, η). On sait que Dir(G) et
Dir(H) sont deux graphes dirig´es fortement connexes sym´etriques. De plus, pour toute
arˆete e ∈ E(G) dont les extr´emit´es sont u et u
(cid:2), il existe deux arcs ae,u,u(cid:2), ae,u(cid:2),u ∈
A(Dir(G)) tels que s(ae,u,u(cid:2)) = t(ae,u(cid:2),u) = u et Sym(ae,u,u(cid:2)) = ae,u(cid:2),u. De mˆeme, pour
(cid:2), il existe deux arcs af,v,v(cid:2), af,v(cid:2),v ∈
toute arˆete f ∈ E(H) dont les extr´emit´es sont v et v
A(Dir(H)) tels que s(af,v,v(cid:2)) = t(af,v(cid:2),v) = v et Sym(af,v,v(cid:2)) = af,v(cid:2),v.
Si G est un revˆetement de H `a travers un homomorphisme γ, on consid`ere l’ho-
momorphisme ϕ de Dir(G) dans Dir(H) tel que pour tout u ∈ V (Dir(G)) = V (G),
ϕ(u) = γ(u), et pour tout arc ae,u,u(cid:2) ∈ A(G), ϕ(ae,u,u(cid:2)) = aγ(e),γ(u),γ(u(cid:2)). Pour tout arc
af,v,v(cid:2) ∈ A(Dir(H)), on sait qu’il existe une arˆete f ∈ E(H) incidente `a v
(cid:2). Par cons´equent,
(cid:2)), on sait qu’il existe une unique arˆete e
pour tout sommet u
(cid:2), on sait que
incidente `a u
γ(u) = v puisque γ est un homomorphisme. Ainsi, ϕ(ae,u,u(cid:2)) = af,v,v(cid:2) et puisqu’il existe
(cid:2) telle que γ(e) = f, on sait qu’il existe un unique arc
une unique arˆete e incidente `a u
a ∈ A(Dir(G)) tel que t(a) = u
(cid:2) et ϕ(a) = af,v,v(cid:2). Le graphe dirig´e Dir(G) est donc ﬁbr´e
sur Dir(H) `a travers l’homomorphisme ϕ.

(cid:2) telle que γ(e) = f. Si on note u l’extr´emit´e de e diﬀ´erente de u

−1(t(af,v,v(cid:2))) = γ

2

(cid:2) ∈ ϕ

−1(v

4.2. Fibrations

89

1

2

1

2

3

3

4

4

4

γ

3

1

2

1

2

G

Dir(G)

3

3

1

D

2

Fig. 14 – Le graphe Dir(G) est ﬁbr´e proprement sur le graphe D `a travers un homomor-
phisme γ qui envoie chaque sommet ´etiquet´e i de Dir(G) sur l’unique sommet ´etiquet´e i
de D.

Par cons´equent, pour tout graphe G, si Dir(G) est minimal pour les ﬁbrations dis-
cr`etes, alors G est minimal pour les revˆetements. Il faut cependant noter qu’il existe des
graphes minimaux pour les revˆetements qui ne sont pas minimaux pour les ﬁbrations
discr`etes ou pour les ﬁbrations discr`etes non-triviales. De tels exemples sont pr´esent´es sur
les Figures 14 et 15.

Exemple 4.7 Le graphe G de la Figure 14 et le graphe H de la Figure 15 sont minimaux
pour les revˆetements puisqu’ils ont un nombre premier de sommets.

Le graphe Dir(G) est ﬁbr´e proprement sur le graphe dirig´e sans boucle D et n’est donc
pas minimal pour les ﬁbrations discr`etes. Cependant, on note que le graphe Dir(G) est
minimal pour les ﬁbrations discr`etes non-triviales.

Le graphe Dir(H) est ﬁbr´e non-trivialement sur le graphe dirig´e sans boucle D(cid:2) et n’est

donc pas minimal pour les ﬁbrations discr`etes non-triviales.

Le graphe D de la Figure 14 et le graphe D(cid:2) de la Figure 15 sont minimaux pour les

ﬁbrations discr`etes.

90

Chapitre 4. Calculs Locaux Cellulaires sur les ´Etoiles

2

2

2

1

H

2

2

2

1

Dir(H)

1

1

1

2

D(cid:2)

Fig. 15 – Le graphe Dir(H) est ﬁbr´e non-trivialement sur le graphe D(cid:2) `a travers un
homomorphisme γ qui envoie chaque sommet ´etiquet´e i de Dir(H) sur l’unique sommet
´etiquet´e i de D(cid:2).

La notion de coloration semi-r´eguli`ere permet de caract´eriser les graphes simples non-
´etiquet´es qui ne sont pas minimaux pour les ﬁbrations discr`etes en termes de colorations
de graphes. Un ´etiquetage (cid:8) d’un graphe simple non-´etiquet´e est une coloration r´eguli`ere
si deux sommets voisins ont des couleurs distinctes et si deux sommets qui ont la mˆeme
couleur ont les mˆemes couleurs dans leur voisinage avec la mˆeme multiplicit´e.
D´eﬁnition 4.8 Une coloration semi-r´eguli`ere d’un graphe simple G est un ´etiquetage (cid:8)
de G tel que

– pour tout i ∈ (cid:8)(V (G)), G[i] est un stable,
– pour tout i, j ∈ (cid:8)(V (G)) avec i (cid:12)= j, G[i, j] est un stable, ou alors G[i, j] est un

graphe biparti semi-r´egulier.

Dans la proposition suivante, on caract´erise les graphes simples non-´etiquet´es qui sont
minimaux pour les ﬁbrations discr`etes `a l’aide de la notion de coloration semi-r´eguli`ere.
On rappelle qu’une coloration (cid:8) est dite propre si |(cid:8)(V (G))| < |V (G)|.
Proposition 4.9 Un graphe simple non-´etiquet´e G est minimal pour les ﬁbrations dis-
cr`etes si et seulement si il n’admet pas de coloration semi-r´eguli`ere propre.

−1((cid:8)(v))|.

Un graphe simple non-´etiquet´e G est minimal pour les ﬁbrations discr`etes non-triviales
si et seulement si pour toute coloration semi-r´eguli`ere (cid:8) de G, il existe un sommet v de G
tel que |(cid:8)
Preuve : On consid`ere un graphe dirig´e fortement connexe sans boucle D tel que Dir(G)
est ﬁbr´e sur D `a travers une ﬁbration γ. On va montrer que γ est une coloration semi-
r´eguli`ere de G et que l’ensemble des couleurs utilis´es est V (D). Puisque D ne contient
pas de boucle, pour toute arˆete {u, u
(cid:2)). Pour tous v, v
(cid:2)), on
note d(v(cid:2),v) le nombre d’arcs a ∈ A(D
(cid:2) et t(a) = v. Pour tout sommet
u ∈ γ
(cid:2). Par cons´equent,
le graphe G[v, v

(cid:2)} ∈ E(G), γ(u) (cid:12)= γ(u
(cid:2)) tels que s(a) = v
(cid:2)] est un graphe ((d(v(cid:2),v), d(v,v(cid:2) ))-r´egulier.

−1(v), il existe exactement d(v(cid:2),v) voisins u

(cid:2) ∈ V (D

(cid:2) de u tels que γ(u

(cid:2)) = v

4.3. Calculs Locaux Cellulaires sur les ´Etoiles

91

Ainsi, si G n’est pas minimal pour les ﬁbrations discr`etes, il existe un graphe dirig´e
fortement connexe sans boucle tel que G est ﬁbr´e proprement sur D `a travers une ﬁbration
γ et donc |γ(V (G))| < |V (G)|. Ainsi, γ est une coloration semi-r´eguli`ere propre de G.

Si G n’est pas minimal pour les ﬁbrations discr`etes non-triviales, il existe un grape
dirig´e fortement connexe sans boucle tel que G est ﬁbr´e non-trivialement sur D `a travers
une ﬁbration γ. Ainsi, γ est une coloration semi-r´eguli`ere de G telle que pour tout u ∈
V (G), |γ

−1(γ(u))| > 1.

(cid:2) ∈ V (D

(cid:2) ∈ V (D

(cid:2)), le graphe G[v, v

(cid:2) tel que Dir(G) soit ﬁbr´e sur D

(cid:2)) est construit de telle sorte que pour tous v, v

R´eciproquement, ´etant donn´ee une coloration semi-r´eguli`ere (cid:8) d’un graphe G, on va
(cid:2). On pose V (D
(cid:2)) = (cid:8)(V (G)). Pour
d´eﬁnir un graphe D
(cid:2)] est semi-r´egulier et il existe donc un entier d(v(cid:2),v) tel
tous v, v
que chaque sommet u ∈ (cid:8)
−1(v) ait exactement d(v(cid:2),v) voisins dans (cid:8)
−1(v
(cid:2)). L’ensemble
(cid:2)), A(D
(cid:2)) contient alors
A(D
(cid:2)
(cid:2)
(cid:2)
(cid:2) et t(a
(cid:2)
d(v(cid:2),v),(v(cid:2),v) tels que s(a
exactement d(v(cid:2),v) arcs a
i,(v(cid:2),v)) = v
i,(v(cid:2),v)) = v
1,(v(cid:2),v), . . . , a
pour tout i ∈ [1, d(v(cid:2) ,v)]. On d´eﬁnit γ de la mani`ere suivante. Pour tout u ∈ V (Dir(G)),
(cid:2)), consid`ere l’ensemble Au,v(cid:2) ∈ A(Dir(G)) des arcs
(cid:2) ∈ V (D
γ(u) = (cid:8)(u) et pour tout v
a tels que t(a) = u et (cid:8)(s(a)) = v. On sait que Au,v(cid:2) contient exactement d(v(cid:2),(cid:5)(u)) arcs
i,(v(cid:2),(cid:5)(u)) pour tout i ∈ [1, d(v(cid:2) ,(cid:5)(u))]. Il
(cid:2)
a1,(v(cid:2),u), . . . , ad(v(cid:2),(cid:3)(u)),(v(cid:2),u) et on d´eﬁnit γ(ai,(v(cid:2),u)) = a
i,(v,v(cid:2)) ∈ A(D
(cid:2)), pour tout u ∈ γ1(v), il
est clair que pour tout v ∈ V (D
(cid:2)
(cid:2)), pour tout arc a
existe un unique arc ai,(u,v(cid:2)) ∈ A(Dir(G)) tel que t(ai,(u,v(cid:2))) = u. Par cons´equent, puisqu’il
n’existe pas deux sommets adjacents de G qui ont la mˆeme image par (cid:8), G est ﬁbr´e sur γ
`a travers D.
Si (cid:8) est une coloration semi-r´eguli`ere propre de G, alors |V (D)| = |(cid:8)(V (G))| < |V (G)|
(cid:2)), alors pour tout v ∈
Si pour tout u ∈ V (G), il existe u
(cid:2)
−1(v)| > 2 et G est donc ﬁbr´e non-trivialement sur D `a travers γ. 2

et G n’est donc pas isomorphe `a D. Ainsi, G est ﬁbr´e proprement sur D `a travers γ.
V (D) = (cid:8)(V (G)), |γ

(cid:12)= u tel que (cid:8)(u) (cid:12)= (cid:8)(u

4.3 Calculs Locaux Cellulaires sur les ´Etoiles

Dans cette partie, on pr´esente les d´eﬁnitions formelles des calculs locaux cellulaires sur
les ´etoiles, puis on ´etudie leurs relations avec les ﬁbrations. Le mod`ele des calculs locaux
cellulaires sur les ´etoiles a ´et´e introduit ´et ´etudi´e par Boldi et al. [BCG+96].

4.3.1 D´eﬁnitions

On d´eﬁnit d’abord les calculs locaux cellulaires sur les ´etoiles pour les graphes simples,
puis on d´ecrit le mod`ele ´equivalent pour les graphes dirig´es. On rappelle qu’on ne consid`ere
que des graphes simples et des graphes dirig´es o`u seuls les sommets peuvent ˆetre ´etiquet´es.
Sur les graphes simples o`u les arˆetes ne sont pas ´etiquet´ees, la notion de calculs locaux

cellulaires sur les ´etoiles correspond aux calculs locaux sur les ´etoiles ouvertes.
D´eﬁnition 4.10 Une relation de r´e´etiquetage est cellulaire et localement engendr´ee sur
(cid:2)),
les ´etoiles si la condition suivante est satisfaite. Pour tous graphes simples (G, λ), (G, λ
(cid:2)), pour tout sommets v ∈ V (G) et w ∈ V (H) tels qu’il existe un isomorphisme
(H, η), (H, η
ϕ : BG(v) → BG(w), si les conditions suivantes sont v´eriﬁ´ees :

1. λ(v) = η(ϕ(v)) et λ

(cid:2)(v) = η

(cid:2)(ϕ(v)),

92

Chapitre 4. Calculs Locaux Cellulaires sur les ´Etoiles

2

D

1

v

2

2

1
(cid:2) D(cid:2)

v

2

1

2

−
−
D(cid:2)(v
D(v) = B
B

(cid:2))

Fig. 16 – Les ´etoiles entrantes des sommets v ∈ V (D) et v

(cid:2) ∈ V (D

(cid:2)) sont isomorphes.

2. pour tout v
3. pour tout v
4. pour tout w

(cid:2) ∈ NG(v), λ(v) = η(ϕ(v)),
(cid:2) (cid:12)= v, λ
(cid:2)(v
(cid:2)) = λ(v
(cid:2)),
(cid:2) (cid:12)= w, η
(cid:2)),
(cid:2)) = η(w
(cid:2)(w

alors (G, λ) R (G, λ

(cid:2)) si et seulement si (H, η) R (H, η

(cid:2)).

Aﬁn de pouvoir obtenir un lemme de rel`evement similaire `a celui d’Angluin [Ang80]
dans le cadre des calculs locaux cellulaires sur les ´etoiles, on a aussi besoin de d´eﬁnir les
calculs locaux cellulaires sur les ´etoiles sur les graphes dirig´es. Pour cela, on d´eﬁnit l’´etoile
entrante d’un sommet v dans un graphe dirig´e D.

−
D(v) = (B

Informellement, l’´etoile entrante d’un sommet v dans un graphe D est une ´etoile dont
le centre est ´etiquet´e comme v et pour chaque arc a dont la cible v, il existe une feuille va
de l’´etoile ´etiquet´ee comme la source de a.
D´eﬁnition 4.11 Pour tout graphe dirig´e D = (D, λ) et pour tout sommet v ∈ V (D),
−
D(v), η) est le graphe simple d´eﬁni de la
l’´etoile entrante de v dans D, not´e B
mani`ere suivante.

D(v)) = {v} ∪ {va | ∃a ∈ A(G), t(a) = v},
−
– V (B
D(v)) = {{v, va} | ∃va ∈ V (B
D(v))},
−
−
– E(B
– η(v) = λ(v) et pour tout va ∈ V (B
−
D(v)), η(va) = λ(s(a)).
Des exemples d’´etoiles entrantes est pr´esent´e sur la Figure 16. On remarque sur cet
exemple que deux sommets peuvent avoir des vues entrantes isomorphes sans que les
graphes induits par chaque sommet et son voisinage ne soient isomorphes. Il est facile
de voir que pour tout graphe simple G et pour tout sommet v ∈ V (G), B
−
Dir(G)(v) est
isomorphe `a BG(v).

Dans la proposition suivante, on montre que les ﬁbrations pr´eservent les ´etoiles en-

trantes.
Proposition 4.12 Si un graphe dirig´e D1 est ﬁbr´e sur un graphe dirig´e D2 `a travers une
ﬁbration γ, alors pour tout v ∈ V (D1), les ´etoiles entrantes B
−
−
D2(γ(v)) sont
D1(v) et B
isomorphes.
Preuve : On consid`ere un graphe dirig´e D1 qui est ﬁbr´e sur un graphe D2 `a travers
une ﬁbration γ et un sommet v ∈ V (D1). On d´eﬁnit un homomorphisme ϕ de B
−
D1(v) =
−
−
−
D2(γ(v)), η2) de la mani`ere suivante : ϕ(v) = γ(v) et
D2(γ(v)) = (B
D1(v), η1) dans B
(B
pour tout va ∈ V (B
−
D1(v)), ϕ(va) = vγ(a). Puisque γ est une ﬁbration, on sait que pour tout
(cid:2) ∈ A(D2) tel que t(a
(cid:2)) = γ(v), il existe un unique a ∈ A(D1) tel que γ(a) = a
(cid:2)) = v.
(cid:2) et t(a
a
Par cons´equent, pour tout va(cid:2) ∈ V (B
−
D1(v)) tel

(cid:2)}, il existe un unique va ∈ V (B

D2(v)) \ {v
−

4.3. Calculs Locaux Cellulaires sur les ´Etoiles

93

que ϕ(va) = va(cid:2). De plus, η1(v) = λ1(v) = λ2(γ(v)) = η2(γ(v)) et pour tout va ∈ B(v1),
η1(va) = λ1(s(a)) = λ2(γ(s(a))) = λ2(s(γ(a))) = η2(vγ(a)) = η2(ϕ(va)). Ainsi, ϕ est un
−
−
D1(v) dans B
D2(γ(v)).
isomorphisme de B
2

On utilise maintenant la notion d’´etoile entrante pour d´eﬁnir les relations de r´e´etique-

tages cellulaires et localement engendr´ees sur les ´etoiles entrantes.

−
D2(w), si les conditions suivantes sont v´eriﬁ´ees :

D´eﬁnition 4.13 Une relation de r´e´etiquetage est cellulaire et localement engendr´ee sur les
´etoiles entrantes si la condition suivante est satisfaite. Pour tous graphes dirig´es (D1, λ1),
2), pour tout sommets v ∈ V (D1) et w ∈ V (D2) tels qu’il existe
(cid:2)
(cid:2)
(cid:2)
1), (D2, λ2), (D2, λ
(D
1, λ
D1(v) → B
−
un isomorphisme ϕ : B
(cid:2)
(cid:2)
1. λ1(v) = λ2(ϕ(v)) et λ
2(ϕ(v)),
1(v) = λ
(cid:2) ∈ V (B
−
D1(v)), λ1(v) = λ2(ϕ(v)),
2. pour tout v
(cid:2) (cid:12)= v, λ
(cid:2)),
(cid:2)) = λ1(v
(cid:2)
3. pour tout v
1(v
(cid:2) (cid:12)= w, λ
(cid:2)) = λ2(w
(cid:2)
(cid:2)),
4. pour tout w
2(w
alors (D1, λ1) R (D1, λ
1) si et seulement si (D2, λ2) R (D2, λ
(cid:2)
(cid:2)
2).

On remarque que toute relation de r´e´etiquetage R cellulaire localement engendr´ee sur
les ´etoiles entrantes peut ˆetre vue comme une relation de r´e´etiquetage cellulaire localement
engendr´ee sur les ´etoiles : G R G(cid:2) si et seulement si Dir(G) R Dir(G(cid:2)).
R´eciproquement, on peut transformer une relation de r´e´etiquetage R celullaire loca-
lement engendr´ee sur les ´etoiles en une relation de r´e´etiquetage R(cid:2) cellulaire localement
engendr´ee sur les ´etoiles entrantes de la mani`ere suivante. Pour tout graphes simples
(cid:2)) et pour tous sommets v ∈ V (G) et
(G, λ), (G, λ
w ∈ V (D) tels qu’il existe un isomorphisme ϕ : B
−
D(w) et tels que les conditions
suivantes sont v´eriﬁ´ees

(cid:2)), pour tous graphes dirig´es (D, η), (D, η
G(v) → B
−

(cid:2)(ϕ(v)),

(cid:2)(v) = η
– λ(v) = η(ϕ(v)) et λ
(cid:2) ∈ NG(v), λ(v) = η(ϕ(v)),
– pour tout v
(cid:2) (cid:12)= v, λ
(cid:2)(v
(cid:2)) = λ(v
(cid:2)),
– pour tout v
(cid:2) (cid:12)= w, η
(cid:2)(w
(cid:2)),
(cid:2)) = η(w
– pour tout w
(cid:2)). Il est facile de voir que R(cid:2)
(cid:2)) si et seulement si (G, λ) R (G, λ
on d´eﬁnit (D, η) R(cid:2) (D, η
est bien d´eﬁnie et que R(cid:2) est une relation de r´e´etiquetage cellulaire localement engendr´ee
sur les ´etoiles entrantes. Ainsi, G R G(cid:2) si et seulement si Dir(G) R(cid:2)
Dir(G(cid:2)) et on peut
donc consid´erer seulement des relations de r´e´etiquetage cellulaire localement engendr´ee
sur les ´etoiles.

Les calculs locaux cellulaires sur les ´etoiles correspondent indistinctement aux rela-
tions de r´e´etiquetages cellulaires localement engendr´ees sur les ´etoiles ou aux relations de
r´e´etiquetages cellulaires localement engendr´ees sur les ´etoiles entrantes.

Une relation de r´e´etiquetage cellulaire localement engendr´ee sur les ´etoiles peut ˆetre
d´ecrite par un ensemble r´ecursif de r`egles de r´e´etiquetage o`u chaque r`egle permet de
modiﬁer l’´etiquette d’un sommet en fonction des ´etiquettes des voisins de ce sommet.
R´eciproquement, un tel ensemble de r`egles induit une relation de r´e´etiquetage cellulaire
localement engendr´ee sur les ´etoiles. Ainsi, on notera R l’ensemble de r`egles de r´e´etiquetage
aussi bien que la relation de r´e´etiquetage correspondante.

94

Chapitre 4. Calculs Locaux Cellulaires sur les ´Etoiles

4.3.2 Fibrations et Calculs Locaux Cellulaires sur les ´Etoiles

1 tel que D1 R∗ D(cid:2)

1 et D(cid:2)

1 est ﬁbr´e sur D(cid:2)

On pr´esente maintenant le lemme qui met en ´evidence le lien entre les ﬁbrations et
les calculs locaux cellulaires sur les ´etoiles. C’est l’´equivalent du lemme d’Angluin [Ang80]
pour les ﬁbrations. Ce lemme a ´et´e prouv´e par Boldi et al. [BCG+96]
Lemme 4.14 (Lemme de rel`evement [BCG+96]) On consid`ere un graphe dirig´e D1
qui est ﬁbr´e sur un graphe dirig´e sans boucle D2 `a travers une ﬁbration γ et une relation
R de r´e´etiquetage cellulaire localement engendr´ee sur les ´etoiles. Si D2 R∗ D(cid:2)
2, alors il
existe D(cid:2)
Preuve : Il suﬃt de prouver ce lemme pour un pas de calcul. On consid`ere deux graphes
dirig´es D1 = (D1, λ1) et D2 = (D2, λ2) tels que (D1, λ1) est ﬁbr´e sur (D2, λ2) `a travers γ.
On consid`ere un pas de r´e´etiquetage qui modiﬁe l’´etiquette d’un sommet v ∈ V (D2) et on
note λ

(cid:2)
2 l’´etiquetage de D2 obtenu apr`es l’application de ce pas de r´e´etiquetage.

D’apr`es la Proposition 4.12, on sait que pour tout u ∈ γ
−
−1(v), B
D1(u) est isomorphe `a
(cid:2) ∈ γ
−
−1(v), il n’existe
D2(v). De plus, puisque D2 ne contient pas de boucle, pour tous u, u
B
(cid:2). On peut donc appliquer le pas de r´e´etiquetage
pas d’arc a tel que s(a) = u et t(a) = u
sur chaque sommet u ∈ γ
−1(v) et on note λ
(cid:2)
1 l’´etiquetage de D1 ainsi obtenu. On sait que
pour tout u ∈ γ
(cid:2)
−1(v), λ
(cid:2)
2(v) et que les ´etiquettes des autres sommets n’ont pas
1(u) = λ
(cid:2)
(cid:2)
1) est donc ﬁbr´e sur (D2, λ
2) `a travers γ.
´et´e modiﬁ´ees. Le graphe (D1, λ
2

2 `a travers γ.

Le diagramme suivant repr´esente la propri´et´e du Lemme 4.14.

R∗−−−−→ D(cid:2)

D1

⏐⏐(cid:3)
D2 −−−−→

ﬁbration

1

⏐⏐(cid:3)ﬁbration

R∗ D(cid:2)

2

4.4 Nommage et ´Enum´eration

On s’int´eresse aux probl`emes d’´enum´eration et du nommage dans le cadre des calculs
locaux cellulaires sur les ´etoiles. On montre d’abord que dans ce mod`ele, il n’existe pas
d’algorithme d’´enum´eration ou de nommage pour un graphe simple G qui n’est pas mi-
nimal pour les ﬁbrations discr`etes ; ce qui a ´et´e montr´e par Boldi et al. [BCG+96]. On
donne ensuite un algorithme d’´enum´eration pour les graphes minimaux pour les ﬁbrations
discretes qui est inspir´e de l’algorithme de Mazurkiewicz [Maz97] ; cet algorithme est nou-
veau et on va voir qu’il n´ecessite beaucoup moins de m´emoire que l’algorithme de Boldi
et al. [BCG+96].

4.4.1 R´esultats d’Impossibilit´e pour l’´Enum´eration et le Nommage
Proposition 4.15 ([BCG+96]) Soit G un graphe simple ´etiquet´e qui n’est pas minimal
pour les ﬁbrations discr`etes. Il n’existe pas d’algorithme d’´enum´eration ou de nommage
pour le graphe G utilisant des calculs locaux cellulaires sur les ´etoiles.

Preuve : Soit D un graphe dirig´e ´etiquet´e sans boucle tel que Dir(G) est ﬁbr´e proprement
sur D `a travers une ﬁbration γ. ´Etant donn´e un algorithme R utilisant des calculs locaux

4.4. Nommage et ´Enum´eration

95

cellulaires sur les ´etoiles, on consid`ere une ex´ecution de R sur D. Si cette ex´ecution est
inﬁnie sur D, alors d’apr`es le Lemme 4.14, il existe une ex´ecution inﬁnie de R sur Dir(G)
et donc sur G ; auquel cas, R n’est ni un algorithme d’´enum´eration, ni de nommage.
On suppose maintenant qu’il existe une ex´ecution ﬁnie de R sur D et on consid`ere la
conﬁguration ﬁnale D(cid:2). D’apr`es le Lemme 4.14, il existe une ex´ecution de R sur G qui
permet d’atteindre une conﬁguration G(cid:2) telle que Dir(G(cid:2)) est ﬁbr´e sur D(cid:2) `a travers γ. Si
G(cid:2) n’est pas une conﬁguration ﬁnale de R, alors il existe un sommet u ∈ V (G) tel qu’on
peut appliquer une r`egle de R sur BG(cid:2)(u). Par cons´equent, cette r`egle peut ˆetre appliqu´ee
−
−
D(cid:2)(γ(u)) d’apr`es la Proposition 4.12, mais cela signiﬁe que D(cid:2)
sur B
Dir(G(cid:2))(u) et sur B
n’est pas une conﬁguration ﬁnale de R, ce qui est impossible. Par cons´equent, G(cid:2) est une
conﬁguration ﬁnale de R. Mais puisque Dir(G(cid:2)) n’est pas isomorphe `a D(cid:2), cela implique
qu’il existe deux sommets de G qui ont la mˆeme ´etiquette dans Dir(G(cid:2)) et donc dans G(cid:2).
Par cons´equent, R ne permet pas d’attribuer de noms distincts `a tous les sommets de G
et donc R n’est pas un algorithme de nommage ou d’´enum´eration pour le graphe G. 2

4.4.2 Un Algorithme d’´Enum´eration

On va maintenant d´ecrire un algorithme d’´enum´eration M tr`es proche de l’algorithme
de Mazurkiewicz qui permet de r´esoudre le probl`eme de l’´enum´eration sur tout graphe
simple G tel que Dir(G) est minimal pour les ﬁbrations discr`etes.
Durant l’ex´ecution de l’algorithme, chaque sommet v essaie d’obtenir une identit´e qui
est un num´ero entre 1 et |V (G)|. Chaque sommet va ensuite observer les num´eros choisis
par ses voisins pour construire sa vue locale, i.e., les num´eros de ses voisins. Ensuite, chaque
sommet diﬀuse dans le r´eseau son num´ero accompagn´e de son ´etiquette initiale et de sa
vue locale.

Si un sommet u d´ecouvre qu’un autre sommet v a le mˆeme num´ero que lui, alors le
sommet u doit d´ecider s’il modiﬁe son identit´e. Pour cela, il compare son ´etiquette λ(u) et
sa vue locale avec l’´etiquette λ(v) et la vue locale de v : si l’´etiquette de u est plus faible que
l’´etiquette de v ou si les deux sommets ont la mˆeme ´etiquette et que la vue locale de u est
plus «faible» (pour un ordre similaire `a l’ordre utilis´e dans l’algorithme de Mazurkiewicz),
alors le sommet u choisit un nouveau num´ero (sa nouvelle identit´e temporaire). Ensuite,
le sommet u diﬀuse `a nouveau son num´ero et sa vue locale dans le r´eseau. Si un sommet se
rend compte que sa vue locale ne correspond pas aux num´eros de ses voisins, alors il met
`a jour sa vue locale et diﬀuse `a nouveau son num´ero et sa vue locale. Lorsque l’ex´ecution
est termin´ee, si le graphe Dir(G) est minimal pour les ﬁbrations discr`etes, alors chaque
sommet a un num´ero unique : l’algorithme permet de r´esoudre le probl`eme du nommage.

´Etiquettes

On consid`ere un graphe G = (G, λ) o`u λ: V (G) → L est un ´etiquetage initial, qui
ne sera pas modiﬁ´e par l’algorithme. Lors de l’ex´ecution, chaque sommet va obtenir une
´etiquette de la forme (λ(v), n(v), N(v), M(v)) qui repr´esente les informations suivantes :
– la premi`ere composante λ(v) est l’´etiquette initiale et ne sera pas modiﬁ´ee lors de
– n(v) ∈ N est le num´ero courant du sommet v qui est modiﬁ´e lors de l’ex´ecution de

l’ex´ecution.

l’algorithme,

96

Chapitre 4. Calculs Locaux Cellulaires sur les ´Etoiles

– N(v) ∈ Pﬁn(N2) est la vue locale du sommet v qui contient des informations sur
les voisins de v. `A chaque fois que v met `a jour sa vue locale, pour chaque num´ero
n apparaissant dans son voisinage, le couple (n, p) apparaˆıt dans N(v) o`u p est le
nombre de voisins de v ayant l’´etiquette n.
– M(v) ⊆ N × L × Pﬁn(N2) est la boˆıte-aux-lettres de v. Elle va contenir toute l’infor-
mation re¸cue par v lors de l’ex´ecution de l’algorithme, i.e., les couples de num´eros
et de vues locales qui auront ´et´e diﬀus´ees par tous les sommets du graphe.
Initialement, chaque sommet a une ´etiquette de la forme (λ(v), 0,∅,∅) qui signiﬁe qu’au
d´ebut de l’algorithme, v n’a pas choisi de num´ero et qu’il n’a aucune information `a propos
de ses voisins, ni `a propos des autres sommets du graphe.

Un Ordre sur les Vues Locales

(cid:2) et p < p

(cid:2).

Comme pour l’algorithme de Mazurkiewicz, on d´eﬁnit un ordre sur les vues locales
qui va permettre d’assurer que certaines propri´et´es seront toujours v´eriﬁ´ees au cours de
l’ex´ecution. L’ordre consid´er´e est exactement le mˆeme que celui de l’algorithme de Mazur-
kiewicz, `a la diﬀ´erence qu’on d´eﬁnit un ordre sur les ensembles ﬁnis de couples d’entiers.
On d´eﬁnit donc un ordre total sur les ensembles ﬁnis de couples d’entiers. Pour cela,
(cid:2)) si n < n
(cid:2),
on consid`ere que N2 est muni de l’ordre lexicographique usuel : (n, p) < (n
ou si n = n
Ensuite, ´etant donn´ees deux ensembles N1, N2 ∈ Pﬁn(N2) distincts, on dit que N1 ≺
N2 si le maximum pour l’ordre lexicographique sur L × N de la diﬀ´erence sym´etrique
N1 (cid:17) N2 = (N1 \ N2) ∪ (N2 \ N1) appartient `a N2.
Si N(u) ≺ N(v), alors on dit que la vue locale N(v) de v est plus forte que celle de u
et que N(u) est plus faible que N(v). En utilisant l’ordre total <L de L, on ´etend l’ordre
≺ pour obtenir un ordre total sur L × Pﬁn(L × N) : ((cid:8), N) ≺ ((cid:8)
(cid:2) ou bien si
(cid:8) = (cid:8)

, N
(cid:2). Par la suite, on notera (cid:19) la clˆoture r´eﬂexive de ≺.

(cid:2) et N ≺ N

(cid:2)) si (cid:8) <L (cid:8)

(cid:2)

, p

(cid:2)

Les R`egles de R´e´etiquetage

On d´ecrit maintenant l’algorithme d’´enum´eration grˆace `a des r`egles de r´e´etiquetage.
La premi`ere r`egle M0 est une r`egle sp´eciale qui permet `a chaque sommet v de modiﬁer
son ´etiquette λ(v) pour obtenir l’´etiquette (λ(v), 0,∅,∅).
Les r`egles sont d´ecrites pour une ´etoile B(v0) de centre v0. L’´etiquette d’un sommet
v ∈ NG(v0) ∪ {v0} avant l’application de la r`egle est not´ee (λ(v), n(v), N(v), M(v)) et
(cid:2)(v0)) l’´etiquette de v0 (la seule ´etiquette qui peut ˆetre
on note (λ(v0), n
modiﬁ´ee) apr`es l’application de la r`egle de r´e´etiquetage. Par ailleurs, aﬁn de rendre plus
lisible les r`egles, on ne mentionne pas les diﬀ´erents champs des ´etiquettes qui ne sont pas
modiﬁ´es. Les deux r`egles de l’algorithme sont tr`es proches des r`egles de l’algorithme de
Mazurkiewicz.

(cid:2)(v0), M

(cid:2)(v0), N

La premi`ere r`egle permet non-seulement `a un sommet de mettre `a jour sa boˆıte-aux-
lettres comme dans l’algorithme de Mazurkiewicz, mais aussi de mettre `a jour sa vue
locale si celle ci n’est pas correcte. Pour tout sommet v0 ∈ V (G), on note code(NG(v0))
l’ensemble de couples d’entiers d´eﬁni de la mani`ere suivante : un couple (n, p) appartient
`a code(NG(v0)) si et seulement si n > 0 et il existe exactement p sommets v1, . . . , vp ∈
NG(v0) tels que pour tout i ∈ [1, p], n(vi) = n.

4.4. Nommage et ´Enum´eration

97

M1: R`egle de Diﬀusion

Pr´econdition :
– ∃v ∈ NG(v0) tel que M(v) \ M(v0) (cid:12)= ∅ ou

N(v0) (cid:12)= code(NG(v0)
(cid:2)(v0) := code(NG(v0)) ;
(cid:2)(v0) := (n(v0), N

R´e´etiquetage :
– N
– M

(cid:2)(v0)) ∪

(cid:4)

w∈V (B(v0))

M(w).

La seconde r`egle de l’algorithme permet `a un sommet v0 qui ne peut pas appliquer la
premi`ere r`egle de modiﬁer son num´ero s’il n’a pas encore choisi son num´ero (i.e. n(v) = 0)
ou s’il sait qu’il existe un sommet dans le graphe qui a le mˆeme num´ero que lui et qui
a une ´etiquette ou une vue locale plus forte que la sienne. Dans ce cas l`a, v0 choisit un
nouveau num´ero et ajoute `a sa boˆıte-aux-lettres le couple (n
M2: R`egle de Renommage

(cid:2)(v0), λ(v0), N(v0)).

Pr´econdition :
– ∀v ∈ NG(v0), M(v) = M(v0),
– N(v0) = code(NG(v0)),
– n(v0) = 0 ou

∃(n(v0), (cid:8), N) ∈ M(v0) tel que (λ(v0), N(v0)) ≺ ((cid:8), N)
(cid:2)(v0) := 1 + max{n
(cid:2)(v0) := M(v0) ∪ {(n

(cid:2)) ∈ M(v0)} ;
(cid:2)(v0), λ(v0), N(v0))}.

R´e´etiquetage :
– n
– M

(cid:2) | ∃(n

(cid:2)

(cid:2)

, (cid:8)

, N

4.4.3 Correction de l’Algorithme d’´Enum´eration

On consid`ere un graphe simple ´etiquet´e G. Pour tout sommet v ∈ V (G), on note
(λ(v), ni(v), Ni(v), Mi(v)) l’´etiquette du sommet v apr`es la i`eme ´etape de r´e´etiquetage
de l’algorithme M d´ecrit ci-dessus. On pr´esente d’abord quelques propri´et´es qui sont
satisfaites par n’importe quelle ex´ecution de l’algorithme.

Propri´et´es Satisfaites lors de l’Ex´ecution

Le lemme suivant, qui peut ˆetre facilement prouv´e par une r´ecurrence sur le nombre
d’´etapes, rappelle quelque propri´et´es simples qui sont toujours satisfaites par l’´etiquetage.
Lemme 4.16 Pour tout sommet v ∈ V (G

(cid:2)), et pour toute ´etape i,

1. ni(v) (cid:12)= 0 =⇒ (ni(v), λ(v), Ni(v)) ∈ Mi(v),
2. ∀(n, p) ∈ Ni(v), n > 0, n (cid:12)= ni(v) et ∃(n, (cid:8), N) ∈ Mi(v),
3. ∀v ∈ V (G),∀v ∈ NG(v), ni(v) > 0 =⇒ ni(v) (cid:12)= ni(v
(cid:2)).
Comme l’algorithme de Mazurkiewicz, l’algorithme M d´ecrit ici a des propri´et´es de

monotonicit´e int´eressantes qui sont donn´ees dans le lemme suivant.
Lemme 4.17 Pour chaque sommet v et chaque ´etape i,

– ni(v) ≤ ni+1(v),
– Ni(v) (cid:19) Ni+1(v),
– Mi(v) ⊆ Mi+1(v).

98

Chapitre 4. Calculs Locaux Cellulaires sur les ´Etoiles

De plus, `a chaque ´etape i, il existe un sommet v telle qu’au moins une de ces in´egalit´es
(ou inclusions) est stricte pour v.
Preuve : On note v le sommet dont l’´etiquette est modiﬁ´ee lors de la (i + 1)`eme ´etape
de r´e´etiquetage. Pour tout sommet w ∈ V (G) diﬀ´erent de v, la propri´et´e est trivialement
vraie. De plus, quelle que soit la r`egle appliqu´ee, on a toujours Mi(v) (cid:4) Mi+1(v).
Si ni(v) (cid:12)= ni+1(v), alors la r`egle M2 a ´et´e appliqu´ee sur l’´etoile B(v) et on sait que
ni+1(v) = 1 + max{n
(cid:2)) ∈ Mi(v)}. De plus, ou bien ni(v) = 0 < ni+1(v), ou
alors d’apr`es le Lemme 4.16, (ni(v), λ(v), Ni(v)) ∈ Mi(v) et donc ni(v) < ni+1(v).
Pour chaque sommet v tel que Ni(v) (cid:12)= Ni+1(v), alors la r`egle M1 a ´et´e appliqu´ee
sur l’´etoile B(v). Si Ni(v) = ∅, alors puisque l’ensemble vide est minimal pour l’ordre
≺, Ni(v) ≺ Ni+1(v). Dans le cas contraire, on consid`ere la derni`ere ´etape j < i + 1 lors
de laquelle la r`egle M1 a ´et´e appliqu´ee sur l’´etoile B(v) : on sait que Nj(v) = Ni(v).
(cid:2) ∈ NG(v), nj(v) ≤ ni(v), on a Nj(v) ≺ Ni+1(v).
Puisqu’on sait que pour chaque sommet v
Enﬁn, puisqu’une r`egle ne peut ˆetre appliqu´ee sur l’´etoile de centre v que si elle modiﬁe
2

l’´etiquette de v, on sait que l’une des in´egalit´es est stricte pour v.

(cid:2) | ∃(n

, N

, (cid:8)

(cid:2)

(cid:2)

(cid:2).

(cid:2)) = m

(cid:2) tel que ni(v

(cid:2) tel que ni(v) = m

(cid:2) ≤ m, il existe un sommet v

Comme pour l’algorithme de Mazurkiewicz, les informations dont dispose chaque som-
met v dans sa boˆıte-aux-lettres permettent d’obtenir des informations v´eriﬁ´ees par la conﬁ-
guration globale du graphe. Les deux lemmes suivants permettent de prouver que si un
sommet v connaˆıt un num´ero m `a une ´etape i (i.e., il existe (cid:8), N tels que (m, (cid:8), N) ∈ Mi(v)),
(cid:2). On montre d’abord
alors pour chaque m
que si v connaˆıt un num´ero m, alors il existe un sommet v
Lemme 4.18 Pour chaque sommet v ∈ V (G) et chaque ´etape i, pour tout (m, (cid:8), N) ∈
Mi(v), il existe un sommet w ∈ V (G) tel que ni(w) = m.
Preuve : On remarque d’abord qu’un triplet (m, (cid:8), N) est ajout´e `a une ´etape i dans
(cid:4)
Mi(v) seulement s’il existe un sommet v tel que ni(v) = m, λ(v) = (cid:8) et Ni(v) = N.
v∈V (G)
´Etant donn´e un sommet v, une ´etape i et un triplet (m, (cid:8), N) ∈ Mi(v), on note U =
{(u, j) ∈ V (G)× N | j ≤ i, nj(u) = m}. On consid`ere ensuite l’ensemble U
(cid:2) = {(u, j) ∈ U |
(cid:2) ≤
∀(u
(cid:2)
j}. Puisque (m, (cid:8), N) ∈ Mi(v), U et U
(cid:2) sont deux ensembles non-vides. On remarque
ais´ement qu’il existe i0 tel que pour tout (u, j) ∈ U
(cid:2) puisqu’`a chaque ´etape, le num´ero
d’au plus un sommet peut ˆetre modiﬁ´e. Le num´ero ni0(u) = m a donc ´et´e modiﬁ´e `a l’´etape
i0 + 1, mais par maximalit´e de (λ(u), Ni0(u)), la r`egle M2 n’a pas pu ˆetre appliqu´ee `a u
`a l’´etape i0. Par cons´equent, i0 = i et il existe donc un sommet w tel que ni(w) = m. 2

Si i0 < i, il existe exactement un ´el´ement (u, i0) ∈ U

(cid:2))) ≺ (λ(u), Nj(u)) ou (λ(u

(cid:2)), Nj(cid:2)(u
(cid:2), j = i0.

(cid:2))) = (λ(u), Nj(u)) et j

(cid:2)) ∈ U, (λ(u

(cid:2)), Nj(cid:2)(u

, j

(cid:2) ∈ [1, m], il existe (m

Dans le lemme suivant, on montre que si un sommet v connaˆıt un num´ero m, alors il
connaˆıt tous les num´eros inf´erieurs `a m.
Lemme 4.19 Pour chaque sommet v et chaque ´etape i, pour tout (m, (cid:8), N) ∈ Mi(v), pour
tout m
Preuve : On montre ce lemme par r´ecurrence sur i. Initialement, la propri´et´e est trivia-
lement vraie. On suppose que la propri´et´e est v´eriﬁ´ee pour i ≥ 0. On note v le sommet
dont l’´etiquette est modiﬁ´ee lors de la (i + 1)`eme ´etape de r´e´etiquetage. La propri´et´e est
trivialement vraie `a l’´etape i + 1 pour tout sommet w ∈ V (G) diﬀ´erent de v.

(cid:2)) ∈ Mi(v).

, N

, (cid:8)

(cid:2)

(cid:2)

4.4. Nommage et ´Enum´eration

99

(cid:2)

(cid:2)

, (cid:8)

(cid:2)) ∈ Mi(v

(cid:2) ∈ NG(v) tel que (m, (cid:8), N) ∈ Mi(v

Si la r`egle M1 a ´et´e appliqu´ee `a l’´etape i + 1, on consid`ere un ´el´ement (m, (cid:8), N) ∈
Mi+1(v). Si m (cid:12)= ni+1(v), alors il existe v
(cid:2)) et
(cid:2)) ⊆ Mi+1(v). Par cons´equent, par hypoth`ese de r´ecurrence, pour tout m
Mi(v
< m, il
(cid:2)) ⊆ Mi+1(v). Si m = ni+1(v), alors ou bien m = 0 et la propri´et´e
existe (m
(cid:2)) ∈ Mi(v)
est trivialement vraie, ou bien on sait d’apr`es le Lemme 4.16 qu’il existe (m, (cid:8)
et par hypoth`ese de r´ecurrence, la propri´et´e est v´eriﬁ´ee.
Si la r`egle M2 est appliqu´ee `a l’´etape i + 1, alors Mi+1(v) = Mi(v) ∪ {(ni+1(v) = 1 +
max{m | (m, (cid:8), N) ∈ Mi(v)}, λ(v), Ni(v))}, et par cons´equent pour chaque m ∈ Mi+1(v),
la propri´et´e reste vraie.

, N

, N

2

(cid:2)

(cid:2)

On peut maintenant montrer que toute ex´ecution de l’algorithme M termine sur G.
D’apr`es les Lemmes 4.18 et 4.19, on sait qu’`a chaque ´etape de l’ex´ecution, les num´eros des
sommets forment un ensemble [1, k] ou un ensemble [0, k] avec k ≤ |V (G)|. Par cons´equent,
d’apr`es le Lemme 4.17, on sait qu’il existe une ´etape i0 telle que pour tout sommet v et
toute ´etape i ≥ i0, ni+1(v) = ni(v).

De plus, pour chaque sommet v et chaque ´etape i lors de laquelle la vue locale de v est
modiﬁ´ee, Ni(v) contient un couple (n, p) si et seulement s’il existe exactement p sommets
v1, . . . , vp ∈ NG(v) tel que ∀k ∈ [1, p], ni(vk) = n. Par cons´equent N(v) ne peut prendre
qu’un nombre ﬁni de valeurs et il en est de mˆeme pour M(v). Ainsi le nombre de valeurs
diﬀ´erentes que peut prendre l’´etiquette de chaque sommet est ﬁni (mais d´epend de la
taille du graphe). Par ailleurs, on sait que les ´etiquettes cons´ecutives de chaque sommet v
forment une suite croissante et puisqu’on sait qu’`a chaque ´etape i, l’´etiquette d’au moins
un sommet est modiﬁ´ee, on sait que toute ex´ecution de l’algorithme termine : la relation
M est noeth´erienne.

Propri´et´es Satisfaites par l’´Etiquetage Final

Puisqu’on sait que l’algorithme termine toujours, on s’int´eresse maintenant aux pro-

pri´et´es satisfaites par l’´etiquetage ﬁnal.
Lemme 4.20 Toute ex´ecution ρ de l’algorithme M sur un graphe simple ´etiquet´e G =
(G, λ) termine et l’´etiquetage ﬁnal (λ, nρ, Nρ, Mρ) v´eriﬁe les propri´et´es suivantes :

1. il existe un entier k ≤ |V (G)| tel que {nρ(v) | v ∈ V (G)} = [1, k],

et pour tous sommets v, v

(cid:2) :

(cid:2)),

(cid:2)),

2. Mρ(v) = Mρ(v
3. (nρ(v), λ(v), Nρ(v)) ∈ Mρ(v
4. si nρ(v) = nρ(v
5. (n, p) ∈ Nρ(v) si et seulement s’il existe p ≥ 1 sommets distincts v1, v2, . . . vp ∈
NG(v) tels que nρ(w) = n ; auquel cas il existe q tel que ∀k ∈ [1, p], (nρ(v), q) ∈
Nρ(vk).

(cid:2)), alors λ(v) = λ(v

(cid:2)) et Nρ(v) = Nρ(v

(cid:2)),

Preuve :

1. D’apr`es les Lemmes 4.18 et 4.19 et puisque la r`egle M2 ne peut pas ˆetre appliqu´ee.
2. Dans le cas contraire, la r`egle M1 peut ˆetre appliqu´ee.
3. C’est une cons´equence directe de la propri´et´e pr´ec´edente d’apr`es le Lemme 4.16.

100

Chapitre 4. Calculs Locaux Cellulaires sur les ´Etoiles

4. Dans le cas contraire, la r`egle M2 peut ˆetre appliqu´ee `a v ou `a v
5. D’apr`es la propri´et´e pr´ec´edente et puisque la r`egle M1 ne peut pas ˆetre appliqu´ee.

(cid:2).

2

Grˆace au Lemme 4.20, on peut prouver que l’´etiquetage ﬁnal permet de construire un
graphe dirig´e sans boucle fortement connexe D tel que Dir(G) est ﬁbr´e proprement sur
D.
Proposition 4.21 ´Etant donn´e un graphe simple G, on peut construire, `a partir de
l’´etiquetage ﬁnal obtenu apr`es une ex´ecution ρ de M, un graphe dirig´e sans boucle forte-
ment connexe D tel que Dir(G) est ﬁbr´e proprement sur D.

Preuve : On utilise les notations du Lemme 4.20.

−1
ρ (m) et si v a p voisins dont le num´ero est m

(cid:2) et t(a) = m, alors il existe un arc a

(cid:2) ∈ V (G), si nρ(v) = nρ(v

(cid:2)) = m, on sait d’apr`es le Lemme 4.20 que pour tout entier m
, p) ∈ Nρ(v) si et seulement si (m
(cid:2))) si et seulement si v (resp. v

On construit un graphe dirig´e D de la mani`ere suivante. L’ensemble V (D) des sommets
est l’ensemble des num´eros apparaissant dans le graphe dans la conﬁguration ﬁnale, i.e.,
V (D) = {m | ∃v ∈ V (G), nρ(v) = m}. Pour tous sommets v, v
(cid:2) ∈ V (G) tels que nρ(v) =
(cid:2) ∈ nρ(V (G)), il existe
nρ(v
, p) ∈ Nρ(v) (resp. (m
, p) ∈
, p) ∈ Nρ(v
(cid:2)
(cid:2)
(cid:2)) et que (m
(cid:2)
(cid:2)
(m
(cid:2). Ainsi,
(cid:2)) a p voisins distincts dont le num´ero est m
Nρ(v
(cid:2) ∈ V (D),
on peut d´eﬁnir les arcs de D de la mani`ere suivante, pour tout sommets m, m
on choisit un sommet v ∈ n
(cid:2), alors A(D)
contient p arcs am(cid:2),m,1, . . . , am(cid:2),m,p tels que ∀k ∈ [1, p], s(am(cid:2) ,m,k) = m
(cid:2) et t(am(cid:2),m,k) = m.
(cid:2) ∈ V (G), nρ(v) (cid:12)= nρ(v
(cid:2))
D’apr`es le Lemme 4.16, on sait que pour tous sommets voisins v, v
et par cons´equent, le graphe D ne contient pas de boucle.
(cid:2) ∈ NG(v) tel que nρ(v
Puisque pour tout couple (m, p) ∈ Nρ(v), p > 1, il existe v
(cid:2)
(cid:2)) = m
et tel qu’il existe (nρ(v), q) ∈ Nρ(v
(cid:2) ∈ nρ(V (G)), s’il existe un arc
(cid:2)). Ainsi, pour tout m, m
(cid:2) ∈ A(D) tel que s(a) = m
a ∈ A(D) tel que s(a) = m
(cid:2). On sait aussi que le graphe D est connexe puisque G est connexe et par
et t(a) = m
cons´equent, D est un graphe dirig´e fortement connexe sans boucle.
(cid:2)) et on peut donc
d´eﬁnir un ´etiquetage η de D de la mani`ere suivante, pour tout v ∈ V (G), η(nρ(v)) = λ(v).
(cid:2)} ∈ E(G), il existe
deux arcs av(cid:2),v, av,v(cid:2) ∈ A(Dir(G)) tels que s(av,v(cid:2)) = t(av(cid:2),v) = v et t(av,v(cid:2)) = s(av(cid:2),v) = v
(cid:2).
De plus, pour tout sommet v ∈ V (G), l’´etiquette de v dans Dir(G) est la mˆeme que dans
G.
On d´eﬁnit maintenant un homomorphisme γ de Dir(G) dans D de la mani`ere suivante.
Pour tout sommet v ∈ V (G), γ(v) = nρ(v). Pour tout sommet v ´etiquet´e n et pour chaque
m ∈ nρ(Nρ(v)), on consid`ere un ordre quelconque sur les sommets v1, v2, . . . , vp ∈ NG(v)
dont le num´ero est m. Ainsi, pour tout arc avi,v, on pose γ(avi,v) = am,n,i. De par la
d´eﬁnition des arcs de A(D), on sait que si un sommet v ´etiquet´e n a p voisins dont le
num´ero est m, alors il existe exactement p arcs dont la source est m et la cible est n
dans D. Ainsi, γ est une ﬁbration de Dir(G) dans D et puisqu’il est clair que γ pr´eserve
l’´etiquetage, Dir(G) est ﬁbr´e sur D.
2

(cid:2)), alors λ(v) = λ(v
Pour tout sommet v, v
On rappelle que V (Dir(G)) = V (G) et que pour tout arˆete {v, v

On consid`ere maintenant un graphe simple G tel que Dir(G) est minimal pour les
ﬁbrations discr`etes. Pour chaque ex´ecution ρ de M sur G, le graphe obtenu `a partir de

4.4. Nommage et ´Enum´eration

101

l’´etiquetage ﬁnal est isomorphe `a G. Par cons´equent, l’ensemble des num´eros des som-
mets est exactement [1,|V (G)|] : chaque sommet a un identiﬁant unique. L’algorithme M
permet de r´esoudre le nommage sur la famille des graphes minimaux pour les ﬁbrations
discr`etes, mais si aucune information `a propos de G n’est disponible, les sommmets ne
peuvent pas d´etecter la terminaison.
Cependant, la d´etection de la terminaison est possible pour un graphe G donn´e. En
eﬀet, une fois qu’un sommet a obtenu le num´ero |V (G)|, d’apr`es les Lemmes 4.18 et 4.19,
il sait que chaque sommet de G a un num´ero unique qui ne va plus ˆetre modiﬁ´e : il peut
donc d´etecter que le nommage est eﬀectu´e.

Par ailleurs, d’apr`es la Proposition 4.15, on sait que pour tout graphe G tel que
Dir(G) n’est pas minimal pour les ﬁbrations discr`etes, il n’existe aucun algorithme utili-
sant des calculs locaux cellulaires sur les ´etoiles non-´etiquet´ees qui permette de r´esoudre les
probl`emes du nommage ou de l’´enum´eration sur G. On a ainsi obtenu une nouvelle preuve
du th´eor`eme suivant qui a ´et´e prouv´e pour la premi`ere fois par Boldi et al.[BCG+96].
Th´eor`eme 4.22 ([BCG+96]) Pour tout graphe simple ´etiquet´e G, les assertions sui-
vantes sont ´equivalentes :

1. il existe un algorithme de nommage (ou d’´enum´eration) pour G utilisant des calculs

locaux cellulaires sur les ´etoiles non-´etiquet´ees,

2. il existe un algorithme de nommage (ou d’´enum´eration) avec d´etection de la termi-
naison pour G utilisant des calculs locaux cellulaires sur les ´etoiles non-´etiquet´ees,

3. Dir(G) est minimal pour les ﬁbrations discr`etes.

Remarque 4.23 ´Etant donn´e un graphe G tel que Dir(G) est minimal pour les ﬁbrations
discr`etes, pour d´etecter que l’algorithme M a attribu´e un identiﬁant unique `a chaque
sommet, il suﬃt de connaˆıtre le nombre de sommets de G. Ainsi, l’algorithme M permet
de r´esoudre l’´enum´eration et le nommage avec d´etection de la terminaison sur les graphes
minimaux pour les ﬁbrations discr`etes de taille donn´ee.

4.4.4 Complexit´e

On s’int´eresse `a la complexit´e de l’algorithme M pr´esent´e ci-dessus. Dans le cadre
des calculs locaux, on s’int´eresse au nombre de pas de r´e´etiquetages eﬀectu´ees lors d’une
ex´ecution. La proposition suivante donne une borne sup´erieure sur le nombre de pas de
r´e´etiquetages de toute ex´ecution de l’algorithme M sur un graphe `a n sommets de degr´e
maximal Δ.
Proposition 4.24 Pour tout graphe G `a n sommets de degr´e maximal Δ, durant toute
ex´ecution de l’algorithme M utilisant des calculs locaux cellullaires sur les ´etoiles, O(Δn3)
r`egles sont appliqu´ees.
Preuve : On consid`ere un graphe G `a n sommets et une ex´ecution ρ de M sur G.
D’apr`es les Lemmes 4.18 et 4.19, on sait que la r`egle M2 ne peut pas ˆetre appliqu´ee plus
de n(n−1)
Entre deux ´etapes o`u la r`egle M2 est appliqu´ee, la vue locale d’un sommet est modiﬁ´ee
au plus Δ fois (une fois pour chaque voisin du sommet dont le num´ero a ´et´e modiﬁ´e). Il
existe donc O(n2) ´etapes o`u la r`egle M1 est appliqu´ee et modiﬁe la vue locale d’un sommet.

fois durant l’ex´ecution ρ.

2

102

Chapitre 4. Calculs Locaux Cellulaires sur les ´Etoiles

est ajout´e M(v). Pour chacun de ces couples, la r`egle M1 est appliqu´ee au plus n fois.

`A chaque fois qu’un sommet v modiﬁe son num´ero ou sa vue locale, un couple (n0, (cid:8), N)
Ainsi, durant toute ex´ecution ρ de M sur G, O(Δn3) r`egles sont appliqu´ees.
Pour la mˆeme raison que dans le Chapitre 3, on remarque que la borne de la Proposi-

2

tion 2.23 et celle de la Proposition 4.24 diﬀ`erent d’un facteur Δ.

On s’int´eresse `a la m´emoire n´ecessaire `a chaque sommet pour stocker son ´etiquette. On
suppose que l’´etiquetage initial λ du graphe G est tel que chaque ´etiquette initiale (cid:8) a une
taille en O(log |V (G)|) bits (ce qui est suﬃsant pour attribuer des ´etiquettes diﬀ´erentes `a
tous les sommets de G).
Proposition 4.25 Pour tout graphe G `a n sommets de degr´e maximal Δ, l’algorithme M
utilisant des calculs locaux cellullaires sur les ´etoiles n´ecessite O(Δn log n) bits de m´emoire
par sommet.

Preuve : On consid`ere un graphe G `a n sommets dont le degr´e maximal est Δ. 0n sait
que la vue locale de chaque sommet contient au plus Δ couples (n0, p0) qui peuvent ˆetre
repr´esent´es avec O(log n) bits. Ainsi, pour chaque sommet v, N(v) peut ˆetre repr´esent´e
avec O(Δ log n) bits.
Chaque sommet peut ne conserver dans sa boˆıte-aux-lettres que l’information utile,
i.e., l’ensemble {(n0, (cid:8), N) ∈ M(v) | ∀(n0, (cid:8)
(cid:2)) (cid:19) ((cid:8), N)}. Ainsi, dans
la boˆıte-aux-lettres de chaque sommet, il existe au plus n triplets (n0, (cid:8), N) dont la taille
est en O(Δ log n) bits. Par cons´equent, on peut repr´esenter la boˆıte-aux-lettres de chaque
sommet avec O(Δn log n) bits.
2

(cid:2)) ∈ M(v), ((cid:8)

, N

(cid:2)

(cid:2)

, N

Remarque 4.26 L’algorithme d´ecrit par Boldi et al. [BCG+96] n´ecessite l’application de
O(n2) pas de r´e´etiquetages, mais la m´emoire n´ecessaire `a chaque sommet est de 2O(n) bits.
Ainsi, on a obtenu un algorithme dont les ex´ecutions n´ecessitent un nombre d’applications
de r`egles plus important (tout en restant polynomial en la taille du graphe), mais qui
n´ecessite une m´emoire polynomiale en la taille du graphe (et non exponentielle) en chaque
sommet.

Cette am´elioration est int´eressante puisque si on veut impl´ementer cet algorithme dans
un syst`eme asynchrone o`u les processus communiquent en ´echangeant des messages en
utilisant des m´ethodes de synchronisation locales probabilistes pr´esent´ees dans [MSZ02]
(comme cela est possible dans ViSiDiA), alors il faut que r´eguli`erement les processus
´echangent leurs ´etats. Ainsi, on peut impl´ementer notre algorithme `a l’aide de m´ethodes
de synchronisation locales probabilistes dans un syst`eme asynchrone o`u les processus com-
muniquent en ´echangeant des messages de taille polynomiale et non exponentielle.

4.4.5

Importance des Connaissances Initiales

Dans la partie pr´ec´edente, on a montr´e que l’algorithme M permettait de r´esoudre
le probl`eme du nommage avec d´etection de la terminaison sur la famille des graphes
minimaux pour les ﬁbrations discr`etes de taille donn´ee.

´Etant donn´e un graphe G minimal pour les ﬁbrations discr`etes, la connaissance d’une
borne sur le diam`etre de G permet de r´esoudre le probl`eme du nommage sur G. En eﬀet, il
est facile de voir qu’on peut modiﬁer l’algorithme M pr´esent´e ci-dessus de la mˆeme mani`ere
que dans le mod`ele ´etudi´e dans le Chapitre 2 pour obtenir la proposition suivante.

4.5. ´Election

103

Proposition 4.27 Pour tout entier B, on peut modiﬁer l’algorithme M pour obtenir un
algorithme M(cid:2) utilisant des calculs locaux cellulaires sur les ´etoiles tel que pour tout graphe
simple G dont le diam`etre est born´e par B, M(cid:2) permet `a chaque sommet de G de d´etecter
que l’algorithme M sous-jacent est termin´e, i.e., l’´etiquette (n(v), N(v), M(v)) de chaque
sommet ne sera plus modiﬁ´e.

On en d´eduit donc le th´eor`eme suivant de la mˆeme mani`ere que dans le Chapitre 2.

Th´eor`eme 4.28 Pour tout entier B, il existe un algorithme de nommage avec d´etection
de la terminaison utilisant des calcusl locaux cellulaires sur les ´etoiles pour la famille des
graphes simples minimaux pour les ﬁbrations discr`etes dont le diam`etre est born´ee par B.

4.5

´Election

On s’int´eresse maintenant au probl`eme de l’´election dans le cadre des calculs locaux
cellulaires sur les ´etoiles. On pr´esente d’abord un r´esultat d’impossibilit´e du `a Boldi et
al. [BCG+96] qui repose sur la notion de ﬁbrations discr`etes, puis on explique comment
utiliser l’algorithme M pr´esent´e ci-dessus pour r´esoudre le probl`eme de l’´election.

4.5.1 R´esultats d’Impossibilit´e

Proposition 4.29 ([BCG+96]) Soit G un graphe simple ´etiquet´e tel que Dir(G) est
non-trivialement ﬁbr´e sur un graphe dirig´e fortement connexe sans boucle D. Il n’existe
pas d’algorithme d’´election pour le graphe G utilisant des calculs locaux cellulaires sur les
´etoiles.

Preuve : On consid`ere un graphe simple G = (G, λ) et un graphe dirig´e fortement
connexe sans boucle D = (D, η) tel que Dir(G) est non-trivialement ﬁbr´e sur D `a travers
une ﬁbration γ. ´Etant donn´e un algorithme R utilisant des calculs locaux cellulaires sur
les ´etoiles, on consid`ere une ex´ecution de R sur D. Si cette ex´ecution est inﬁnie sur D,
alors d’apr`es le Lemme 4.14, il existe une ex´ecution inﬁnie de R sur Dir(G) et donc sur
G ; auquel cas, R n’est pas un algorithme d’´election.
On suppose maintenant qu’il existe une ex´ecution ﬁnie de R sur D et on consid`ere la
conﬁguration ﬁnale D(cid:2). D’apr`es le Lemme 4.14, il existe une ex´ecution de R sur G qui
permet d’atteindre une conﬁguration G(cid:2) telle que Dir(G(cid:2)) est non-trivialement ﬁbr´e sur
D(cid:2) `a travers γ. Si G(cid:2) n’est pas une conﬁguration ﬁnale de R, alors il existe un sommet
u ∈ V (G) tel qu’on peut appliquer une r`egle de R sur BG(cid:2)(u). Par cons´equent, cette
−
−
Dir(G(cid:2))(u) et sur B
D(cid:2)(γ(u)) d’apr`es la Proposition 4.12,
r`egle peut ˆetre appliqu´ee sur B
mais cela signiﬁe que D(cid:2) n’est pas une conﬁguration ﬁnale de R, ce qui est impossible.
Par cons´equent, G(cid:2) est une conﬁguration ﬁnale de R. Mais puisque Dir(G(cid:2)) est ﬁbr´e non-
trivialement sur D(cid:2), cela implique que pour tout sommet u ∈ V (G), il existe au moins deux
−1(γ(u)) qui ont la mˆeme ´etiquette dans G(cid:2). Par cons´equent, il n’existe
sommets dans γ
pas de sommet u ∈ V (G) qui a une ´etiquette unique. L’algorithme R ne permet donc pas
de r´esoudre le probl`eme de l’´election sur G.

2

104

Chapitre 4. Calculs Locaux Cellulaires sur les ´Etoiles

4.5.2 Un Algorithme d’´Election

On va maintenant montrer comment utiliser l’algorithme de la Proposition 4.27 pour
r´esoudre le probl`eme de l’´election sur les graphes simples minimaux pour les ﬁbrations
discr`etes non-triviales. Pour cela, on utilise le fait que le graphe G est un graphe simple
aﬁn de d´eterminer le nombre d’ant´ec´edents de chaque sommet du graphe dirig´e reconstruit
`a partir de l’´etiquetage ﬁnal de G lorsque l’ex´ecution de l’algorithem M sous-jacent est
termin´ee.

(cid:2) ∈ V (D).

(cid:2)), p(v

(cid:2)

−1(v

(cid:2))|.

(cid:2))|γ

−1(v)| = p(v

(cid:2)

, v)|γ

(cid:2) ∈ V (D), il existe deux entiers p(v, v

1 ∈ A(D) tel que s(a
(cid:2)
(cid:2)
(cid:2)
(cid:2) tels qu’il existe un arc a
1) = v et t(a
1) = v

Dans la proposition suivante, on montre que si un graphe Dir(G) est ﬁbr´e sur un
graphe dirig´e sans boucle D `a travers un homomorphisme γ, alors si on connaˆıt D et la
taille de la ﬁbre d’un sommet v ∈ V (D), on peut calculer la taille de la ﬁbre de tout
sommet v
Proposition 4.30 ´Etant donn´e un graphe dirig´e fortement connexe sans boucle D, pour
, v) premiers entre eux tels
tous sommets v, v
que pour tout graphe simple G que Dir(G) est ﬁbr´e sur D `a travers une ﬁbration γ,
p(v, v
Preuve : On consid`ere un graphe dirig´e fortement connexe sans boucle D, et deux
(cid:2). On
sommets v, v
suppose qu’il existe un graphe simple G tel que Dir(G) est ﬁbr´e sur D `a travers une
ﬁbration γ. Puisque D est fortement connexe, γ est un homomorphisme surjectif et il existe
(cid:2) ∈ V (Dir(G)) et un arc a1 ∈ A(Dir(G)) tels que s(a1) = u et t(a1) = u
(cid:2), γ(u) = v,
u, u
1. Par cons´equent, il existe un arc a2 = Sym(a1) ∈ A(Dir(G)) tel
(cid:2)
(cid:2) et γ(a1) = a
(cid:2)) = v
γ(u
1 ∈ A(D) , il existe un
(cid:2)
(cid:2) et t(γ(a2)) = v. Ainsi, pour tout arc a
que s(γ(a2)) = γ(s(a2)) = v
2 ∈ A(D) tel que s(a
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
2).
1) = t(a
1) et s(a
2) = t(a
arc a
(cid:2) que pour tous
On fait une d´emonstration par r´ecurrence sur la distance k entre v et v
(cid:2)
(cid:2)) et p(v
, v) telles que
sommets v, v
pour tout graphe simple G tel que Dir(G) est ﬁbr´e sur D `a travers un homomorphisme
(cid:2))|. Si v = v
(cid:2))|γ
(cid:2), on d´eﬁnit p(v, v) = 1 et la propri´et´e est
γ, p(v, v
v´eriﬁ´ee.
(cid:2) ∈ V (D), on note d(v,v(cid:2)) (resp. d(v(cid:2),v)) le nombre d’arcs
(cid:2) et t(a) = v). On sait que chaque sommet
−1(v)) est la cible d’exactement d(v(cid:2),v) arcs dont la source est envoy´e par γ sur v
(cid:2)
(cid:2) tels que
(cid:2)} dans E(G)
(cid:2). De mˆeme, on peut montrer qu’il existe exactement
(cid:2) et on a donc
(cid:2)) = 1 en
(cid:2) `a distance inf´erieure `a
(cid:2) ∈ V (D) `a distance k + 1 dans D. Il existe
k dans D. On consid`ere deux sommets v, v
(cid:2)(cid:2) de v dans D qui est `a distance k de v
(cid:2) dans D. Par hypoth`ese de
alors un voisin v
(cid:2) =
r´ecurrence, il existe donc deux entiers p = p(v, v
(cid:2)) tels que pour tout graphe simple G tel que Dir(G) est ﬁbr´e sur
(cid:2)(cid:2) = p(v
(cid:2)(cid:2)), q
(cid:2)(cid:2)
p(v
, v
, v
(cid:2)(cid:2))|. Mais alors, on a
(cid:2)|γ
−1(v)| = p
D `a travers γ, p|γ
−1(v)| = p
(cid:2)|γ
(cid:2)(cid:2)|γ
(cid:2)(cid:2)
−1(v
(cid:2)(cid:2) et
(cid:2) en divisant pq
q
pq
(cid:2) par leur plus grand d´enominateur commun.
(cid:2)(cid:2)
q
p

a tels que s(a) = v et t(a) = v
u ∈ γ
et puisque G est un graphe simple, le sommet u a exactement d(v(cid:2),v) voisins u
(cid:2). Par cons´equent, il existe exactement d(v(cid:2),v)|γ
(cid:2)) = v
γ(u
(cid:2)) = v
telles que γ(u) = v et γ(u
d(v,v(cid:2))|γ
(cid:2))| arˆetes {u, u
(cid:2)} dans E(G) telles que γ(u) = v et γ(u
−1(v
d(v(cid:2),v)|γ
−1(v)| = d(v,v(cid:2))|γ
(cid:2))|. Ainsi, la propri´et´e est v´eriﬁ´ee pour distD(v, v
−1(v
divisant d(v(cid:2),v) et d(v,v(cid:2) ) par leur plus grand d´enominateur commun.

(cid:2) ∈ V (D), il existe deux entiers premiers entre eux p(v, v
−1(v)| = p(v

, v) et deux entiers q
−1(v
(cid:2))| et la propri´et´e est bien v´eriﬁ´ee pour v, v

(cid:2)(cid:2))| et q

−1(v

−1(v)| arˆetes {u, u
(cid:2)) = v

On suppose que la propri´et´e est vraie pour tous sommets v, v

(cid:2)(cid:2)), p
−1(v

(cid:2)(cid:2) = p(v
(cid:2)(cid:2)|γ
(cid:2))| = q

Pour tout sommets voisins v, v

(cid:2) (resp. s(a) = v

(cid:2)

, v)|γ

−1(v

(cid:2)

(cid:2)(cid:2)|γ

(cid:2)(cid:2)

2

4.5. ´Election

105

La proposition pr´ec´edente va permettre de montrer qu’il est possible de r´esoudre le
probl`eme de l’´election dans les graphes simples minimaux pour les ﬁbrations discr`etes
non-triviales. On d´eﬁnit d’abord les candidats d’un graphe dirig´e sans boucle sur lequel
est ﬁbr´e le graphe dirig´e obtenu `a partir d’un graphe simple.
D´eﬁnition 4.31 ´Etant donn´e un graphe dirig´e fortement connexe sans boucle D tel qu’il
existe un graphe simple G tel que Dir(G) est ﬁbr´e sur D, un sommet v est un candidat
de D si pour tout v

(cid:2) ∈ V (D), p(v

, v) = 1.

(cid:2)

On note CD l’ensemble des candidats d’un graphe dirig´e fortement connexe sans boucle

D.

Dans le lemme suivant, on montre que si Dir(G) est ﬁbr´e sur un graphe D `a travers un
homomorphisme γ, la ﬁbre d’un sommet de D qui n’est pas un candidat n’est pas triviale.
Lemme 4.32 Pour tout graphe G tel que Dir(G) est ﬁbr´e sur un graphe dirig´e fortement
connexe D `a travers un homomorphisme γ, pour tout sommet v ∈ V (D)\CD, |γ
−1(v)| > 1.

De plus, pour tous v, v

(cid:2) ∈ CD, |γ

−1(v)| = |γ

−1(v

(cid:2))|.

(cid:2)

(cid:2)

−1(v

(cid:2))/p(v

(cid:2)

(cid:2)) = p(v

(cid:2)

−1(v)| = |γ

(cid:2) ∈ CD, p(v, v

(cid:2)), N(u

(cid:2)) et M(u

, v) = 1 et alors |γ

Une fois que chaque sommet u a d´etect´e que pour chaque sommet u

(cid:2) ∈ V (D), il existe exactement p(v, v
(cid:2)) et p(v
−1(v)| = 1, alors v ∈ CD.

Preuve : On consid`ere un graphe simple G tel que Dir(G) est ﬁbr´e sur un graphe dirig´e
fortement connexe sans boucle D `a travers un homomorphisme γ. Soit v un sommet de D
−1(v)| = 1. Pour tout v
tel que |γ
, v) sommets
−1(v
(cid:2)), mais puisque p(v, v
, v) sont premier entre eux, cela implique que
dans γ
, v) = 1. Par cons´equent, si |γ
p(v
(cid:2))|. 2
De plus, pour tous v, v
On sait d’apr`es la Proposition 4.27, qu’il existe une extension M(cid:2) de l’algorithme M
tel que pour chaque graphe simple G de taille born´e par B, chaque sommet u ∈ V (G)
peut d´etecter que l’algorithme M sous-jacent est termin´e.
(cid:2) ∈ V (G), les valeurs
(cid:2)) ne seront plus modiﬁ´ees, il peut reconstruire un graphe dirig´e
de n(u
sans boucle D `a partir de sa boˆıte-aux-lettres comme indiqu´e dans la Proposition 4.21.
De plus, le sommet u sait que tous les sommets ont la mˆeme boˆıte-aux-lettres et qu’ils
reconstruiront donc le mˆeme graphe dirig´e D. Par ailleurs, on sait que Dir(G) est ﬁbr´e
sur D.
Si G est minimal pour les ﬁbrations discr`etes non-triviales, on sait qu’il existe un
sommet v ∈ V (D) dont la ﬁbre est triviale. D’apr`es le Lemme 4.32, le sommet v est un
candidat de D et tous les candidats de D ont une ﬁbre triviale. Puisque V (D) = n(V (G)),
on peut choisir d’´elire le sommet de G dont l’image est le candidat de D avec le plus petit
num´ero, i.e., un sommet u prend l’´etiquette ´elu si n(u) ∈ CD et si pour tout n ∈ CD,
n(u) ≤ n. Les autres sommets, i.e., les sommets v tels que n(v) /∈ CD ou tels qu’il existe
n ≤ n(v) dans l’ensemble CD prennent l’´etiquette non-´elu. Ainsi, puisqu’il existe un
unique sommet dans n

−1(n(u)), un seul sommet de G sera ´elu.

D’apr`es la Proposition 4.29, si G n’est pas minimal pour les ﬁbrations discr`etes non-
triviales, il n’existe pas d’algorithme d’´election utilisant des calculs locaux cellulaires sur
les ´etoiles pour G. On a donc montr´e les deux th´eor`emes suivants. Le premier a ´et´e montr´e
par Boldi et al. [BCG+96]. Le second a ´et´e montr´e par Boldi et Vigna [BV01] dans le cas
particulier o`u les sommets disposent de la connaissance d’une borne sur la taille, et non
sur le diam`etre.

106

Chapitre 4. Calculs Locaux Cellulaires sur les ´Etoiles

P3

Dir(P3)

D

Fig. 17 – Le graphe Dir(P3) est ﬁbr´e proprement sur le graphe D et P3 n’est donc
pas minimal pour les ﬁbrations discr`etes. Cependant P3 est minimal pour les ﬁbrations
discr`etes non-triviales

Th´eor`eme 4.33 ([BCG+96]) Pour tout graphe simple ´etiquet´e G, il existe un algo-
rithme d’´election pour G utilisant des calculs locaux cellulaires sur les ´etoiles si et seule-
ment si Dir(G) est minimal pour les ﬁbrations discr`etes non-triviales.

Th´eor`eme 4.34 Pour tout entier B, il existe un algorithme d’´election utilisant des calculs
locaux cellulaires sur les ´etoiles pour la famille des graphes minimaux pour les ﬁbrations
discr`etes non-triviales dont le diam`etre est born´e par B.

Il existe des graphes dans lesquels on ne peut pas nommer en utilisant des calculs
locaux cellulaires sur les ´etoiles, mais dans lesquels on peut ´elire. Par exemple, certains
arbres ne sont pas minimaux pour les ﬁbrations discr`etes, comme par exemple celui de la
Figure 17. Ainsi, il n’existe pas d’algorithme universel de nommage utilisant des calculs
locaux cellulaires sur les ´etoiles pour la famille des arbres.

Cependant, l’algorithme d’´election pour la famille des arbres pr´esent´e dans le Cha-
pitre 1 utilise des calculs locaux cellulaires sur les ´etoiles et on a donc le th´eor`eme suivant.
Th´eor`eme 4.35 Il existe un algorithme d’´election pour la famille des arbres utilisant des
calculs locaux cellulaires sur les ´etoiles.

4.5.3 Des Algorithmes Eﬀectifs de Nommage et d’´Election

On suppose maintenant qu’on connaˆıt seulement une borne serr´ee sur la taille du
graphe et on va montrer qu’il existe des algorithmes eﬀectifs d’´election de nommage avec
d´etection de la terminaison utilisant des calculs locaux cellulaires sur les arˆetes.
Th´eor`eme 4.36 Pour tout entier B, il existe un algorithme eﬀectif de nommage avec
d´etection de la terminaison utilisant des calculs locaux cellulaires sur les ´etoiles pour la
classe des graphes G tels que V (G) ≤ B < 2|V (G)|.
´Etant donn´e un graphe simple G, si on connaˆıt une borne serr´ee B sur la
Preuve :
taille de G, on sait que |V (G)| ≤ B < 2|V (G)|. Soit D le graphe reconstruit par chaque
sommet u `a la ﬁn de l’ex´ecution de l’algorithme M(cid:2). Si CD est diﬀ´erent de V (D), on sait
que Dir(G) est ﬁbr´e proprement sur D et par cons´equent, G n’est pas minimal pour les
ﬁbrations discr`etes.
(cid:2) ∈
(cid:2))|. Par
(cid:2)) = p(v
V (D), p(v, v
cons´equent, si Dir(G) n’est pas isomorphe `a D, il existe une constante q ≥ 2 telle que

On suppose maintenant que CD = V (D). Par cons´equent, pour tous sommets v, v

, v) = 1. Ainsi, pour tous v, v

(cid:2)

(cid:2) ∈ V (D), |γ

−1(v)| = |γ

−1(v

4.6. Conclusions et Perspectives

107

−1(v)| = q. Par cons´equent, 2|V (D)| ≤ |V (G)| ≤ B. Au contraire,
pour tout v ∈ V (D), |γ
si Dir(G) est isomorphe `a D, 2|V (D)| = 2|V (G)| > B.
Puisque tous les sommets de G connaissent D `a la ﬁn de l’ex´ecution de M(cid:2), ils peuvent
v´eriﬁer si CD = V (D) et si 2|V (D)| > B. Si ces deux conditions sont satisfaites, il savent
que l’algorithme M(cid:2) a attribu´e des noms uniques `a tous les sommets de G. Dans le cas
contraire, ils savent que Dir(G) est ﬁbr´e proprement sur D et ils peuvent donc conclure
que G n’est pas minimal pour les ﬁbrations discr`etes.
2

De plus, pour tous sommet v ∈ CD et v

(cid:2) ∈ V (D), |γ

−1(v

Th´eor`eme 4.37 Pour tout entier B, il existe un algorithme eﬀectif d’´election utilisant
des calculs locaux cellulaires sur les ´etoiles pour la classe des graphes G tels que V (G) ≤
B < 2|V (G)|.
Preuve : ´Etant donn´e un graphe simple G, si on connaˆıt une borne serr´ee B sur la taille
de G, on sait que |V (G)| ≤ B < 2|V (G)|. Soit D le graphe reconstruit par chaque sommet
u `a la ﬁn de l’ex´ecution de l’algorithme M(cid:2) ; on rappelle que V (D) = n(V (G)). Si CD ne
contient aucun sommet de V (D), on sait que Dir(G) est ﬁbr´e non-trivialement sur D et
par cons´equent, G n’est pas minimal pour les ﬁbrations discr`etes non-triviales.
−1(v)|. Par
(cid:2))|γ
(cid:2))| = p(v, v
(cid:6)
cons´equent, puisque p(v, v) = 1, on sait que |V (G)| = |γ
(cid:2)). Si
p(v, v
v(cid:2)∈V (G)
−1(v)| ≥ 2, on sait que Dir(G) est ﬁbr´e non-trivialement sur D et que 2T ≤ |V (G)| ≤ B.
|γ
Au contraire si |γ
Par cons´equent, puisque tous les sommets de G connaissent D `a la ﬁn de l’ex´ecution
de M(cid:2), ils peuvent v´eriﬁer si CD (cid:12)= ∅ et si 2T > B. Si ces deux conditions sont satisfaites,
les sommets savent que tous les sommets u ∈ V (G) tels que n(u) ∈ CD ont des ´etiquettes
uniques. Le sommet u ∈ V (G) tel que n(u) = min{n | n ∈ CD} prend l’´etiquette ´elu et
les autres sommets prennent l’´etiquette non-´elu. Dans le cas o`u l’une des deux conditions
n’est pas satisfaite, les sommets de G savent que Dir(G) est ﬁbr´e non-trivialement sur
D et ils peuvent donc conclure que G n’est pas minimal pour les ﬁbrations discr`etes non-
triviales.
2

−1(v)| = 1, |V (G)| = T et donc 2T = 2|V (G)| > B.

−1(v)|T , o`u T =

Comme dans le cas des calculs locaux sur les ´etoiles ferm´ees, on remarque que si la
borne sur la taille de G n’est pas serr´ee, il n’existe pas d’algorithme utilisant des calculs
locaux cellulaires sur les ´etoiles qui permet de r´esoudre le probl`eme du nommage avec
d´etection de la terminaison (resp. le probl`eme de l’´election) sur G ou de d´etecter que G
n’est pas minimal pour les ﬁbrations discr`etes (resp. les ﬁbrations discr`etes non-triviales).

4.6 Conclusions et Perspectives

Dans ce chapitre, on a pr´esent´e une caract´erisation des graphes admettant un algo-
rithme de nommage utilisant des calculs locaux sur les ´etoiles ouvertes (Th´eor`eme 4.22).
On a aussi pr´esent´e une caract´erisation des graphes admettant un algorithme d’´election
(Th´eor`eme 4.33). Les caract´erisations pr´esent´ees dans ce chapitre sont bas´ees sur la notion
de ﬁbrations.

On a par ailleurs ´etudi´e les connaissances initiales n´ecessaires pour r´esoudre ces pro-
bl`emes. Ainsi, la connaissance initiale d’une borne sur le diam`etre permet de r´esoudre

108

Chapitre 4. Calculs Locaux Cellulaires sur les ´Etoiles

´election (resp. nommage) sur un graphe minimal pour les ﬁbrations non-triviales (resp.
minimal pour les ﬁbrations) ; ces r´esultats sont pr´esent´es dans les Th´eor`emes 4.34 et 4.28.
Par ailleurs, la connaissance initiale d’une borne serr´ee sur la taille permet d’obtenir des
algorithmes eﬀectifs de nommage et d’´election (Th´eor`emes 4.36 et 4.37).

Les r´esultats obtenus dans ce mod`ele nous permettent de penser que les techniques
pr´esent´ees dans [GM03, GMM04, God02b, MT00, GM02] peuvent ˆetre adapt´ees dans le
mod`ele ´etudi´e dans ce chapitre. Il semble en particulier que lorsqu’aucune connaissance
initiale n’est disponible, les classes de graphes simples reconnaissables dans ce mod`ele
doivent v´eriﬁer les mˆemes propri´et´es que celles pr´esent´ees dans [GMM04].

Chapitre 5

Calculs Locaux sur les Arˆetes
Non-´Etiquet´ees

Sommaire
5.1

quet´ees

5.4

Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
5.1.1 R´esultats
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
5.1.2 Travaux Li´es
5.2 Pseudo-revˆetements . . . . . . . . . . . . . . . . . . . . . . . . . . 111
5.3 Calculs Locaux sur les Arˆetes Non-´Etiquet´ees . . . . . . . . . . 114
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114

5.3.1 D´eﬁnitions
5.3.2 Pseudo-Revˆetements et Calculs Locaux sur les Arˆetes Non-´Eti-

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
´Enum´eration, Nommage et ´Election . . . . . . . . . . . . . . . . 115
5.4.1 R´esultats d’Impossibilit´e . . . . . . . . . . . . . . . . . . . . . . . 116
5.4.2 Un Algorithme d’´Enum´eration . . . . . . . . . . . . . . . . . . . 116
5.4.3 Correction de l’Algorithme d’´Enum´eration . . . . . . . . . . . . . 120
5.4.4 Complexit´e . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
5.5 Connaissance Initiale du Degr´e . . . . . . . . . . . . . . . . . . . 127
´Election dans la Famille des Arbres . . . . . . . . . . . . . . . . . 127
´Election dans les Familles de Diam`etre Born´e . . . . . . . . . . . 129
Impossibilit´e de D´etecter la Non-Minimalit´e . . . . . . . . . . . . 134
5.6 Conclusion et Perspectives . . . . . . . . . . . . . . . . . . . . . . 136

5.5.1
5.5.2
5.5.3

5.1

Introduction

Dans ce chapitre, on ´etudie les calculs locaux sur les arˆetes non-´etiquet´ees. Dans ce
mod`ele, on consid`ere des graphes simples o`u seuls les sommets peuvent ˆetre ´etiquet´es,
comme dans le Chapitre 4. Un pas de calcul est d´ecrit par une r`egle de r´e´etiquetage de
la forme pr´esent´ee sur la Figure 18. Si dans un graphe G, deux sommets voisins sont
(cid:2) et Y par
´etiquet´es X et Y , alors lors de l’application de cette r`egle, on remplace X par X
(cid:2). Les ´etiquettes de tous les autres sommets de G ne sont pas prises en compte lors de
Y

109

110

Chapitre 5. Calculs Locaux sur les Arˆetes Non-´Etiquet´ees

X

Y

(cid:2)

X

(cid:2)

Y

Fig. 18 – Forme g´en´erique d’une r`egle de calcul pour les calculs locaux sur les arˆetes
non-´etiquet´ees.

l’application de la r`egle et ne sont pas modiﬁ´ees. Les sommets de G dont les ´etiquettes sont
modiﬁ´ees sont dits actifs et les autres sommets de G sont dits inactifs. Les calculs r´ealis´es
en utilisant uniquement ce type de r`egles de r´e´etiquetage sont appel´es calculs locaux sur les
arˆetes non-´etiquet´ees. Il faut noter, que comme dans le mod`ele du Chapitre 3, les r`egles ne
sont pas sym´etriques, i.e., l’application d’une r`egle de r´e´etiquetage sur une arˆete dont les
deux extr´emit´es ont la mˆeme ´etiquette peut attribuer des nouvelles ´etiquettes diﬀ´erentes
aux deux sommets.

La diﬀ´erence entre ce mod`ele et le mod`ele des calculs locaux sur les arˆetes ´etiquet´ees
est que les arˆetes ne peuvent pas ˆetre ´etiquet´ees (et r´e´etiquet´ees) ; cela donne un mod`ele
strictement plus faible. On montre aussi que les calculs locaux sur les arˆetes non-´etiquet´ees
et les calculs locaux cellulaires sur les ´etoiles ont des puissances de calcul incomparables.
En eﬀet, il existe des graphes admettant un algorithme de nommage et d’´election utili-
sant des calculs locaux sur les arˆetes non-´etiquet´ees pour lesquels il n’existe pas d’algo-
rithme d’´election ou de nommage utilisant des calculs locaux cellulaires sur les ´etoiles, et
r´eciproquement. Ainsi, lorsque les arˆetes ne peuvent pas ˆetre ´etiquet´ees, il n’existe pas de
r´esultat correspondant `a la Proposition 3.42.

5.1.1 R´esultats

Dans le mod`ele des calculs locaux sur les arˆetes non-´etiquet´ees, on caract´erise les
graphes admettant un algorithme de nommage et d’´election. Comme dans les Chapitres 2
et 3, on peut ´elire dans un graphe si et seulement si on peut nommer dans ce graphe. On
introduit la notion de pseudo-revˆetements pour pouvoir exprimer cette caract´erisation.

On montre qu’un graphe admet un algorithme de nommage et d’´election utilisant
des calculs locaux sur les arˆetes non-´etiquet´ees si et seulement s’il est minimal pour les
pseudo-revˆetements (Th´eor`eme 5.19). L’algorithme d’´enum´eration qu’on pr´esente dans la
Section 5.4 est adapt´e de l’algorithme de Mazurkiewicz.

Cependant, dans le mod`ele consid´er´e ici, un sommet ne peut pas distinguer ses voisins.
Lorsqu’un sommet ´echange son num´ero avec un de ses voisins, il doit aussi d´etruire de sa
vue locale l’information relative `a l’ancien num´ero de ce voisin. Ainsi, dans notre algo-
rithme, `a chaque fois que la vue locale d’un sommet v est modiﬁ´ee, on supprime beaucoup
d’information de la vue locale de v aﬁn de s’assurer que les informations erron´ees ont bien
´et´e eﬀac´ees. Toutefois, on peut aussi supprimer de cette mani`ere des informations valides
qui devront ˆetre acquises `a nouveau par le sommet v.

De plus, dans le mod`ele ´etudi´e ici, l’algorithme doit assurer que tous les num´eros
attribu´es au sommets apparaissent avec la mˆeme cardinalit´e dans la conﬁguration ﬁnale.
La solution propos´ee est d’associer un identiﬁant `a chaque transaction entre deux voisins
de telle sorte que deux transactions impliquant un mˆeme sommet aient deux identiﬁants
distincts. On montre qu’avec cette m´ethode, dans la conﬁguration ﬁnale, tous les num´eros
associ´es aux sommets apparaissent avec la mˆeme cardinalit´e. Cependant, ce m´ecanisme
implique que lorsqu’un sommet v met `a jour sa vue locale en se synchronisant avec un

5.2. Pseudo-revˆetements

111

(cid:2), alors la vue locale de v

(cid:2) est aussi modiﬁ´ee et des informations valides en sont
voisin v
(cid:2) doit alors aussi remettre `a jour sa vue locale, etc. Il faut donc
eﬀac´ees. Le sommet v
montrer que la pr´esence des identiﬁants associ´ees aux transactions entre voisins ne g´en`ere
pas d’ex´ecution inﬁnie.

Le m´ecanisme utilis´e pour s’assurer que tous les num´eros associ´es aux sommets appa-
raissent avec la mˆeme cardinalit´e dans la conﬁguration ﬁnale a un impact non-n´egligeable
sur la complexit´e. En eﬀet, certaines ex´ecutions de l’algorithme n´ecessitent un nombre
d’´etapes de r´e´etiquetage exponentiel en la taille du graphe.

On ´etudie ensuite l’inﬂuence de la connaissance initiale du degr´e et on montre que
si initialement, chaque sommet connaˆıt son degr´e, alors il suﬃt de connaˆıtre une borne
sur le diam`etre pour pouvoir nommer ou ´elire dans un graphe minimal pour les pseudo-
revˆetements (Th´eor`eme 5.28). Contrairement aux mod`eles ´etudi´es dans les Chapitres 2,
3 et 4, la connaissance initiale du degr´e ne permet pas d’obtenir un algorithme eﬀectif
d’´election dans ce mod`ele mˆeme si on connaˆıt la taille exacte du graphe.

Une partie des r´esultats pr´esent´es dans ce chapitre a ´et´e publi´ee dans [Cha05].

5.1.2 Travaux Li´es

Dans [AAD+04, AAD+06, AAE06b, AAE06a], Angluin et al. consid`erent un mod`ele
utilisant le mˆeme type de r`egles. Ils supposent que la m´emoire de chaque processus est
ﬁnie : l’ensemble des ´etiquettes apparaissant sur les sommets au cours de toute ex´ecution
est donc ﬁni et ind´ependant de la taille du graphe.

De plus, ils supposent que si une conﬁguration globale peut ˆetre inﬁniment souvent
atteinte en un nombre ﬁni d’´etapes `a partir de la conﬁguration courante, alors cette conﬁ-
guration globale sera atteinte. De cette mani`ere, il n’est pas n´ecessaire de consid´erer des
relations de r´e´etiquetage noetheriennes. Ils montrent que dans ce contexte, la topologie
du graphe n’entre pas en compte et qu’ils peuvent toujours consid´erer que le graphe est
complet.

Ils supposent qu’il existe une fonction de sortie qui permet d’attribuer `a chaque conﬁ-
guration globale du graphe une valeur, qui est le r´esultat du calcul. Ils consid`erent des
ex´ecutions qui calculent un r´esultat de mani`ere stabilisante : ce sont les ex´ecutions telles
qu’`a partir d’une certaine ´etape, la fonction de sortie renvoie toujours la mˆeme valeur.
Cette notion de terminaison est `a rapprocher de la terminaison implicite, au sens o`u les
sommets ne savent pas si l’ex´ecution est termin´ee. Il faut toutefois noter que la fonction
de sortie est globale et par cons´equent, les ´etiquettes peuvent ˆetre modiﬁ´ees, tant que
globalement, le r´esultat reste le mˆeme.

En supposant que chaque sommet v `a initialement une valeur input(v) dans un apha-
bet d’entr´ee Σ, Angluin et al. d´eterminent quels pr´edicats satisfaits par le multi-ensemble
des entr´ees peuvent ˆetre calcul´es de mani`ere stabilisante. Ils montrent que dans ce mod`ele,
les pr´edicats calculables de mani`ere stabilisante sont les pr´edicats semi-lin´eaires portant
sur la multiplicit´e de chaque symbole de Σ.

5.2 Pseudo-revˆetements

Dans ce chapitre, les pseudo-revˆetements sont les homomorphismes qui permettent
de caract´eriser les graphes o`u on peut r´esoudre l’´election et le nommage avec des calculs

112

Chapitre 5. Calculs Locaux sur les Arˆetes Non-´Etiquet´ees

locaux sur les arˆetes non-´etiquet´ees.
D´eﬁnition 5.1 Un graphe simple G est un un pseudo-revˆetement d’un graphe simple H
`a travers un homomorphisme γ : G → H et respectivement `a G
(cid:2) est un sous-graphe
(cid:2) est
partiel de G (i.e., V (G
un homomorphisme localement bijectif de G

(cid:2)) ⊆ E(G)) et si la restriction γ|G(cid:2) de γ `a G

(cid:2)) = V (G) et E(G

(cid:2) dans H.

(cid:2) si G

Un graphe simple G est un pseudo-revˆetement propre de H si γ n’est pas un isomor-
phisme et G est minimal pour les pseudo-revˆetements si G n’est un pseudo-revˆetement
propre d’aucun autre graphe simple.

Naturellement, un graphe simple ´etiquet´e (G, λ) est un pseudo-revˆetement d’un graphe

(cid:2)
simple (H, η) `a travers γ et respectivement `a (G
Proposition 5.2 Si le graphe G est un pseudo-revˆetement d’un graphe H `a travers γ
et respectivement `a G(cid:2), alors pour chaque arˆete {v1, v2} ∈ E(H), chaque sommet u1 ∈
−1(v1) (resp. u2 ∈ γ
−1(v2) (resp.
γ
u1 ∈ γ
−1(v2) est un couplage

−1(v2)) est adjacent `a exactement un sommet u2 ∈ γ

−1(v1)) dans le graphe G
(cid:2).

Par cons´equent, le sous-graphe de G

, λ) si γ conserve l’´etiquetage.

parfait dans le sous-graphe de G induit par γ
Preuve : On consid`ere un graphe G qui est un pseudo-revˆetement d’un graphe H `a
travers γ et respectivement `a G(cid:2).
−1(v1), il existe un
−1(v2)∩NG(cid:2)(v1) puisque γ|G(cid:2) est un homomorphisme localement bijectif de G
unique u2 ∈ γ
(cid:2)
−1(v1)∩ NG(cid:2)(v2).
dans H. Par sym´etrie, pour tout u2 ∈ γ

On consid`ere deux sommets voisins v1, v2 ∈ V (H). Pour tout u1 ∈ γ
−1(v2), il existe un unique u1 ∈ γ

(cid:2) induit par γ
−1(v1) et γ

−1(v1) et γ
−1(v2).

2

Exemple 5.3 Le graphe G de la Figure 19 est un pseudo-revˆetement de H `a travers γ et
respectivement `a G(cid:2).
Les arˆetes repr´esent´ees en gras dans la repr´esentation de G (resp. G(cid:2)) sont les arˆetes
de G (resp. G(cid:2)) que γ envoie sur l’arˆete {1, 3} de H. On remarque sur cet exemple qu’un
homomorphisme γ qui d´eﬁnit un pseudo-revˆetement ne conserve pas forc´ement le degr´e,
contrairement `a un homomorphisme localement bijectif.

Le graphe G est un pseudo-revˆetement propre de H et le graphe H est minimal pour

les pseudo-revˆetements.

On note que le graphe G de la Figure 19 est minimal pour les ﬁbrations discr`etes. Ainsi,
il existe des graphes minimaux pour les ﬁbrations discr`etes qui ne sont pas minimaux pour
les pseudo-revˆetements. R´eciproquement, le graphe de la Figure 15 est minimal pour les
pseudo-revˆetements (il a un nombre premier de sommets) mais il n’est pas minimal pour
les ﬁbrations discr`etes non-triviales.

Si G est un pseudo-revˆetement de H `a travers γ et respectivement `a G(cid:2), les propositions
suivantes sont des corollaires des Propositions 2.5 et 2.6, puisque G(cid:2) est un revˆetement de
H `a travers γ|G(cid:2) et puisque V (G
Proposition 5.4 Si un graphe simple G est un pseudo-revˆetement d’un graphe simple
connexe H `a travers γ et respectivement `a G(cid:2), alors γ est surjectif.
Proposition 5.5 Si un graphe simple G est un pseudo-revˆetement d’un graphe simple
connexe H `a travers γ et respectivement `a G(cid:2), alors il existe une constante q telle que
pour tout sommet v ∈ V (H), |γ

−1(v)| = q.

(cid:2)) = V (G).

5.2. Pseudo-revˆetements

113

3G

1

2

2

1

γ

3

H

1

sous-graphe partiel

1

2

3

γ|G(cid:2)

2

1

G(cid:2)

3

3

2

Fig. 19 – Le graphe G est un pseudo-revˆetement de H `a travers l’homomorphisme γ et
respectivement `a G(cid:2) o`u γ envoie chaque sommet de G ´etiquet´e i sur l’unique sommet de
H ´etiquet´e i.

Ainsi, les graphes simples ayant un nombre premier de sommets sont minimaux pour les
pseudo-revˆetements. Cependant, on va voir dans la Section 5.5 que les arbres ne sont pas
minimaux pour les pseudo-revˆetements, bien qu’ils soient minimaux pour les revˆetements
et pour les ﬁbrations discr`etes non-triviales.

La notion de coloration pseudo-r´eguli`ere permet de caract´eriser les graphes minimaux
pour les pseudo-revˆetements en termes de colorations de graphes. Un ´etiquetage (cid:8) d’un
graphe non-´etiquet´e est une coloration pseudo-r´eguli`ere si deux sommets voisins ont des
couleurs distinctes et si le graphe induit par deux classes de couleurs adjacentes admet un
coupage parfait.
D´eﬁnition 5.6 Une coloration pseudo-r´eguli`ere d’un graphe simple non-´etiquet´e G est
un ´etiquetage (cid:8) de G tel que

– pour tout i ∈ (cid:8)(V (G)), G[i] est un stable,
– pour tout i, j ∈ (cid:8)(V (G)) avec i (cid:12)= j, G[i, j] est un stable, ou alors G[i, j] admet un

couplage parfait.

Dans la proposition suivante, on caract´erise les graphes qui sont minimaux pour les
pseudo-revˆetements `a l’aide de la notion de coloration pseudo-r´eguli`ere. On rappelle qu’une
coloration (cid:8) est dite propre si |(cid:8)(V (G))| < |V (G)|.
Proposition 5.7 Un graphe G est minimal pour les pseudo-revˆetements si et seulement
si G n’admet aucune coloration pseudo-r´eguli`ere propre.
Preuve : ´Etant donn´e un graphe G qui n’est pas minimal pour les pseudo-revˆetements, on
(cid:2) de G, un graphe H et un homomorphisme γ : G → H
consid`ere un sous graphe partiel G
(cid:2). On
tels que G est un pseudo-revˆetement propre de H `a travers γ et respectivement `a G
va montrer que γ est une coloration pseudo-r´eguli`ere de G et que l’ensemble des couleurs
(cid:2)} ∈ V (G),
utilis´es est V (H). Puisque H est un graphe simple, pour toute arˆete {u, u

114

Chapitre 5. Calculs Locaux sur les Arˆetes Non-´Etiquet´ees

(cid:2)). De plus, pour tous v, v

γ(u) (cid:12)= γ(u
puisque γ est un homomorphisme. Et si {v, v
on sait que les arˆetes du sous-graphe induit par γ
parfait de G[v, v
r´eguli`ere propre de G.

(cid:2)] est un stable
(cid:2)} ∈ E(H), alors d’apr`es la Proposition 5.2,
(cid:2) est un couplage
(cid:2)]. Finalement, puisque |V (H)| < |V (G)|, γ est une coloration pseudo-

(cid:2)} /∈ E(H), alors G[v, v

(cid:2) ∈ V (H), si {v, v

−1(v) ∪ γ

(cid:2)) dans G

−1(v

(cid:2) ∈ V (H), l’arˆete {v, v

R´eciproquement, ´etant donn´ee une coloration pseudo-r´eguli`ere propre (cid:8) d’un graphe
G, on va d´eﬁnir un graphe H tel que G soit un pseudo-revˆetement de H. On pose
(cid:2)} appartient `a E(H) si et seule-
V (H) = (cid:8)(V (G)). Pour tous v, v
(cid:2)] n’est pas un stable. Le graphe H ainsi d´eﬁni est un graphe simple. On
ment si G[v, v
pose γ = (cid:8) et pour toute arˆete {u, u
(cid:2))] n’est pas un stable et par
cons´equent, {γ(u), γ(u
(cid:2))} ∈ E(H). Ainsi, γ est un homomorphisme de G dans H. Pour
(cid:2)} ∈ E(H), il existe un en-
d´eﬁnir G
semble d’arˆetes M{v,v(cid:2)} ∈ E(G) qui est un couplage parfait de (cid:8)
(cid:2)). On pose
M{v,v(cid:2)}. ´Etant donn´e un sommet u ∈ V (G), on note v = γ(u). Pour
(cid:2)) =
E(G
(cid:2) ∈ NH(v), il existe exactement une arˆete {u, u
(cid:2)} ∈ M{v,v(cid:2)} et par cons´equent, u a
(cid:2)). Ainsi γ|G(cid:2) est un homomorphisme localement bijectif de G
(cid:2)

tout v
un unique voisin u
dans H et G n’est donc pas minimal pour les pseudo-revˆetements.

(cid:2)} ∈ E(G), G[(cid:8)(u), (cid:8)(u
(cid:2)). Pour toute arˆete {v, v

(cid:2), il suﬃt de d´eﬁnir E(G

−1(v) ∪ (cid:8)

{v,v(cid:2)}∈E(H)

(cid:2) ∈ γ

−1(v

−1(v

(cid:4)

2

5.3 Calculs Locaux sur les Arˆetes Non-´Etiquet´ees

On rappelle qu’informellement, les calculs locaux sur les arˆetes non-´etiquet´ees sont les
calculs r´ealis´es en utilisant uniquement des r`egles de la forme pr´esent´ee sur la Figure 18 : `a
chaque pas de calcul, l’´etiquette de deux sommets voisins sont modiﬁ´ees par l’application
d’une r`egle qui ne d´epend que de l’´etiquette de ces deux sommets. On pr´esente maintenant
un d´eﬁnition plus formelle du mod`ele.

5.3.1 D´eﬁnitions

Une relation de r´e´etiquetage R est localement engendr´ee sur les arˆetes non-´etiquet´ees
si l’application d’une r`egle ne d´epend que des ´etiquettes des extr´emit´es d’une arˆete et si
seulement ces deux ´etiquettes sont modiﬁ´ees.
D´eﬁnition 5.8 Une relation de r´e´etiquetage R est localement engendr´ee sur les arˆetes
(cid:2)),
non-´etiquet´ees si la condition suivante est satisfaite : Pour tous graphes (G, λ), (G, λ
(cid:2)) et toutes arˆetes {v1, v2} ∈ E(G) et {w1, w2} ∈ E(H), si les trois conditions
(H, η), (H, η
suivantes sont v´eriﬁ´ees :

1. λ(v1) = η(w1), λ(v2) = η(w2), λ
2. λ(v) = λ
3. η(w) = η

(cid:2)(v), pour tout v /∈ {v1, v2},
(cid:2)(w), pour tout w /∈ {w1, w2},

alors (G, λ) R (G, λ

(cid:2)) si et seulement si (H, η) R (H, η

(cid:2)).

(cid:2)(v1) = η

(cid:2)(w1) et λ

(cid:2)(v2) = η

(cid:2)(w2),

Par d´eﬁnition, les calculs locaux sur les arˆetes non-´etiquet´ees correspondent aux rela-

tions de r´e´etiquetage localement engendr´ees sur les arˆetes non-´etiquet´ees.

Une relation de r´e´etiquetage localement engendr´ee sur les arˆetes non-´etiquet´ees peut
ˆetre d´ecrite par un ensemble r´ecursif de r`egles de la forme pr´esent´ees sur la Figure 18.

5.4. ´Enum´eration, Nommage et ´Election

115

R´eciproquement, un tel ensemble de r`egles induit une relation de r´e´etiquetage locale-
ment engendr´ee sur les arˆetes non-´etiquet´ees. Ainsi, on notera R l’ensemble de r`egles de
r´e´etiquetage aussi bien que la relation de r´e´etiquetage correspondante.

5.3.2 Pseudo-Revˆetements et Calculs Locaux sur les Arˆetes Non-´Eti-

quet´ees

Le lemme suivant met en ´evidence le lien entre les calculs locaux sur les arˆetes non-
´etiquet´ees et les pseudo-revˆetements. C’est l’´equivalent du lemme de rel`evement d’Angluin
[Ang80] pour les pseudo-revˆetements.
Lemme 5.9 On consid`ere un graphe simple G0 = (G, λ0) qui est un pseudo-revˆetement
d’un graphe simple H0 = (H, η0) `a travers un homomorphisme γ et respectivement `a un
, λ0) de G. Pour toute relation R de r´e´etiquetage localement
sous graphe partiel G(cid:2)
engendr´ee sur les arˆetes, si H0 R∗ H1 = (H, η1), alors il existe G1 = (G, λ1) tel que
G0 R∗ G1 et G1 est un pseudo-revˆetement de H1 `a travers γ et respectivement `a G(cid:2)
1 =
(cid:2)
(G

(cid:2)
0 = (G

, λ1).

Puisque G

−1(v

(cid:2))) a un unique voisin u ∈ γ

(cid:2) est un revˆetement de H `a travers γG(cid:2), tout sommet u ∈ γ

Preuve : On consid`ere deux graphes (G, λ0), (H, ν0) tels que (G, λ0) est un pseudo-
(cid:2)
revˆetement de (H, ν0) `a travers ϕ et respectivement `a (G
, λ0). Il suﬃt de prouver le
lemme pour un pas de calcul. On consid`ere un pas de r´e´etiquetage sur H qui modiﬁe les
(cid:2)} ∈ E(H). On note η1 l’´etiquetage de H obtenu
´etiquettes des extr´emit´es d’une arˆete {v, v
apr`es ce pas de r´e´etiquetage.
−1(v) (resp.
(cid:2) ∈ γ
(cid:2))) et on
u
peut donc appliquer la r`egle de r´e´etiquetage sur toutes les arˆetes {u, u
(cid:2)) telles
−1(v) a l’´etiquette η1(v) et tout
que γ(u) = v et γ(u
(cid:2)) ; les ´etiquettes des autres sommets ne sont pas
−1(v
sommet u
(cid:2)
modiﬁ´ees. On note λ1, l’´etiquetage de G ainsi obtenu et on sait que (G
, λ1) est toujours un
revˆetement de (H, η1) `a travers γG(cid:2). De plus, γ est toujours un homomorphisme de (G, λ1)
dans (H, λ1) et par cons´equent (G, λ1) est un pseudo-revˆetement de (H, η1) `a travers γ et
(cid:2)
respectivement `a (G
2

(cid:2)) = v
(cid:2)) a l’´etiquette η1(v

(cid:2). Ainsi, tout sommet u ∈ γ

−1(v

(cid:2)) ∩ NG(cid:2)(u) (resp. u ∈ γ

−1(v) ∩ NG(cid:2)(u
(cid:2)} ∈ E(G

(cid:2) ∈ γ

, λ1).

Le diagramme suivant repr´esente la propri´et´e du Lemme 5.9.

pseudo-revˆetement

R∗−−−−→ G(cid:2)

G

⏐⏐(cid:3)
H −−−−→

R∗ H(cid:2)

⏐⏐(cid:3)pseudo-revˆetement

5.4

´Enum´eration, Nommage et ´Election

On s’int´eresse maintenant aux probl`emes d’´election et de nommage dans le cadre
des calculs locaux sur les arˆetes non-´etiquet´ees. Dans ce mod`ele, les graphes o`u on peut
r´esoudre l’´election sont exactement les graphes o`u on peut r´esoudre le nommage et l’´enu-
m´eration. Cela est du `a la Proposition 5.5 : si on arrive `a distinguer un sommet en lui

116

Chapitre 5. Calculs Locaux sur les Arˆetes Non-´Etiquet´ees

attribuant une ´etiquette sp´eciale, alors on arrivera `a donner des ´etiquettes uniques `a tous
les sommets.

On montre d’abord qu’il ne peut pas exister d’algorithme d’´election ou de nommage
pour un graphe simple G qui n’est pas minimal pour les pseudo-revˆetements. On pr´esente
ensuite un algorithme d’´enum´eration `a la Mazurkiewicz pour les graphes minimaux pour
les pseudo-revˆetements.

5.4.1 R´esultats d’Impossibilit´e

Proposition 5.10 Soit G un graphe simple ´etiquet´e qui n’est pas minimal pour les pseudo-
revˆetements. Il n’existe pas d’algorithme de nommage, d’´enum´eration ou d’´election pour
le graphe G utilisant des calculs locaux sur les arˆetes non-´etiquet´ees.

Preuve : On consid`ere un graphe simple ´etiquet´e H qui n’est pas isomorphe `a G et tel
que G soit un pseudo-revˆetement de H `a travers un homomorphisme γ et respectivement
`a un sous-graphe G(cid:2) de G. ´Etant donn´e un algorithme R utilisant des calculs locaux sur
les arˆetes non-´etiquet´ees, on consid`ere une ex´ecution de R sur H. Si cette ex´ecution est
inﬁnie sur H, alors d’apr`es le Lemme 5.9, il existe une ex´ecution inﬁnie de R sur G ; auquel
cas, R n’est ni un algorithme d’´enum´eration, ni de nommage, ni d’´election.
On suppose maintenant qu’il existe une ex´ecution ﬁnie de R sur H et on consid`ere
la conﬁguration ﬁnale H1. D’apr`es le Lemme 5.9, il existe une ex´ecution de R sur G qui
permet d’atteindre une conﬁguration G1 telle que G1 est un pseudo-revˆetement de H1 `a
1. Si G1 n’est pas une conﬁguration ﬁnale de R, alors il
travers γ et respectivement `a G(cid:2)
(cid:2)} ∈ E(G) telle qu’on puisse appliquer une r`egle de r´e´etiquetage sur
existe une arˆete {u, u
(cid:2)}. Dans ce cas l`a, on peut aussi appliquer cette mˆeme r`egle de r´e´etiquetage sur l’arˆete
{u, u
(cid:2))} ∈ E(H) et la conﬁguration H1 n’est pas une conﬁguration ﬁnale de R. Par
{γ(u), γ(u
cons´equent, G1 est une conﬁguration ﬁnale de R. Mais puisque G1 n’est pas isomorphe `a
H1, on sait d’apr`es la Proposition 5.5 que chaque ´etiquette de H1 apparaˆıt au moins deux
fois dans G1 et par cons´equent, R n’est ni un algorithme de nommage, ni un algorithme
d’´enum´eration, ni un algorithme d’´election.

2

5.4.2 Un Algorithme d’´Enum´eration

On va maintenant d´ecrire un algorithme d’´enum´eration M pour les graphes minimaux
pour les pseudo-revˆetements. Cet algorithme s’inspire de l’algorithme de Mazurkiewicz.
Durant l’ex´ecution de l’algorithme, chaque sommet v essaie d’obtenir une identit´e qui
est un num´ero entre 1 et |V (G)|. Chaque sommet va ensuite ´echanger son num´ero avec
ses voisins. `A chacune de ces transactions o`u deux sommets ´echangent leurs num´eros, on
va associer un identiﬁant tel que deux transactions impliquant le mˆeme sommet aient des
identiﬁant diﬀ´erents. Grˆace `a ces ´echanges de num´eros, chaque sommet peut construire sa
vue locale, qui est ici un ensemble ﬁni de couples d’entiers : `a chaque ´echange de num´ero
avec un de ses voisins, le sommet ajoute le num´ero de ce voisin associ´e `a l’identiﬁant de
la transaction `a sa vue locale. Ensuite, chaque sommet va diﬀuser dans tout le graphe son
num´ero et sa vue locale. Si un sommet u d´ecouvre qu’un autre sommet v a le mˆeme num´ero
que lui, alors le sommet u doit d´ecider s’il modiﬁe son identit´e. Pour cela, il compare son
´etiquette λ(u) et sa vue locale avec l’´etiquette λ(v) et la vue locale de v : si l’´etiquette

5.4. ´Enum´eration, Nommage et ´Election

117

de u est plus faible que l’´etiquette de v ou si les deux sommets ont la mˆeme ´etiquette
et que la vue locale de u est plus «faible» (pour un ordre proche de l’ordre utilis´e dans
l’algorithme de Mazurkiewicz), alors le sommet u choisit un nouveau num´ero (sa nouvelle
identit´e temporaire) et la diﬀuse `a nouveau avec sa vue locale. Lorsque l’ex´ecution est
termin´ee, si le graphe G est minimal pour les pseudo-revˆetements, alors chaque sommet
a un num´ero unique : l’algorithme permet de r´esoudre le probl`eme du nommage.

Une premi`ere diﬃcult´e par rapport aux versions pr´ec´edentes est qu’un sommet ne peut
pas faire la distinction entre ses voisins qui ont le mˆeme num´ero. Ainsi, lorsqu’un sommet
´echange son num´ero avec un de ses voisins, il doit aussi d´etruire de sa vue locale l’informa-
tion relative `a l’ancien num´ero de ce voisin. Pour cela, l’algorithme qu’on pr´esente d´etruit
des informations qui peuvent ˆetre valides de la vue locale du sommet aﬁn de s’assurer que
l’information obsol`ete a bien ´et´e supprim´ee. Cette m´ethode permet de s’assurer que dans
la conﬁguration ﬁnale, la vue locale de chaque sommet ne contient que des informations
pertinentes.

Par ailleurs, dans le mod`ele ´etudi´e ici, l’algorithme doit assurer que tous les num´eros
attribu´es au sommets apparaissent avec la mˆeme cardinalit´e dans la conﬁguration ﬁnale.
Pour cela, dans notre algorithme, on associe un identiﬁant `a chaque transaction entre deux
voisins. Cette m´ethode permet d’assurer que dans la conﬁguration ﬁnale, tous les num´eros
associ´es aux sommets apparaissent avec la mˆeme cardinalit´e. Cependant, ce m´ecanisme
implique que lorsqu’un sommet v met `a jour sa vue locale en se synchronisant avec un
(cid:2) est aussi modiﬁ´ee et des informations valides en sont
voisin v
(cid:2) doit alors aussi remettre `a jour sa vue locale, etc. Il faut donc
eﬀac´ees. Le sommet v
montrer que l’utilisation des identiﬁants associ´ees aux transactions entre voisins ne g´en`ere
pas d’ex´ecution inﬁnie.

(cid:2), alors la vue locale de v

L’utilisation de ces identiﬁants pour assurer un r´esultat correct a un impact non-
n´egligeable sur la complexit´e. En eﬀet, certaines ex´ecutions de l’algorithme n´ecessitent un
nombre d’´etapes de r´e´etiquetage exponentiel en la taille du graphe.

´Etiquettes

l’ex´ecution.

l’algorithme,

On consid`ere un graphe G = (G, λ) o`u λ: V (G) → L est un ´etiquetage initial, qui
ne sera pas modiﬁ´e par l’algorithme. Lors de l’ex´ecution, chaque sommet va obtenir une
´etiquette de la forme (λ(v), n(v), N(v), M(v)) qui repr´esente les informations suivantes :
– la premi`ere composante λ(v) est l’´etiquette initiale et ne sera pas modiﬁ´ee lors de
– n(v) ∈ N est le num´ero courant du sommet v qui est modiﬁ´e lors de l’ex´ecution de
– N(v) ∈ Pﬁn(N2) est la vue locale du sommet v. Informellement, la vue locale contient
(cid:2), un
(cid:2)} va permettre de g´en´erer un identiﬁant o et d’ajouter
(cid:2)). Ainsi N(v) est toujours un ensemble
– M(v) ⊆ N × L × Pﬁn(N2) est la boˆıte-aux-lettres de v. Elle va contenir toute l’infor-
mation re¸cue par v lors de l’ex´ecution de l’algorithme, i.e., les couples de num´eros
et de vues locales qui auront ´et´e diﬀus´ees par tous les sommets du graphe.

l’information la plus r´ecente que v a de ses voisins. Si le sommet v a un voisin v
pas de r´e´etiquetage sur {v, v
(n(v
ﬁni de couples d’entiers.

(cid:2)), o) `a N(v) ainsi que (n(v), o) `a N(v

118

Chapitre 5. Calculs Locaux sur les Arˆetes Non-´Etiquet´ees

Initialement, chaque sommet a une ´etiquette de la forme (λ(v), 0,∅,∅) qui signiﬁe qu’au
d´ebut de l’algorithme, v n’a pas choisi de num´ero et qu’il n’a aucune information `a propos
de ses voisins, ni `a propos des autres sommets du graphe.

La diﬀ´erence entre les ´etiquettes utilis´ees ici et les ´etiquettes de l’algorithme de Mazur-
kiewicz [Maz97] sont les identiﬁants o qui apparaissent dans les vues locales des sommets.
Dans le Chapitre 3, les num´eros associ´es aux arˆetes permettaient de distinguer les diﬀ´erents
voisins d’un sommet et permettaient de d´eﬁnir les arˆetes du graphe construit `a partir de
l’´etiquetage ﬁnal. Ici, les identiﬁants o vont permettre de d´eterminer quelles sont les arˆetes
(cid:2) soit un revˆetement du graphe
de G qui devront ˆetre conserv´ees dans E(G
construit `a partir de l’´etiquetage ﬁnal.

(cid:2)) aﬁn que G

Un Ordre sur les Vues Locales

(cid:2)

(cid:2)) si n < n

(cid:2) ou si n = n

(cid:2) et si o < o
(cid:2).

, o

Comme pour l’algorithme de Mazurkiewicz [Maz97], les bonnes propri´et´es de l’algo-
rithme reposent sur un ordre sur les vues locales, i.e., sur les ensembles ﬁnis de couples
d’entiers. Pour cela, on consid`ere que N2 est muni de l’ordre lexicographique usuel :
(n, o) < (n
Ensuite, on utilise le mˆeme ordre sur les ensembles que Mazurkiewicz : ´etant donn´es
deux ensembles N1, N2 ∈ Pﬁn(N2) distincts, on dit que N1 ≺ N2 si le maximum pour
l’ordre lexicographique sur N2 de la diﬀ´erence sym´etrique N1(cid:17) N2 = (N1\ N2)∪ (N2 \ N1)
appartient `a N2.
Si N(u) ≺ N(v), alors on dit que la vue locale N(v) de v est plus forte que celle de u
et que N(u) est plus faible que N(v). En utilisant l’ordre total <L de L, on ´etend l’ordre
≺ pour obtenir un ordre total sur L×Pﬁn(N) : ((cid:8), N) ≺ ((cid:8)
(cid:2) ou bien si (cid:8) = (cid:8)
(cid:2)
et N ≺ N

, N
(cid:2). Par la suite, on notera (cid:19) la clˆoture r´eﬂexive de ≺.

(cid:2)) si (cid:8) <L (cid:8)

(cid:2)

Les R`egles de R´e´etiquetage

On d´ecrit maintenant l’algorithme d’´enum´eration grˆace `a des r`egles de r´e´etiquetage.
La premi`ere r`egle M0 est une r`egle sp´eciale qui permet `a chaque sommet de modiﬁer son
´etiquette initiale λ(v) pour obtenir l’´etiquette (λ(v), 0,∅,∅).
Les r`egles M1 et M2 sont proches des deux r`egles de l’algorithme de Mazurkiewicz
(cid:2) de partager les infor-
[Maz97]. La premi`ere r`egle permet `a deux sommets voisins v et v
mations contenues dans leurs boˆıtes-aux-lettres `a propos des ´etiquettes apparaissant dans
le graphe.

M1 :
((cid:8)1, n1, N1, M1)

((cid:8)2, n2, N2, M2)

((cid:8)1, n1, N1, M

(cid:2))

((cid:8)2, n2, N2, M

(cid:2))

Si M1 (cid:12)= M2 alors M

(cid:2) := M1 ∪ M2.

La deuxi`eme r`egle M2 ne d´epend que de l’´etiquette d’un seul sommet v. Elle permet `a
v de modiﬁer son num´ero si v n’a pas encore choisi de num´ero (son num´ero courant est 0),
ou si la boˆıte-aux-lettres de v contient un message indiquant qu’il existe un autre sommet
dans le graphe ayant le mˆeme num´ero que v et qui a une ´etiquette sup´erieure `a celle de v
ou qui a une vue locale plus forte que celle de v.

5.4. ´Enum´eration, Nommage et ´Election

119

M2 :

Si
alors

((cid:8), n, N, M)

((cid:8), k, N, M

(cid:2))

n = 0 ou ∃(n, (cid:8)
(cid:2)
k := 1 + max{n
M

, N
(cid:2) | ∃(n
(cid:2)
, (cid:8)
(cid:2) := M ∪ {(k, (cid:8), N)}.

(cid:2)

(cid:2)) ∈ M tel que ((cid:8), N) ≺ ((cid:8)

(cid:2)

, N

(cid:2))

(cid:2)) ∈ M} et

, N

(cid:2)
La troisi`eme r`egle permet `a un sommet v de modiﬁer son num´ero s’il a un voisin v
(cid:2)),
(cid:2)), N(v
(cid:2))). Cette r`egle ne peut ˆetre appliqu´ee que si on ne peut pas appliquer la r`egle M2 `a

qui est exactement dans le mˆeme ´etat, i.e., (λ(v), n(v), N(v), M(v)) = (λ(v
M(v
v ou `a v

(cid:2)), n(v

(cid:2).

M3 :
((cid:8), n, N, M)

((cid:8), n, N, M)

((cid:8), k, N, M

(cid:2))

((cid:8), n, N, M

(cid:2))

Si

alors

(cid:2)

(cid:2)) ∈ M, ((cid:8)

n > 0 et
∀(n, (cid:8)
, N
k := 1 + max{n
M

(cid:2)) (cid:19) ((cid:8), N)
, N
(cid:2) | ∃(n
(cid:2)
(cid:2)
, (cid:8)
(cid:2) := M ∪ {(k, (cid:8), N)}.

, N

(cid:2)

(cid:2)) ∈ M} et

(cid:2)) et (n(v

La quatri`eme r`egle permet `a deux sommets voisins v et v

(cid:2) d’´echanger leurs num´eros
si une mise `a jour de leurs vues locales est n´ecessaires, i.e., s’il n’existe pas de o tel que
(cid:2)), o) ∈ N(v). Cette r`egle ne peut ˆetre appliqu´ee sur une arˆete
(n(v), o) ∈ N(v
{v, v

(cid:2)} que si les trois r`egles pr´ec´edentes ne peuvent pas ˆetre appliqu´ees sur {v, v
Le rˆole de l’identiﬁant o associ´e `a cet ´echange est d’assurer qu’`a la ﬁn de l’ex´ecution,
(cid:2) tel
si un couple (n
(cid:2)). De plus, dans la conﬁguration ﬁnale, cet identiﬁant o
(cid:2)) = n
que n(v
permet de construire un couplage parfait entre les sommets ´etiquet´es n(v) et ceux ´etiquet´es
(cid:2)). Ainsi, dans la conﬁguration ﬁnale, tous les num´eros apparaissant dans le graphe
n(v
apparaissent avec la mˆeme cardinalit´e.

, o) appartient `a la vue locale d’un sommet v alors v a un voisin v

(cid:2)
(cid:2) et (n(v), o) ∈ N(v

(cid:2)}.

(cid:2)

(cid:2)) et (n(v

On remarque que si un couple (n, o) est ajout´e `a la vue locale N(v) de v, tous les couples
(cid:2) ≤ n sont supprim´es de N(v). La justiﬁcation de toutes ces suppressions est
(cid:2)) avec n
(n
, o
(cid:2) se synchronisent et se rendent compte qu’ils n’ont pas
la suivante. Si deux voisins v et v
(cid:2)), o) ∈ N(v), alors ils doivent
un identiﬁant commun o tels que (n(v), o) ∈ N(v
(cid:2)), o) `a N(v).
se mettre d’accord sur un identiﬁant o et ajouter (n(v), o) `a N(v
(cid:2) pour la
Mais on peut se retrouver dans deux situations. Si v ´echange son num´ero avec v
(cid:2)), o) `a N(v). Cependant, si v et v
(cid:2) avaient
premi`ere fois, il suﬃt d’ajouter le couple (n(v
(cid:2) a chang´e de num´ero, alors il
d´ej`a ´echang´e leurs num´eros auparavant et qu’entre-temps v
(cid:2)), o) `a N(v), mais il faut aussi supprimer l’ancien couple
faut non-seulement ajouter (n(v
(cid:2)) correspondant au pr´ec´edent ´echange de num´ero avec v
(cid:2). Le probl`eme est que v n’a
(n
(cid:2) et donc il
pas moyen de savoir lequel des couples apparaissant dans N(v) correspond `a v
ne peut pas savoir quel couple il doit eﬀacer. Cependant, l’algorithme assure que lorsqu’un
sommet change de num´ero, son num´ero ne peut qu’augmenter. Par cons´equent, on sait
(cid:2)), toute l’information obsol`ete
que si on supprime tous les couples (n
(cid:2) aura ´et´e eﬀac´ee. Avec cette m´ethode, on peut aussi eﬀacer des informations
relative `a v

(cid:2)) tels que n

(cid:2)) et (n(v

(cid:2) ≤ n(v

, o

, o

(cid:2)

(cid:2)

120

Chapitre 5. Calculs Locaux sur les Arˆetes Non-´Etiquet´ees

valides sur certains voisins de v, mais ce n’est pas un probl`eme puisque v peut r´ecup´erer
cette information en se resynchronisant avec ces voisins l`a.

M4 :
((cid:8)1, n1, N1, M)

((cid:8)2, n2, N2, M)

((cid:8)1, n1, N

(cid:2)
1, M

(cid:2))

((cid:8)2, n2, N

(cid:2)
2, M

(cid:2))

Si

alors

(cid:2)
1, N
(cid:2)
2, N

(cid:2)
1, N
(cid:2)
2, N
(cid:2)

n1, n2 > 0, n1 (cid:12)= n2,
1) ∈ M, ((cid:8)
∀(n1, (cid:8)
(cid:2)
2) ∈ M, ((cid:8)
∀(n2, (cid:8)
(cid:2)
(cid:2)o | (n2, o) ∈ N1 et (n1, o) ∈ N2
o := 1 + max{o
(cid:2) | ∃(n
1 := N1 \ {(n
(cid:2)) ∈ N1 | n
(cid:2)
(cid:2)
, o
N
2 := N2 \ {(n
(cid:2)) ∈ N2 | n
(cid:2)
(cid:2)
, o
N
(cid:2) := M ∪ {(n1, (cid:8)1, N
M

1) (cid:19) ((cid:8)1, N1),
(cid:2)
2) (cid:19) ((cid:8)2, N2) et
(cid:2)
(cid:2)) ∈ N1 ∪ N2},
, o

(cid:2)
1), (n2, (cid:8)2, N

2)}.
(cid:2)

(cid:2) ≤ n2} ∪ {(n2, o)},
(cid:2) ≤ n1} ∪ {(n1, o)} et

5.4.3 Correction de l’Algorithme d’´Enum´eration

On consid`ere un graphe simple ´etiquet´e G. Pour tout sommet v ∈ V (G), on note
(λ(v), ni(v), Ni(v), Mi(v)) l’´etiquette du sommet v apr`es la i`eme ´etape de r´e´etiquetage
de l’algorithme M d´ecrit ci-dessus. On pr´esente d’abord quelques propri´et´es qui sont
satisfaites par n’importe quelle ex´ecution de l’algorithme.

Propri´et´es Satisfaites lors de l’Ex´ecution

Le lemme suivant, qui peut ˆetre facilement prouv´e par une r´ecurrence sur le nombre
d’´etapes, rappelle quelque propri´et´es simples qui sont toujours satisfaites par l’´etiquetage.
Lemme 5.11 Pour chaque sommet v et chaque ´etape i,

(cid:2) (cid:12)= 0 et ∃(n

1. ni(v) (cid:12)= 0 =⇒ (ni(v), λ(v), Ni(v)) ∈ Mi(v),
(cid:2)) ∈ Ni(v), n
2. ∀(n
, o
3. (cid:2)(ni(v), o) ∈ Ni(v),
4. ∀(n
L’algorithme M a des propri´et´es de monotonicit´e int´eressantes qui sont donn´ees dans

(cid:2)(cid:2)) ∈ Ni(v), n
, o

(cid:2)) ∈ Mi(v),

(cid:2) (cid:12)= n

(cid:2)), (n

(cid:2)(cid:2).

, o

, (cid:8)

, N

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)(cid:2)

le lemme suivant.
Lemme 5.12 Pour chaque sommet v et chaque ´etape i,

– ni(v) ≤ ni+1(v),
– Ni(v) (cid:19) Ni+1(v),
– Mi(v) ⊆ Mi+1(v).

De plus, `a chaque ´etape i, il existe un sommet v telle qu’au moins une de ces in´egalit´es
(ou inclusions) est stricte pour v.

Preuve : La propri´et´e est trivialement vraie pour les sommets qui ne sont pas r´e´etiquet´es
lors de la (i + 1)`eme ´etape. De plus, il est facile de voir que quelque soit la r`egle appliqu´ee
`a l’´etape i + 1, on a toujours Mi(v) ⊆ Mi+1(v) pour tout sommet v ∈ V (G).

5.4. ´Enum´eration, Nommage et ´Election

121

, (cid:8)

, N

(cid:2) | ∃(n

Pour chaque sommet v tel que ni(v) (cid:12)= ni+1(v), alors la r`egle M2 ou M3 a ´et´e appliqu´ee
`a v et on sait que ni+1(v) = 1 + max{n
(cid:2)) ∈ Mi(v)}. De plus, ou bien ni(v) =
0 < ni+1(v), ou alors d’apr`es le Lemme 5.11, (ni(v), λ(v), Ni(v)) ∈ Mi(v) et donc ni(v) <
ni+1(v).
Pour chaque sommet v tel que Ni(v) (cid:12)= Ni+1(v), la r`egle M4 a ´et´e appliqu´ee au
(cid:2) ; on note o l’identiﬁant associ´e `a cet ´echange de num´ero.
(cid:2)) ∈ Ni+1(v) et on sait que
, o
(cid:2) | ∃(n
(cid:2))}. Par
(cid:2)) ∈ Ni(v) ∪ Ni(v
(cid:2)
, o
(cid:2)), o) ∈ Ni+1(v) et donc Ni(v) ≺ Ni+1(v).
Puisque chaque application d’une r`egle modiﬁe l’´etiquette d’au moins un sommet v,
2

sommet v et `a un de ses voisins v
Pour chaque (n
(ni+1(v), o) ∈ Ni+1(v) \ Ni(v) puisque o = 1 + max{o
cons´equent, on a max(Ni(v)(cid:17)Ni+1(v)) = (ni+1(v

on sait que l’une de ces in´egalit´es est stricte pour v.

(cid:2)) ∈ Ni(v), si n
, o

(cid:2)), alors (n

> ni+1(v

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2).

(cid:2)) = m

(cid:2)) = m

(cid:2) tel que ni(v

(cid:2) tel que ni(v

Les informations dont dispose chaque sommet v dans sa boˆıte-aux-lettres permettent
d’obtenir des informations v´eriﬁ´ees par la conﬁguration globale du graphe. Les deux
lemmes suivants permettent de prouver que si un sommet v connaˆıt un num´ero m `a
(cid:2) ≤ m, il
une ´etape i (i.e., il existe (cid:8), N tels que (m, (cid:8), N) ∈ Mi(v)), alors pour chaque m
(cid:2). On montre d’abord que si v connaˆıt un num´ero
existe un sommet v
m, alors il existe un sommet v
Lemme 5.13 Pour chaque sommet v ∈ V (G) et chaque ´etape i, pour tout (m, (cid:8), N) ∈
Mi(v), il existe un sommet w ∈ V (G) tel que ni(w) = m.
Preuve : On remarque d’abord qu’un triplet (m, (cid:8), N) est ajout´e `a une ´etape i dans
(cid:4)
Mi(v) seulement s’il existe un sommet v tel que ni(v) = m, λ(v) = (cid:8) et Ni(v) = N.
v∈V (G)
´Etant donn´e un sommet v, une ´etape i et un triplet (m, (cid:8), N) ∈ Mi(v), on note U =
{(u, j) ∈ V (G)× N | j ≤ i, nj(u) = m}. On consid`ere ensuite l’ensemble U
(cid:2) = {(u, j) ∈ U |
(cid:2) ≤
∀(u
(cid:2)
j}. Puisque (m, (cid:8), N) ∈ Mi(v), U et U
(cid:2) sont deux ensembles non-vides. On remarque
ais´ement qu’il existe i0 tel que pour tout (u, j) ∈ U
(cid:2) puisqu’`a chaque ´etape, le num´ero
d’au plus un sommet peut ˆetre modiﬁ´e. Le num´ero ni0(u) = m a donc ´et´e modiﬁ´e `a l’´etape
i0 + 1, mais puisque `a cette ´etape, le sommet u n’avait aucun voisin avec le mˆeme num´ero
m, la r`egle M3 n’a pu ˆetre appliqu´ee, et par maximalit´e de (λ(u), Ni0(u)), la r`egle M2
n’a pas non plus pu ˆetre appliqu´ee `a u `a l’´etape i0. Par cons´equent, i0 = i et il existe donc
un sommet w tel que ni(w) = m.
2

Si i0 < i, il existe exactement un ´el´ement (u, i0) ∈ U

(cid:2))) ≺ (λ(u), Nj(u)) ou (λ(u

(cid:2)), Nj(cid:2)(u
(cid:2), j = i0.

(cid:2))) = (λ(u), Nj(u)) et j

(cid:2)) ∈ U, (λ(u

(cid:2)), Nj(cid:2)(u

, j

Dans le lemme suivant, on montre que si un sommet v connaˆıt un num´ero m, alors il

connaˆıt tous les num´eros inf´erieurs `a m.
Lemme 5.14 Pour chaque sommet v et chaque ´etape i, pour tout (m, (cid:8), N) ∈ Mi(v), pour
tout m

(cid:2) ∈ [1, m], il existe (m

(cid:2)) ∈ Mi(v).

, N

, (cid:8)

(cid:2)

(cid:2)

Preuve : On montre ce lemme par r´ecurrence sur i. Initialement, la propri´et´e est tri-
vialement vraie. On suppose que la propri´et´e est v´eriﬁ´ee pour i ≥ 0. La propri´et´e est
trivialement vraie `a l’´etape i + 1 pour tout sommet w ∈ V (G) dont l’´etiquette n’est pas
modiﬁ´ee `a l’´etape i + 1. Soit v un sommet dont l’´etiquette est modiﬁ´ee `a l’´etape i + 1.
(cid:2), alors Mi+1(v) =
Mi(v) ∪ Mi(v
(cid:2)) et la propri´et´e est v´eriﬁ´ee `a l’´etape i + 1 puisqu’elle ´etait vraie pour v et

Si la r`egle M1 est appliqu´ee `a l’´etape i+1 `a v et `a un de ses voisins v

122

Chapitre 5. Calculs Locaux sur les Arˆetes Non-´Etiquet´ees

(cid:2) `a l’´etape i.
v
Si la r`egle M2 ou M3 est appliqu´ee `a v `a l’´etape i + 1, alors Mi+1(v) = Mi(v) ∪
{(ni+1(v) = 1+max{m | (m, (cid:8), N) ∈ Mi(v)}, λ(v), Ni(v))}, et par cons´equent pour chaque
m ∈ Mi+1(v), la propri´et´e reste vraie.
Si la r`egle M4 est appliqu´ee `a v `a l’´etape i + 1, pour tout (m, (cid:8), N) ∈ Mi+1(v), il existe

(m, (cid:8), N

(cid:2)) ∈ Mi(v) et la propri´et´e reste donc vraie.

2

(cid:2).

(cid:2) | ∃(n

(cid:2) tel que n(v

(cid:2)) > max{n

(cid:2)) = n, ou bien ni(v

(cid:2) ∈ NG(v) tel que, ou bien ni(v

Dans le lemme suivant, on montre que si un couple (n, o) apparaˆıt dans la vue locale
(cid:2)) = n, ou bien la r`egle M4

(cid:2)) = n. D’apr`es le Lemme 5.11, il existe (n, (cid:8), N) ∈ Mi0(v
Dans le cas contraire, pour chaque ´etape j ∈ [i0, i], on pose m(j) = max{n

N(v) d’un sommet v, alors ou bien v a un voisin v
peut ˆetre appliqu´ee au sommet v et `a un de ses voisins v
Lemme 5.15 Pour chaque sommet v ∈ V (G) et chaque ´etape i, pour tout (n, o) ∈ Ni(v),
(cid:2)) ∈
il existe v
, o
Ni(v)}.
Preuve : Soit i0 l’´etape o`u (n, o) a ´et´e ajout´e `a N(v) : ∀j ≥ i0, (n, o) ∈ Nj(v) et
(n, o) /∈ Ni0−1(v). Cela signiﬁe qu’`a l’´etape i0, la r`egle M4 a ´et´e appliqu´ee `a v et v
(cid:2) avec
(cid:2)) = n,
(cid:2)) = ni0(v
ni0(v
alors la propri´et´e est v´eriﬁ´ee.
(cid:2) | ∃(n
(cid:2)) ∈
(cid:2)
, o
Nj(v)}. On sait que mi0(v) ≥ n et qu’il existe (mi0(v), (cid:8), N) ∈ Mi0(v
(cid:2)). Si un couple (n
(cid:2)
(cid:2))
, o
est ajout´e `a N(v) lors d’une ´etape i1 ∈ [i0, i], alors la r`egle M4 a ´et´e appliqu´ee `a v et `a un
< n, puisque (n, o) ∈ Ni1(v) et par cons´equent,
de ses voisins lors de l’´etape i1. De plus n
mi0(v) = mi(v).
(cid:2) lors d’une
Puisque ni(v
´etape i2 ∈ [i0, i]. Par ailleurs, on sait qu’il existe (mi0(v), (cid:8), N) ∈ Mi0(v
(cid:2)) et par
(cid:2)) ∈ Ni(v)}. La propri´et´e
cons´equent, ni(v
, o
est donc v´eriﬁ´ee.

(cid:2)), une des r`egles M2 ou M3 a ´et´e appliqu´ee `a v
(cid:2)) > mi0(v) = mi(v) = max{n

(cid:2)) (cid:12)= ni0(v
(cid:2)) ≥ ni2(v

(cid:2)) ⊆ Mi2(v

(cid:2)). Si ni(v

(cid:2) | ∃(n

(cid:2)

2

(cid:2)

(cid:2)

Terminaison

On veut maintenant montrer que toute ex´ecution de l’algorithme M termine sur G.
D’apr`es les Lemmes 5.13 et 5.14, on voit qu’`a chaque ´etape de l’ex´ecution, les num´eros des
sommets forment un ensemble [1, k] ou un ensemble [0, k] avec k ≤ |V (G)|. Par cons´equent,
d’apr`es le Lemme 5.12, on sait qu’il existe une ´etape i0 telle que pour tout sommet v et
toute ´etape i ≥ i0, ni+1(v) = ni(v).
Pour montrer que l’algorithme termine toujours, il est suﬃsant de montrer que la r`egle
M4 ne peut pas ˆetre appliqu´ee inﬁniment souvent. En eﬀet, cela implique alors que les
identiﬁants o associ´es `a chaque ´echange de num´ero ne peuvent prendre qu’un nombre ﬁni
de valeurs. Et dans ce cas, les vues locales et les boˆıtes-aux-lettres des sommets ne peuvent
prendre qu’un nombre ﬁni de valeurs et on peut assurer que l’algorithme termine d’apr`es
le Lemme 5.12.
vante. ´Etant donn´ees deux arˆetes {v, w},{v
{ni0(v
, w
{ni0(v), ni0(w)}. Si {v, w}  {v
{v, w}  {v

On commence par d´eﬁnir un pr´e-ordre  sur les arˆetes de G de la mani`ere sui-
(cid:2)} ∈ E(G) telles que {ni0(v), ni0(w)} (cid:12)=
(cid:2))} ∈
(cid:2)), ni0(w
(cid:2))}, on dit que

(cid:2)
(cid:2)} si max{ni0(v), ni0(w)}(cid:17){ni0(v
(cid:2)), ni0(w

(cid:2))}, on dit que {v, w} {v
(cid:2)}.

(cid:2)} ou si {ni0(v), ni0(w)} = {ni0(v

(cid:2)), ni0(w

, w

, w

, w

(cid:2)

(cid:2)

(cid:2)

5.4. ´Enum´eration, Nommage et ´Election

123

Dans le lemme suivant, on montre qu’une fois que les sommets ne modiﬁent plus leurs

num´eros, la r`egle M4 ne peut pas ˆetre appliqu´ee inﬁniment souvent sur chaque arˆete.
Lemme 5.16 Pour toute arˆete {v0, w0} ∈ E(G) et toute ´etape i1 ≥ i0 telles que la r`egle
M4 n’est pas appliqu´ee lors d’une ´etape i ≥ i1 sur une arˆete {v, w} {v0, w0}, il existe au
plus une ´etape i ≥ i1 lors de laquelle la r`egle M4 est appliqu´ee sur l’arˆete {v0, w0}.
Preuve : On consid`ere une arˆete {v0, w0} ∈ E(G) et une ´etape i1 ≥ i0 telles que la r`egle
M4 n’est pas appliqu´ee lors d’une ´etape i ≥ i1 sur une arˆete {v, w} {v0, w0}. On suppose
que ni0(v0) > ni0(w0) et on note n0 = ni0(v0) et m0 = ni0(w0).
On remarque que pour toute arˆete {v, w} sur laquelle la r`egle M4 est appliqu´ee `a une
´etape i > i1, on a ni(v) = ni0(v) ≤ n0 et ni0(w) ≤ n0. Ainsi, pour toute ´etape i ≥ i1 et tout
sommet v ∈ V (G), pour tout n > ni0(v), (n, o) ∈ Ni(v) si et seulement si (n, o) ∈ Ni1(v).
De plus pour tout sommet v tel que ni0(v) = n0, si la r`egle M4 est appliqu´e a v et `a
un de ses voisins w `a une ´etape i ≥ i1, alors ni(w) = ni0(w) ≤ m0. Ainsi pour toute ´etape
i, pour tout n > m0, (n, o) ∈ Ni(v) si et seulement si (n, o) ∈ Ni1(v).
On consid`ere maintenant une arˆete {v, w} ∈ E(G) telle que ni0(v) = n0 et mi0(v) = m0
et telle qu’il existe une ´etape j1 > i1 lors de laquelle la r`egle M4 a ´et´e appliqu´ee sur l’arˆete
{v, w}.
On montre par induction sur j que pour toute ´etape j ≥ j1, il existe un identiﬁant o
tel que (m0, o) ∈ Nj(v). De par la d´eﬁnition de j1, il existe (m0, o) ∈ Nj1(v) et (n0, o) ∈
Nj1(w). De plus, si la vue locale de v est modiﬁ´ee lors de l’´etape j + 1, alors la r`egle
M4 a ´et´e appliqu´e `a v et `a l’un de ses voisins w
(cid:2) lors de cette ´etape. On sait d´ej`a que
(cid:2)) < m0,
ni0(w
(m0, o) ∈ Nj+1(v). Si nj(w
(cid:2)) = m0, alors un identiﬁant o est cr´e´e lors de cette ´etape et
(m0, o) ∈ Nj+1(v). De la mˆeme mani`ere, on peut montrer que pour toute ´etape j ≥ j1, il
existe un identiﬁant o tel que (n0, o) ∈ Nj(w).
On suppose maintenant que la r`egle M4 est appliqu´ee lors de deux ´etapes j2 > j1 ≥ i1
sur l’arˆete {v0, w0}. On sait qu’il existe un identiﬁant o0 tel que (m0, o0) ∈ Nj1(v0) et
(n0, o0) ∈ Nj1(w0). Puisque la r`egle M4 peut ˆetre appliqu´ee lors de l’´etape j2, il existe
deux identiﬁants distincts o1, o2 ≥ o0 tels que (n0, o1) ∈ Nj2−1(w0) et (m0, o2) ∈ Nj2−1(v0).
On consid`ere le cas o`u o2 > o1. Puisque o2 > o1 ≥ o0, il existe une ´etape j telle que j1 <
j < j2 lors de laquelle la r`egle M4 a ´et´e appliqu´ee entre le sommet v0 et un de ses voisins w
tel que ni0(w) = m0. Puisque la r`egle M4 a pu ˆetre appliqu´ee et que (m0, λ(w0), Nj1(w0)) ∈
Mj1(v0) ⊆ Mj(v0) = Mj(w), cela signiﬁe que (λ(w0), Nj1(w0)) (cid:19) (λ(w), Nj−1(w)) ≺
(λ(w), Nj(w)). De plus, on sait que (n0, o2) ∈ Nj(w) et que (n0, λ(w), Nj(w)) ∈ Mj(v0) ⊆
Mj2−1(v0) = Mj2−1(w0). On rappelle que pour tout n > n0, (n, o) ∈ Nj2−1(w0) si et seule-
ment si (n, o) ∈ Nj1(w0) et on sait que (n0, o2) ∈ Nj(w)\ Nj2−1(w0). Ainsi puisque o2 > o1
et que (λ(w0), Nj1(w0)) ≺ (λ(w), Nj(w)), on sait que (λ(w0), Nj2(w0)) ≺ (λ(w), Nj(w)).
Par cons´equent, la r`egle M4 ne peut pas ˆetre appliqu´ee sur l’arˆete {v0, w0} lors de l’´etape
j2.
Dans le cas o`u o1 > o2, on peut de la mˆeme mani`ere montrer qu’il existe (n0, (cid:8), N) ∈
Mj2−1(v0) tel que (λ(v0), Nj2−1(v0)) ≺ ((cid:8), N) et la r`egle M4 ne peut donc pas non plus
ˆetre appliqu´ee sur l’arˆete {v0, w0} lors de l’´etape j2.

(cid:2)) < m0, alors il existe (m0, o) ∈ Nj(v) et puisque ni0(w

(cid:2)) ≤ m0 et si ni0(w

On peut d´esormais montrer que toute ex´ecution de l’algorithme M sur G termine. En
eﬀet, s’il existe une ex´ecution inﬁnie de M sur G, alors on consid`ere l’ensemble E1 des

2

124

Chapitre 5. Calculs Locaux sur les Arˆetes Non-´Etiquet´ees

arˆetes sur lesquels la r`egle M4 est appliqu´ee inﬁniment souvent. On consid`ere une ´etape
i1 telle que pour toute ´etape i > i1, les r`egles M2 et M3 ne sont pas appliqu´ees `a l’´etape
i et si la r`egle M4 est appliqu´ee sur une arˆete {v, w} `a l’´etape i, alors {v, w} ∈ E1. On
consid`ere alors une arˆete de E1 qui est un ´el´ement maximal pour l’ordre  et d’apr`es
le Lemme 5.16, on sait qu’on ne peut pas appliquer la r`egle M4 sur {v, w} inﬁniment
souvent : l’ensemble E1 est donc vide et toute ex´ecution de M sur G termine.

Propri´et´es Satisfaites par l’´Etiquetage Final

Puisqu’on sait que l’algorithme termine toujours, on s’int´eresse maintenant aux pro-
pri´et´es satisfaites par l’´etiquetage ﬁnal.
Lemme 5.17 Toute ex´ecution ρ de l’algorithme M sur un graphe simple ´etiquet´e G =
(G, λ) termine et l’´etiquetage ﬁnal (λ, nρ, Nρ, Mρ) v´eriﬁe les propri´et´es suivantes :

1. il existe un entier k ≤ |V (G)| tel que {nρ(v) | v ∈ V (G)} = [1, k],

et pour tous sommets v, v

(cid:2) :

(cid:2)),

2. Mρ(v) = Mρ(v
3. (nρ(v), λ(v), Nρ(v)) ∈ Mρ(v
4. si nρ(v) = nρ(v
5. (n, o) ∈ Nρ(v) si et seulement s’il existe w ∈ NG(v) tel que nρ(w) = n ; auquel cas,

(cid:2)), alors λ(v) = λ(v

(cid:2)) et Nρ(v) = Nρ(v

(cid:2)),

(cid:2)),

(nρ(v), o) ∈ Nρ(w).

Preuve :

1. D’apr`es les Lemmes 5.13 et 5.14 et puisque la r`egle M2 ne peut pas ˆetre appliqu´ee.
2. Dans le cas contraire, la r`egle M1 peut ˆetre appliqu´ee.
3. C’est une cons´equence directe de la propri´et´e pr´ec´edente d’apr`es le Lemme 5.11.
4. Dans le cas contraire, la r`egle M2 peut ˆetre appliqu´ee `a v ou `a v
5. D’apr`es le Lemme 5.15 et puisque les r`egles M3 et M4 ne peuvent plus ˆetre ap-

(cid:2).

pliqu´ees.

Grˆace au Lemme 5.17, on va montrer comment construire un graphe H `a partir de

l’´etiquetage ﬁnal et on va montrer que G est un pseudo-revˆetement de H.
Proposition 5.18 ´Etant donn´e un graphe simple G, on peut construire, `a partir de
l’´etiquetage ﬁnal obtenu apr`es une ex´ecution ρ de M, un graphe simple H tel que G
est un pseudo-revˆetement de H.

2

(cid:2)} | ∃v, v

Preuve : On utilise les notations du Lemme 5.17.
On consid`ere le graphe H d´eﬁni par V (H) = {m ∈ N | ∃v ∈ V (G), nρ(v) = m} et
(cid:2)} ∈ E(G)}. On d´eﬁnit
(cid:2) ∈ V (G); nρ(v) = m, nρ(v
E(H) = {{m, m
(cid:2)) = m
un ´etiquetage η de H en posant η(nρ(v)) = λ(v) ; d’apr`es le Lemme 5.17, si deux sommets
(cid:2) ∈ V (G) ont le mˆeme num´ero, alors λ(v) = λ(v
(cid:2)) et par cons´equent, cet ´etiquetage est
v, v
bien d´eﬁni.
(cid:2) ∈ V (G) et un
D’apr`es le Lemme 5.17, {m, m
(cid:2)). D’apr`es

(cid:2)} ∈ E(H) si et seulement s’il existe v, v

, o) ∈ Nρ(v) et (m, o) ∈ Nρ(v

identiﬁant o tels que nρ(v) = m, nρ(v

(cid:2) et {v, v

(cid:2)) = m

(cid:2), (m

(cid:2)

5.4. ´Enum´eration, Nommage et ´Election

125

(cid:2)

(cid:2)

(cid:2)

(cid:2)) = nim(cid:2) (v)(v

(cid:2)) = m

On va maintenant d´eﬁnir l’ensemble d’arˆetes E(G

(cid:2)). Pour chaque arˆete {m, m

(cid:2)} ∈ E(G), alors {nρ(v), nρ(v

, o) ∈ Nρ(v) et on note im(cid:2)(v) l’´etape o`u (m
(cid:2) tel que nim(cid:2) (v)(v

le Lemme 5.11, on sait qu’il n’existe aucun {n, n} ∈ E(H) : le graphe H ne contient pas
de boucle. De plus, par d´eﬁnition, E(H) ne contient pas d’arˆetes multiples.
On consid`ere maintenant la fonction nρ : V (G) → V (H). Par d´eﬁnition de H, on
(cid:2))} ∈ E(G). De plus, pour tout v ∈ V (G),
sait que si {v, v
η(nρ(v)) = λ(v) et par cons´equent, nρ est un homomorphisme de G dans H.
(cid:2)} ∈
−1
ρ (m) et les sommets de
E(H), on veut d´eﬁnir un couplage parfait entre les sommets de n
(cid:2)). ´Etant donn´e un sommet v tel que nρ(v) = m, on sait qu’il existe un identiﬁant
−1
ρ (m
n
, o) a ´et´e ajout´e `a N(v), i.e.,
o tel que (m
, o) ∈ Nim(cid:2) (v)(v) \ Nim(cid:2) (v)−1(v). Cela signiﬁe que lors de l’´etape im(cid:2)(v), la r`egle M4 a
(m
(cid:2). D’apr`es le Lemme 5.15
(cid:2)) = m
´et´e appliqu´ee `a v et `a un de ses voisins v
(cid:2), que (m, o) ∈
et puisque l’ex´ecution est termin´ee, on sait que nρ(v
(cid:2)). Par cons´equent, on sait que im(cid:2)(v) =
Nim(v(cid:2))(v
im(v
(cid:2)} appartient `a E(G) si
(cid:2)} appartient `a
et seulement si inρ(v(cid:2))(v) = inρ(v)(v
(cid:2)} et que l’identiﬁant cr´e´e `a ce
E(G) si et seulement si la r`egle M4 a ´et´e appliqu´ee sur {v, v
(cid:2) dans la conﬁguration
moment l`a apparaˆıt toujours dans les vues locales des sommets v et v
ﬁnale. Puisque lors d’une ´etape de calcul, seules les ´etiquettes des extr´emit´es d’une arˆete
sont modiﬁ´ees, il est clair que pour tout {m, m
−1
ρ (m) est
(cid:2) est bien un
−1
ρ (m
adjacent `a exactement un sommet de n
revˆetement de H `a travers nρ et puisque nρ pr´eserve l’´etiquetage, G(cid:2) est un revˆetement
de H `a travers nρ.
G(cid:2).

Ainsi, le graphe G est un pseudo-revˆetement de H `a travers nρ et respectivement `a
2

(cid:2)} ∈ E(H), chaque sommet de n
(cid:2)) dans G

(cid:2). Par cons´equent, G

(cid:2)) comme ceci : une arˆete {v, v

(cid:2)). En d’autres termes, une arˆete {v, v

(cid:2)).
On d´eﬁnit les arˆetes de E(G

(cid:2)) \ Nim(v(cid:2))−1(v

(cid:2)) et que (m, o) ∈ Nρ(v

On consid`ere maintenant un graphe G qui est minimal pour les pseudo-revˆetements.
Pour chaque ex´ecution ρ de M sur G, le graphe obtenu `a partir de l’´etiquetage ﬁnal
est isomorphe `a G. Par cons´equent, l’ensemble des num´eros des sommets est exactement
[1,|V (G)|] : chaque sommet a un identiﬁant unique. L’algorithme M permet de r´esoudre
le nommage sur la famille des graphes minimaux pour les pseudo-revˆetements, mais si
aucune information `a propos de G n’est disponible, les sommets ne peuvent pas d´etecter
la terminaison.
Cependant, il est possible de d´etecter la terminaison pour un graphe G donn´e (l’algo-
rithme d´epend alors de G). En eﬀet, une fois qu’un sommet a obtenu le num´ero |V (G)|,
d’apr`es les Lemmes 5.13 et 5.14, il sait que tous les sommets de G ont un num´ero unique qui
ne va plus ˆetre modiﬁ´e. Dans ce cas l`a, on peut aussi r´esoudre le probl`eme de l’´election,
puisque ce sommet peut prendre l’´etiquette ´elu et diﬀuser ensuite l’information qu’un
sommet a ´et´e ´elu.

Par ailleurs, d’apr`es la Proposition 5.10, on sait que pour tout graphe G qui n’est pas
minimal pour les pseudo-revˆetements, il n’existe aucun algorithme utilisant des calculs
locaux sur les arˆetes non-´etiquet´ees qui permettent de r´esoudre les probl`emes du nommage
ou de l’´enum´eration sur G. On a donc prouv´e le th´eor`eme suivant.

Th´eor`eme 5.19 Pour tout graphe simple ´etiquet´e G, les assertions suivantes sont ´equi-
valentes :

126

Chapitre 5. Calculs Locaux sur les Arˆetes Non-´Etiquet´ees

1. il existe un algorithme de nommage (ou d’´enum´eration) pour G utilisant des calculs

locaux sur les arˆetes non-´etiquet´ees,

2. il existe un algorithme d’´election et un algorithme de nommage (ou d’´enum´eration)
avec d´etection de la terminaison pour G utilisant des calculs locaux sur les arˆetes
non-´etiquet´ees,

3. G est minimal pour les pseudo-revˆetements.

Remarque 5.20 ´Etant donn´e un graphe G minimal pour les pseudo-revˆetements, pour
d´etecter que l’algorithme M a attribu´e un identiﬁant unique `a chaque sommet, il suﬃt de
connaˆıtre le nombre de sommets de G. Ainsi, l’algorithme M permet de r´esoudre l’´election
ainsi que le nommage avec d´etection de la terminaison sur les graphes minimaux pour les
pseudo-revˆetements de taille donn´ee.

5.4.4 Complexit´e

2

fois durant l’ex´ecution ρ.

2

On s’int´eresse `a la complexit´e de l’algorithme M pr´esent´e ci-dessus. Dans le cadre
des calculs locaux, on s’int´eresse au nombre de pas de r´e´etiquetages eﬀectu´ees lors d’une
ex´ecution. La proposition suivante donne une borne sup´erieure sur le nombre de pas de
r´e´etiquetages de toute ex´ecution de l’algorithme M sur un graphe `a m arˆetes.
Proposition 5.21 Pour tout graphe G `a m arˆetes, durant toute ex´ecution de l’algorithme
M utilisant des calculs locaux sur les arˆetes non-´etiquet´ees, 2O(m) r`egles sont appliqu´ees.
Preuve : On consid`ere un graphe G `a n sommets et `a m arˆetes ainsi qu’une ex´ecution ρ
de M sur G. D’apr`es les Lemmes 5.13 et 5.14, on sait que les r`egles M2 et M3 ne peuvent
pas ˆetre appliqu´ees plus de n(n−1)
Entre deux ´etapes o`u une des r`egles M2,M3 est appliqu´ee, d’apr`es le Lemme 5.16, la
r`egle M4 est appliqu´ee au plus 2m fois. Ainsi, la r`egle M4 est appliqu´ee O(n22m) = 20(m)
fois durant l’ex´ecution ρ.
est ajout´e M(v). Pour chacun de ces couples, la r`egle M1 est appliqu´ee au plus n fois.

`A chaque fois qu’un sommet v modiﬁe son num´ero ou sa vue locale, un couple (n0, (cid:8), N)
Ainsi, durant toute ex´ecution ρ de M sur G, 20(m) r`egles sont appliqu´ees.
Contrairement aux mod`eles ´etudi´es dans les Chapitres 2, 3 et 4, on remarque que
certaines ex´ecutions de l’adaptation de l’algorithme de Mazurkiewicz qu’on a pr´esent´e
dans ce chapitre n´ecessitent un nombre de pas de r´e´etiquetages qui peut ˆetre exponentiel
en la taille du graphe. Cela est du au fait que dans les Chapitres 2, 3 et 4, lorsqu’un
sommet met `a jour sa vue locale, il sait quelle information n’est plus `a jour et il peut alors
supprimer seulement cette information. Au contraire, dans le cadre des calculs locaux sur
les arˆetes non-´etiquet´ees, `a chaque fois qu’un sommet met `a jour sa vue locale, il supprime
les informations obsol`etes, mais il supprime aussi des informations qui peuvent ˆetre valides.
De plus, `a chaque fois qu’un sommet v applique la r`egle M4 avec un de ses voisins v
(cid:2) pour
(cid:2) est modiﬁ´ee pour qu’il existe un entier o
mettre `a jour sa vue locale, la vue locale de v
(cid:2)). Certaines informations pertinentes peuvent
tel que (n(v
(cid:2) qui doit alors remettre `a jour sa vue
alors ˆetre supprim´ees de la vue locale du sommet v
locale. Ainsi, `a chaque fois qu’un sommet modiﬁe son num´ero, cela peut n´ecessiter que la
r`egle M4 soit appliqu´ee sur toutes les arˆetes de graphes et que cette r`egle soit appliqu´ee
un nombre exponentiel de fois sur les arˆetes minimales pour l’ordre .

(cid:2)), o) ∈ N(v) et (n(v), o) ∈ N(v

5.5. Connaissance Initiale du Degr´e

127

u1

u2

(cid:2)
u
1

(cid:2)
u
2

v1

v2

T1

T2

Fig. 20 – L’arbre T1 n’est pas minimal pour les pseudo-revˆetements puisque T1 est un
pseudo-revˆetement de T2.

On s’int´eresse maintenant `a la m´emoire n´ecessaire `a chaque sommet pour stocker son
´etiquette. On suppose que l’´etiquetage initial λ du graphe G est tel que chaque ´etiquette
initiale (cid:8) a une taille en O(log |V (G)|) bits (ce qui est suﬃsant pour attribuer des ´etiquettes
diﬀ´erentes `a tous les sommets et `a toutes les arˆetes de G). On obtient ici aussi une borne
sup´erieure sur la m´emoire n´ecessaire `a chaque sommet plus ´elev´ee que dans les Chapitres 2,
3 et 4.
Proposition 5.22 Pour tout graphe G `a n sommets et m arˆetes dont le degr´e maximal est
Δ, l’algorithme M utilisant des calculs locaux sur les arˆetes ´etiquet´ees n´ecessite O(Δnm)
bits de m´emoire par sommet.

Preuve : On consid`ere un graphe G `a n sommets et m arˆetes dont le degr´e maximal est
Δ. D’apr`es le Lemme 5.16, la valeur maximale des num´eros o g´en´er´es par l’application de
la r`egle M4 sont en 2O(m). Ainsi, la vue locale de chaque sommet peut ˆetre repr´esent´ee en
utilisant O(Δm) bits.
Chaque sommet peut ne conserver dans sa boˆıte-aux-lettres que l’information utile,
(cid:2)) (cid:19) ((cid:8), N)}. Ainsi, dans
i.e., l’ensemble {(n0, (cid:8), N) ∈ M(v) | ∀(n0, (cid:8)
la boˆıte-aux-lettres de chaque sommet, il existe au plus n triplets (n0, (cid:8), N) dont la taille
est en O(Δm) bits. Par cons´equent, on peut repr´esenter la boˆıte-aux-lettres de chaque
sommet avec O(Δnm) bits.
2

(cid:2)) ∈ M(v), ((cid:8)

, N

(cid:2)

, N

(cid:2)

5.5 Connaissance Initiale du Degr´e

On ´etudie dans cette partie l’inﬂuence de la connaissance initiale du degr´e sur les
calculs locaux sur les arˆetes non-´etiquet´ees. C’est `a dire qu’initialement, chaque sommet
v d’un graphe G = (G, λ) connaˆıt son degr´e, i.e., son degr´e fait partie de son ´etiquette
initiale λ(v).

5.5.1

´Election dans la Famille des Arbres

Il existe des arbres qui ne sont pas minimaux pour les pseudo-revˆetements. Par exemple,
(cid:2)
consid`erons le graphe non-´etiquet´e T1 de la Figure 20. On note T
1 le sous graphe partiel
1) = {{u1, u2},{u
2}} et γ l’homomorphisme de T1 dans T2 qui
(cid:2)
(cid:2)
(cid:2)
de T1 d´eﬁni par E(T
1, u
(cid:2)
(cid:2)
(cid:2)
1 est un
envoie u1 (resp. u
1) sur v1 et u2 (resp. u
2) sur v2. Il est facile de voir que T
revˆetement simple de T2 et par cons´equent, T1 est un pseudo-revˆetement de T2 `a travers γ
(cid:2)
1. On a ainsi exhib´e un arbre qui n’est pas minimal pour les pseudo-
et respectivement `a T
revˆetements et il est facile de voir que toutes les chaines de longueurs paires ne sont pas
minimales pour les pseudo-revˆetements.

128

Chapitre 5. Calculs Locaux sur les Arˆetes Non-´Etiquet´ees

En utilisant la mˆeme preuve que dans le Chapitre 3, on peut montrer maintenant
que mˆeme si on consid`ere seulement les arbres minimaux pour les pseudo-revˆetements,
il n’existe pas d’algorithme utilisant des calculs locaux sur les arˆetes non-´etiquet´ees qui
permette de r´esoudre le probl`eme de l’´election sur la famille des arbres minimaux pour
les pseudo-revˆetements. En eﬀet, les arbres de la Figure 12 consid´er´es dans la preuve du
Chapitre 3 sont tous les deux minimaux pour les revˆetements puisqu’ils ont tous les deux
un nombre premier de sommets.

On va montrer maintenant que si initialement, tous les sommets connaissent leur degr´e,
il existe un algorithme d’´election pour la famille des arbres utilisant des calculs locaux sur
les arˆetes non-´etiquet´ees. L’algorithme est inspir´e de l’algorithme d’´election dans les arbres
pr´esent´e dans le Chapitre 1.
On consid`ere la famille des arbres T ´etiquet´es de telle sorte que pour tout arbre T ∈ T ,
T = (T, (λ, d)) o`u λ est une fonction d’´etiquetage habituel et d est la fonction qui associe
`a chaque sommet son degr´e dans l’arbre.
Pour tout sommet v ∈ V (G), l’´etiquette initiale d’un sommet est donc (λ(v), d(v)) o`u
d(v) est le degr´e du sommet v dans G. On va montrer qu’avec la connaissance du degr´e, il
est facile de coder l’algorithme d’´election dans les arbres pr´esent´e dans le Chapitre 1. La
premi`ere r`egle est une r`egle «d’´elagage» qui permet `a un sommet qui n’a qu’un seul voisin
actif (i.e. dont l’´etiquette n’est pas terminale) dans l’arbre de prendre l’´etiquette non-´elu
et d’informer son voisin qu’il a un voisin actif de moins

T1 :

((cid:8)1, 1)

((cid:8)2, d2)

non-´elu

((cid:8)2, d2 − 1)

La seconde r`egle permet `a un sommet qui n’a plus aucun voisin actif dans l’arbre de

prendre l’´etiquette ´elu.

T2 :

((cid:8), 0)

´elu

On consid`ere un arbre T et une ex´ecution de l’algorithme d´ecrit pr´ec´edemment sur T.
Pour chaque ´etape i de l’ex´ecution, on note (λ(v), di(v)) l’´etiquette du sommet v apr`es le
i`eme pas de r´e´etiquetage.

On observe qu’`a chaque application d’une des deux r`egles, le nombre de sommets qui
n’ont pas d’´etiquettes ﬁnales diminue strictement. On est donc assur´e que toute ex´ecution
de l’algorithme termine. On dit qu’un sommet est actif si son ´etiquette n’est pas ﬁnale
(i.e., son ´etiquette est diﬀ´erente de ´elu et de non-´elu). On montre dans le lemme suivant
un invariant qui permet de prouver la correction de l’algorithme.
Lemme 5.23 Pour toute ´etape i, le graphe induit par l’ensemble des sommets actifs est
un arbre et pour tout sommet v, di(v) est le nombre de voisins actifs de v.

Preuve : On montre ce lemme par r´ecurrence sur i. Initialement, tous les sommets sont
actifs et par cons´equent, la propri´et´e est bien v´eriﬁ´ee puisque d(v) correspond au degr´e de
v dans T . On suppose que la propri´et´e est v´eriﬁ´ee `a l’´etape i.

5.5. Connaissance Initiale du Degr´e

129

Si la r`egle T1 est appliqu´ee `a l’´etape i+1 sur une arˆete {v, v

(cid:2)} lors de laquelle le sommet
v prend l’´etiquette non-´elu. On sait que di(v) = 1 est le nombre de voisins actifs de v
et par cons´equent v est une feuille dans l’arbre induit par les sommets actifs `a l’´etape i.
Par cons´equent, `a l’´etape i + 1, le graphe induit par les sommets actifs est toujours un
(cid:2) a exactement un voisin actif de moins `a l’´etape i+ 1 qu’`a l’´etape i et par
arbre. De plus, v
(cid:2) `a l’´etape i + 1.
(cid:2)) = di(v
cons´equent di+1(v
Si la r`egle T2 est appliqu´ee lors de l’´etape i + 1 et modiﬁe l’´etiquette d’un sommet
v, cela signiﬁe que v n’a aucun voisin actif et puisque le graphe induit par les sommets
actifs est connexe, cela implique qu’`a l’´etape i + 1, il n’y aucun sommet actif dans T : la
propri´et´e reste vraie.
2

(cid:2)) − 1 est bien le nombre de voisins actifs de v

On consid`ere la conﬁguration ﬁnale d’une ex´ecution de l’algorithme sur T. S’il existe
encore des sommets actifs, alors d’apr`es le Lemme 5.23, le graphe induit par les sommets
actifs est un arbre et ou bien, cet arbre est r´eduit `a un sommet et la r`egle T2 peut ˆetre
appliqu´ee, ou bien il existe un sommet actif qui a un unique voisin actif et la r`egle T1
peut ˆetre appliqu´ee. Par cons´equent, dans la conﬁguration ﬁnale, tous les sommets ont
l’´etiquette ´elu ou non-´elu. De plus, d’apr`es le Lemme 5.23, si la r`egle T2 est appliqu´ee
lors d’une ´etape i, alors il n’y a plus aucun sommet actif apr`es l’´etape i. Par cons´equent,
il y au plus un sommet qui a l’´etiquette ´elu dans la conﬁguration ﬁnale. De plus, si on
consid`ere le dernier sommet qui a pris une ´etiquette ﬁnale, ce sommet n’a pas pu appliquer
la r`egle T1 et il a par cons´equent l’´etiquette ´elu dans la conﬁguration ﬁnale. L’algorithme
d´ecrit ci-dessus est donc bien un algorithme d’´election pour la famille des arbres.
Th´eor`eme 5.24 Il existe un algorithme d’´election pour la famille des arbres utilisant des
calculs locaux sur les arˆetes non-´etiquet´ees avec connaissance initiale du degr´e.

Un corollaire int´eressant de ce th´eor`eme et de l’exemple donn´e sur la Figure 20 est
que les calculs locaux sur les arˆetes non-´etiquet´ees avec connaissance initiale du degr´e
permettent de r´esoudre le probl`eme de l’´election sur strictement plus de graphes que les
calculs locaux sur les arˆetes non-´etiquet´ees sans connaissance initiale du degr´e. Cela est
du au fait que, contrairement aux revˆetements, les pseudo-revˆetements ne conserve pas
forc´ement le degr´e. En eﬀet, si on consid`ere le graphe T1 de la Figure 20, la connaissance
initiale du degr´e rend le graphe minimal pour les pseudo-revˆetements puisque les deux seuls
sommets dont l’´etiquette initiale (i.e. leur degr´e) est 2 sont adjacents et ils ne peuvent donc
pas avoir la mˆeme image `a travers un homomorphisme de graphes simples.

5.5.2

´Election dans les Familles de Diam`etre Born´e

On montre dans cette partie que pour pouvoir ´elire dans un graphe G minimal pour
les pseudo-revˆetements, il n’est pas n´ecessaire de connaˆıtre la taille de G, mais qu’une
borne sur le diam`etre suﬃt si chaque sommet connaˆıt initialement son degr´e. Pour cela,
on explique comment impl´ementer l’algorithme GSSP d´ecrit dans le Chapitre 2 utilisant
des calculs locaux sur les arˆetes non-´etiquet´ees avec connaissance du degr´e.

On va utiliser les mˆemes id´ee que dans les Chapitres 2 et 3 pour impl´ementer l’algo-
rithme GSSP dans le mod`ele consid´er´e ici. Comme dans le Chapitre 3, chaque sommet va
devoir stocker des informations `a propos du rayon de conﬁance de ses voisins. Cependant,
dans le Chapitre 3, chaque sommet pouvait distinger ses voisins en utilisant les num´eros
distincts attribu´ees `a chacune des arˆetes qui lui ´etaient incidentes. On ne peut pas utiliser

130

Chapitre 5. Calculs Locaux sur les Arˆetes Non-´Etiquet´ees

ce principe ici, puisque les arˆetes ne peuvent pas ˆetre ´etiquet´ees. N´eanmoins, si le graphe
G est minimal pour les pseudo-revˆetements, on sait que pour toute ex´ecution de l’algo-
rithme M sur G, il existe une ´etape lors de laquelle tous les sommets de G ont un num´ero
diﬀ´erent. Par cons´equent, s’il y a moins de degG(v) couples (n, o) dans la vue locale de v,
on sait que la vue locale d’un sommet v ne peut pas ˆetre sa vue locale ﬁnale. En revanche,
(cid:2) de v
si un sommet v a degG(v) couples (n, o) dans sa vue locale et que chaque voisin v
n’a pas modiﬁ´e sa boˆıte-aux-lettres depuis la derni`ere ´etape lors de laquelle une r`egle de
(cid:2)}, tous les voisins de v ont des num´eros diﬀ´erents et
M a ´et´e appliqu´ee sur l’arˆete {v, v
le sommet v les connaˆıt. Par cons´equent, le sommet v peut distinguer ses voisins grˆace
`a leurs num´eros et on peut donc impl´ementer l’algorithme GSSP en utilisant des calculs
locaux sur les arˆetes non-´etiquet´ees.

Comme dans le Chapitre 3, l’´etiquette de chaque sommet v va ˆetre de la forme
(λ(v), d(v), n(v), N(v), M(v), a(v), A(v)) o`u λ(v), n(v), N(v) et M(v) jouent le mˆeme rˆole
que dans l’algorithme M. Le champ d(v) code le degr´e de v dans le graphe et ne sera pas
modiﬁ´e. Le champ a(v) correspond au rayon de conﬁance du sommet v et le champ A(v)
est un ensemble de couples d’entiers qui contient l’information dont v dispose `a propos
du rayon de conﬁance de ses voisins. Comme dans l’algorithme M, l’´etiquette initiale de
chaque sommet v ∈ V (G) est (λ(v), d(v), 0,∅,∅,−1,∅).

Il est `a noter qu’ici, on consid`ere que l’´etiquette initiale du sommet est (λ(v), d(v)) et
que les triplets ajout´es `a M(v) sont de la forme (n, ((cid:8), d), N). De cette mani`ere, on s’assure
que dans la conﬁguration ﬁnale, deux sommets qui ont le mˆeme num´ero ont aussi le mˆeme
degr´e.

Les r`egles M1, M2, M3, M4 restent les mˆemes que dans l’algorithme M a la seule
diﬀ´erence que si la boˆıte-aux-lettres d’un sommet v est modiﬁ´ee par l’application d’une de
ces r`egles, alors a(v) est r´einitialis´e `a −1 et A(v) est r´einitialis´e `a ∅. En eﬀet, si un sommet
modiﬁe sa boˆıte-aux-lettres, cela signiﬁe que ses voisins peuvent avoir changer de num´ero
3 et M(cid:2)
et les num´eros apparaissant dans A(v) sont alors obsol`etes. On note M(cid:2)
4
les r`egles ainsi obtenues.

2, M(cid:2)

1, M(cid:2)

M(cid:2)
1 :

((cid:8)1, d1, n1, N1,

M1, a1, A1)

((cid:8)2, d2, n2, N2,
M2, a2, A2)

M2 \ M1 (cid:12)= ∅
Si
1 ∪ M
(cid:2) := M
(cid:2)
(cid:2)
2 ;
alors M
1 := −1 ;
(cid:2)
a
1 := ∅.
(cid:2)
A

((cid:8)1, d1, n1, N1,

M

(cid:2)

(cid:2)
(cid:2)
1)
1, A
, a

((cid:8)2, d2, n2, N2,
M2, a2, A2)

5.5. Connaissance Initiale du Degr´e

131

M(cid:2)
2 :

Si
alors

M(cid:2)
3 :

(cid:2)

(cid:2)
, a

((cid:8), d, k, N, M

((cid:8), d, n, N, M, a, A)

(cid:2))
, A
n = 0 ou ∃(n, (d
(cid:2)) ∈ M tel que ((d, (cid:8)), N) ≺ ((d
(cid:2)), N
(cid:2)
(cid:2)
, (cid:8)
(cid:2) | ∃(n
k := 1 + max{n
(cid:2)
(cid:2)
, (d
, (cid:8)
(cid:2) := M ∪ {(k, (d, (cid:8)), N)} ;
M
(cid:2) := −1 ;
a
(cid:2) := ∅.
A

(cid:2)) ∈ M} ;

(cid:2)), N

(cid:2)), N

(cid:2))

, (cid:8)

((cid:8), d1, n, N,
M, a1, A1)

((cid:8), d2, n, N,
M, a2, A2)

((cid:8), d1, k, N,
(cid:2)
(cid:2)
1)
M
1, A
, a

(cid:2)

((cid:8), d2, n, N,
(cid:2)
(cid:2)
2)
2, A
, a
M

(cid:2)

(cid:2)) (cid:19) ((d, (cid:8)), N)
(cid:2)) ∈ M} ;

(cid:2)

n > 0 et
(cid:2)) ∈ M, ((d
∀(n, (d
(cid:2)
(cid:2)), N
(cid:2)), N
(cid:2)
, (cid:8)
, (cid:8)
(cid:2) | ∃(n
k := 1 + max{n
(cid:2)
(cid:2)), N
, (d
, (cid:8)
(cid:2) := M ∪ {(k, (d, (cid:8)), N)} ;
M
1 := −1 ;
(cid:2)
a
1 := ∅ ;
(cid:2)
A
2 := −1 ;
(cid:2)
a
2 := ∅.
(cid:2)
A

Si

alors

M(cid:2)
4 :

((cid:8), d1, n1, N1,
M, a1, A1)

((cid:8), d2, n2, N2,
M, a2, A2)

(cid:2)
((cid:8), d1, n1, N
1,
(cid:2)
(cid:2)
1)
1, A
, a
M

(cid:2)

(cid:2)
((cid:8), d2, n2, N
2,
(cid:2)
(cid:2)
2)
2, A
, a
M

(cid:2)

Si

alors

(cid:2)

(cid:2)) ∈ N1 ∪ N2} ;
, o

1) (cid:19) ((d1, (cid:8)1), N1),
(cid:2)
2) (cid:19) ((d2, (cid:8)2), N2) et
(cid:2)

n1, n2 > 0, n1 (cid:12)= n2,
1) ∈ M, ((d
∀(n1, (d
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
1), N
1), N
1, (cid:8)
1, (cid:8)
2) ∈ M, ((d
∀(n2, (d
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
2), N
2), N
2, (cid:8)
2, (cid:8)
(cid:2)o | (n2, o) ∈ N1 et (n1, o) ∈ N2
o := 1 + max{o
(cid:2) | ∃(n
(cid:2) ≤ n2} ∪ {(n2, o)} ;
1 := N1 \ {(n
(cid:2)) ∈ N1 | n
(cid:2)
(cid:2)
, o
N
2 := N2 \ {(n
(cid:2)) ∈ N2 | n
(cid:2) ≤ n1} ∪ {(n1, o)} ;
(cid:2)
(cid:2)
, o
N
(cid:2) := M ∪ {(n1, (d1, (cid:8)1), N
2)} ;
(cid:2)
(cid:2)
1), (n2, (d2, (cid:8)2), N
M
1 := −1 ;
(cid:2)
a
1 := ∅ ;
(cid:2)
A
2 := −1 ;
(cid:2)
a
2 := ∅ ;
(cid:2)
A
5 permet `a un sommet v qui ne peut pas appliquer la r`egle M(cid:2)

La r`egle M(cid:2)

2, dont le
rayon de conﬁance est −1 et dont la vue locale contient d(v) exactement couples (n, o) de
prendre le rayon de conﬁance 0 et de construire un ensemble A(v) qui contient un couple
(n,−1) pour chaque couple (n, o) apparaissant dans sa vue locale. Cet ensemble A(v) va

132

Chapitre 5. Calculs Locaux sur les Arˆetes Non-´Etiquet´ees

permettre `a chaque sommet de stocker le rayon de conﬁance de ses voisins.

M(cid:2)
5 :

((cid:8), d, n, N, M,−1, A)

(cid:2))
((cid:8), d, k, N, M, 0, A

, (cid:8)

Si

(cid:2)) ∈ M, ((d
(cid:2)

(cid:2)) (cid:19) ((d, (cid:8)), N) et

(cid:2)), N
, o) ∈ N}.

(cid:2)), N
,−1) | ∃(n
(cid:2)

n > 0,
∀(n, (d
(cid:2)
, (cid:8)
|N| = d
(cid:2) := {(n
6 permet `a un sommet dont le rayon de conﬁance est sup´erieur ou ´egal
`a 0 d’augmenter son rayon de conﬁance si chacun de ses voisins a un rayon de conﬁance
sup´erieur ou ´egal au sien. On remarque que si un sommet a un rayon de conﬁance sup´erieur
ou ´egal `a 0, on sait que la r`egle M(cid:2)

2 ne peut pas ˆetre appliqu´ee sur le sommet v.

Alors A
La r`egle M(cid:2)

(cid:2)

M(cid:2)
6 :

((cid:8), d, n, N, M, a, A)

((cid:8), d, k, N, M, a + 1, A)

Cette r`egle est applicable si n > 0, a ≥ 0 et
(cid:2)) ∈ A, a
, a

∀(n

(cid:2)

(cid:2) ≥ a.

La r`egle M(cid:2)

7 permet `a deux sommets d’´echanger leurs rayons de conﬁance une fois que
ceux ci ont ´et´e modiﬁ´es par la r`egle pr´ec´edente. Cette r`egle ne peut ˆetre appliqu´ee sur une
arˆete e que si aucune des r`egles M(cid:2)

4 ne peut ˆetre appliqu´ee sur e.

1,M(cid:2)

2,M(cid:2)

3,M(cid:2)

M(cid:2)
7 :

(cid:2)
1,

Si

M, a1, A1)

((cid:8)1, d1, n1, N1,

((cid:8), d2, n2, N2,
M, a2, A2)

((cid:8)1, d1, n1, N
(cid:2)
1)
M, a1, A
p > 0, n1 > 0, n2 > 0, n1 (cid:12)= n2), a1 ≥ 0, a2 ≥ 0
∃o tel que(n2, o) ∈ N1 et (n1, o) ∈ N2 et
(n1, a1) /∈ A2 ou (n2, a2) /∈ A1
1 := A1 \ {(n
(cid:2)
alors A
2 := A2 \ {(n
(cid:2)
A

2 = n2} ∪ {(n2, a2)} ;
(cid:2)
1 = n1} ∪ {(n1, a1)} ;
(cid:2)

(cid:2)) | n
(cid:2)) | n

(cid:2)
2, a
(cid:2)
1, a

(cid:2)
2,

((cid:8), d2, n2, N
(cid:2)
2)
M, a2, A

On s’int´eresse maintenant aux propri´et´es satisfaites par toute ex´ecution de l’algorithme
M(cid:2). Comme pr´ecedemment, on consid`ere une ex´ecution de l’algorithme M(cid:2) sur un graphe
´etiquet´e G. Pour tout sommet v ∈ V (G), on note (λ(v), d(v), ni(v), Ni(v), Mi(v), ai(v),
Ai(v)) l’´etiquette du sommet v apr`es la i`eme ´etape de r´e´etiquetage.

Le lemme suivant qui peut ˆetre facilement prouv´e par induction sur le nombre d’´etapes
montre que le rayon de conﬁance d’un sommet ne peut qu’augmenter tant que sa boˆıte-
aux-lettres n’est pas modiﬁ´ee.
Lemme 5.25 Pour tout sommet v et toute ´etape i, si Mi(v) = Mi+1(v), alors ai+1(v) ≥
ai(v) et pour tout (n, a) ∈ Mi(v), il existe (n
(cid:2) ≥ a ≥ ai+1(v) − 1. De
plus, si ai(v) ≥ 0, alors la r`egle M(cid:2)

2 ne peut ˆetre appliqu´ee sur le sommet v.

(cid:2)) ∈ Mi+1(v) et a
, a

(cid:2)

5.5. Connaissance Initiale du Degr´e

133

Dans le lemme suivant, on montre que le rayon de conﬁance d’un sommet permet d’ob-
tenir des informations sur le contenu des boˆıtes-aux-lettres d’autres sommets du graphe
lors d’´etapes pr´ec´edentes de l’ex´ecution. Cette propri´et´e est la mˆeme que la propri´et´e de
l’algorithme du Chapitre 3.
Lemme 5.26 Pour tout sommet v ∈ V (G) et toute ´etape i, pour tout sommet w ∈ V (G)
tel que distG(v, w) ≤ ai(v), il existe une ´etape j ≥ i telle que aj(w) ≥ ai(v) − distG(v, w)
et Mj(v) = Mi(v).

D’apr`es le Lemme 5.15, puisque Ni0(v) = Ni(v), on sait que pout toute ´etape i

(cid:2)

(cid:2)) = n et ai(cid:2)(v

7 a ´et´e appliqu´ee sur v et on sait que Mi(v) = Mi0(v) ⊆ Mi1(v) ⊆ Mi(v).

Preuve : On fait une d´emonstration par r´ecurrence sur la distance k entre v et w dans
G. Si k = 0, la propri´et´e est trivialement vraie. On suppose maintenant que la propri´et´e
est vraie pour tous sommets v, w tels que distG(v, w) ≤ k.
On consid`ere deux sommets v, w et une ´etape i tels que ai(v) ≥ k + 1 ≥ 1 et
distG(v, w) = k + 1. Il existe une ´etape i0 < i lors de laquelle la r`egle M(cid:2)
6 a ´et´e ap-
(cid:2) ∈ [i0, i] lors
pliqu´ee sur le sommet v telle que Mi(v) = Mi0(v). Il existe aussi une ´etape i
de laquelle la r`egle M(cid:2)
7 a ´et´e appliqu´ee sur v. On note i1 la derni`ere ´etape lors de laquelle
la r`egle M(cid:2)
(cid:2) ∈
[i0, i1], pour tout couple (n, o) ∈ Ni(cid:2)(v), ou bien il existe u ∈ NG(v) tel que ni(cid:2)(u) = n,
(cid:2)) ∈ Ni0(v)}. De plus, pour
ou bien il existe u ∈ NG(v) tel que ni(cid:2)(u) ≥ max{n
(cid:2) | ∃(n
, o
tout (n, a) ∈ Ai(v), a ≥ ai(v) − 1 ≥ 0 et par cons´equent, pour tout (n, o) ∈ Ni(v), il
(cid:2)}
7 a ´et´e appliqu´ee sur une arˆete {v, v
(cid:2) ∈ [i0, i1] lors de laquelle r`egle M(cid:2)
existe une ´etape i
(cid:2)) = a ≥ 0. Par cons´equent, puisque les num´eros des sommets
telle que ni(cid:2)(v
ne peuvent qu’augmenter et que |Ni0(v)| = degG(v), on sait que pour tout u ∈ NG(v), il
existe (ni0(u), o) ∈ Ni0(v). De plus, d’apr`es le Lemme 5.15, pour toute ´etape i
(cid:2) ∈ [i0, i] lors
7 est appliqu´ee sur l’arˆete {u, v}, ni(cid:2)(u) = ni0(u) et Mi(cid:2)(u) = Mi(v).
de laquelle la r`egle M(cid:2)
On sait qu’il existe un sommet u ∈ NG(v) tel que distG(u, w) = k. On consid`ere
7 a ´et´e appliqu´ee sur l’arˆete {u, v}.
la derni`ere ´etape j
On sait qu’il existe (nj(cid:2)(u), aj(cid:2)(u)) ∈ Ni(v). Par cons´equent, d’apr`es le Lemme 5.25, on
sait que aj(cid:2)(u) ≥ ai(cid:2)(v) − 1 et Mj(cid:2)(u) = Mi(v). Par hypoth`ese de r´ecurrence, on sait
(cid:2) telle que aj(w) ≥ aj(cid:2)(u) − k ≥ ai(v) − (k + 1) et telle
qu’il existe une ´etape j < j
que Mj(w) = Mj(cid:2)(u) = Mi(v). Ainsi, la propri´et´e est v´eriﬁ´ee pour tous sommets v, w `a
distance k + 1 dans G.
2

(cid:2) lors de laquelle la r`egle r`egle M(cid:2)

Comme dans l’algorithme GSSP des Chapitres 2 et 3, on montre que si `a un moment
donn´e, un sommet a un rayon de conﬁance sup´erieur au diam`etre du graphe, alors tous
les sommets du graphe ont la mˆeme boˆıte-aux-lettres et ont tous un rayon de conﬁance
sup´erieur `a 0.
Lemme 5.27 S’il existe un sommet v et une ´etape i telle que ai(v) ≥ D(G) + 1, alors
pour tout w ∈ V (G), Mi(w) = Mi(v) et ai(v) ≥ 0.
Preuve : Puisque ai(v) > D(G), on sait d’apr`es le Lemme 5.26 que pour tout sommet
w ∈ V (G), il existe une ´etape iw < i telle que aiw ≥ 1 et Miw(w) = Mi(v).
Supposons qu’il existe un sommet w tel que Mi(w) (cid:12)= Miw(w). Soit j l’´etape de
l’ex´ecution lors de laquelle pour la premi`ere fois, la boˆıte-aux-lettres d’un sommet w
qui valait Mi(v) a ´et´e modiﬁ´ee. Autrement dit, pour tout sommet w ∈ V (G), il existe
(cid:2) ≥ j − 1 telle que Mj(cid:2)(w) = Mi(v) et il existe un sommet w tel que
une ´etape j

134

Chapitre 5. Calculs Locaux sur les Arˆetes Non-´Etiquet´ees

3,M(cid:2)

2,M(cid:2)

1,M(cid:2)

2 n’a pas pu ˆetre appliqu´ee sur le sommet w.

(cid:2)) = Mj(w) = Mi(v) lors de laquelle la r`egle M(cid:2)

Mj−1(w) = Mi(v) (cid:4) Mj(w). Cela signiﬁe qu’une des r`egles M(cid:2)
4 a ´et´e ap-
pliqu´ee lors de l’´etape j. Soit w un sommet tel que Mj−1(w) (cid:4) Mj(w) ; on sait d’apr`es le
Lemme 5.25 que Mj−1(w) = Mi(v) et aj−1(w) ≥ 0. Par cons´equent, d’apr`es le Lemme 5.25,
la r`egle M(cid:2)
du choix de j, on sait que la r`egle M(cid:2)
sait que aj−1(w) ≥ 1 et par cons´equent, pour tout sommet w
(cid:2) ≤ j telle que Mj(cid:2)(w
j
l’arˆete {w, w
nj−1(w
plus, aucune des r`egles M(cid:2)
`a l’´etape j
{w

On consid`ere un sommet w dont l’´etiquette a ´et´e modiﬁ´ee lors de l’´etape j. En raison
1 n’a pas pu ˆetre appliqu´ee `a l’´etape j. Par ailleurs, on
(cid:2) ∈ NG(w), il existe une ´etape
7 a ´et´e appliqu´ee sur
(cid:2)) =
(cid:2)) = Mi(v). De
, w}
(cid:2) + 1 et par cons´equent, aucune de ces r`egles ne peut ˆetre appliqu´ee sur l’arˆete

, w} `a l’´etape j. Ainsi pour tout sommet w ∈ V (G), Mi(w) = Mi(v).
Ainsi, si on connaˆıt une borne B sur le diam`etre de G, l’algorithme M(cid:2) permet de
d´etecter que l’ex´ecution de l’algorithme M sous-jacent est termin´e. En eﬀet, une fois qu’un
sommet a un rayon de conﬁance sup´erieur ou ´egal `a B + 1, il sait que tous les sommets de
G ont la mˆeme boˆıte-aux-lettres et qu’ils ont leurs num´eros et vues locales ﬁnaux.

(cid:2)}. De plus, en raison du choix de j, on sait que nj(cid:2)(w) = nj−1(w), nj(cid:2)(w
5 n’a peut ˆetre appliqu´ee sur l’arˆete {w
(cid:2)

(cid:2)), Nj(cid:2)(w) = Nj−1(w), Nj(cid:2)(w
2,M(cid:2)

(cid:2)) = Nj−1(w
3,M(cid:2)

(cid:2)) et Mj(cid:2)(w) = Mj(cid:2)(w

1,M(cid:2)

4,M(cid:2)

(cid:2)

2

Si on sait que le graphe G est minimal pour les pseudo-revˆetements, on sait alors
d’apr`es la Proposition 5.18 que tous les sommets ont un identiﬁant unique et dans ce cas
l`a, le sommet dont le num´ero est 1 peut prendre l’´etiquette ´elu et diﬀuser l’information.
On a par cons´equent montr´e le th´eor`eme suivant.
Th´eor`eme 5.28 Pour tout entier B, il existe un algorithme d’´election et un algorithme
de nommage avec d´etection de la terminaison utilisant des calculs locaux sur les arˆetes
non-´etiquet´ees avec connaissance initiale du degr´e pour la famille des graphes minimaux
pour les pseudo-revˆetements dont le diam`etre est born´ee par B.

Ainsi, comme dans les mod`eles consid´er´es dans les Chapitres 2 et 3, il n’est pas
n´ecessaire de connaˆıtre la taille pour pouvoir ´elire dans un graphe G que l’on sait mi-
nimal pour les pseudo-revˆetements : une borne sur la taille ou le diam`etre est suﬃsante.
Cependant, on peut montrer en utilisant la mˆeme preuve que dans le Chapitre 3, que
si les sommets ne connaissent pas initialement leur degr´e, il est impossible de r´esoudre le
probl`eme de l’´election sur les graphes minimaux pour les pseudo-revˆetements en connais-
sant seulement une borne sur la taille.

5.5.3

Impossibilit´e de D´etecter la Non-Minimalit´e

On montre maintenant que mˆeme si initialement les sommets connaissent leurs degr´es
ainsi que la taille n du graphe G, si celle-ci n’est pas un nombre premier (sinon, d’apr`es
la Remarque 5.20, on peut ´elire dans la famille des graphes de taille n puisque ceux-ci
sont tous minimaux pour les pseudo-revˆetements), il n’existe pas d’algorithme utilisant
des calculs locaux sur les arˆetes non-´etiquet´ees qui permet de r´esoudre le probl`eme de
l’´election sur G ou de d´etecter que G n’est pas minimal pour les pseudo-revˆetements.
Pour tout entier n qui n’est pas premier, on suppose qu’il existe un algorithme eﬀectif
d’´election R pour la classe des graphes de taille n utilisant des calculs locaux sur les arˆetes
non-´etiquet´ees avec connaissance initiale du degr´e. On consid`ere deux entiers p, q tels que
n = pq.

5.5. Connaissance Initiale du Degr´e

135

(1, 4)

G3,2

(3, 4)

(2, 4)

(3, 4)

(6, 2)

(3, 4)

(5, 2)

(1, 4)

K3

H3,2

(2, 4)

(3, 4)

(1, 4)

(2, 4)

(1, 4)

(2, 4)

(4, 2)

Fig. 21 – Le graphe G3,2 est un pseudo-revˆetement de K3 et K3 est un sous-graphe de
H3,2. Dans les graphes G3,2 et H3,2, l’´etiquette de chaque sommet est de la forme ((cid:8), d)
o`u (cid:8) est l’´etiquette initiale du sommet et d est le degr´e du sommet dans le graphe.

On note Kp le graphe complet `a p sommets et on consid`ere un ´etiquetage μ de Kp
tel que chaque sommet ait un num´ero unique. On construit ensuite le graphe (Gp,q, λ) de
la mani`ere suivante. On consid`ere q copies (Kp,1, μ), . . . , (Kp,q, μ) distinctes de (Kp, μ) et
pour tous entiers distincts i, j ∈ [1, q], pour tous sommets vi ∈ Kp,i et vj ∈ Kp,j, on ajoute
une arˆete entre vi et vj si μ(vi) (cid:12)= μ(vj). Le graphe ainsi obtenu est un graphe multiparti
complet avec p parties de taille q (chaque ´etiquette d´eﬁnit une partie). On remarque que
chaque sommet v ∈ V (Gp,q) a exactement q(p − 1) voisins dans (Gp,q, λ). On consid`ere le
graphe ´etiquet´e Gp,q = (Gp,q, (λ, d)) o`u pour tout sommet v ∈ V (Gp,q), d(v) = q(p − 1)
est le degr´e de v dans Gp,q. On consid`ere le graphe Kp = (K, (μ, d)) o`u pour tout sommet
v ∈ V (Kp), d(v) = q(p − 1). Sur la Figure 21, les graphes G3,2 et K3 sont repr´esent´ees.
On remarque que dans Kp, les ´etiquettes initiales des sommets ne contiennent pas
le degr´e de chaque sommet. On peut toutefois ex´ecuter l’algorithme R sur K, mˆeme si
l’algorithme n’est pas cens´e terminer dans une conﬁguration correcte, puisque l’information
initiale dont dispose chaque sommet n’est pas correcte. D’apr`es le Lemme 5.9, il existe
une ex´ecution ρG de R sur Gp,q qui est relev´ee d’une ex´ecution ρK sur Kp. De plus,
puisque l’ex´ecution ρG est relev´ee de l’ex´ecution ρK, on sait que dans la conﬁguration
ﬁnale G(cid:2)
p,q de ρG, les sommets n’ont pas des ´etiquettes uniques et par cons´equent, dans
G(cid:2)
p,q, tous les sommets ont une ´etiquette ﬁnale indiquant que Gp,q n’est pas minimal pour
les revˆetements. Par ailleurs, puisque la conﬁguration ﬁnale G(cid:2)
p,q de ρG est relev´ee de la
conﬁguration ﬁnale K(cid:2)
p, tous les sommets ont une ´etiquette
ﬁnale indiquant que le graphe n’est pas minimal pour les revˆetements.

p de ρK, on sait que dans K(cid:2)

On construit maintenant un graphe (Hp,q, η) minimal pour les revˆetements qui a pq
sommets. Pour cela, on consid`ere une copie de (Kp, λ) qui contient p sommets qui ont
tous un degr´e ´egal `a p − 1. Pour tout ensemble de p − 1 sommets de (Kp, λ), on ajoute
q − 1 sommets qui sont tous adjacents `a tous ces p − 1 sommets. Le graphe ainsi obtenu
est le graphe Hp,q, on ´etend l’´etiquetage de (Kp, λ) de telle sorte que tous les sommets
du graphe aient des ´etiquettes diﬀ´erentes. Le graphe ´etiquet´e ainsi obtenu est le graphe
(H, η) et ce graphe `a p + p(q − 1) = pq sommets. On remarque que chaque sommet qui est
dans la copie de Kp a p − 1 voisins dans la copie de Kp et (p − 1)(q − 1) voisins parmi les
sommets ajout´es pour construire Hp,q : tous ces sommets ont un degr´e ´egal `a q(p− 1). On
note Hp,q le graphe (Hp,q, (η, d)) o`u pour tout sommet v ∈ V (Hp,q), d(v) est le degr´e de v
dans Hp,q. La construction du graphe H3,2 est pr´esent´e sur la Figure 21. Dans le graphe

136

Chapitre 5. Calculs Locaux sur les Arˆetes Non-´Etiquet´ees

Hp,q, tous les sommets ont une ´etiquette initiale diﬀ´erente et ce graphe est donc mimimal
pour les pseudo-revˆetements.
Le graphe Hp,q a la mˆeme taille que Gp,q et tous les sommets de Hp,q connaissent
initialement leur degr´e : par cons´equent, toute ex´ecution de l’algorithme R doit ´elire un
sommet de Hp,q puisqu’il est minimal pour les pseudo-revˆetements. On sait que le graphe
Kp est un sous-graphe de Hp,q, puisqu’on a construit le graphe Hp,q de telle sorte que tous
les sommets de la copie de Kp aient un degr´e ´egal `a q(p − 1) dans Hp,q. Par cons´equent
on peut trouver une ex´ecution de R sur Hp,q dont le pr´eﬁxe est ρK. Dans la conﬁguration
ﬁnale de cette ex´ecution, les sommets de la copie de Kp dans Hp,q ont une ´etiquette ﬁnale
indiquant que le graphe Hp,q n’est pas minimal pour les pseudo-revˆetements, ce qui est
faux.

Par cons´equent, dans le mod`ele des calculs locaux sur les arˆetes non-´etiquet´ees, il

n’existe pas de th´eor`eme correspondant aux Th´eor`emes 3.50 et 2.31.

5.6 Conclusion et Perspectives

Dans ce chapitre, on a caract´eris´e les graphes admettant un algorithme de nommage
et d’´election utilisant des calculs locaux sur les arˆetes non-´etiquet´ees (Th´eor`eme 5.19).
Cette caract´erisation s’exprime `a l’aide de la notion de pseudo-revˆetements. Contrairement
aux algorithmes des Chapitres 2, 3 et 4, l’algorithme pr´esent´e dans la Section 5.4 peut
n´ecessiter un nombre d’´etapes de r´e´etiquetages exponentiel en la taille du graphe. Le
probl`eme de d´eterminer s’il existe un algorithme polynomial de nommage pour tous les
graphes minimaux de taille donn´ee est une question qui n’a pas ´et´e r´esolue pour le moment.
Ce r´esultat nous permet de penser qu’il est possible d’utiliser les techniques pr´esent´ees
dans [GM03, GMM04] aﬁn de caract´eriser les classes de graphes qui peuvent ˆetre reconnues
par des calculs locaux sur les arˆetes non-´etiquet´ees avec ou sans connaissance initiale (la
terminaison est alors implicite). Cependant, on peut reconnaˆıtre strictement moins de
classes de graphes en utilisant des calculs locaux sur les arˆetes ´etiquet´ees (avec ou sans
connaissance initiale) que dans les mod`eles ´etudi´es dans les Chapitres 2, 3 et 4.

Dans la Section 5.5, on a ´etudi´e l’importance de la connaissance initiale du degr´e. On
a montr´e qu’avec la connaissance initiale du degr´e, la connaissance initiale d’une borne
sur le diam`etre du graphe permettait de r´esoudre ´election et nommage dans un graphe
minimal pour les revˆetements (Th´eor`eme 5.28).

Ce r´esultat nous permet de penser qu’on peut ´etendre les techniques utilis´es dans
[GM02] aux calculs locaux sur les arˆetes non-´etiquet´ees aﬁn de caract´eriser les classes de
graphes qui admettent un algorithme universel d’´election dans ce mod`ele.

Cependant, le fait qu’il n’existe pas d’algorithme eﬀectif d’´election pour les graphes
de taille donn´ee utilisant des calculs locaux sur les arˆetes non-´etiquet´ees et plus parti-
culi`erement, le fait qu’on ne puisse pas impl´ementer l’algorithme GSSP pour les graphes
qui ne sont pas minimaux pour les pseudo-revˆetements dans ce mod`ele nous laissent sup-
poser qu’on ne peut pas employer dans ce mod`ele les techniques utilis´es dans [MT00] pour
caract´eriser ce qui peut ˆetre calcul´e avec d´etection de la terminaison.

Par ailleurs, mˆeme si chaque sommet connaˆıt initialement son degr´e, l’algorithme
d’´enum´eration auto-stabilisant de Godard pr´esent´e dans [God02b] ne semble pas pou-
voir ˆetre ´etendu au mod`ele consid´er´e dans ce chapitre. Contrairement au mod`eles ´etudi´es

5.6. Conclusion et Perspectives

137

dans les Chapitres 2 et 4, dans le mod`ele des calculs locaux sur les arˆetes non-´etiquet´ees,
un sommet ne peut pas forc´ement se rendre compte que l’information dont il dispose `a
propos de ses voisins (sa vue locale) est erronn´ee.

138

Chapitre 5. Calculs Locaux sur les Arˆetes Non-´Etiquet´ees

Chapitre 6

Calculs Locaux Cellulaires sur les
Arˆetes Non-´Etiquet´ees

Sommaire
6.1

Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
6.1.1 R´esultats
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
6.1.2 Travaux Li´es
6.2 Submersions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
6.3 Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees . . . 143
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143

6.3.1 D´eﬁnitions
6.3.2

6.5

6.4

Submersions et Calculs Locaux Cellulaires sur les Arˆetes Non-
´Etiquet´ees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
´Enum´eration et Nommage . . . . . . . . . . . . . . . . . . . . . . 145
6.4.1 R´esultats d’Impossibilit´e pour l’´Enum´eration et le Nommage . . 145
6.4.2 Un Algorithme d’´Enum´eration . . . . . . . . . . . . . . . . . . . 146
6.4.3 Correction de l’Algorithme d’´Enum´eration . . . . . . . . . . . . . 148
6.4.4 Complexit´e . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
´Election . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
6.5.1 Conditions N´ecessaires pour l’´Election . . . . . . . . . . . . . . . 154
6.5.2 Un Algorithme d’´Election . . . . . . . . . . . . . . . . . . . . . . 155
6.5.3 Correction de l’Algorithme d’´Election . . . . . . . . . . . . . . . 160
6.6 Exemples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
6.6.1 Arbres, Grilles et Graphes Bipartis . . . . . . . . . . . . . . . . . 164
6.6.2 Anneaux de Taille Premi`ere . . . . . . . . . . . . . . . . . . . . . 165
6.7 Connaissance Initiale du Degr´e . . . . . . . . . . . . . . . . . . . 166

6.7.1 Pas d’Algorithme d’´Election ou de Nommage pour la Famille des

Arbres . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166
6.7.2 Nommage dans les Familles de Diam`etre Born´e . . . . . . . . . . 166
6.8 Conclusion et Perspectives . . . . . . . . . . . . . . . . . . . . . . 167

139

140Chapitre 6. Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees

X

Y

(cid:2)

X

Y

Fig. 22 – Forme g´en´erique d’une r`egle de calcul pour les calculs locaux cellulaires sur les
arˆetes non-´etiquet´ees.

6.1

Introduction

Dans ce chapitre, on ´etudie les calculs locaux cellulaires sur les arˆetes non-´etiquet´ees.
Dans ce mod`ele, on consid`ere des graphes simples o`u seuls les sommets peuvent ˆetre
´etiquet´es, comme dans les Chapitres 4 et 5. Un pas de calcul est d´ecrit par une r`egle
de r´e´etiquetage de la forme pr´esent´ee sur la Figure 22. Si dans un graphe G, il existe
un sommet ´etiquet´e X qui a un voisin ´etiquet´e Y , alors l’application de la r`egle de la
(cid:2). Les ´etiquettes de tous les
Figure 22 permet de remplacer l’´etiquette X par l’´etiquette X
autres sommets ne sont pas prises en compte pour l’application de la r`egle de r´e´etiquetage
et restent inchang´ees. Le sommet de G dont l’´etiquette est modiﬁ´ee est dit actif (et est
repr´esent´e en noir sur les ﬁgures), le voisin du sommet actif qui est utilis´e pour pouvoir
appliquer la r`egle est dit passif (et est repr´esent´e en blanc sur les ﬁgures). Tous les autres
sommets de G qui ne participent pas `a l’application de la r`egle sont dits inactifs. Les
calculs r´ealis´es en utilisant uniquement ce type de r´e´etiquetage sont appel´es calculs locaux
cellulaires sur les arˆetes non-´etiquet´ees.

La diﬀ´erence entre ce mod`ele et le mod`ele des calculs locaux cellulaires sur les arˆetes
´etiquet´ees est que les arˆetes ne peuvent pas ˆetre ´etiquet´ees (et r´e´etiquet´ees) ; cela donne
un mod`ele strictement plus faible. On va aussi montrer que les calculs locaux cellulaires
sur les arˆetes non-´etiquet´ees sont strictement plus faibles que les calculs locaux sur les
arˆetes non-´etiquet´ees et que les calculs locaux cellulaires sur les ´etoiles. Ainsi, lorsque
les arˆetes ne peuvent pas ˆetre ´etiquet´ees, il n’existe pas de r´esultats correspondant aux
Propositions 3.20 et 3.42.

6.1.1 R´esultats

Dans le mod`ele des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees, on caract´erise
les graphes admettant un algorithme de nommage et les graphes admettant un algorithme
d’´election. Comme dans le Chapitre 4, les deux probl`emes ne sont pas ´equivalents dans le
mod`ele consid´er´e dans ce chapitre. On utilise la notion de submersions (qui correspondent
aux homomorphismes de graphes simples localement surjectifs) pour pouvoir exprimer ces
caract´erisations.

On montre qu’un graphe admet un algorithme de nommage utilisant des calculs locaux
cellulaires sur les arˆetes non-´etiquet´ees si et seulement s’il est minimal pour les submersions
(Th´eor`eme 6.16). L’algorithme de nommage qu’on pr´esente dans la Section 6.4.2 est inspir´e
de l’algorithme de Mazurkiewicz [Maz97] et utilise les id´ees pr´esent´ees dans le Chapitre 5.
La caract´erisation des graphes admettant un algorithme d’´election utilise aussi la no-
tion d’homomorphismes localement surjectifs, mais est un peu plus diﬃcile `a exprimer
(Th´eor`eme 6.28). L’algorithme d’´election qu’on pr´esente dans la Section 6.5 repose `a la
fois sur l’algorithme de Mazurkiewicz [Maz97] et sur une adaptation de l’algorithme de
Szymansky, Shi et Prywes [SSP85] diﬀ´erente de l’algorithme GSSP pr´esent´ee dans les Cha-
pitres 2, 3 et 5. Dans le cadre des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees, il

6.1. Introduction

141

n’est pas possible d’assurer que tous les voisins d’un sommet ont des ´etiquettes distinctes
`a partir d’une certaine ´etape, contrairement `a l’algorithme d’´election pour les familles de
diam`etre born´e pr´esent´e dans le Chapitre 5.

On ´etudie ensuite l’inﬂuence de la connaissance initiale du degr´e et on montre que si
initialement, chaque sommet connaˆıt son degr´e, alors il suﬃt de connaˆıtre une borne
sur le diam`etre pour pouvoir nommer dans un graphe minimal pour les submersions
(Th´eor`eme 6.31). Cependant, on n’obtient pas de r´esultats similaires pour le probl`eme
de l’´election et on montre que contrairement aux mod`eles ´etudi´es dans les Chapitres 3 et
5, la connaissance initiale du degr´e ne permet pas d’´elire dans la famille des arbres.

Les r´esultats pr´esent´es dans ce chapitre ont ´et´e obtenus en collaboration avec Yves
M´etiver et Wies(cid:3)law Zielonka. Une version pr´eliminaire de certains de ces r´esultats est
parue dans [CMZ04] et une version compl`ete est parue dans [CMZ06].

6.1.2 Travaux Li´es

Processus `a M´emoire Finie

Dans [AAER05], Angluin et al. consid`erent un mod`ele utilisant le mˆeme type de r`egles.
Cependant, ils supposent que la m´emoire de chaque processus est ﬁnie : l’ensemble des
´etiquettes apparaissant sur les sommets au cours de toute ex´ecution est donc ﬁni et
ind´ependant de la taille du graphe. Dans leurs travaux, Angluin et al. ne consid`erent
que le cas o`u le graphe est un graphe complet.

De plus, ils supposent que si une conﬁguration globale peut ˆetre inﬁniment souvent
atteinte en un nombre ﬁni d’´etapes `a partir de la conﬁguration courante, alors cette conﬁ-
guration globale sera atteinte. De cette mani`ere, il n’est pas n´ecessaire de consid´erer des
relations de r´e´etiquetage noeth´eriennes.

Ils supposent qu’il existe une fonction de sortie qui permet d’attribuer `a chaque conﬁ-
guration globale du graphe une valeur, qui est le r´esultat du calcul. Ils consid`erent des
ex´ecutions qui calculent un r´esultat de mani`ere stabilisante : ce sont les ex´ecutions telles
qu’`a partir d’une certaine ´etape, la fonction de sortie renvoie toujours la mˆeme valeur.
Cette notion de terminaison est `a rapprocher de la terminaison implicite, au sens o`u les
sommets ne savent pas si l’ex´ecution est termin´ee. Cependant, il faut noter que la fonc-
tion de sortie est globale et par cons´equent, les ´etiquettes peuvent ˆetre modiﬁ´ee, tant que
globalement, le r´esultat reste le mˆeme.

En supposant que chaque sommet v a initialement une valeur input(v) dans un
alphabet d’entr´ee Σ, Angluin et al. d´eterminent quels pr´edicats satisfaits par le multi-
ensemble des entr´ees peuvent ˆetre calcul´es de mani`ere stabilisante. Ils montrent que dans
ce mod`ele particulier, les pr´edicats calculables de mani`ere stabilisante sont les combinai-
sons bool´eennes ﬁnies de pr´edicats de la forme |{v|input(v) = a}| ≥ r o`u a ∈ Σ et r est
une constante.

Assignation de Rˆoles

Les homomorphismes localement surjectifs ont ´et´e ´etudi´es pr´ec´edemment dans le cadre
des probl`emes de l’assignation de rˆoles dans les r´eseaux sociaux [EB91, FP03, FP05, KT00].
En particulier, Fiala et Paulusma ont montr´e [FP05] que pour tout graphe H ﬁx´e, il est

142Chapitre 6. Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees

G

3

1

2

3

3

γ

H

1

2

Fig. 23 – Le graphe simple G est une submersion de H `a travers l’homomorphisme γ qui
envoie chaque sommet de G ´etiquet´e i sur l’unique sommet de H dont l’´etiquette est i.
Cette submersion est propre et donc le graphe G n’est pas minimal pour les submersions,
mais le graphe H est minimal pour les submersions.

NP-complet de d´ecider s’il existe un homomorphisme localement surjectif d’un graphe G
donn´e dans H.

6.2 Submersions

Dans ce chapitre, les submersions, i.e., les homomorphismes de graphes localement sur-
jectifs sont les homomorphismes qui permettent de donner des conditions n´ecessaires que
doivent v´eriﬁer les graphes admettant un algorithme de nommage ou d’´election utilisant
des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees.
D´eﬁnition 6.1 Un graphe simple G est une submersion d’un graphe simple H `a travers
un homomorphisme γ : G → H si pour tout sommet v ∈ V (G), γ induit une surjection du
voisinage NG(v) sur le voisinage NH(γ(v)), i.e., γ(NG(v)) = NH(γ(v)). On dit alors que
l’homomorphisme γ est localement surjectif.

Un graphe simple G est une submersion propre de H si γ n’est pas un isomorphisme
et G est minimal pour les submersions si G n’est une submersion propre d’aucun autre
graphe simple.

Naturellement, un graphe simple ´etiquet´e (G, λ) est une submersion d’un graphe simple
´etiquet´e (H, η) `a travers γ si G est une submersion de H `a travers γ et si γ conserve
l’´etiquetage.

Un exemple de submersion est pr´esent´e sur la Figure 23.
Comme les homomorphismes localement bijectifs, un homomorphisme localement sur-

jectif d’un graphe G dans un graphe connexe H est surjectif.
Proposition 6.2 Si G est une submersion d’un graphe connexe H `a travers γ, alors γ
est surjectif.

Preuve : On consid`ere un graphe G qui est une submersion d’un graphe H `a travers un
homomorphisme γ. Pour tout sommet v ∈ γ(V (G)), il existe u ∈ V (G) tel que γ(u) = v.
(cid:2) ∈ Nu(v) tel
Puisque γ est localement surjectif, pour tout sommet v
que γ(u

(cid:2). Ainsi, puisque H est connexe, on sait que γ est surjectif.

(cid:2)) = v

(cid:2) ∈ NH(v), il existe u

2

La notion de coloration connexe permet de caract´eriser les graphes minimaux pour
les submersions en termes de colorations de graphes. Un ´etiquetage (cid:8) d’un graphe non-
´etiquet´e est une coloration connexe si deux sommets voisins ont des couleurs distinctes et

6.3. Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees

143

si deux sommets qui ont la mˆeme couleur ont les mˆemes couleurs dans leur voisinage.
D´eﬁnition 6.3 Une coloration connexe d’un graphe simple non-´etiquet´e G est un ´etique-
tage (cid:8) de G tel que

– pour tout i ∈ (cid:8)(V (G)), G[i] est un stable,
– pour tout i, j ∈ (cid:8)(V (G)) avec i (cid:12)= j, G[i, j] est un stable, ou alors G[i, j] n’a pas de

sommet isol´e.

Dans la proposition suivante, on utilise la notion de coloration connexe pour ca-
ract´eriser les graphes minimaux pour les submersions. On rappelle qu’une coloration (cid:8)
est dite propre si |(cid:8)(V (G))| < |V (G)|.
Proposition 6.4 Un graphe simple non-´etiquet´e G est minimal pour les submersions si
et seulement si G n’admet aucune coloration connexe propre.
Preuve : ´Etant donn´e un graphe G qui n’est pas minimal pour les submersions, soit H
un graphe tel que G est une submersion propre de H `a travers un homomorphisme γ. Alors
γ est une coloration connexe propre de G et l’ensemble des couleurs utilis´ees est V (H).
(cid:2)} ∈ E(G), γ(u) (cid:12)= γ(u
De plus, puisque H est un graphe simple, pour toute arˆete {u, u
(cid:2)).
(cid:2)] est un stable puisque γ est
Enﬁn, pour tous v, v
(cid:2)} ∈ E(H), alors pour tout u ∈ γ
un homomorphisme. Et si {v, v
−1(v) (resp. u
−1(v
(cid:2))),
(cid:2)) (resp. u ∈ NG(u
−1(v
(cid:2)] n’a
il existe u
pas de sommets isol´es. Par ailleurs, puisque G est une submersion propre de H, on sait
que |(cid:8)(V (G))| = |V (H)| < |V (G)| : G admet donc une coloration connexe propre.

−1(v)) : par cons´equent, G[v, v

(cid:2)} /∈ E(H), alors G[v, v

(cid:2) ∈ V (H), si {v, v

(cid:2) ∈ γ

(cid:2) ∈ NG(u) ∩ γ

(cid:2)) ∩ γ

On consid`ere maintenant un graphe G et une coloration connexe propre (cid:8) de G. On va
maintenant d´eﬁnir un graphe H et un homomorphisme localement surjectif γ de G dans
(cid:2)} appartient `a E(H) si
H. On pose V (H) = (cid:8)(V (G)). Pour tous v, v
(cid:2)] n’est pas un stable. Le graphe H ainsi d´eﬁni est un graphe simple.
et seulement si G[v, v
(cid:2)} ∈ E(G), γ(u) (cid:12)= γ(u
On pose γ = (cid:8). Pour toute arˆete {u, u
(cid:2))] n’est pas
(cid:2))} ∈ E(H) : γ est donc un homomorphisme de G dans H.
un stable et donc {γ(u), γ(u
Enﬁn, pour tout u ∈ V (G), on note v = γ(u) et pour tout v
(cid:2)]) n’est
(cid:2)). Par cons´equent,
(cid:2)] a un voisin u
pas un stable et donc u qui appartient `a G[v, v
γ est un homomorphisme localement surjectif de G dans H.

(cid:2)) et G[γ(u), γ(u
(cid:2) ∈ NH(v), V (G[v, v
(cid:2) ∈ γ

(cid:2) ∈ V (H), l’arˆete {v, v

−1(v

2

Exemple 6.5 Le graphe complet `a n sommets Kn ne peut pas ˆetre colori´e avec moins de
n couleurs et par cons´equent Kn est minimal pour les submersions.

6.3 Calculs Locaux Cellulaires sur les Arˆetes Non-´Etique-

t´ees

Dans cette partie, on pr´esente les d´eﬁnitions formelles des calculs locaux cellulaires sur

les arˆetes non-´etiquet´ees puis on ´etudie leurs relations avec les submersions.

6.3.1 D´eﬁnitions

On rappelle qu’informellement, les calculs locaux cellulaires sur les arˆetes non-´etique-
t´ees sont les calculs r´ealis´es en utilisant uniquement des r`egles de la forme pr´esent´ee sur la
Figure 22 : `a chaque pas de calcul, l’´etiquette d’un sommet est modiﬁ´ee par l’application

144Chapitre 6. Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees

d’une r`egle qui d´epend de l’´etiquette du sommet et de l’´etiquette d’un de ses voisins. On
pr´esente maintenant un d´eﬁnition plus formelle du mod`ele.
D’apr`es la D´eﬁnition 5.8, une relation de r´e´etiquetage R est localement engendr´ee
sur les arˆetes non-´etiquet´ees si l’application d’une r`egle ne d´epend que des ´etiquettes des
extr´emit´es d’une arˆete, i.e., si la condition suivante est satisfaite. Pour tous graphes (G, λ),
(cid:2)) et toutes arˆetes {v1, v2} ∈ E(G) et {w1, w2} ∈ E(H), si les trois
(G, λ
conditions suivantes sont v´eriﬁ´ees :

(cid:2)), (H, η), (H, η

(cid:2)(v1) = η

(cid:2)(w1) et λ

(cid:2)(v2) = η

(cid:2)(w2),

1. λ(v1) = η(w1), λ(v2) = η(w2), λ
2. λ(v) = λ
3. η(w) = η

(cid:2)(v), pour tout v /∈ {v1, v2},
(cid:2)(w), pour tout w /∈ {w1, w2},

alors (G, λ) R (G, λ

(cid:2)) si et seulement si (H, η) R (H, η

(cid:2)).

Une relation de r´e´etiquetage R localement engendr´ee sur les arˆetes non-´etiquet´ees est
cellulaire si lors de l’application d’une r`egle de r´e´etiquetage, l’´etiquette d’un seul sommet
est modiﬁ´ee.
D´eﬁnition 6.6 Une relation de r´e´etiquetage R localement engendr´ee sur les arˆetes non-
(cid:2)) alors il existe un sommet v ∈ V (G) tel
´etiquet´ees est cellulaire si lorsque (G, λ) R (G, λ
que ∀w ∈ V (G), w (cid:12)= v =⇒ λ(w) = λ

(cid:2)(w).

Par d´eﬁnition, les calculs locaux cellulaires sur les arˆetes non-´etiquet´ees correspon-
dent aux relations de r´e´etiquetage cellulaires localement engendr´ees sur les arˆetes non-
´etiquet´ees.

Une relation de r´e´etiquetage cellulaire localement engendr´ee sur les arˆetes non-´eti-
quet´ees peut ˆetre d´ecrite par un ensemble r´ecursif de r`egles de la forme pr´esent´ees sur la
Figure 22. R´eciproquement, un tel ensemble de r`egles induit une relation de r´e´etiquetage
cellulaire localement engendr´ee sur les arˆetes non-´etiquet´ees. Ainsi, on notera R l’ensemble
de r`egles de r´e´etiquetage aussi bien que la relation de r´e´etiquetage correspondante.

6.3.2 Submersions et Calculs Locaux Cellulaires sur les Arˆetes Non-

´Etiquet´ees

On pr´esente maintenant le lemme qui met en ´evidence le lien entre les calculs locaux
cellulaires sur les arˆetes non-´etiquet´ees et les submersions. C’est l’´equivalent du lemme de
rel`evement d’Angluin [Ang80] pour les submersions.
Lemme 6.7 (Lemme de rel`evement) On consid`ere un graphe simple G qui est une
submersion d’un graphe simple H `a travers un homomorphisme γ et une relation R de
r´e´etiquetage cellulaire localement engendr´ee sur les arˆetes non-´etiquet´ees. Si H R∗ H(cid:2),
alors il existe G(cid:2) tel que G R∗ G(cid:2) et G(cid:2) est une submersion de H(cid:2) `a travers γ.
Preuve : Il suﬃt de prouver ce lemme pour un pas de calcul. On consid`ere deux graphes
simples (G, λ) et (H, η) tels que (G, λ) est une submersion de (H, ν) `a travers γ. On
consid`ere un pas de r´e´etiquetage sur H qui implique un sommet actif w et un sommet
(cid:2) le nouvel ´etiquetage de H obtenu apr`es ce pas de r´e´etiquetage.
passif w
(cid:2) ∈
Puisque γ est localement surjectif, pour chaque sommet v ∈ γ
−1(w), il existe v
−1(w) et on
−1(w
ϕ
peut donc appliquer la r`egle de r´e´etiquetage `a chaque sommet v ∈ ϕ
−1(w). On obtient ainsi

(cid:2) et on note η
(cid:2)) ∩ NG(v). Puisque les sommets de ϕ

−1(w) forment un stable, v

/∈ ϕ

(cid:2)

6.4. ´Enum´eration et Nommage

145

un ´etiquetage λ
surjectif.

(cid:2) de G tel que γ : (G, λ

(cid:2)) → (H, η

(cid:2)) reste un homomorphisme localement

On note que chaque pas de r´e´etiquetage dans H est simul´e par plusieurs pas de
2

r´e´etiquetage dans G o`u la mˆeme r`egle de r´e´etiquetage est appliqu´ee.

Le diagramme suivant repr´esente la propri´et´e du Lemme 6.7.

R∗−−−−→ G(cid:2)

⏐⏐(cid:3)submersion

submersion

G

⏐⏐(cid:3)
H −−−−→

R∗ H(cid:2)

6.4

´Enum´eration et Nommage

On s’int´eresse aux probl`emes d’´enum´eration et du nommage dans le cadre des calculs
locaux cellulaires sur les arˆetes non-´etiquet´ees. On montre d’abord que dans ce mod`ele, il
n’existe pas d’algorithme d’´enum´eration ou de nommage pour un graphe G qui n’est pas
minimal pour les submersions. On donne ensuite un algorithme d’´enum´eration pour les
graphes minimaux pour les submersions qui est inspir´e de l’algorithme de Mazurkiewicz
[Maz97].

6.4.1 R´esultats d’Impossibilit´e pour l’´Enum´eration et le Nommage

Proposition 6.8 Soit G un graphe simple ´etiquet´e qui n’est pas minimal pour les sub-
mersions. Il n’existe pas d’algorithme d’´enum´eration ou de nommage pour le graphe G
utilisant des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees.

Preuve : Soit H un graphe ´etiquet´e non-isomorphe `a G et tel qu’il existe un homomor-
phisme localement surjectif γ de G dans H. ´Etant donn´e un algorithme R utilisant des
calculs locaux cellulaires sur les arˆetes non-´etiquet´ees, on consid`ere une ex´ecution de R sur
H. Si cette ex´ecution est inﬁnie sur H, alors d’apr`es le Lemme 6.7, il existe une ex´ecution
inﬁnie de R sur G ; auquel cas, R n’est ni un algorithme d’´enum´eration, ni de nommage.
On suppose maintenant qu’il existe une ex´ecution ﬁnie de R sur H et on consid`ere
la conﬁguration ﬁnale H(cid:2). D’apr`es le Lemme 6.7, il existe une ex´ecution de R sur G qui
permet d’atteindre une conﬁguration G(cid:2) telle que G(cid:2) est une submersion de H(cid:2) `a travers
γ. Si G(cid:2) n’est pas une conﬁguration ﬁnale de R, alors il existe un sommet u ∈ V (G) et
(cid:2) de u tels qu’on puisse appliquer une r`egle de r´e´etiquetage o`u u est le sommet
un voisin u
(cid:2) est le sommet passif. Dans ce cas l`a, on peut appliquer la mˆeme r`egle dans H(cid:2)
actif et u
(cid:2)), ce qui est impossible. Par cons´equent, G(cid:2) est une conﬁguration
aux sommets γ(u) et γ(u
ﬁnale de R. Mais puisque G(cid:2) n’est pas isomorphe `a H(cid:2), cela implique qu’il existe deux
sommets de G qui ont la mˆeme ´etiquette dans G(cid:2). Par cons´equent, R ne permet pas
d’attribuer de noms distincts `a tous les sommets de G et donc R n’est pas un algorithme
de nommage ou d’´enum´eration pour le graphe G.

2

146Chapitre 6. Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees

6.4.2 Un Algorithme d’´Enum´eration

On va maintenant d´ecrire un algorithme `a la Mazurkiewicz M qui utilise des calculs
locaux cellulaires sur les arˆetes non-´etiquet´ees et qui permet de r´esoudre le probl`eme de
l’´enum´eration sur un graphe G = (G, λ) qui est minimal pour les submersions.
Durant l’ex´ecution de l’algorithme, chaque sommet v essaie d’obtenir une identit´e qui
est un num´ero entre 1 et |V (G)|. Chaque sommet va observer les num´eros choisis par
ses voisins pour construire sa vue locale, i.e., l’ensemble des num´eros de ses voisins et va
ensuite diﬀuser dans tout le graphe son num´ero et sa vue locale. Si un sommet u d´ecouvre
qu’un autre sommet v a le mˆeme num´ero que lui, alors le sommet u doit d´ecider s’il modiﬁe
son identit´e. Pour cela, il compare son ´etiquette λ(u) et sa vue locale avec l’´etiquette λ(v)
et la vue locale de v : si l’´etiquette de u est plus faible que l’´etiquette de v ou si les deux
sommets ont la mˆeme ´etiquette et que la vue locale de u est plus «faible» (pour un ordre
similaire `a l’ordre utilis´e dans l’algorithme de Mazurkiewicz), alors le sommet u choisit
un nouveau num´ero (sa nouvelle identit´e temporaire) et la diﬀuse `a nouveau avec sa vue
locale. Lorsque l’ex´ecution est termin´ee, si le graphe G est minimal pour les submersions,
alors chaque sommet a un num´ero unique : l’algorithme permet de r´esoudre le probl`eme
du nommage.

Comme dans le Chapitre 5, un sommet ne peut pas faire la distinction entre ses voisins
qui ont le mˆeme num´ero. Ainsi, lorsqu’un sommet ajoute le num´ero d’un de ses voisins `a
sa vue locale, il doit aussi supprimer l’ancien num´ero de ce voisin de sa vue locale. Puisque
le sommet ne peut pas toujours distinguer ses voisins, il va supprimer des informations
qui peuvent ˆetre valides de sa vue locale aﬁn de s’assurer que l’ancien num´ero du voisin en
question a bien ´et´e supprim´e. Cette m´ethode permet de s’assurer que dans la conﬁguration
ﬁnale, la vue locale de chaque sommet ne contient que des informations pertinentes.

´Etiquettes

l’ex´ecution.

l’algorithme,

On consid`ere un graphe G = (G, λ) o`u λ: V (G) → L est un ´etiquetage initial, qui
ne sera pas modiﬁ´e par l’algorithme. Lors de l’ex´ecution, chaque sommet va obtenir une
´etiquette de la forme (λ(v), n(v), N(v), M(v)) qui repr´esente les informations suivantes :
– la premi`ere composante λ(v) est l’´etiquette initiale et ne sera pas modiﬁ´ee lors de
– n(v) ∈ N est le num´ero courant du sommet v qui est modiﬁ´e lors de l’ex´ecution de
– N(v) ∈ Pﬁn(N) est la vue locale du sommet v. Informellement, la vue locale contient
l’information la plus r´ecente que v a de ses voisins. Lors de l’ex´ecution, l’algorithme
va mettre `a jour cette vue locale pour qu’elle contienne les num´eros courants des
voisins de v. Ainsi, N(v) va toujours ˆetre un ensemble ﬁni d’entiers.
– M(v) ⊆ N × L × Pﬁn(N) est la boˆıte-aux-lettres de v. Elle va contenir toute l’infor-
mation re¸cue par v lors de l’ex´ecution de l’algorithme, i.e., les couples de num´eros
et de vues locales qui auront ´et´e diﬀus´ees par tous les sommets du graphe.
Initialement, chaque sommet a une ´etiquette de la forme (λ(v), 0,∅,∅) qui signiﬁe qu’au
d´ebut de l’algorithme, v n’a pas choisi de num´ero et qu’il n’a aucune information `a propos
de ses voisins, ni `a propos des autres sommets du graphe.

6.4. ´Enum´eration et Nommage

147

Un Ordre sur les Vues Locales

Comme pour l’algorithme de Mazurkiewicz [Maz97], les bonnes propri´et´es de notre
algorithme reposent sur un ordre sur les vues locales, i.e., sur les ensembles ﬁnis d’entiers.
L’ordre choisi doit ˆetre tel que lors de l’ex´ecution de l’algorithme, la vue locale de chaque
sommet ne puisse pas diminuer.
´Etant donn´es deux ensembles N1, N2 ∈ Pﬁn(N) distincts, on dit que N1 ≺ N2 si le
maximum de la diﬀ´erence sym´etrique N1 (cid:17) N2 = (N1 \ N2) ∪ (N2 \ N1) appartient `a N2.
Cet ordre est un ordre total et en particulier, l’ensemble vide est minimum pour l’ordre
≺.
Si N(u) ≺ N(v), alors on dit que la vue locale N(v) de v est plus forte que celle de u
et que N(u) est plus faible que N(v). En utilisant l’ordre total <L de L, on ´etend l’ordre
≺ pour obtenir un ordre total sur L×Pﬁn(N) : ((cid:8), N) ≺ ((cid:8)
(cid:2) ou bien si (cid:8) = (cid:8)
(cid:2)
et N ≺ N

, N
(cid:2). Par la suite, on notera (cid:19) la clˆoture r´eﬂexive de ≺.

(cid:2)) si (cid:8) <L (cid:8)

(cid:2)

Les R`egles de R´e´etiquetage

On d´ecrit maintenant les r`egles de r´e´etiquetages qui d´eﬁnissent l’algorithme d’´enum´e-
ration.
Pour lancer l’algorithme, il y a une r`egle sp´eciale M0 qui permet `a chaque sommet de
modiﬁer son ´etiquette initiale λ(v) pour obtenir l’´etiquette (λ(v), 0,∅,∅).
Les deux premi`eres r`egles M1 et M2 sont proches des deux r`egles de l’algorithme de
Mazurkiewicz. La premi`ere r`egle M1 permet `a un sommet v de mettre `a jour sa boˆıte-
aux-lettres en observant la boˆıte-aux-lettres de l’un de ses voisins.

M1 :
((cid:8)1, n1, N1, M1)

((cid:8)2, n2, N2, M2)

((cid:8)1, n1, N1, M

(cid:2)
1)

((cid:8)2, n2, N2, M2)

Si M2 \ M1 (cid:12)= ∅ alors M

1 := M1 ∪ M2.
(cid:2)

La deuxi`eme r`egle M2 ne d´epend que de l’´etiquette d’un seul sommet. Elle permet `a
un sommet v de modiﬁer son num´ero si son num´ero courant est 0 (il n’a pas encore choisi
de num´ero) ou si la boˆıte-aux-lettres de v contient un message indiquant qu’il existe un
autre sommet ayant le mˆeme num´ero que v et qui a une ´etiquette plus grande ou une vue
locale plus forte.
M2 :

((cid:8), n, N, M)

((cid:8), k, N, M

(cid:2))

Si
alors

n = 0 ou ∃(n, (cid:8)
(cid:2)
k := 1 + max{n
M

, N
(cid:2) | ∃(n
(cid:2)
, (cid:8)
(cid:2) := M ∪ {(k, (cid:8), N)}.

(cid:2)

(cid:2)) ∈ M tel que ((cid:8), N) ≺ ((cid:8)

(cid:2)

, N

(cid:2))

(cid:2)) ∈ M} et

, N

La troisi`eme r`egle M3 permet `a un sommet v de modiﬁer son num´ero s’il a un voisin v
(cid:2)
(cid:2)),
(cid:2)), N(v
(cid:2))). Cette r`egle ne peut ˆetre appliqu´ee que si la r`egle M2 ne peut pas ˆetre appliqu´ee

qui est exactement dans le mˆeme ´etat, i.e., (λ(v), n(v), N(v), M(v)) = (λ(v
M(v
par v ou v

(cid:2)), n(v

(cid:2).

148Chapitre 6. Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees

M3 :
((cid:8), n, N, M)

((cid:8), n, N, M)

((cid:8), k, N, M

(cid:2))

((cid:8), n, N, M)

Si

alors

(cid:2)

(cid:2)) ∈ M, ((cid:8)

n > 0 et
∀(n, (cid:8)
, N
k := 1 + max{n
M

(cid:2)) (cid:19) ((cid:8), N)
(cid:2)
, N
(cid:2) | ∃(n
(cid:2)
(cid:2)
, (cid:8)
, N
(cid:2) := M ∪ {(k, (cid:8), N)}.

(cid:2)) ∈ M} et

(cid:2) et qu’il remarque que le num´ero n(v

ses voisins v
pr´ec´edentes ne peuvent pas ˆetre appliqu´ees.

(cid:2) dans N(v) mais on doit aussi eﬀacer l’ancien num´ero de v

La quatri`eme r`egle M4 permet `a un sommet v d’ajouter le num´ero n(v

(cid:2)) d’un de
(cid:2) a sa vue locale. Cette r`egle ne peut ˆetre appliqu´ee que si les trois r`egles
(cid:2)) est ajout´e `a la vue locale N(v) de v, tous les ´el´ements m <
Lorsque le num´ero n(v
(cid:2)) sont supprim´es de N(v). La justiﬁcation de cette suppression est la suivante. Si un
n(v
(cid:2)) de
sommet v se synchronise avec un de ses voisins v
(cid:2) n’apparaˆıt pas dans sa vue locale, il doit ajouter ce num´ero `a N(v), puisque le rˆole de
v
N(v) est de stocker les num´eros des voisins de v. Mais on peut alors se retrouver dans deux
(cid:2)) `a N(v).
(cid:2), il suﬃt d’ajouter n(v
situations. Si v se synchronise pour la premi`ere fois avec v
(cid:2) auparavant et qu’entre-temps,
Mais, il se peut aussi que v se soit d´ej`a synchronis´e avec v
(cid:2) ait chang´e de num´ero. Dans ce cas l`a, on doit non seulement ajouter le num´ero courant
v
(cid:2) de N(v). Le probl`eme
de v
est que v n’a a priori aucun moyen de savoir lequel des num´eros de N(v) il doit eﬀacer et
(cid:2) auparavant
en fait, il n’est mˆeme pas capable de savoir s’il s’est d´ej`a synchronis´e avec v
ou non. Cependant, notre algorithme assure que lorsqu’un sommet change de num´ero,
(cid:2) est
son num´ero ne peut qu’augmenter. Par cons´equent, on sait que l’ancien num´ero de v
(cid:2)) et il est donc suﬃsant d’eﬀacer tous les m < n(v
(cid:2))
inf´erieur `a son num´ero actuel n(v
(cid:2) a bien ´et´e eﬀac´e. Avec cette m´ethode, on peut
pour assurer que l’ancien num´ero de v
aussi eﬀacer les num´eros courants d’autres voisins de v de la vue locale de v. Mais ce n’est
pas un probl`eme puisque v peut r´ecup´erer cette information en se resynchronisant avec
ces voisins l`a.
M4 :
((cid:8)1, n1, N1, M)

((cid:8)2, n2, N2, M)

(cid:2)
1, M

(cid:2))

Si

((cid:8)1, n1, N

((cid:8)2, n2, N2, M)
n1 > 0, n2 > 0, n1 (cid:12)= n2,
1) ∈ M, ((cid:8)
1) (cid:19) ((cid:8)1, N1),
∀(n1, (cid:8)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
1, N
1, N
2) ∈ M, ((cid:8)
2) (cid:19) ((cid:8)2, N2) et
∀(n2, (cid:8)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
2, N
2, N
n2 /∈ N1
(cid:2) ∈ N1 | n
< n2} ∪ {n2} et
1 := N1 \ {n
(cid:2)
(cid:2)
alors N
(cid:2) := M ∪ {(n1, (cid:8)1, N
1)}.
(cid:2)
M

6.4.3 Correction de l’Algorithme d’´Enum´eration

On consid`ere un graphe simple ´etiquet´e G. Pour tout sommet v ∈ V (G), on note
(λ(v), ni(v), Ni(v), Mi(v)) l’´etiquette du sommet v apr`es la i`eme ´etape de r´e´etiquetage

6.4. ´Enum´eration et Nommage

149

de l’algorithme M d´ecrit ci-dessus. On pr´esente d’abord quelques propri´et´es qui sont
satisfaites par n’importe quelle ex´ecution de l’algorithme.

Propri´et´es Satisfaites lors de l’Ex´ecution

Le lemme suivant, qui peut ˆetre facilement prouv´e par une r´ecurrence sur le nombre
d’´etapes, rappelle quelque propri´et´es simples qui sont toujours satisfaites par l’´etiquetage.
Lemme 6.9 Pour chaque sommet v et chaque ´etape i,

1. ni(v) (cid:12)= 0 =⇒ (ni(v), λ(v), Ni(v)) ∈ Mi(v),
(cid:2) ∈ Ni(v), n
2. ∀n
3. ni(v) /∈ Ni(v).
L’algorithme M a des propri´et´es de monotonicit´e int´eressantes qui sont donn´ees dans

(cid:2) ∈ Pﬁn(N), (n

(cid:2)) ∈ Mi(v),

(cid:2) (cid:12)= 0 et ∃(cid:8)

(cid:2) ∈ L,∃N

, N

, (cid:8)

(cid:2)

(cid:2)

le lemme suivant.
Lemme 6.10 Pour chaque sommet v et chaque ´etape i,

– ni(v) ≤ ni+1(v),
– Ni(v) (cid:19) Ni+1(v),
– Mi(v) ⊆ Mi+1(v).

De plus, `a chaque ´etape i, il existe un sommet v telle qu’au moins une de ces in´egalit´es
(ou inclusions) soit stricte pour v.

(cid:2)

(cid:2)

, (cid:8)

, N

(cid:2) | (n

Si Ni(v) (cid:12)= Ni+1(v), la r`egle M4 a ´et´e appliqu´ee `a v et `a un de ses voisins v

Preuve :
On note v le sommet dont l’´etiquette est modiﬁ´ee lors de la (i + 1)`eme ´etape de
r´e´etiquetage. Pour tout sommet w ∈ V (G) diﬀ´erent de v, la propri´et´e est trivialement
vraie. De plus, quelle que soit la r`egle appliqu´ee, on a toujours Mi(v) (cid:4) Mi+1(v).
Si ni(v) (cid:12)= ni+1(v), alors la r`egle M2 ou M3 a ´et´e appliqu´ee, et on a ni+1(v) =
(cid:2)) ∈ Mi(v)}. De plus, ou bien ni(v) = 0 < ni+1(v), ou alors d’apr`es
1 + max{n
le Lemme 6.9, (ni(v), λ(v), Ni(v)) ∈ Mi(v) et donc ni(v) < ni+1(v).
(cid:2). Pour
(cid:2)), n ∈ Ni(v) et puisque ni+1(v) ∈ Ni+1(v) \ Ni(v),
chaque n ∈ Ni(v) tel que n > ni+1(v
(cid:2)) ∈ Ni+1(v). Par cons´equent Ni(v) ≺ Ni+1(v). 2
on a max(Ni(v) (cid:17) Ni+1(v)) = ni+1(v
Les informations dont dispose chaque sommet dans sa boˆıte-aux-lettres reﬂ`etent des
propri´et´es v´eriﬁ´ees par la conﬁguration globale du graphe. Les deux lemmes suivants per-
mettent de prouver que si un sommet v connaˆıt un num´ero m `a une ´etape i (i.e., il existe
(cid:8), N tels que (m, (cid:8), N) ∈ Mi(v)), alors pour chaque m
(cid:2) tel que
(cid:2). On montre d’abord que si v connaˆıt un num´ero m, alors il existe un sommet
ni(v
(cid:2) tel que ni(v) = m
v
Lemme 6.11 Pour chaque sommet v ∈ V (G) et chaque ´etape i, pour tout (m, (cid:8), N) ∈
Mi(v), il existe un sommet w ∈ V (G) tel que ni(w) = m.
Preuve : On remarque d’abord qu’un triplet (m, (cid:8), N) est ajout´e `a une ´etape i dans
(cid:4)
Mi(v) seulement s’il existe un sommet v tel que ni(v) = m, λ(v) = (cid:8) et Ni(v) = N.
´Etant donn´e un sommet v, une ´etape i et un triplet (m, (cid:8), N) ∈ Mi(v), on note U =
(cid:2) = {(u, j) ∈ U |

v∈V (G)
{(u, j) ∈ V (G)× N | j ≤ i, nj(u) = m}. On consid`ere ensuite l’ensemble U

(cid:2) ≤ m, il existe un sommet v

(cid:2)) = m

(cid:2).

150Chapitre 6. Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees

, j

(cid:2)), Nj(cid:2)(u

(cid:2)) ∈ U, (λ(u

(cid:2))) = (λ(u), Nj(u)) et j

(cid:2))) ≺ (λ(u), Nj(u)) ou (λ(u

Si i0 < i, il existe exactement un ´el´ement (u, i0) ∈ U

∀(u
(cid:2)
j}. Puisque (m, (cid:8), N) ∈ Mi(v), U et U
ais´ement qu’il existe i0 tel que pour tout (u, j) ∈ U

(cid:2) ≤
(cid:2) sont deux ensembles non-vides. On remarque
(cid:2) puisqu’`a chaque ´etape, le num´ero
d’au plus un sommet peut ˆetre modiﬁ´e. Le num´ero ni0(u) = m a donc ´et´e modiﬁ´e `a l’´etape
i0 + 1, mais puisque `a cette ´etape, le sommet u n’avait aucun voisin avec le mˆeme num´ero
m, la r`egle M3 n’a pu ˆetre appliqu´ee, et par maximalit´e de (λ(u), Ni0(u)), la r`egle M2
n’a pas non plus pu ˆetre appliqu´ee `a u `a l’´etape i0. Par cons´equent, i0 = i et il existe donc
un sommet w tel que ni(w) = m.
2

(cid:2)), Nj(cid:2)(u
(cid:2), j = i0.

Dans le lemme suivant, on montre que si un sommet v connaˆıt un num´ero m, alors il

connaˆıt tous les num´eros inf´erieurs `a m.
Lemme 6.12 Pour chaque sommet v et chaque ´etape i, pour tout (m, (cid:8), N) ∈ Mi(v), pour
tout m

(cid:2) ∈ [1, m], il existe (m

(cid:2)) ∈ Mi(v).

, N

(cid:2)

(cid:2)

, (cid:8)

Si la r`egle M1 est appliqu´ee `a l’´etape i+1 `a v et `a un de ses voisins v

Preuve : On montre ce lemme par r´ecurrence sur i. Initialement, la propri´et´e est trivia-
lement vraie. On suppose que la propri´et´e est v´eriﬁ´ee pour i ≥ 0. Soit v le sommet dont
l’´etiquette est modiﬁ´ee `a l’´etape i + 1. La propri´et´e est trivialement vraie `a l’´etape i + 1
pour tout sommet w ∈ V (G) distinct de v.
(cid:2), alors Mi+1(v) =
Mi(v) ∪ Mi(v
(cid:2)) et la propri´et´e est v´eriﬁ´ee `a l’´etape i + 1 puisqu’elle ´etait vraie pour v et
(cid:2) `a l’´etape i.
v
Si la r`egle M2 ou M3 est appliqu´ee `a v `a l’´etape i + 1, alors Mi+1(v) = Mi(v) ∪
{(ni+1(v) = 1+max{m | (m, (cid:8), N) ∈ Mi(v)}, λ(v), Ni(v))}, et par cons´equent pour chaque
m ∈ Mi+1(v), la propri´et´e reste vraie.
Si la r`egle M4 est appliqu´ee `a v `a l’´etape i + 1, pour tout (m, (cid:8), N) ∈ Mi+1(v), il existe

(m, (cid:8), N

(cid:2)) ∈ Mi(v) et la propri´et´e reste donc vraie.

2

De plus, pour chaque sommet v et chaque ´etape i, si Ni(v) contient un num´ero n

des sommets forment un ensemble [1, k] ou un ensemble [0, k] avec k ≤ |V (G)|.

D’apr`es les Lemmes 6.11 et 6.12, on voit qu’`a chaque ´etape de l’ex´ecution, les num´eros
(cid:2), alors
(cid:2). Par cons´equent
d’apr`es les Lemmes 6.9 et 6.11, il existe v
N(v) ne peut prendre qu’un nombre ﬁni de valeurs et il en est de mˆeme pour M(v). Ainsi
le nombre de valeurs diﬀ´erentes que peut prendre l’´etiquette de chaque sommet est ﬁni
(mais d´epend de la taille du graphe). Par ailleurs, on sait que les ´etiquettes cons´ecutives
de chaque sommet v forment une suite croissante et puisqu’on sait qu’`a chaque ´etape i,
l’´etiquette d’au moins un sommet est modiﬁ´ee, on sait que toute ex´ecution de l’algorithme
termine : la relation M est noeth´erienne.

(cid:2) ∈ V (G) tel que ni(v

(cid:2)) = n

(cid:2) tel que n(v

Dans le lemme suivant, on montre que si un num´ero n apparaˆıt dans la vue locale d’un
(cid:2)) = n, ou bien la r`egle M4 peut ˆetre

sommet v, alors ou bien v a un voisin v
appliqu´ee au sommet v et `a un de ses voisins v
Lemme 6.13 Pour chaque sommet v ∈ V (G) et chaque ´etape i, pour tout n0 ∈ Ni(v), il
existe v
Preuve : Soit i0 la derni`ere ´etape o`u n0 a ´et´e ajout´e `a N(v) : ∀j ≥ i0, n0 ∈ Nj(v) et
n0 /∈ Ni0−1(v). Cela signiﬁe qu’`a l’´etape i0, la r`egle M4 a ´et´e appliqu´ee `a v et v
(cid:2) avec

(cid:2) ∈ NG(v) tel que, ou bien ni(v

(cid:2)) = n0, ou bien ni(v

(cid:2)) > max Ni(v).

(cid:2).

6.4. ´Enum´eration et Nommage

151

(cid:2)). Si ni(v

(cid:2)) = ni0(v

(cid:2)) = n0. D’apr`es le Lemme 6.9, il existe (n0, (cid:8), N) ∈ Mi0(v
(cid:2)) = n0,
ni0(v
alors la propri´et´e est v´eriﬁ´ee.
Dans le cas contraire, pour chaque ´etape j ∈ [i0, i], on note m(j) = max Nj(v). On sait
que mi0(v) ≥ n0 et qu’il existe (mi0(v), (cid:8), N) ∈ Mi0(v
(cid:2)). Si un num´ero n1 est ajout´e `a N(v)
lors d’une ´etape i1 ∈ [i0, i], alors la r`egle M4 a ´et´e appliqu´ee `a v et `a un de ses voisins lors
de l’´etape i1. De plus n1 ≤ n0, puisque n0 ∈ Ni1(v) et par cons´equent, mi0(v) = mi(v).
(cid:2) lors d’une
´etape i2 ∈ [i0, i]. Par ailleurs, on sait qu’il existe (mi0(v), (cid:8), N) ∈ Mi0(v
(cid:2)) ⊆ Mi2(v
(cid:2)) et
(cid:2)) > mi0(v) = mi(v) = max Ni(v). La propri´et´e est donc
par cons´equent, ni(v
v´eriﬁ´ee.

(cid:2)), une des r`egles M2 ou M3 a ´et´e appliqu´ee `a v

(cid:2)) (cid:12)= ni0(v

(cid:2)) ≥ ni2(v

Puisque ni(v

2

Propri´et´es Satisfaites par l’´Etiquetage Final

Puisqu’on sait que l’algorithme termine toujours, on s’int´eresse maintenant aux pro-
pri´et´es satisfaites par l’´etiquetage ﬁnal.
Lemme 6.14 Toute ex´ecution ρ de l’algorithme M sur un graphe simple ´etiquet´e G =
(G, λ) termine et l’´etiquetage ﬁnal (λ, nρ, Nρ, Mρ) v´eriﬁe les propri´et´es suivantes :

1. il existe un entier k ≤ |V (G)| tel que {nρ(v) | v ∈ V (G)} = [1, k],

et pour tous sommets v, v

(cid:2) :

(cid:2)),

2. Mρ(v) = Mρ(v
3. (nρ(v), λ(v), Nρ(v)) ∈ Mρ(v
4. si nρ(v) = nρ(v
5. n ∈ Nρ(v) si et seulement s’il existe w ∈ NG(v) tel que nρ(w) = n ; auquel cas,
nρ(v) ∈ Nρ(w).

(cid:2)), alors λ(v) = λ(v

(cid:2)) et Nρ(v) = Nρ(v

(cid:2)),

(cid:2)),

Preuve :

1. D’apr`es les Lemmes 6.11 et 6.12 et puisque la r`egle M2 ne peut pas ˆetre appliqu´ee.
2. Dans le cas contraire, la r`egle M1 peut ˆetre appliqu´ee.
3. C’est une cons´equence directe de la propri´et´e pr´ec´edente d’apr`es le Lemme 6.9.
4. Dans le cas contraire, la r`egle M2 peut ˆetre appliqu´ee `a v ou `a v
5. D’apr`es le Lemme 6.13 et puisque les r`egles M3 et M4 ne peuvent plus ˆetre ap-

(cid:2).

pliqu´ees.

Grˆace au Lemme 6.14, on peut prouver que l’´etiquetage ﬁnal permet de construire un

graphe H tel que G est une submersion de H.
Proposition 6.15 ´Etant donn´e un graphe simple G, on peut construire, `a partir de
l’´etiquetage ﬁnal obtenu apr`es une ex´ecution ρ de M, un graphe simple H tel qu’il existe
un homomorphisme localement surjectif de G dans H.

2

Preuve : On utilise les notations du Lemme 6.14.
(cid:2) ∈ V (G); nρ(v) = m, nρ(v
E(H) = {{m, m

On consid`ere le graphe H d´eﬁni par V (H) = {m ∈ N | ∃v ∈ V (G), nρ(v) = m} et
(cid:2)} ∈ E(G)}. On d´eﬁnit

(cid:2)} | ∃v, v

(cid:2) et {v, v

(cid:2)) = m

152Chapitre 6. Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees

(cid:2)) = m

(cid:2), m

(cid:2) ∈ Nρ(v) et m ∈ Nρ(v

(cid:2)} ∈ E(H) si et seulement s’il existe v, v

(cid:2) ∈ V (G) ont le mˆeme num´ero, alors λ(v) = λ(v
D’apr`es le Lemme 6.14, {m, m

un ´etiquetage η de H en posant η(nρ(v)) = λ(v) ; d’apr`es le Lemme 6.14, si deux sommets
(cid:2)) et par cons´equent, cet ´etiquetage est
v, v
bien d´eﬁni.
(cid:2) ∈ V (G) tels
(cid:2)). D’apr`es le Lemme 6.9, on sait
que nρ(v) = m, nρ(v
qu’il n’existe aucun {n, n} ∈ E(H) : le graphe H ne contient pas de boucle. De plus, par
d´eﬁnition, E(H) ne contient pas d’arˆetes multiples.
On consid`ere maintenant la fonction nρ : V (G) → V (H). Par d´eﬁnition de H, on
sait que si {v, v
(cid:2))} ∈ E(G). De plus, pour tout v ∈ V (G),
η(nρ(v)) = λ(v) et par cons´equent, nρ est un homomorphisme de G dans H. D’apr`es le
Lemme 6.14, m ∈ NH(nρ(v)) si et seulement s’il existe w ∈ NG(v) tel que nρ(w) = m et
par cons´equent nρ est un homomorphisme localement surjectif de G dans H.

(cid:2)} ∈ E(G), alors {nρ(v), nρ(v

2

On consid`ere maintenant un graphe G qui est minimal pour les submersions. Pour
chaque ex´ecution ρ de M sur G, le graphe obtenu `a partir de l’´etiquetage ﬁnal est
isomorphe `a G. Par cons´equent, l’ensemble des num´eros des sommets est exactement
[1,|V (G)|] : chaque sommet a un identiﬁant unique. L’algorithme M permet de r´esoudre
le nommage sur la famille des graphes minimaux pour les submersions, mais si aucune
information `a propos de G n’est disponible, les sommmets ne peuvent pas d´etecter la
terminaison.
Cependant, la d´etection de la terminaison est possible pour un graphe G donn´e. En
eﬀet, une fois qu’un sommet a obtenu le num´ero |V (G)|, d’apr`es les Lemmes 6.11 et 6.12,
il sait que tous les sommets de G ont un num´ero unique qui ne va plus ˆetre modiﬁ´e : il
peut donc d´etecter que le nommage est eﬀectu´e.

Par ailleurs, d’apr`es la Proposition 6.8, on sait que pour tout graphe G qui n’est pas
minimal pour les submersions, il n’existe aucun algorithme utilisant des calculs locaux cel-
lulaires sur les arˆetes non-´etiquet´ees qui permettent de r´esoudre les probl`emes du nommage
ou de l’´enum´eration sur G. On a donc prouv´e le th´eor`eme suivant.
Th´eor`eme 6.16 Pour tout graphe simple ´etiquet´e G, les assertions suivantes sont ´equi-
valentes :

1. il existe un algorithme de nommage (ou d’´enum´eration) pour G utilisant des calculs

locaux cellulaires sur les arˆetes non-´etiquet´ees,

2. il existe un algorithme de nommage (ou d’´enum´eration) avec d´etection de la termi-
naison pour G utilisant des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees,

3. G est minimal pour les submersions.

Remarque 6.17 ´Etant donn´e un graphe G minimal pour les submersions, pour d´etecter
que l’algorithme M a attribu´e un identiﬁant unique `a chaque sommet, il suﬃt de connaˆıtre
le nombre de sommets de G. Ainsi, l’algorithme M permet de r´esoudre l’´enum´eration et le
nommage avec d´etection de la terminaison sur les graphes minimaux pour les submersions
de taille donn´ee.

6.4.4 Complexit´e

On s’int´eresse `a la complexit´e de l’algorithme M pr´esent´e ci-dessus. Dans le cadre
des calculs locaux, on s’int´eresse au nombre de pas de r´e´etiquetages eﬀectu´ees lors d’une

6.4. ´Enum´eration et Nommage

153

ex´ecution. La proposition suivante donne une borne sup´erieure sur le nombre de pas de
r´e´etiquetages de toute ex´ecution de l’algorithme M sur un graphe `a n sommets de degr´e
maximal Δ.
Proposition 6.18 Pour tout graphe G `a n sommets de degr´e maximal Δ, durant toute
ex´ecution de l’algorithme M utilisant des calculs locaux sur les arˆetes ´etiquet´ees, O(n32Δ)
r`egles sont appliqu´ees.
Preuve : On consid`ere un graphe G `a n sommets et une ex´ecution ρ de M sur G.
D’apr`es les Lemmes 6.11 et 6.12, on sait que les r`egles M2 et M3 ne peuvent pas ˆetre
appliqu´ees plus de n(n−1)
Entre deux ´etapes o`u une des r`egles M2,M3 est appliqu´ee, la r`egle M4 est appliqu´ee
au plus 2Δ fois, puisqu’il existe 2Δ sous-ensembles de n(NG(v)). La r`egle M4 est donc
appliqu´ee O(n22Δ) fois durant l’ex´ecution ρ.
est ajout´e M(v). Pour chacun de ces couples, la r`egle M1 est appliqu´ee au plus n fois.

`A chaque fois qu’un sommet v modiﬁe son num´ero ou sa vue locale, un couple (n0, (cid:8), N)
Ainsi, durant toute ex´ecution ρ de M sur G, O(n32Δ) r`egles sont appliqu´ees.

fois durant l’ex´ecution ρ.

2

2

Remarque 6.19 Si on consid`ere les graphes de degr´e maximum Δ born´e, l’algorithme
M pr´esent´e dans ce Chapitre s’ex´ecute O(n3) ´etapes de r´e´etiquetage sur un graphe G de
taille n, ce qui est comparable au nombre d’´etapes n´ecessaires `a l’ex´ecution de l’algorithme
de Mazurkiewicz sur G. Malgr´e un pouvoir de synchronisation beaucoup plus faible, l’al-
gorithme M utilisant des calculs locaux cellulaires sur les arˆetes permet de nommer sur
les graphes minimaux pour les submersions de degr´e born´e aussi «rapidement» que l’algo-
rithme de Mazurkiewicz.

Comme dans le Chapitre 5, certaines ex´ecutions de l’adaptation de l’algorithme de Ma-
zurkiewicz qu’on a pr´esent´e dans ce chapitre n´ecessitent un nombre de pas de r´e´etiquetages
qui peut ˆetre exponentiel. Cela est du au fait que lorsqu’un sommet met `a jour sa vue
locale, il supprime les informations obsol`etes, mais il supprime aussi des informations qui
peuvent ˆetre valides.

On s’int´eresse `a la m´emoire n´ecessaire `a chaque sommet pour stocker son ´etiquette. On
suppose que l’´etiquetage initial λ du graphe G est tel que chaque ´etiquette initiale (cid:8) a une
taille en O(log |V (G)|) bits (ce qui est suﬃsant pour attribuer des ´etiquettes diﬀ´erentes `a
tous les sommets de G).
Proposition 6.20 Pour tout graphe G `a n sommets de degr´e maximal Δ, l’algorithme M
utilisant des calculs locaux sur les arˆetes ´etiquet´ees n´ecessite O(Δn log n) bits de m´emoire
par sommet.

Preuve : On consid`ere un graphe G `a n sommets et m arˆetes dont le degr´e maximal
est Δ. 0n sait que la vue locale de chaque sommet contient au plus Δ entiers n0 qui
peuvent ˆetre repr´esent´es avec O(log n) bits. Ainsi, pour chaque sommet v, N(v) peut ˆetre
repr´esent´e avec O(Δ log n) bits.
Chaque sommet peut ne conserver dans sa boˆıte-aux-lettres que l’information utile,
(cid:2)) (cid:19) ((cid:8), N)}. Ainsi, dans
i.e., l’ensemble {(n0, (cid:8), N) ∈ M(v) | ∀(n0, (cid:8)
la boˆıte-aux-lettres de chaque sommet, il existe au plus n triplets (n0, (cid:8), N) dont la taille
est en O(Δ log n) bits. Par cons´equent, on peut repr´esenter la boˆıte-aux-lettres de chaque
sommet avec O(Δn log n) bits.
2

(cid:2)) ∈ M(v), ((cid:8)

, N

, N

(cid:2)

(cid:2)

154Chapitre 6. Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees

3

G

2

1

γ

4

4

2

1

3

4

H

Fig. 24 – Le graphe G est une submersion de H `a travers l’homomorphisme γ qui envoie
chaque sommet de G ´etiquet´e i sur l’unique sommet de H ´etiquet´e i. Il n’existe pas
d’algorithme d’´enum´eration pour G, mais il existe un algorithme d’´election pour G.

6.5

´Election

On remarque que s’il existe un algorithme d’´enum´eration avec d´etection de la termi-
naison pour un graphe G, alors on peut facilement obtenir un algorithme d’´election pour
G. En eﬀet, une fois qu’un sommet a d´etect´e que tous les sommets ont un identiﬁant
unique, il prend l’´etiquette ´elu si son num´ero est ´egal `a 1.

Cependant, dans le mod`ele des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees,
les probl`emes d’´enum´eration et d’´election ne sont pas ´equivalents. En eﬀet, le graphe G de
la Figure 24 n’est pas minimal pour les submersions puisque c’est une submersion de H.
Par cons´equent, il n’y a pas d’algorithme de nommage ou d’´enum´eration pour G utilisant
des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees. Mais si on consid`ere n’importe
quelle ex´ecution de l’algorithme M sur G, on atteint une conﬁguration ﬁnale, o`u seul le
sommet ´etiquet´e 3 sur la Figure 24 a au moins trois num´eros diﬀ´erents dans sa vue locale
et il est donc le seul sommet qui sait qu’il a au moins trois voisins : il peut donc se d´eclarer
´elu et diﬀuser l’information aux autres sommets.

6.5.1 Conditions N´ecessaires pour l’´Election

On pr´esente ici des conditions que doivent satisfaire les graphes pour lesquels il existe
un algorithme d’´election. ´Etant donn´e un graphe G, on note SG l’ensemble des graphes
H tels que G soit une submersion de H. D’apr`es le Lemme 6.7, si un algorithme utilisant
des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees permet d’´elire dans le graphe
G, alors ce mˆeme algorithme permet aussi d’´elire dans n’importe quel graphe H ∈ SG.
Remarque 6.21 On consid`ere un algorithme utilisant des calculs locaux cellulaires sur les
arˆetes non-´etiquet´ees R qui permet d’´elire dans G. Supposons qu’il existe un sous-graphe
G(cid:2) de G tel que G(cid:2) soit une submersion d’un graphe H ∈ SG `a travers un homomorphisme
−1(v)| >
γ. S’il existe une ex´ecution de R sur H qui ´elit un sommet v ∈ V (H) tel que |γ
1, alors d’apr`es le Lemme 6.7, il existe une ex´ecution de R sur G(cid:2) tel que l’´etiquette
´elu apparaissent au moins deux fois. Puisque chaque ex´ecution de R sur G(cid:2) peut ˆetre
´etendue pour obtenir une ex´ecution de R sur G, il existe une ex´ecution de R sur G tel
que l’´etiquette ´elu apparaisse au moins deux fois et dans ce cas, R n’est pas un algorithme
d’´election pour G.

´Etant donn´e un graphe H ∈ SG et un sous-graphe G(cid:2) de G qui est une submersion de
−1(v)| > 1} et

H `a travers un homomorphisme γ, on d´eﬁnit PH(G(cid:2)

, γ) = {v ∈ V (H) | |γ

6.5. ´Election

155

, γ). On d´eﬁnit alors PH(G) comme l’union de tous les PH(G(cid:2)

on sait, d’apr`es la Remarque 6.21 que chaque ex´ecution de R sur H ne peut pas ´elire un
sommet v ∈ PH(G(cid:2)
, γ) pour
tous les sous-graphes G(cid:2) de G et pour tous les homomorphismes localement surjectifs γ
de G(cid:2) dans H. On d´eﬁnit aussi l’ensemble CH(G) = V (H) \ PH(G) et les ´el´ements de cet
ensemble sont appel´es les candidats de H pour G.
D’apr`es la Remarque 6.21, un algorithme d’´election pour le graphe G doit permettre
d’´elire un sommet de CH(G) dans n’importe quel graphe H ∈ SG. Par cons´equent, s’il
existe un algorithme d’´election pour le graphe G, alors pour tout graphe H ∈ SG, l’en-
semble CH(G) des candidats de H pour G est non-vide.

Par ailleurs, s’il existe deux sous-graphes disjoint (qui n’ont aucun sommet en commun)
G1 et G2 de G qui sont respectivement des submersions de deux graphes H1 et H2
appartenant `a SG, alors il n’existe pas d’algorithme d’´election pour le graphe G. En eﬀet,
s’il existe un algorithme R d’´election pour G, cet algorithme permet d’´elire dans H1 et
dans H2. Par cons´equent, d’apr`es le Lemme 6.7, il existe une ex´ecution de R sur G tel
que l’´etiquette ´elu apparaisse une fois dans G1 et une fois dans G2 : R n’est pas un
algorithme d’´election pour G.

La proposition suivante r´esume les conditions n´ecessaires que doit satisfaire tout graphe
G pour lequel il existe un algorithme d’´election utilisant des calculs locaux cellulaires sur
les arˆetes non-´etiquet´ees.
Proposition 6.22 Pour tout graphe G pour lequel il existe un algorithme d’´election uti-
lisant des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees, les conditions suivantes
sont satisfaites.

1. pour tout H ∈ SG, CH(G) (cid:12)= ∅,
2. il n’existe pas deux sous-graphes disjoints G1, G2 de G qui sont respectivement des

submersions de deux graphes H1, H2 ∈ SG.

6.5.2 Un Algorithme d’´Election

On consid`ere dans cette partie un graphe G qui v´eriﬁe les conditions ´enonc´ees dans la
Proposition 6.22. On veut d´ecrire par des r`egles de r´e´etiquetage un algorithme tel que lors
de toute ex´ecution sur G, on d´etecte un graphe H ∈ SG tel qu’il existe un sous-graphe
G(cid:2) qui est une submersion de H. Pour ce faire, on r´eutilise l’algorithme d’´enum´eration
pr´esent´ee dans la partie pr´ec´edente aﬁn de reconstruire le graphe H et on utilise une adap-
tation de l’algorithme de d´etection de la terminaison de Szymansky, Shi et Prywes [SSP85]
(SSP) aﬁn de s’assurer qu’un tel sous-graphe G(cid:2) existe.
Le principe est le suivant : `a partir des boˆıtes-aux-lettres des sommets obtenues par
l’algorithme d’´enum´eration, on reconstruit un graphe H et ensuite, les sommets de G(cid:2)
vont v´eriﬁer qu’ils sont tous d’accord sur ce graphe.

On va utiliser une adaptation de l’algorithme SSP en utilisant les id´ees de l’algorithme

GSSP introduite dans [MT00, GM03] et pr´esent´e dans le Chapitre 2.

Dans le mod`ele consid´er´e ici, la principale diﬃcult´e est qu’un sommet ne peut pas
distinguer ses voisins et on ne peut donc pas assurer qu’un sommet observe les valeurs des
niveaux de conﬁance de tous ses voisins avant de modiﬁer son propre niveau de conﬁance
a(v). Aﬁn de r´ecolter le plus d’informations possibles, un sommet va utiliser les num´eros
qui apparaissent dans sa vue locale aﬁn d’obtenir le plus d’information possible `a propos de

156Chapitre 6. Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees

ses voisins. Ainsi, un sommet ne pourra augmenter son niveau de conﬁance a(v) seulement
(cid:2)) = n
si pour chaque num´ero n apparaissant dans sa vue locale, il a un voisin v
et a(v

(cid:2) tel que n(v

(cid:2)) ≥ a(v).

Contrairement `a l’adaptation de l’algorithme GSSP pr´esent´e dans le Chapitre 5, chaque
sommet ne connaˆıt pas son degr´e et n’est pas assur´e que tous ses voisins vont avoir des
num´eros distincts `a partir d’un certain moment. Par cons´equent, les sommets doivent
pouvoir commencer l’algorithme GSSP `a presque tout moment de l’ex´ecution et ils ne
peuvent pas attendre d’avoir un certain type d’informations `a propos de leurs voisinages
comme dans les Chapitres 3 et 5.
Le principe de l’algorithme est de d´etecter un sous-graphe G(cid:2) de G qui est une submer-
sion d’un graphe H(cid:2) ∈ SG. Ce sous-graphe peut ˆetre G lui-mˆeme, mais les sommets n’ont
pas moyen de savoir si c’est le cas ou pas. Une fois qu’un tel sous graphe G(cid:2) a ´et´e d´etect´e,
les sommets doivent ´elire un sommet de G(cid:2), puisque dans le cas o`u G(cid:2) (cid:9) G, les sommets
ne peuvent pas obtenir plus d’information sur G. Cependant, une fois qu’un sommet de
G(cid:2) a ´et´e ´elu, il ne faut pas qu’un autre sous-graphe G(cid:2)(cid:2) de G qui est une submersion
d’un graphe H(cid:2)(cid:2) ∈ SG. Puisqu’on suppose que le graphe G satisfait les conditions de la
Proposition 6.22, cela signiﬁe qu’avant d’´elire un sommet de G(cid:2), il faut s’assurer que les
sommets de G(cid:2) ne vont pas ensuite participer `a la d´etection d’un autre sous-graphe G(cid:2)(cid:2)
de G qui est une submersion d’un graphe H(cid:2)(cid:2) ∈ SG.
Ainsi, contrairement aux adaptations de l’algorithme GSSP pr´esent´e dans les Cha-
pitres 3 et 5, un sommet ne peut pas toujours r´einitialiser son rayon de conﬁance `a −1 s’il
a un voisin avec une boˆıte-aux-lettres diﬀ´erente de la sienne. De cette mani`ere, on assure
que si lors d’une ´etape un sommet de G(cid:2) prend l’´etiquette ´elu, les autres sommets de G(cid:2)
ne modiﬁeront plus leurs boˆıtes-aux-lettres apr`es cette ´etape et qu’ils ne pourront alors
modiﬁer leur ´etiquette que pour prendre l’´etiquette non-´elu. Les restrictions qu’on pose
pour qu’un sommet puisse modiﬁer son rayon de conﬁance nous assurent qu’au plus un
sommet de G prendra l’´etiquette ´elu si G satisfait les conditions de la Proposition 6.22,
mais il faut prouver que ces restrictions ne m`enent pas `a des situations d’inter-blocage lors
de l’ex´ecution de l’algorithme.

´Etiquettes

Comme dans la partie pr´ec´edente, on consid`ere un graphe G = (G, λ) o`u λ est un
´etiquetage initial qui ne sera pas modiﬁ´e par l’algorithme. Lors de l’ex´ecution, chaque
sommet v va avoir une ´etiquette (λ(v), n(v), N(v), M(v), a(v), H(v)) qui repr´esente les
informations suivantes.

l’ex´ecution.

– la premi`ere composante λ(v) est l’´etiquette initiale et ne sera pas modiﬁ´ee lors de
– n(v) ∈ N est le num´ero du sommet v qui est modiﬁ´e lors de l’ex´ecution de l’algo-
– a(v) ∈ N est le niveau de conﬁance du sommet v,
– N(v) ∈ Pﬁn(N2) est la vue locale du sommet v. Si un sommet v a un voisin v

(cid:2), les
(cid:2))) `a N(v).
r`egles de r´e´etiquetage vont permettre `a v d’ajouter le couple (n(v
Ainsi, N(v) est toujours un ensemble ﬁni de paires d’entiers. Pour tout N ∈ Pﬁn(N2),
on note Π1(N) = {n | ∃(n, a) ∈ N} la projection sur la premi`ere composante de N.
– M(v) ⊆ N × L × Pﬁn(N) est la boˆıte-aux-lettres du sommet v. Elle va contenir

rithme,

(cid:2)), a(v

6.5. ´Election

157

toute l’information re¸cue par v lors de l’ex´ecution de l’algorithme, i.e., les paires de
num´eros et de vues locales qui auront ´et´e diﬀus´ees par tous les sommets du graphe.
– H(v) est l’historique du sommet v. Si `a un moment donn´e (n, N, M, a) ∈ H(v), cela
signiﬁe qu’auparavant le sommet v avait un niveau de conﬁance a pour la valeur M
et qu’`a ce moment l`a, il avait le num´ero n et la vue locale N.

Les R`egles de R´e´etiquetage

La premi`ere r`egle de r´e´etiquetage E0 remplace juste l’´etiquette initiale λ(v) par (λ(v), 0,

∅,∅,−1,∅).

Les quatre r`egles de r´e´etiquetage suivantes correspondent aux quatre r`egles de l’algo-

rithme d’´enum´eration.

E1 :
((cid:8)1, n1, N1, M1,−1, H1)

((cid:8)2, n2, N2, M2, a, H2)

((cid:8)1, n1, N1, M

1,−1, H1)
(cid:2)

((cid:8)2, n2, N2, M2, a, H2)

Si M2 \ M1 (cid:12)= ∅ alors M
E2 :

1 := M1 ∪ M2.
(cid:2)

((cid:8), n, N, M,−1, H)
((cid:8), k, N, M
(cid:2)) ∈ M tel que ((cid:8), Π1(N)) ≺ ((cid:8)

(cid:2)

(cid:2)) ∈ M} et

(cid:2)

,−1, H)

(cid:2))

, K

Si
alors

n = 0 ou ∃(n, (cid:8)
(cid:2)
k := 1 + max{n
M

, K
(cid:2) := M ∪ {(k, (cid:8), Π1(N))}.

, K
(cid:2) | ∃(n

, (cid:8)

(cid:2)

(cid:2)

E3 :

((cid:8), n, N1, M,−1, H1)

((cid:8), n, N2, M, a, H2)

((cid:8), k, N1, M

(cid:2)

,−1, H1)

((cid:8), n, N2, M, a, H2)

Si

alors

(cid:2)

n > 0,
Π1(N1) = Π1(N2) et
(cid:2)) ∈ M, ((cid:8)
(cid:2)) (cid:19) ((cid:8), Π1(N1))
∀(n, (cid:8)
(cid:2)
, K
(cid:2) | ∃(n
(cid:2)) ∈ M} et
k := 1 + max{n
(cid:2)
(cid:2)
, (cid:8)
, K
(cid:2) := M ∪ {(k, (cid:8), Π1(N
1))}.
(cid:2)
M

, K

E4 :
((cid:8)1, n1, N1, M,−1, H1)

((cid:8)2, n2, N2, M, a, H2)

((cid:8)1, n1, N

(cid:2)
1, M

(cid:2)

,−1, H1)

((cid:8)2, n2, N2, M, a, H2)

Si

(cid:2)
1, K
(cid:2)
2, K

n1 > 0, n2 > 0, n1 (cid:12)= n2,
∀(n1, (cid:8)
(cid:2)
1, K
∀(n2, (cid:8)
(cid:2)
2, K
(n2,−1) /∈ N1
1 := N1 \ {(n
(cid:2)
alors N
(cid:2) := M ∪ {(n1, (cid:8)1, N
M

1) ∈ M, ((cid:8)
(cid:2)
2) ∈ M, ((cid:8)
(cid:2)

(cid:2)

1)}.
(cid:2)

1) (cid:19) ((cid:8)1, Π1(N1)),
(cid:2)
2) (cid:19) ((cid:8)2, Π1(N2)) et
(cid:2)

(cid:2)) ∈ N1 | n
, a

(cid:2)

< n2} ∪ {(n2,−1)} et

158Chapitre 6. Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees

La cinqui`eme r`egle permet `a un sommet v d’incr´ementer son niveau de conﬁance s’il

d´etecte que tous les voisins qu’il connaˆıt ont un niveau de conﬁance a ≥ a(v).

(cid:2)

(cid:2)) ∈ πn(M), (n, (cid:8), N) (cid:19) (n, (cid:8)

On explique d’abord comment construire un graphe H `a partir du contenu de la boˆıte-
aux-lettres d’un sommet. `A partir d’une boˆıte-aux-lettres M, pour chaque n > 0, on d´eﬁnit
πn(M) comme l’ensemble des triplets (n, (cid:8), N) ∈ M dont la premi`ere composante est n
(cid:2))} ; Ainsi,
et on pose u(M) = {(n, (cid:8), N) ∈ M | ∀(n, (cid:8)
u(M) contient le triplet (n, (cid:8), N) de πn(M) pour lequel le couple ((cid:8), N) est maximum pour
l’ordre (cid:19).
Ensuite, on d´eﬁnit le graphe HM = (HM , ηM ) de la mani`ere suivante. S’il existe
(n1, (cid:8)1, N1), (n2, (cid:8)2, N2) ∈ u(M) tels que n2 ∈ N1 et n1 /∈ N2, alors le graphe HM
n’est pas d´eﬁni. Sinon, le graphe HM est le graphe dont l’ensemble de sommets est
V (HM ) = {n | (n, (cid:8), N) ∈ u(M)} et l’ensemble d’arˆetes est E(HM ) = {{n1, n2} |
∃(n1, (cid:8)1, N1), (n2, (cid:8)2, N2) ∈ u(M), n2 ∈ N1 et n1 ∈ N2}. L’´etiquetage ηM de HM est aussi
obtenu `a partir de u(M) : pour tout (n, (cid:8), N) ∈ u(M), on pose ηM (n) = (cid:8).

, N

, N

(cid:2)

E5 :

((cid:8), n, N, M, a, H)

((cid:8), n, N, M, a + 1, H)

Cette r`egle est applicable si n > 0,
(cid:2)) ∈ M, ((cid:8)
∀(n, (cid:8)
(cid:2)
, K
HM ∈ SG,
(cid:2)) ∈ N, a ≤ a
∀(n
(cid:2)
, a
a ≤ |V (G)| + 1.

(cid:2)

, K
(cid:2) et

(cid:2)) (cid:19) ((cid:8), Π1(N)),

La sixi`eme r`egle permet `a un sommet v de mettre `a jour les informations dont il dispose
`a propos du niveau de conﬁance de l’un de ses voisins si ce niveau de conﬁance a augment´e.

E6 :
((cid:8)1, n1, N1, M, a1, H1)

((cid:8)2, n2, N2, M, a2, H2)

((cid:8)1, n1, N

(cid:2)
1, M, a1, H1)

((cid:8)2, n2, N2, M, a2, H2)

Si

a1 ≥ 0,
∀(n2, (cid:8)
(cid:2)
2, N
∃(n2, a) ∈ N1 tel que a2 > a
1 := N1 \ {(n2, a)} ∪ {(n2, a2)}.
(cid:2)

2) ∈ M, ((cid:8)
(cid:2)

(cid:2)
2, N

2) (cid:19) ((cid:8)2, Π1(N2)) et
(cid:2)

alors N
Les r`egles E7,E8 et E9 ont pour but d’´eviter tout inter-blocage lors de l’ex´ecution de
l’algorithme. Si l’une de ces r`egles est appliqu´ee `a un sommet v, alors la boˆıte-aux-lettres
de v est modiﬁ´ee. Par cons´equent, le niveau de conﬁance de v, qui est associ´ee `a une
valeur de sa boˆıte-aux-lettres, est r´einitialis´ee, ainsi que les niveaux de conﬁance associ´es
aux voisins de v dans sa vue locale.
La r`egle E7 permet `a un sommet v de modiﬁer sa boˆıte-aux-lettres M s’il a un voisin
(cid:2) qui a eu auparavant un niveau de conﬁance associ´e `a M sup´erieur `a a(v) − 1 et qui a
v
entre-temps modiﬁ´e sa boˆıte-aux-lettres. Puisque le but de l’historique est de conserver
une trace des niveaux de conﬁance associ´es aux pr´ec´edents contenus de la boˆıte-aux-lettres
de v, le sommet v ajoute (n(v), N(v), M(v), a(v)) `a son historique.

6.5. ´Election

159

((cid:8)2, n2, N2, M2, a2, H2)

E7 :
((cid:8)1, n1, N1, M1, a1, H1)
M2 \ M1 (cid:12)= ∅ et
ou bien a1 = 0, ou bien (a1 ≥ 0 et ∃(n, N, M1, a) ∈ H2,∃(n, a
1 := {(n,−1) | ∃(n, a) ∈ N1},
(cid:2)
alors N
(cid:2) := M1 ∪ M2 et
M
1 := H1 ∪ {(n1, N1, M1, a1)}.
(cid:2)
H

,−1, H1)

((cid:8)1, n1, N

Si

(cid:2)
1, M

(cid:2)

((cid:8)2, n2, N2, M2, a2, H2)

(cid:2)) ∈ N1, a ≥ a
(cid:2))

La r`egle E8 permet `a un sommet v dont le niveau de conﬁance est ´egal `a 0 de modiﬁer
son ´etat s’il d´ecouvre l’existence d’un voisin ayant le mˆeme num´ero que lui. Ici encore, le
sommet v modiﬁe son historique en cons´equence.

E8 :

((cid:8), n, N1, M, 0, H1)

((cid:8), n, N2, M, a, H2)

((cid:8), k, N

(cid:2)
1, M

(cid:2)

,−1, H
(cid:2)
1)

((cid:8), n, N2, M, a, H2)

Si

alors

(cid:2)

, K

n > 0,
Π1(N1) = Π1(N2) et
(cid:2)) ∈ M, ((cid:8)
(cid:2)) (cid:19) ((cid:8), Π1(N1))
∀(n, (cid:8)
(cid:2)
, K
(cid:2) | ∃(n
(cid:2)) ∈ M},
k := 1 + max{n
(cid:2)
(cid:2)
, (cid:8)
, K
1 := {(n,−1) | ∃(n, a) ∈ N1},
(cid:2)
N
(cid:2) := M ∪ {(k, (cid:8), Π1(N
1))} et
(cid:2)
M
1 := H1 ∪ {(n, N1, M, 0)}.
(cid:2)
H

La r`egle E9 permet `a un sommet v dont le niveau de conﬁance est 0 de modiﬁer son
´etat s’il d´ecouvre un voisin qu’il ne connaˆıt pas, i.e., le num´ero de ce voisin n’apparaˆıt pas
dans sa vue locale. Ici encore, le sommet v modiﬁe son historique H(v) en cons´equence.

E9 :

((cid:8)1, n1, N1, M, 0, H1)

((cid:8)2, n2, N2, M, a, H2)

((cid:8)1, n1, N

(cid:2)
1, M

(cid:2)

,−1, H
(cid:2)
1)

((cid:8)2, n2, N2, M, a, H2)

Si

n1 > 0, n2 > 0, n1 (cid:12)= n2
1) ∈ M, ((cid:8)
∀(n1, (cid:8)
(cid:2)
(cid:2)
(cid:2)
1, K
1, K
2) ∈ M, ((cid:8)
∀(n2, (cid:8)
(cid:2)
(cid:2)
(cid:2)
2, K
2, K
(cid:2)) ∈ N1
(cid:2)(n2, a
1 := {(n,−1) | ∃(n, a
(cid:2)) ∈ N1; n > n2} ∪ {(n2,−1)},
(cid:2)
alors N
(cid:2) := M ∪ {(n1, (cid:8)1, N
1)} et
(cid:2)
M
1 := H1 ∪ {(n1, N1, M, 0)}.
(cid:2)
H

1) (cid:19) ((cid:8)1, Π1(N1)),
(cid:2)
2) (cid:19) ((cid:8)2, Π1(N2)) et
(cid:2)

La r`egle E10 permet a un sommet dont le niveau de conﬁance est ´egal `a |V (G)| + 2
de prendre l’´etiquette ´elu si son num´ero est le plus grand num´ero qui correspond `a un
candidat du graphe HM pour G.

160Chapitre 6. Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees

E10 :

((cid:8), n, N, M, a, H)

´elu

Cette r`egle est applicable si n = max{n ∈ CHM (G)} et

a = |V (G)| + 2.

Les deux derni`eres r`egles permettent de diﬀuser l’information que l’´election a ´et´e ef-

fectu´ee, une fois qu’un sommet a pris l’´etiquette ´elu.

E11 :

((cid:8), n, N, M, a, H)

´elu

non-´elu

´elu

E12 :

((cid:8), n, N, M, a, H)

non-´elu

non-´elu

non-´elu

6.5.3 Correction de l’Algorithme d’´Election

L’algorithme d´ecrit par les r`egles pr´esent´ees ci-dessus est appel´e E et on appelle E(cid:2)
l’algorithme d´ecrit par les r`egles E1, . . . ,E9. Si on prouve que l’algorithme E(cid:2) termine, alors
il est ´evident que l’algorithme E termine puisque l’´etiquette de chaque sommet ne peut ˆetre
modiﬁ´ee qu’une fois par l’application d’une des r`egles E10,E11,E12. De plus, il est clair que
les ´etiquettes ´elu et non-´elu sont ﬁnales. Il est donc suﬃsant de prouver la terminaison
de E(cid:2) et de prouver qu’exactement un sommet peut appliquer la r`egle E10. En eﬀet, dans
ce cas l`a, il y aura exactement un sommet avec l’´etiquette ´elu dans la conﬁguration ﬁnale
et tous les autres sommets auront l’´etiquette non-´elu.
On note (λ(v), ni(v), Ni(v), Mi(v), ai(v), Hi(v)) l’´etiquette d’un sommet v apr`es le i`eme
pas de calcul de l’algorithme E(cid:2). Les propri´et´es de croissance des ´etiquettes de l’algorithme
M sont conserv´ees.
Lemme 6.23 Pour chaque sommet v et chaque ´etape i,

1. ni(v) ≤ ni+1(v),
2. Mi(v) ⊆ Mi+1(v),
3. Hi(v) ⊆ Hi+1(v),
4. si Hi(v) = Hi+1(v), alors Π1(Ni(v)) (cid:19) Π1(Ni+1(v)), ai(v) ≤ ai+1(v) et ∀(n, a1) ∈

Ni(v), (n, a2) ∈ Ni+1(v), a1 ≤ a2.
Et pour chaque ´etape i, il existe exactement un sommet v tel que l’une de ces in´egalit´es

soit stricte pour v.

Comme pour l’algorithme M, on peut montrer que pour tout sommet v et pour toute
´etape i, la valeur de ni(v) est toujours inf´erieure ou ´egale `a |V (G)|. Puisque par ailleurs,
la valeur de ai(v) est toujours comprise entre −1 et |V (G)| + 2, on sait que les valeurs que

6.5. ´Election

161

peuvent prendre Ni(v), Mi(v) et Hi(v) sont aussi en nombre ﬁni. D’apr`es le Lemme 6.23,
on peut donc d´eduire que chaque ex´ecution de E(cid:2) termine.
Dans le lemme suivant, on montre que pour tout sommet v et pour toute ´etape i, si un
niveau de conﬁance a est associ´ee `a un num´ero n dans la vue locale de v, alors a ≥ ai(v)−1.
Lemme 6.24 Pour chaque sommet v et chaque ´etape i, pour tout (n, a) ∈ Ni(v), a ≥
ai(v) − 1.
Preuve : On prouve cette propri´et´e par r´ecurrence sur le nombre d’´etapes. Initialement,
N(v) = ∅ pour tout sommet v et la propri´et´e est trivialement vraie.
On suppose maintenant que la propri´et´e est vraie apr`es la i`eme ´etape. Soit v le sommet
dont l’´etiquette est modiﬁ´ee lors de la (i + 1)`eme ´etape ; pour tout sommet w ∈ V (G) dis-
tinct de v, la propri´et´e est conserv´ee. Si une des r`egles E1,E2,E3,E4,E7,E8,E9 est appliqu´ee
`a v lors de l’´etape i + 1, alors ai+1(v) = −1 et la propri´et´e est conserv´ee.
Si la r`egle E5 est appliqu´ee `a v `a l’´etape i + 1, pour tout (n, a) ∈ Ni(v) = Ni+1(v),
a ≥ ai(v) = ai+1(v) − 1 : la propri´et´e est conserv´ee.
Si la r`egle E6 est appliqu´ee `a l’´etape i `a v en fonction de l’´etiquette d’un de ses voisins
(cid:2)))} et ai(v
(cid:2), alors Ni+1(v) = Ni(v) \ {(ni(v
(cid:2)), a1)} ∪ {(ni(v
(cid:2)) > a1. Puisque par
(cid:2)), ai(v
v
(cid:2)) > ai+1(v) − 1 et la propri´et´e
hypoth`ese de r´ecurrence, a1 ≥ ai+1(v) − 1, on a alors ai(v
est conserv´ee.

2

(cid:2) `a une ´etape i

(cid:2)) et ai(cid:2)(v

(cid:2)) ≥ ai(v) − 1.

(cid:2) de v tel que l’une des r`egles E7,E8,E9 a ´et´e appliqu´e `a v

Dans le lemme suivant, on montre que si la r`egle E7 est appliqu´ee `a une ´etape i + 1
`a un sommet v dont le niveau de conﬁance ´etait sup´erieur ou ´egal `a 1, alors il existe un
(cid:2) + 1 ≤ i
voisin v
telle que Mi(v) = Mi(cid:2)(v
Lemme 6.25 Pour chaque sommet v ∈ V (G) et chaque ´etape i tels que ai(v) ≥ k + 1 ≥ 1
(cid:2)) =
et Mi(v) (cid:4) Mi+1(v), il existe un sommet v
Mi(v) (cid:4) Mi(cid:2)+1(v
Preuve : Puisque ai(v) ≥ k + 1 et Mi(v) (cid:4) Mi+1(v), cela signiﬁe que ai+1(v) = −1 et
que la r`egle E7 a ´et´e appliqu´ee `a l’´etape i + 1 `a v en fonction de l’´etiquette de l’un de ses
voisins v
(cid:2)) tel que a ≥ ai(v) − 1 ≥ k. Si a ≥ 1,
(cid:2) et par cons´equent,
(cid:2) + 1 o`u une des r`egles E7,E8,E9 a ´et´e

Par cons´equent, il existe (n, N, Mi(v), a) ∈ Hi(v
(cid:2)) = a ≥ k et Mi(cid:2)(v
Si a = 0, alors k = 0 et il existe une ´etape i

(cid:2) + 1 ≤ i o`u la r`egle E7 a ´et´e appliqu´e `a v

alors il existe une ´etape i
ai(cid:2)(v

(cid:2) ∈ NG(v) et une ´etape i
(cid:2)

(cid:2)) = Mi(v) (cid:4) Mi(cid:2)+1(v

(cid:2)).

(cid:2)) et ai(cid:2)(v

(cid:2)) ≥ k.

< i tels que Mi(cid:2)(v

(cid:2).

appliqu´ee `a v

(cid:2). Par cons´equent, ai(cid:2)(v

(cid:2)) = 0 ≥ k et Mi(cid:2)(v

(cid:2)) = Mi(v) (cid:4) Mi(cid:2)+1(v

(cid:2)).

2

Dans la proposition suivante, on montre que chaque ex´ecution de E(cid:2) sur G ne s’arrˆete

pas avant qu’un sommet ait un niveau de conﬁance ´egal `a |V (G)| + 2.
Proposition 6.26 Pour toute ex´ecution de E(cid:2) sur G, il existe un sommet v ∈ V (G) et
une ´etape i telle que ai(v) = |V (G)| + 2.
Preuve : On sait d´ej`a que toute ex´ecution de E(cid:2) sur G termine : on consid`ere donc une
ex´ecution ρ de E(cid:2) sur G et on note (λ, nρ, Nρ, Mρ, aρ, Hρ) l’´etiquetage ﬁnal obtenu. On
suppose que pour tout sommet v, aρ(v) ≤ |V (G)| + 1.
On suppose d’abord que pour tout sommet v, aρ(v) = −1. D’apr`es la proposition
6.15, on sait que l’´etiquetage ﬁnal nρ permet de construire un graphe H tel que G est

162Chapitre 6. Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees

une submersion de H `a travers nρ, i.e., H ∈ SG. Par cons´equent, pour chaque sommet v,
HMρ(v) = H ∈ SG et l’une des deux r`egles E2,E5 peut ˆetre appliqu´ee `a v : l’ex´ecution de
E(cid:2) n’est donc pas termin´ee.
On consid`ere maintenant un sommet v tel que aρ(v) ≥ 1. Puisqu’on ne peut pas
, aρ(v)− 1) ∈ Nρ(v).
appliquer la r`egle E5 `a v, on sait d’apr`es le Lemme 6.24 qu’il existe (n
Consid´erons alors la derni`ere ´etape i o`u la r`egle E6 a ´et´e appliqu´ee `a v en fonction de l’un
(cid:2)) = aρ(v)−1 ≥ 0 et donc Mρ(v) = Mi(v) =
(cid:2) tel que ni(v
de ses voisins v
(cid:2)), alors on peut appliquer la r`egle E7 `a v en fonction de l’´etiquette
(cid:2)). Si Mi(v
(cid:2)) (cid:4) Mρ(v
Mi(v
(cid:2)) = nρ(v
(cid:2))).
(cid:2). Par cons´equent, Mi(v
de v
Puisque la r`egle E6 ne peut pas ˆetre appliqu´ee `a v en fonction de l’´etiquette de v
(cid:2), cela
(cid:2)) = aρ(v) − 1. Par cons´equent, pour chaque sommet v tel que aρ(v) ≥ 1,
signiﬁe que aρ(v
il existe un sommet v

(cid:2). Ainsi, ai(v
(cid:2)), ni(v

(cid:2)) = n
(cid:2)) = Mρ(v

(cid:2) tel que Mρ(v) = Mρ(v

(cid:2))) = Π1(Nρ(v

(cid:2)) et Π1(Ni(v

(cid:2)

(cid:2)) et aρ(v
(cid:2) ∈ V (G), si aρ(v

(cid:2)) = 0.
(cid:2)) ≥ 0, alors Mρ(v) = Mρ(v
(cid:2)

(cid:2)) = n

(cid:2)) = −1.

(cid:2), alors ai(v

(cid:2) tel que ni(v
(cid:2)) = −1. Puisqu’on ne peut appliquer ni la r`egle E1 `a v

On consid`ere maintenant un sommet v dont le niveau de conﬁance aρ(v) est ´egal
(cid:2)) ou
`a 0 et tel que pour tout sommet v
,−1) ∈
(cid:2))\ Mρ(v) (cid:12)= ∅. Puisque la r`egle E5 ne peut pas ˆetre appliqu´ee `a v, il existe (n
Mρ(v
Nρ(v). Si on consid`ere la derni`ere ´etape i o`u la r`egle E6 a ´et´e appliqu´ee `a v en fonction de
l’´etiquette d’un voisin v
(cid:2), ni la r`egle
Supposons que aρ(v
(cid:2)) et donc HMρ(v(cid:2)) ∈ SG. Par cons´equent, une des deux
E7 `a v, on sait que Mρ(v) = Mρ(v
r`egles E2,E5 peut ˆetre appliqu´ee `a v
(cid:2) et l’ex´ecution n’est pas termin´ee.
(cid:2)) ≥ 0. Puisque la r`egle E7 ne peut pas ˆetre appliqu´ee `a v, on sait
(cid:2)), alors Π1(Nρ(v)) = Π1(Nρ(v
(cid:2))) et on peut donc
(cid:2). Par cons´equent, nρ(v) (cid:12)= nρ(v
(cid:2))
(cid:2)) /∈ Π1(Nρ(v)). Dans le
(cid:2)) = ni(v
(cid:2) ; dans le
Par cons´equent, il n’existe pas d’ex´ecution ρ de E(cid:2) qui termine dans une conﬁguration

que Mρ(v) = Mρ(v
appliquer la r`egle E8 `a v en fonction de l’´etiquette de v
et d’apr`es le Lemme 6.13, ou bien nρ(v
premier cas, la r`egle E6 peut ˆetre appliqu´ee `a v en fonction de l’´etiquette de v
second cas, on peut appliquer la r`egle E9 `a v en fonction de l’´etiquette de v
ﬁnale o`u il n’existe aucun sommet v ∈ V (G) avec aρ(v) = |V (G)| + 2.

(cid:2)). Si nρ(v) = nρ(v

(cid:2)), ou bien nρ(v

Supposons que aρ(v

(cid:2).

2

De plus pour tout sommet v ∈ V (G

La propri´et´e cruciale de l’algorithme est donn´ee dans la proposition suivante. On
montre que si le niveau de conﬁance d’un sommet v est |V (G)| + 2, alors G a un sous
graphe G(cid:2) qui est une submersion de HM (v).
Proposition 6.27 S’il existe un sommet v0 ∈ V (G) et une ´etape i0 tels que ai0(v0) =
|V (G)| + 2, alors il existe un sous-graphe G(cid:2) de G qui est une submersion de HMi0
(v0).
(cid:2)) et pour toute ´etape i ≥ i0, Mi(v) = Mi0(v0) et il
existe une ´etape i1 ≥ i0 o`u un sommet peut appliquer la r`egle S10.
Preuve : On consid`ere un sommet v0 ∈ V (G) et une ´etape i0 tels que ai0(v0) = |V (G)|+2 ;
on pose M0 = Mi0(v0).
On d´eﬁnit une fonction partielle i : V (G) → N de la mani`ere suivante. ´Etant donn´e
un sommet v ∈ V (G), s’il existe une ´etape j ≤ i0 telle que Mj(v) = M0, alors i(v) =
max{j ≤ i0 | Mj(v) = M0} ; sinon i(v) n’est pas d´eﬁni.
On peut maintenant d´eﬁnir r´ecursivement une suite d’ensembles de sommets (Vj)j∈N `a
l’aide de la fonction i. On pose V0 = {v0} et Vk+1 = Vk ∪{w | ∃v ∈ NG(w)∩ Vk; ai(w)(w) ≥
ai(v)(v) − 1}.
(cid:2)) =

, ν) le sous-graphe de G d´eﬁni par V (G

Vj = V|V (G)| et E(G

Soit G(cid:2) = (G
(cid:2)

(cid:2)) =

(cid:4)
j∈N

6.5. ´Election

163

(cid:2))| ≥ 2.

(cid:8)
(cid:2)); ai(v)(v) ≥ a

Puisque aj1(v1) ≥ |V (G)| + 2 − |V (G

(cid:2)} ∈ E(G) | v, v

(cid:2) ∈ V (G

(cid:2));∃(ni(v)(v), a) ∈ Ni(v(cid:2))(v

On consid`ere maintenant un sommet v ∈ V (G

(cid:2)) et l’homomorphisme γ est localement surjectif pour tout v ∈ V (G

(cid:7){v, v
. L’´etiquetage ν de
(cid:2) est la restriction de l’´etiquetage λ de G `a G
(cid:2). On note γ l’homomorphisme de G(cid:2) dans
G
HM0 d´eﬁni par γ(v) = ni(v)(v).
Pour chaque sommet v ∈ Vp \ Vp−1, il existe un chemin ´el´ementaire de longueur p
(cid:2)) tel que ai(v)(v) = |V (G)| + 2 − p, il
de v `a v0. Ainsi, pour chaque sommet v ∈ V (G
existe un chemin ´el´ementaire de v `a v0 de longueur sup´erieure ou ´egale `a p, puisqu’un
tel sommet v appartient `a Vk \ Vk−1 o`u k ≥ p. De plus, pour tout sommet v ∈ V (G
(cid:2)),
ai(v)(v) ≥ |V (G)| + 2 − |V (G
(cid:2)). Si (n, a) ∈ Ni(v)(v), cela signiﬁe que
a ≥ ai(v)(v)−1 ≥ 1 et par cons´equent, la r`egle E6 a ´et´e appliqu´ee `a une ´etape j ≤ i(v) `a v en
fonction de l’´etiquette de l’un de ses voisins w tel que nj(w) = n, Mj(w) = Mi(v)(v) = M0
et aj(w) = a. Par cons´equent i(w) est d´eﬁni et ai(w)(w) ≥ aj(w) = a ≥ ai(v)(v) − 1. Ainsi,
w ∈ V (G
(cid:2)) : le graphe
G(cid:2) est une submersion de HM0.
On suppose qu’il existe un sommet v ∈ V (G
(cid:2)) et une ´etape j telle que Mj(v) =
M0 (cid:4) Mj+1(v). On consid`ere alors un sommet v1 ∈ V (G
(cid:2)) et une ´etape j1 tels que
(cid:2)), il existe une ´etape j ≥ j1 telle que
Mj1(v1) = M0 (cid:4) Mj1+1(v1) et pour tout v ∈ V (G
Mj(v) = M0(v).
(cid:2))|, on peut appliquer le Lemme 6.25 aﬁn de
trouver une suite de sommets (v1, . . . , vk) et une suite d´ecroissante d’´etapes (j1, . . . , jk)
(cid:2))| + 1 et pour tout 1 ≤ p ≤ k, Mjp(vp) = M0 (cid:4) Mjp+1(vp) et
telles que k = |V (G)| − |V (G
ajp(vp) ≥ k+1−p. En raison de notre choix de v1, on sait que pour tout p ≥ 2, vp /∈ V (G
(cid:2)).
(cid:2))| + 1, il existe deux ´etapes p > q telles que vp = vq. Mais
Puisque k = |V (G)| − |V (G
alors, M0 = Mjp(vp) (cid:4) Mjp+1(vp) ⊆ Mjq(vq) = M0, ce qui est impossible. Par cons´equent,
pour tout sommet v ∈ V (G
(cid:2)) et pour toute ´etape i > i0, Mi(v) = M0.
On va maintenant montrer qu’il existe une ´etape i1 ≥ i0 o`u la r`egle E10 peut ˆetre
appliqu´ee `a un sommet v. Supposons qu’on arrive `a une conﬁguration ﬁnale o`u la r`egle
E10 ne peut ˆetre appliqu´ee `a aucun sommet v ∈ V (G). On consid`ere alors l’´etiquetage ﬁnal
(λ, nρ, Nρ, Mρ, aρ, Hρ) de G.
On sait que Mρ(v0) = Mi0(v0) et aρ(v0) = ai0(v0) = |V (G)|+2. On peut donc red´eﬁnir
le graphe G(cid:2) comme pr´ec´edemment en consid´erant la derni`ere ´etape de l’ex´ecution `a la
place de l’´etape i0. Si dans la conﬁguration ﬁnale, a(v) = |V (G)| + 2 pour tout sommet
(cid:2)) tel que n(v1) = max{n ∈ CHM0 (G)}
v ∈ V (G
puisque G v´eriﬁe les conditions de la Proposition 6.22 : on peut donc appliquer la r`egle
E10 au sommet v1.
(cid:2)) dont le niveau de conﬁance
est minimum. Puisqu’on ne peut pas appliquer la r`egle E5 `a v, cela signiﬁe qu’il existe
(n, aρ(v)− 1) ∈ Nρ(v). On consid`ere alors la derni`ere ´etape j o`u la r`egle E6 a ´et´e appliqu´ee
(cid:2)) = n. Comme expliqu´e
`a v en fonction de l’´etiquette d’un de ses voisins v
(cid:2) ∈ V (G
(cid:2)) =
pr´ec´edemment, v
(cid:2)) ≥ aρ(v) >
(cid:2)) = aρ(v) − 1. Ainsi, puisque nρ(v
(cid:2)) et que aρ(v
(cid:2)) et aj(v
Mρ(v
aρ(v) − 1, on peut appliquer la r`egle E6 `a v en fonction de l’´etiquette de v
(cid:2) et l’ex´ecution
n’est pas termin´ee.
Il existe donc toujours une ´etape i1 > i0 o`u la r`egle E10 peut ˆetre appliqu´ee `a un
sommet v ∈ V (G).

Dans le cas contraire, on consid`ere un sommet v ∈ V (G

(cid:2)), il existe un unique sommet v1 ∈ V (G

(cid:2)) et {v, v

(cid:2)} ∈ E(G

(cid:2)). Par cons´equent, Mρ(v) = Mj(v) = Mj(v

(cid:2) tel que nj(v
(cid:2)) = nj(v

2

164Chapitre 6. Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees

D’apr`es la Proposition 6.27, si un sommet v0 a un niveau de conﬁance ´egal `a |V (G)|+2
(v0) ∈
(v0) et

apr`es une ´etape i0, il existe un sous-graphe G(cid:2) de G qui est une submersion de HMi0
SG et tel que pour tout sommet v ∈ V (G
(cid:2)) et toute ´etape i > i0, HMi(v) = HMi0
ai(v) ≥ 1.
On sait qu’il n’existe pas deux sous-graphes disjoints G1, G2 de G tels que G1 (resp.
G2) soit une submersion d’un graphe H1 ∈ SG (resp. H2 ∈ SG). Par cons´equent, il y a
exactement un sommet de G qui peut appliquer la r`egle E10 et l’algorithme E est bien un
algorithme d’´election pour G.

On a donc montr´e qu’il existe un algorithme d’´election utilisant des calculs locaux cellu-
laires sur les arˆetes non-´etiquet´ees pour tout graphe qui satisfait les conditions n´ecessaires
de la Proposition 6.22.
Th´eor`eme 6.28 Il existe un algorithme d’´election utilisant des calculs locaux cellulaires
sur les arˆetes non-´etiquet´ees pour un graphe simple ´etiquet´e G si et seulement si les condi-
tions suivantes sont v´eriﬁ´ees :

1. pour tout H ∈ SG, CH(G) (cid:12)= ∅,
2. il n’existe pas deux sous-graphes disjoints G1, G2 de G qui sont respectivement des

submersions de deux graphes H1, H2 ∈ SG.

Remarque 6.29 Contrairement `a l’algorithme M, l’algorithme E n´ecessite de connaˆıtre
exactement le graphe G, aﬁn de pouvoir calculer la famille SG.

6.6 Exemples

Si dans un graphe G, chaque sommet a un identiﬁant unique, lors le graphe G est
minimal pour les submersions. La connaissance de la taille du graphe permet `a l’algorithme
M de r´esoudre le nommage avec d´etection de la terminaison sur G, et par cons´equent de
r´esoudre l’´election sur G.

On sait que tout graphe complet est minimal pour les submersions, et par cons´equent,
la connaissance de la taille du graphe permet de r´esoudre l’´election et le nommage avec
d´etection de la terminaison avec des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees.

6.6.1 Arbres, Grilles et Graphes Bipartis

´Etant donn´e un graphe biparti non-´etiquet´e G avec au moins trois sommets, G peut
ˆetre colori´e (au sens classique) avec deux couleurs. Une telle coloration montre que G
est une submersion du graphe complet `a deux sommets K2. Puisque G a au moins trois
sommets, G est une submersion propre de K2 et il n’existe donc pas d’algorithme de
nommage pour G utilisant des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees.
De plus, ´etant donn´e un homomorphisme localement surjectif γ1 : G → K2, on peut
ais´ement construire un autre homomorphisme localement surjectif γ2 : G → K2 obtenu en
−1
1 (v2), o`u v1 et v2 sont les sommets de K2. Par cons´equent, pour tout
inversant γ
2 (v2)| > 1,
graphe biparti G ayant au moins trois sommets, ou bien |γ
−1
1 (v2)| > 1. Ainsi, il n’existe pas d’algorithme d’´election pour
ou bien |γ
−1
le graphe G utilisant des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees.

−1
1 (v1) et γ
2 (v1)| > 1 et |γ
−1

1 (v1)| > 1 et |γ
−1

On ne peut donc pas r´esoudre l’´election ou le nommage avec des calculs locaux cellu-
laires sur les arˆetes non-´etiquet´ees dans un graphe biparti non-´etiquet´e. Par cons´equent,

6.6. Exemples

165

on ne peut pas r´esoudre l’´election et le nommage dans ce mod`ele sur les arbres ou les
grilles ayant au moins trois sommets.

6.6.2 Anneaux de Taille Premi`ere

Il est connu qu’on ne peut pas r´esoudre les probl`emes de nommage ou d’´election
sur un anneau anonyme dans un mod`ele asynchrone o`u les processus communiquent en
´echangeant des messages [Tel00]. Par cons´equent, il est n´ecessaire d’avoir un m´ecanisme de
synchronisation entre voisins pour pouvoir r´esoudre ces probl`emes sur un anneau anonyme.
N´eanmoins, mˆeme dans le mod`ele des calculs locaux sur les ´etoiles ferm´ees (le mod`ele im-
pliquant le plus de synchronisation parmi ceux ´etudi´es dans ce m´emoire), on ne peut pas
r´esoudre ce probl`eme sur un anneau de taille quelconque : on ne peut pas r´esoudre le
probl`eme si la taille de l’anneau n’est pas un nombre premier (sauf pour l’anneau `a quatre
sommets). On va montrer ici que les calculs locaux cellulaires sur les arˆetes non-´etiquet´ees
sont un mod`ele de calcul assez puissant pour r´esoudre ´election et nommage sur les anneaux
de taille premi`ere. Ce r´esultat vient de la proposition suivante.

Proposition 6.30 Un anneau non-´etiquet´e de taille p est minimal pour les submersions
si et seulement si p est un nombre premier.
Preuve : On consid`ere un anneau non-´etiquet´e Cp de taille p o`u V (Cp) = {c0, c1, . . . ,
cp−1}, E(Cp) = {{ci, ci+1 mod p} | 0 ≤ i < p}.

Si 2 divise p, alors le graphe Cp est biparti et Cp est une submersion de K2. Si q > 2
divise p, alors Cp est un revˆetement simple propre de Cq et par cons´equent, Cp est une
submersion propre de Cq.
R´eciproquement, on consid`ere un homomorphisme localement surjectif γ : Cp → H
tel que H n’est pas isomorphe `a Cp. Puisque l’image d’un sommet de degr´e 2 par un
homomorphisme localement surjectif est un sommet de degr´e 1 ou 2, le graphe H est ou
bien un anneau Cq, ou un chemin Pq (avec V (Pq) = {p0, . . . , pq−1} et E(Pq) = {{pi, pi+1} |
i ∈ [0, q − 1]}). Dans le premier cas, pour tout v ∈ V (Cp), |γ(NCp(v))| = |NCp(v)| et γ est
donc un revˆetement : q divise donc p. Dans le second cas, γ envoie un sommet v ∈ V (Cp)
sur l’extr´emit´e p0 du chemin Pq et pour tout 1 ≤ i < p/2, γ envoie les deux sommets de
Cp `a distance i de v sur ci. Si p est impair, alors les deux sommets `a distance (cid:22)p/2(cid:23) de v
dans Cp sont voisins et sont tous les deux envoy´es sur le mˆeme sommet par γ, ce qui est
impossible. Par cons´equent, Cp est un anneau de taille paire.
2

Pour toute anneau de taille premi`ere Cp, il existe donc des algorithmes de nommage
et d’´election utilisant des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees. C’est
un corollaire int´eressant des Th´eor`emes 6.16 et 6.28, puisque le mod`ele de r´e´etiquetage
utilis´e ici est le mod`ele induisant une synchronisation minimale entre deux voisins. De
plus, l’algorithme M ne n´ecessite aucun sens de la direction sur les anneaux consid´er´es,
contrairement `a d’autres algorithmes existants.
Par ailleurs, on remarque que d’apr`es la Proposition 6.18, toute ex´ecution de l’algo-
rithme M ne n´ecessite que O(p3) ´etapes de r´e´etiquetages sur un anneau de taille premi`ere
Cp, ce qui est comparable au nombre de pas de r´e´etiquetages n´ecessaire `a l’algorithme de
Mazurkiewicz pour ´elire dans un anneau de taille p.

166Chapitre 6. Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees

1

1

T1

T2

1

1

3

2

1

3

1

3

2

3

2

Fig. 25 – Le graphe T1 est une submersion de T2. Dans le graphe T1, l’´etiquette de
chaque sommet est son degr´e.

6.7 Connaissance Initiale du Degr´e

On ´etudie dans cette partie l’inﬂuence de la connaissance initiale du degr´e sur les
calculs locaux cellulaires sur les arˆetes non-´etiquet´ees. C’est `a dire qu’initialement, chaque
sommet v d’un graphe G = (G, λ) connaˆıt son degr´e, i.e., son degr´e fait partie de son
´etiquette initiale λ(v).

6.7.1 Pas d’Algorithme d’´Election ou de Nommage pour la Famille des

Arbres

Contrairement aux mod`eles ´etudi´es dans les Chapitres 3 et 5, la connaissance initiale
du degr´e ne permet pas de r´esoudre le probl`eme de l’´election ou du nommage dans la
famille des arbres. En eﬀet, il existe des arbres qui ne v´eriﬁent pas les conditions du
Th´eor`emes 6.28, mˆeme si les sommets connaissent initialement leurs degr´es. Un tel exemple
est pr´esent´e sur la Figure 25.

6.7.2 Nommage dans les Familles de Diam`etre Born´e

On ´etudie dans cette partie l’importance de la connaissance initiale du degr´e pour
pouvoir trouver un algorithme utilisant des calculs locaux cellulaires sur les arˆetes non-
´etiquet´ees qui permet de nommer sur les familles de graphes minimaux pour les submer-
sions dont le diam`etre est born´e.
En fait, il est facile de voir qu’on peut modiﬁer l’algorithme M pr´esent´e ci-dessus de
la mˆeme mani`ere que dans le mod`ele ´etudi´e dans le Chapitre 5 pour obtenir le th´eor`eme
suivant.

Th´eor`eme 6.31 Pour tout entier B, il existe un algorithme de nommage avec d´etection
de la terminaison utilisant des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees avec
connaissance initiale du degr´e pour la famille des graphes minimaux pour les submersions
dont le diam`etre est born´ee par B.

6.8. Conclusion et Perspectives

167

Ainsi, comme dans les mod`eles consid´er´es dans les Chapitres 2, 3 et 5, lorsque les
sommets connaissent initialement leurs degr´es, il n’est pas n´ecessaire de connaˆıtre la taille
pour pouvoir nommer dans un graphe G que l’on sait minimal pour les submersions : une
borne sur la taille ou le diam`etre est suﬃsante. Cependant, on ne connaˆıt pas de r´esultat
´equivalent pour le probl`eme de l’´election, que les sommets connaissent initialement leurs
degr´es ou non.

Toutefois, on peut montrer en utilisant la mˆeme preuve que dans le Chapitre 3, que
si les sommets ne connaissent pas initialement leur degr´e, il est impossible de r´esoudre le
probl`eme de l’´election ou du nommage sur les graphes minimaux pour les submersions en
connaissant seulement une borne sur la taille.

De plus, en utilisant la mˆeme preuve, que dans le Chapitre 5, on peut montrer que
pour tout entier n qui n’est pas premier, il n’existe pas d’algorithme eﬀectif d’´election
ou de nommage pour la classe des graphes de taille n, mˆeme si les sommets connaissent
initialement leurs degr´es. En eﬀet, si on consid`ere les graphes Gp,q, Kp et Hp,q construits
dans la preuve du Chapitre 5, on observe que le graphe Gp,q est une submersion de Kp et
que le graphe Hp,q est minimal pour les submersions.

6.8 Conclusion et Perspectives

Dans ce chapitre, on a caract´eris´e les graphes admettant un algorithme de nommage
(Th´eor`eme 6.16) et ceux admettant un algorithme d’´election utilisant des calculs locaux
cellulaires sur les arˆetes non-´etiquet´ees (Th´eor`eme 6.28). Ces caract´erisations sont bas´ees
sur la notion de submersions.

La caract´erisation pour le probl`eme du nommage s’exprime simplement en termes
de submersions. Cela nous permet de penser qu’il est possible d’utiliser les techniques
pr´esent´ees dans [GM03, GMM04] aﬁn de caract´eriser les classes de graphes qui peuvent
ˆetre reconnues par des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees avec ou sans
connaissance initiale (la terminaison est alors implicite).

Par ailleurs, on a montr´e que la connaissance initiale du degr´e permet de r´esoudre
le probl`eme du nommage sur les familles de graphes minimaux pour les submersions
(Th´eor`eme 6.31). Ce r´esultat nous permet de penser que les techniques de [GM02] peuvent
ˆetre utilis´ees pour caract´eriser les familles de graphes admettant un algorithme universel
de nommage utilisant des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees.

La caract´erisation des graphes o`u on peut r´esoudre l’´election est un peu plus complexe.
De plus, l’algorithme d’´election pour un graphe G n´ecessite la connaissance du graphe lui-
mˆeme (et pas seulement de sa taille) aﬁn de pouvoir construire l’ensemble SG. Ainsi, pour
deux graphes diﬀ´erents, la connaissance initiale est diﬀ´erente. Il pourrait ˆetre int´eressant
de r´eussir `a caract´eriser les familles de graphe admettant un algorithme d’´election, comme
cela a ´et´e fait dans le mod`ele des calculs locaux sur les ´etoiles ferm´ees [GM02], mais
les m´ethodes utilis´es dans [GM02, GM03, MT00] ne semblent pas pouvoir ˆetre adapt´ees
facilement dans le mod`ele des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees.

168Chapitre 6. Calculs Locaux Cellulaires sur les Arˆetes Non-´Etiquet´ees

Chapitre 7

´Echanges de Messages en Mode
Asynchrone

Sommaire
7.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
7.2 Fibrations et Revˆetements Dirig´es . . . . . . . . . . . . . . . . . 171
7.3 Le Mod`ele . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
Syst`emes Distribu´es avec Communication par ´Echange de Messages177
7.3.1
7.3.2 Algorithmes utilisant des Messages . . . . . . . . . . . . . . . . . 177
7.4 Codage du R´eseau . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
´Etiquetage des Ports et Graphes Dirig´es Sym´etriques . . . . . . . 180
. . . . . . . 180

7.4.1
7.4.2 Codage du R´eseau avec un Graphe Simple ´Etiquet´e
7.4.3 Coder un Algorithme utilisant des ´echanges de Messages en Mode

Asynchrone . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
7.5 Un Algorithme d’´Enum´eration . . . . . . . . . . . . . . . . . . . 183
´Etiquettes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
7.5.1
7.5.2 Un Ordre sur les Vues Locales
. . . . . . . . . . . . . . . . . . . 184
7.5.3 L’Algorithme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
7.5.4 Propri´et´es de l’Algorithme 1
. . . . . . . . . . . . . . . . . . . . 185
7.5.5 Remarques sur l’Algorithme . . . . . . . . . . . . . . . . . . . . . 190
7.5.6 Complexit´e . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
´Election dans les Familles de Diam`etre Born´e . . . . . . . . . . 193
. . . . . . . . . . . . . . 196
7.7.1 Nommage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
´Election . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
7.7.2
. . . . . . . . . . . . . . . . . . . . . . . . . . . 199
7.7.3 Caract´erisations
7.8 Conclusion et Perspectives . . . . . . . . . . . . . . . . . . . . . . 201

7.6
7.7 Des ´Etiquetages des Ports plus Faibles

7.1

Introduction

Dans ce chapitre, on consid`ere des r´eseaux mod´elis´es par des graphes simples dispo-
sant d’´etiquetages des ports o`u les processus communiquent en ´echangeant des messages.

169

170

Chapitre 7. ´Echanges de Messages en Mode Asynchrone

Lorsqu’un processus envoie (ou re¸coit) un message, il connaˆıt le num´ero du port par le-
quel le message a ´et´e envoy´e (ou re¸cu). Le mod`ele est asynchrone : il n’y a pas d’horloge
globale, les messages parviennent `a leurs destinataires en un temps ﬁni mais arbitraire et
les processus ex´ecutent les instructions `a des vitesses arbitraires. Ce mod`ele correspond
au mod`ele ´etudi´e par Yamashita et Kameda dans [YK96b] et au mod`ele port-`a-port de
[YK99].

On donne une caract´erisation des graphes disposant d’un ´etiquetage des ports dans les-
quelles on peut r´esoudre l’´election et le nommage (Th´eor`eme 7.32). Cette caract´erisation
repose sur les notions de ﬁbrations et de revˆetements dirig´es. Elle peut ˆetre obtenue `a
partir des r´esultats de Boldi et al [BCG+96] en interpr´etant leurs r´esultats dans le mod`ele
´etudi´e ici. Il convient cependant de noter que les techniques pr´esent´ees dans ce chapitre
sont diﬀ´erentes des techniques employ´ees dans [BCG+96]. On pr´esente ensuite une ca-
ract´erisation des graphes admettant un algorithme d’´election quel que soit l’´etiquetage
des ports (Th´eor`eme 7.34).

Pour obtenir des conditions n´ecessaires, on repr´esente un graphe avec un ´etiquetage
des ports par un graphe simple ´etiquet´e et on obtient ainsi un r´esultat d’impossibilit´e di-
rectement `a partir du lemme de rel`evement d’Angluin [Ang80] pr´esent´e dans le Chapitre 3
(Proposition 7.24).

L’algorithme d’´enum´eration pr´esent´e dans la Section 7.5 est inspir´e de l’algorithme
de Mazurkiewicz. Il est tr`es diﬀ´erent de l’algorithme de Yamashita et Kameda [YK96b]
(et de l’algorithme de Boldi et al. [BCG+96] qui utilise sur les mˆemes techniques que
l’algorithme de Yamashita et Kameda) et a des propri´et´es int´eressantes que l’algoritme de
Yamashita et Kameda n’a pas. L’algorithme qu’on obtient est un algorithme qui utilise un
nombre polynomial de messages de taille polynomiale, alors que l’algorithme de Yamashita
et Kameda n´ecessite des messages de taille exponentielle. Par ailleurs, pour tout graphe
G avec un ´etiquetage des ports, il existe une ex´ecution de notre algorithme qui permet
de r´esoudre l’´election et le nommage. Ainsi, notre algorithme permet parfois d’exploiter
l’asym´etrie qui peut provenir de l’ex´ecution de l’algorithme et non du graphe sur lequel
l’algorithme est ex´ecut´e.

On ´etudie ensuite l’importance des connaissances initiales dans ce mod`ele (Section 7.6).
On montre qu’il suﬃt de connaˆıtre une borne sur le diam`etre pour pouvoir nommer ou
´elire dans un graphe minimal pour les revˆetements dirig´es sym´etriques (Th´eor`eme 7.42) et
que la connaissance d’une borne serr´ee sur la taille permet d’obtenir un algorithme eﬀectif
d’´election et de nommage (Th´eor`eme 7.43).

Dans la Section 7.7, on consid`ere d’autres mod`eles o`u les processus communiquent par
´echanges de messages qui ont ´et´e ´etudi´es par Yamashita et Kameda [YK99] et on montre
que des r´esultats similaires `a ceux pr´esent´es pour le mod`ele consid´er´e dans ce chapitre
peuvent ˆetre obtenus. On pr´esente aussi les caract´erisations obtenues par Yamashita et
Kameda [YK99] qui sont exprim´ees en termes d’´etiquetage.

Les r´esultats pr´esent´es dans ce chapitre ont ´et´e obtenus en collaboration avec Yves
M´etivier et une partie de ces r´esultats a ´et´e publi´ee dans [CM05]. Dans ce mod`ele, on a
obtenu d’autres r´esultats [CDS06, CGMT07] qui ne sont pas d´etaill´es ici mais qui sont
pr´esent´es dans la conclusion de ce chapitre.

7.2. Fibrations et Revˆetements Dirig´es

171

7.2 Fibrations et Revˆetements Dirig´es

Dans ce chapitre, on a besoin de consid´erer des graphes dirig´es aﬁn de pouvoir exprimer
des conditions n´ecessaires et suﬃsantes pour qu’un graphe admette un algorithme de
nommage ou d’´election dans les diﬀ´erents mod`eles consid´er´es.

Les homomorphismes qu’on consid`ere dans ce Chapitre sont les ﬁbrations et les revˆe-
tements dirig´es. Ces objets ont ´et´e introduits par Boldi et al. [BCG+96]. Les d´eﬁnitions
et propri´et´es pr´esent´ees ici sont dues `a Boldi et Vigna [BV02a].

On rappelle ici la d´eﬁnition des ﬁbrations donn´ee dans le Chapitre 4

D´eﬁnition 7.1 Un graphe dirig´e D est ﬁbr´e sur un graphe dirig´e D
morphisme γ : D → D
existe un unique arc a ∈ A(D) tel que t(a) = v et ϕ(a) = a
(cid:2).

(cid:2) si pour tout arc a

(cid:2)) et pour tout sommet v ∈ γ

(cid:2) ∈ A(D

On dit alors que l’homomorphisme γ est une ﬁbration de D dans D
Un graphe dirig´e D est ﬁbr´e proprement sur D

(cid:2).

(cid:2) `a travers un homo-
(cid:2))), il

−1(t(a

rellement, un graphe dirig´e ´etiquet´e (D, λ) est ﬁbr´e sur un graphe dirig´e ´etiquet´e (D
`a travers γ si D est ﬁbr´e sur D

(cid:2) `a travers γ et si γ conserve l’´etiquetage.

(cid:2) si γ n’est pas un isomorphisme. Natu-
(cid:2))
, λ

(cid:2)

Comme dans le Chapitre 4, on ne consid`ere que des graphes dirig´es fortement connexes,
mais les graphes dirig´es consid´er´es dans ce chapitre peuvent avoir des boucles. On d´eﬁnit
maintenant les graphes minimaux pour les ﬁbrations.

D´eﬁnition 7.2 Un graphe dirig´e fortement connexe D est minimal pour les ﬁbrations si
D n’est ﬁbr´e proprement sur aucun autre graphe dirig´e fortement connexe.

Un graphe simple G est minimal pour les ﬁbrations si Dir(G) est minimal pour les

ﬁbrations discr`etes.

On rappelle ici la d´eﬁnition des ﬁbrations non-triviales donn´ee dans le Chapitre 4.

D´eﬁnition 7.3 Si un graphe dirig´e D est ﬁbr´e sur un graphe dirig´e fortement connexe D(cid:2)
`a travers une ﬁbration γ, pour tout sommet v ∈ V (D
−1(v) est la ﬁbre de
−1(v)| = 1
v. La ﬁbre d’un sommet v est triviale si elle est r´eduite `a un singleton, i.e., |γ
et non-triviale sinon.
D est non-trivialement ﬁbr´e sur D(cid:2).

La ﬁbration γ est non-triviale si toutes ses ﬁbres sont non-triviales. On dit alors que

(cid:2)), l’ensemble γ

On donne maintenant la d´eﬁnition des graphes minimaux pour les ﬁbrations non-
triviales. Ici aussi, les graphes consid´er´es sont toujours fortement connexes et peuvent
avoir des boucles. On remarque que tout graphe minimal pour les ﬁbrations est aussi
minimal pour les ﬁbrations non-triviales.

D´eﬁnition 7.4 Un graphe dirig´e fortement connexe D est minimal pour les ﬁbrations
non-triviales si D n’est ﬁbr´e non-trivialement sur aucun autre graphe dirig´e fortement
connexe.

Un graphe simple G est minimal pour les ﬁbrations non-triviales si Dir(G) est minimal

pour les ﬁbrations non-triviales.

On montre dans la proposition suivante que si D ﬁbr´e sur D

´etiquetage cod´eterministe de D

(cid:2) en un ´etiquetage cod´eterministe de D.

(cid:2), alors on peut relever un

172

Chapitre 7. ´Echanges de Messages en Mode Asynchrone

, λ

(cid:2) de D

(cid:2)) `a travers γ.

(cid:2) `a travers γ, pour
(cid:2), il existe un ´etiquetage cod´eterministe λ de D tel

Proposition 7.5 Si un graphe dirig´e D est ﬁbr´e sur un graphe dirig´e D
tout ´etiquetage cod´eterministe λ
que (D, λ) est ﬁbr´e sur (D
Preuve : On consid`ere un graphe dirig´e D ﬁbr´e sur un graphe dirig´e D
un ´etiquetage cod´eterministe λ
suivante : pour tout x ∈ V (D) ∪ A(D), λ(x) = λ
pr´eserve l’´etiquetage, (D, λ) est ﬁbr´e sur (D
, λ
ﬁbration, pour tout arcs distincts a, a
t(γ(a)) = t(γ(a
aussi un ´etiquetage cod´eterministe.

(cid:2) `a travers γ et
(cid:2). On d´eﬁnit un ´etiquetage λ de D de la mani`ere
(cid:2)(γ(x)). Puisque γ est une ﬁbration qui
(cid:2)) `a travers γ. De plus, puisque γ est une
(cid:2)). Puisque
(cid:2)). Ainsi, λ est

(cid:2) est un ´etiquetage cod´eterministe, λ(a) (cid:12)= λ(a

(cid:2)), on a γ(a) (cid:12)= γ(a

(cid:2) tels que t(a) = t(a

(cid:2))) et que λ

(cid:2) de D

2

(cid:2)

(cid:2)

On introduit maintenant les d´eﬁnitions de revˆetements dirig´es et de revˆetements di-
rig´es sym´etriques qui sont des ﬁbrations particuli`eres. On va aussi voir les liens entre ces
homomorphismes et les revˆetements introduits dans le Chapitre 3.
Un graphe dirig´e D est un revˆetement d’un graphe dirig´e D(cid:2) `a travers un homomor-
phisme γ si pour tout sommet v ∈ V (D), γ induit une bijection entre les arcs incidents `a
v dans D et les arcs incidents `a γ(v) dans D(cid:2).
D´eﬁnition 7.6 Un graphe dirig´e D est un revˆetement dirig´e d’un graphe dirig´e D
travers un homomorphisme γ : D → D
(cid:2))) (resp. v ∈ γ
v ∈ γ
−1(s(a
(cid:2).
(resp. s(a) = v) et ϕ(a) = a

(cid:2) `a
(cid:2)) et pour tout sommet
(cid:2))), il existe un unique arc a ∈ A(D) tel que t(a) = v

(cid:2) si pour tout arc a

(cid:2) ∈ A(D

−1(t(a

On dit alors que l’homomorphisme γ est un homomorphisme localement bijectif. Un

graphe dirig´e D est un revˆetement dirig´e propre de D

(cid:2) si γ n’est pas un isomorphisme.
Naturellement, un graphe dirig´e ´etiquet´e (D, λ) est un revˆetement dirig´e d’un graphe
(cid:2) `a travers γ et si γ

(cid:2)) `a travers γ si D est un revˆetement dirig´e de D

(cid:2)

dirig´e ´etiquet´e (D
, λ
conserve l’´etiquetage.

D’apr`es les d´eﬁnitions pr´ec´edentes, on remarque que si un graphe dirig´e D est un
revˆetement dirig´e d’un graphe dirig´e D(cid:2), alors D est ﬁbr´e sur D(cid:2). On d´eﬁnit maintenant
les graphes minimaux pour les revˆetements dirig´es.
D´eﬁnition 7.7 Un graphe dirig´e fortement connexe D est minimal pour les revˆetements
dirig´es si D n’est un revˆetement dirig´e propre d’aucun autre graphe dirig´e fortement
connexe.

Un graphe simple G est minimal pour les revˆetements dirig´es si Dir(G) est minimal

pour les revˆetements dirig´es.

(cid:2), alors

On montre dans la proposition suivante que si D est un revˆetement dirig´e de D

(cid:2) en un ´etiquetage d´eterministe de D.
on peut relever un ´etiquetage d´eterministe de D
Proposition 7.8 Si un graphe dirig´e D est un revˆetement dirig´e d’un graphe dirig´e D
(cid:2) de D
travers γ, pour tout ´etiquetage d´eterministe λ
λ de D tel que (D, λ) est un revˆetement dirig´e de (D
Preuve : On consid`ere un graphe dirig´e D qui est un revˆetement dirig´e d’un graphe
(cid:2). On d´eﬁnit un ´etiquetage λ de
dirig´e D
D de la mani`ere suivante : pour tout x ∈ V (D)∪ A(D), λ(x) = λ
(cid:2)(γ(x)). Puisque γ est un
(cid:2)) `a travers γ. De
(cid:2)
revˆetement qui pr´eserve l’´etiquetage, (D, λ) est un revˆetement de (D
(cid:2) tels que s(a) = s(a
(cid:2)),
plus, puisque γ est un revˆetement dirig´e, pour tout arcs distincts a, a

(cid:2) `a
(cid:2), il existe un ´etiquetage d´eterministe
(cid:2)
, λ

(cid:2) `a travers γ et un ´etiquetage d´eterministe λ

(cid:2)) `a travers γ.

(cid:2) de D

, λ

7.2. Fibrations et Revˆetements Dirig´es

173

on a γ(a) (cid:12)= γ(a
λ(a) (cid:12)= λ(a

(cid:2)). Puisque s(γ(a)) = s(γ(a

(cid:2))) et que λ

(cid:2)). Ainsi, λ est aussi un ´etiquetage cod´eterministe.

(cid:2) est un ´etiquetage d´eterministe,

2

Si D est un revˆetement dirig´e de D

(cid:2), on sait d’apr`es les Propositions 7.5 et 7.8,
(cid:2) en un ´etiquetage

(cid:2)

, λ

, λ

Pour tout arc a

(cid:2)) `a travers γ.

(cid:2)
(cid:2)), pour tout sommet u ∈ γ

Dans la proposition suivante, on montre que si un graphe D a un ´etiquetage d´etermi-

qu’on peut relever tout ´etiquetage d´eterministe et cod´eterministe de D
d´eterministe et cod´eterministe de D.
niste, alors D est ﬁbr´e sur un graphe D(cid:2) si et seulement si D est un revˆetement de D(cid:2).
Proposition 7.9 On consid`ere un graphe dirig´e D = (D, λ) est ﬁbr´e sur un graphe dirig´e
fortement connexe D(cid:2) = (D
(cid:2)) `a travers γ. Si λ est un ´etiquetage d´eterministe, alors D
est un revˆetement de D(cid:2) `a travers γ.
Preuve : On consid`ere un graphe dirig´e (D, λ) dont l’´etiquetage est d´eterministe qui est
ﬁbr´e sur un graphe dirig´e (D
(cid:2))), il existe un arc a ∈ A(D)
(cid:2) ∈ A(D
(cid:2) et t(a) = u. De plus, puisque l’´etiquetage des arcs de D est d´eterministe,
(cid:2)), λ(a1) = λ(a2) et par cons´equent, s(a1) (cid:12)= s(a2).
(cid:2) ∈ A(D), on peut associer `a tout sommet u ∈ γ
(cid:2))), un unique
(cid:2)))|. Puisque D est un
(cid:2))) et par cons´equent, |γ
−1(s(a
(cid:2))| = |γ
(cid:2))|.
(cid:2)), |γ
(cid:2) ∈ V (D
Pour tous arcs distincts a1, a2 ∈ A(D) tels que s(a1) = s(a2), λ(a1) (cid:12)= λ(a2) et par
(cid:2)), on peut associer `a tout arc
−1(a
(cid:2))). Par ailleurs, puisque γ est une ﬁbration,
−1(s(a))|. Par
−1(t(a))| et ainsi, |γ
−1(a)| = |γ
(cid:2))), il existe un unique arc a ∈ γ
(cid:2)) tel que
−1(a

tel que γ(a) = a
pour tous arcs distincts a1, a2 ∈ γ
Ainsi, pour tout arc a
sommet v ∈ γ
−1(s(a
graphe fortement connexe, on sait donc que pour tout u
cons´equent, γ(a1) (cid:12)= γ(a2). Ainsi, pour tout arc a
(cid:2)), un unique sommet u ∈ γ
a ∈ γ
pour tout arc a
cons´equent, pour tout sommet u ∈ γ
(cid:2).
γ(a) = a
(cid:2)) `a travers γ.

Puisque γ est une ﬁbration, on a donc montr´e que (D, λ) ´etait un revˆetement dirig´e
2

−1(s(a
−1(a)| = |γ
−1(s(a

, v
(cid:2) ∈ A(D

−1(t(a
−1(u

(cid:2) ∈ A(D

(cid:2)), |γ

−1(t(a

(cid:2)))| ≤ |γ

−1(t(a

−1(a

(cid:2)

de (D

, λ

(cid:2)

−1(v

Les revˆetements dirig´es sym´etriques sont les revˆetements dirig´es qui pr´eservent la fonc-

tion Sym sur les arcs.
D´eﬁnition 7.10 Un graphe dirig´e sym´etrique D est un revˆetement dirig´e sym´etrique
(cid:2) si D est un
d’un graphe dirig´e sym´etrique D
(cid:2) `a travers γ et si γ pr´eserve Sym, i.e., pour tout arc a ∈ A(D),
revˆetement dirig´e de D
Sym(γ(a)) = γ(Sym(a)).
(cid:2) si γ n’est pas

Un graphe dirig´e D est un revˆetement dirig´e sym´etrique propre de D

(cid:2) `a travers un homomorphisme γ : D → D

un isomorphisme.

Naturellement, un graphe dirig´e sym´etrique ´etiquet´e (D, λ) est un revˆetement dirig´e
(cid:2)) `a travers γ si D est un revˆe-

sym´etrique d’un graphe dirig´e sym´etrique ´etiquet´e (D
tement dirig´e sym´etrique de D

(cid:2) `a travers γ et si γ conserve l’´etiquetage.

, λ

(cid:2)

D’apr`es les d´eﬁnitions pr´ec´edentes, on remarque que si un graphe dirig´e D est un
revˆetement dirig´e sym´etrique d’un graphe dirig´e D(cid:2), alors D est un revˆetement dirig´e de
D(cid:2).

On d´eﬁnit maintenant les graphes minimaux pour les revˆetements dirig´es sym´etriques
et puisque pour tout graphe simple G, Dir(G) est un graphe dirig´e sym´etrique, on peut
´etendre cette d´eﬁnition aux graphes simples comme pr´ec´edemment.

174

Chapitre 7. ´Echanges de Messages en Mode Asynchrone

D´eﬁnition 7.11 Un graphe dirig´e sym´etrique fortement connexe D est minimal pour les
revˆetements dirig´es sym´etriques si D n’est un revˆetement dirig´e sym´etrique propre d’aucun
autre graphe dirig´e sym´etrique fortement connexe.

Un graphe simple G est minimal pour les revˆetements dirig´es sym´etriques si Dir(G)

est minimal pour les revˆetements dirig´es sym´etriques.

On montre dans la proposition suivante que si D est un revˆetement dirig´e sym´etrique
(cid:2), alors on peut relever un ´etiquetage d´eterministe, cod´eterministe et sym´etrique de
de D
(cid:2) en un ´etiquetage d´eterministe, cod´eterministe et sym´etrique de D.
D
Proposition 7.12 Si un graphe dirig´e sym´etrique D est un revˆetement dirig´e sym´etrique
(cid:2) `a travers γ, pour tout ´etiquetage d´eterministe, cod´eter-
d’un graphe dirig´e sym´etrique D
(cid:2), il existe un ´etiquetage d´eterministe, cod´eterministe et
(cid:2) de D
ministe et sym´etrique λ
(cid:2)) `a travers
sym´etrique λ de D tel que (D, λ) est un revˆetement dirig´e sym´etrique de (D
γ.
Preuve : On consid`ere un graphe dirig´e sym´etrique D qui est un revˆetement dirig´e
(cid:2) `a travers γ et un ´etiquetage d´eterministe,
sym´etrique d’un graphe dirig´e sym´etrique D
(cid:2). On d´eﬁnit un ´etiquetage λ de D de la mani`ere
cod´eterministe et sym´etrique λ
suivante : pour tout x ∈ V (D) ∪ A(D), λ(x) = λ
(cid:2)(γ(x)). Puisque γ est un revˆetement
(cid:2)) `a travers
dirig´e sym´etrique qui pr´eserve l’´etiquetage, (D, λ) est un revˆetement de (D
, λ
(cid:2) tels que s(a) = s(a
(cid:2))
γ. De plus, puisque γ est un revˆetement dirig´e, pour tout arcs a, a
(cid:2)
(cid:2)))). Puisque λ
(cid:2))) (resp. t(γ(a)) = t(γ(a
(resp. t(a) = t(a
est un ´etiquetage d´eterministe et cod´eterministe, λ est aussi un ´etiquetage d´eterministe et
cod´eterministe. Par ailleurs, puisque γ est un revˆetement dirig´e sym´etrique, pour tout arc
a ∈ A(D), Sym(λ(a)) = Sym(λ
(cid:2)(γ(a))) = λ
(cid:2)(γ(Sym(a))) = λ(Sym(a))
et ainsi, λ est un ´etiquetage sym´etrique de D.

(cid:2)) et s(γ(a)) = s(γ(a

(cid:2)(Sym(γ(a))) = λ

(cid:2))), γ(a) (cid:12)= γ(a

(cid:2)

, λ

(cid:2)

(cid:2) de D

2

Dans la proposition suivante, on montre le lien entre les revˆetements de graphes non-

dirig´es et et les revˆetements dirig´es sym´etriques.
Proposition 7.13 Si un graphe G est un revˆetement d’un graphe H, alors Dir(G) est
un revˆetement dirig´e sym´etrique d’un graphe Dir(H).
Preuve : On consid`ere deux graphes G = (G, λ), H = (H, η). On sait que Dir(G) et
Dir(H) sont deux graphes dirig´es fortement connexes sym´etriques. De plus, pour toute
(cid:2), il existe deux arcs ae,u,u(cid:2), ae,u(cid:2),u ∈
arˆete e ∈ E(G) dont les extr´emit´es sont u et u
A(Dir(G)) tels que λ(ae,u,u(cid:2)) = λ(ae,u(cid:2),u) = λ(e), s(ae,u,u(cid:2)) = t(ae,u(cid:2),u) = u et tels que
Sym(ae,u,u(cid:2)) = ae,u(cid:2),u. De mˆeme, pour toute arˆete f ∈ E(H) dont les extr´emit´es sont v
(cid:2), il existe deux arcs af,v,v(cid:2), af,v(cid:2),v ∈ A(Dir(H)) tels que η(af,v,v(cid:2)) = η(af,v(cid:2),v) = η(f),
et v
s(af,v,v(cid:2)) = t(af,v(cid:2),v) = v et Sym(af,v,v(cid:2)) = af,v(cid:2),v.

On suppose que G est un revˆetement de H `a travers un homomorphisme γ. On
d´eﬁnit un homomorphisme ϕ de Dir(G) dans Dir(H) de la mani`ere suivante : pour tout
u ∈ V (Dir(G)) = V (G), ϕ(u) = γ(u) et pour tout arc ae,u,u(cid:2) ∈ A(Dir(G)), ϕ(ae,u,u(cid:2)) =
aγ(e),γ(u),γ(u(cid:2)). Pour tout sommet u ∈ V (Dir(G)), η(ϕ(u)) = η(γ(u)) = λ(u) et pour tout
arc ae,u,u(cid:2) ∈ A(Dir(G)), η(ϕ(ae,u,u(cid:2))) = η(γ(e)) = λ(e) = λ(ae,u,u(cid:2)). Ainsi, ϕ pr´eserve
l’´etiquetage. De plus, pour tout ae,u,u(cid:2) ∈ A(Dir(G)), s(ϕ(ae,u,u(cid:2))) = s(aγ(e),γ(u),γ(u(cid:2))) =
γ(u) = ϕ(s(ae,u,u(cid:2))) et Sym(ϕ(ae,u,u(cid:2))) = Sym(aγ(e),γ(u),γ(u(cid:2))) = aγ(e),γ(u(cid:2)),γ(u) =
ϕ(ae,u(cid:2),u(cid:2)) = ϕ(Sym(ae,u,u(cid:2))). Ainsi, ϕ est un homomorphisme de Dir(G) dans Dir(H)
qui pr´eserve la fonction Sym. Par ailleurs, ´etant donn´es un sommet u ∈ V (Dir(G)) et

7.2. Fibrations et Revˆetements Dirig´es

175

un arc af,γ(u),v(cid:2) ∈ A(Dir(H)) (resp. af,v,γ(u) ∈ A(Dir(H))), il existe e ∈ E(G) tel que
γ(e) = f et u ∈ ext(e) : ainsi, il existe ae,u,u(cid:2) ∈ A(G) (resp. ae,u(cid:2),u ∈ A(G)) tel que
ϕ(ae,u,u(cid:2)) = af,γ(u),v(cid:2) et s(ae,u,u(cid:2)) = u (resp. ϕ(ae,u(cid:2),u) = af,v,γ(u) et t(ae,u(cid:2),u) = u). Ainsi
Dir(G) est un revˆetement de H `a travers ϕ.
2

Comme pour les revˆetements de graphes non-dirig´es, si un graphe dirig´e D est un
revˆetement d’un graphe dirig´e D(cid:2) fortement connexe, alors tous les sommets et les arcs de
D(cid:2) ont le mˆeme nombre d’ant´ec´edents, qui est appel´e le nombre de feuillets du revˆetement.
Proposition 7.14 Si un graphe dirig´e D est un revˆetement dirig´e d’un graphe connexe
D(cid:2) `a travers γ, alors il existe une constante q telle que pour tout x ∈ V (D
(cid:2)),
−1(x)| = q.
|γ
Cette constante q est appel´ee le nombre de feuillets du revˆetement.

(cid:2)) ∪ A(D

−1(a
−1(v

(cid:2) ∈ A(D

(cid:2)(cid:2)) = s(a), γ(a

(cid:2)(cid:2)) (cid:12)= a

(cid:2)) tel que s(a

(cid:2)) = v

(cid:2).

Puisque γ est un homomorphisme, pour tout arc a ∈ γ
(cid:2))| ≤ |γ
−1(a
(cid:2)), il existe un unique arc a ∈ γ
−1(v
(cid:2))|.
−1(v

Preuve : On consid`ere un graphe dirig´e D qui est un revˆetement d’un graphe dirige
(cid:2) ∈ V (D
fortement connexe D(cid:2) `a travers un homomorphisme γ. On consid`ere un sommet v
(cid:2))
et un arc a
(cid:2)), γ(s(a)) = s(γ(a)) = v
(cid:2).
(cid:2)(cid:2) diﬀ´erent de a tel
(cid:2))|.
−1(a
(cid:2))
(cid:2) ∈
(cid:2)) et tout arc a
(cid:2))|. Ainsi, puisque le graphe D(cid:2) est fortement
−1(x)| = |γ

De plus, puisque γ est localement bijectif, on sait que pour tout arc a
que s(a
tel que s(a) = v. Par cons´equent |γ

(cid:2). Par cons´equent, |γ
R´eciproquement, pour tout sommet v ∈ γ
(cid:2))| ≥ |γ
−1(v
(cid:2)), |γ

(cid:2) ∈ V (D
De la mˆeme mani`ere, on montre que pour tout sommet v
(cid:2)) tel que t(a
(cid:2))|.
−1(x

(cid:2)) = v
A(D
connexe, pour tout x, x

−1(a
(cid:2))| = |γ
(cid:2)) ∪ A(D

(cid:2), |γ
−1(a
(cid:2) ∈ V (D

2

Grˆace `a la Proposition 7.14, on voit que si un graphe dirig´e D est un revˆetement propre

de D(cid:2), alors D est ﬁbr´e non-trivialement sur D(cid:2).
Exemple 7.15 Des exemples de ﬁbrations et de revˆetements sont pr´esent´es sur la Fi-
gure 26. Le graphe dirig´e D1 est minimal pour les ﬁbrations non-triviales, mais est ﬁbr´e
proprement sur D(cid:2)
1. Le graphe dirig´e D2 est minimal pour les revˆetements dirig´es, mais
est ﬁbr´e non-trivialement sur D(cid:2)
2. Le graphe dirig´e D3 est minimal pour les revˆetements
sym´etriques dirig´es, mais est un revˆetement dirig´e propre de D

(cid:2)
3.

´Etant donn´e un graphe dirig´e D, il existe un graphe dirig´e D0 canonique sur lequel
D est ﬁbr´e. Ce graphe dirig´e D0 est appel´e la base minimale de D ; c’est le «plus petit»
graphe dirig´e sur lequel D est ﬁbr´e. La proposition suivante est due `a Boldi et Vigna
[BV02a].
Proposition 7.16 ([BV02a]) Pour tout graphe dirig´e fortement connexe D, il existe un
graphe dirig´e fortement connexe D0 tel que D est ﬁbr´e sur D0 et pour tout graphe dirig´e
fortement connexe D(cid:2) tel que D est ﬁbr´e sur D, D(cid:2) est ﬁbr´e sur D0.

Le graphe D0 est la base minimale de D.

La base minimale d’un graphe dirig´e D peut ˆetre calcul´e en temps polynomial en
utilisant la m´ethode du raﬃnement de degr´e [BV02a, Lei82]. Cette m´ethode est similaire
`a la technique classique utilis´ee pour minimiser un automate d´eterministe qu’on peut
trouver par exemple dans [HU79].

176

Chapitre 7. ´Echanges de Messages en Mode Asynchrone

1

1

1

1

2

2

D(cid:2)

1

D(cid:2)

2

(cid:2)
D
3

1

D1

D2

1

2

2

2

2

D3

Fig. 26 – Le graphe dirig´e D1 est ﬁbr´e proprement sur D(cid:2)
trivialement sur D(cid:2)

2 et le graphe D3 est un revˆetement dirig´e propre de D(cid:2)
3.

1, le graphe D2 est ﬁbr´e non-

7.3. Le Mod`ele

7.3 Le Mod`ele

177

Les d´eﬁnitions pr´esent´ees dans cette section correspondent aux d´eﬁnitions donn´ees par
Tel dans [Tel00] (pp. 45-47). On peut aussi se r´ef´erer au livre d’Attiya et Welch [AW04]
(pp. 10-12).

´Etant donn´e un graphe simple G, un ´etiquetage des ports est un ensemble de fonctions

locales qui permettent `a chaque sommet de distinguer ses voisins.
D´eﬁnition 7.17 ´Etant donn´e un graphe simple G, un ´etiquetage des ports δ est un en-
semble de fonctions {δu | u ∈ V (G)} tel que pour tout sommet u, δu est une bijection entre
NG(u) et [1, degG(u)].
l’incidence entre le sommet u et l’arˆete {u, v} comme repr´esent´e sur la Figure 27.

On repr´esente un graphe G avec un ´etiquetage δ en repr´esentant le num´ero δu(v) sur

7.3.1 Syst`emes Distribu´es avec Communication par ´Echange de Mes-

sages

Un syst`eme distribu´e avec communication par ´echange de message (P, C) est d´eﬁni par
un ensemble P de processus et un sous-syst`eme de communication C qui est repr´esent´e
par un graphe simple connexe G o`u les sommets repr´esentent les processus et les arˆetes
repr´esentent des liens de communications bidirectionnels. Le syst`eme est asynchrone : il
n’y a pas d’horloge globale, les messages parviennent `a leurs destinataires en un temps
ﬁni mais arbitraire et les processus ex´ecutent les instructions `a des vitesses arbitraires.
Les processus communiquent en ´echangeant des messages en mode asynchrone et chaque
processus distingue les canaux par lesquels il re¸coit ou envoie chaque message, i.e., il existe
une fonction δ d’´etiquetage des ports du graphe G. Ainsi, le syst`eme de communication C
est repr´esent´e par un graphe simple G avec un ´etiquetage des ports δ. Chaque processus
a un ´etat initial d´eﬁni par une fonction d’´etiquetage des sommets λ. Le syst`eme distribu´e
(P, C) est alors repr´esent´e par un graphe ´etiquet´e G = (G, λ) avec un ´etiquetage des ports
δ. On appellera parfois ce syst`eme distribu´e un r´eseau on le notera (G, δ).
Remarque 7.18 Si le r´eseau est anonyme, tous les sommets doivent avoir le mˆeme ´etat
initial, et l’´etiquetage λ est alors uniforme (tous les sommets ont la mˆeme ´etiquette). Si
les processus du r´eseau ont tous des identit´es distinctes, l’´etiquetage λ est tel que pour tout
u, v ∈ V (G), λ(u) (cid:12)= λ(v). S’il existe un sommet distingu´e dans le r´eseau, alors il existe
un sommet v ∈ V (G) tel que pour tout u ∈ V (G) diﬀ´erent de v, λ(u) (cid:12)= λ(v).

7.3.2 Algorithmes utilisant des Messages

Un syst`eme de transition est associ´e `a chaque processus, et ce syst`eme de transi-
tion interagit avec le syst`eme de communication. Les diﬀ´erents types de transitions (ou
d’´ev´enements) associ´es `a chaque processus sont des transitions internes, des transitions
d’envoi et des transitions de r´eception. Si une transition d’envoi (resp. de r´eception) est
eﬀectu´ee, un message est cr´e´e (resp. consomm´e).
p, d´enot´e Dp est d´eﬁni par

´Etant donn´e un processus p repr´esent´e par le sommet v, l’algorithme local du processus

– l’ensemble r´ecursif Q des ´etats possibles de p,
– l’´etat initial λ(v) de p,

178

Chapitre 7. ´Echanges de Messages en Mode Asynchrone

– une relation r´ecursive (cid:24)p de transitions (transitions internes, transitions d’envoi et
Pour toute arˆete {v, v

transitions de r´eception).

(cid:2)} ∈ E(G), on note M(v, v
messages en transit entre le processus p (resp. p
et le processus p
ensembles M(v, v

(cid:2) (resp. p) correspondant au sommet v
(cid:2)) sont vides.

(cid:2)

(cid:2)) (resp. M(v
, v)) le multi-ensemble des
(cid:2)) correspondant au sommet v (resp. v
(cid:2))
(cid:2) (resp. v). Initialement, tous les

Pour tout processus p repr´esent´e par un sommet v, l’´etat de p est not´e state(p) et

une transition associ´ee au processus p est not´ee sous la forme

(c, in, m) (cid:24)p (d, out, m

(cid:2)

),

(cid:2)

, v) tel que δv(v

(cid:2)

, v), o`u v

(cid:2) est le sommet tel que δv(v

(cid:2)) = in.

(cid:2) = ⊥ (m

(cid:2) = ⊥ (m et m

– Si in (cid:12)= 0, alors out = 0 et m

o`u c et d sont des ´etats, in et out sont des entiers, et m et m
transition a la signiﬁcation suivante.
– Si in = out = 0, alors m = m

(cid:2) sont des messages. Une telle
(cid:2) ne sont pas d´eﬁnis) et cela repr´esente
une transition interne. Cette transition ne peut ˆetre eﬀectu´ee que si l’´etat de p est
c. Lorsque cette transition est eﬀectu´ee, l’´etat de p devient d.
(cid:2) n’est pas d´eﬁni) et cela repr´esente une
transition de r´eception. Cette transition ne peut ˆetre appliqu´ee que si l’´etat de p est
c et qu’il existe un message m ∈ M(v
(cid:2)) = in. Lorsque cette transition
est eﬀectu´ee, l’´etat du processus devient d et une occurrence de m est eﬀac´ee de
M(v
– Si out (cid:12)= 0, alors in = 0 et m = ⊥ (m n’est pas d´eﬁni) et cela repr´esente une
transition d’envoi. Cette transition ne peut ˆetre eﬀectu´ee que si l’´etat du processus
(cid:2)
p est c. Lorsque cette transition est eﬀectu´ee, l’´etat de p devient d et un message m
est ajout´e `a M(v, v
Un algorithme distribu´e utilisant des ´echanges de messages D pour le r´eseau (G, δ)
est une collection d’algorithmes locaux Dp (un pour chaque processus p associ´e `a chaque
sommet de G). Un tel algorithme est not´e D = (Dp)p∈P . Une transition de l’algorithme
distribu´e est une transition eﬀectu´ee par un processus du syst`eme.
Remarque 7.19 On consid`ere g´en´eralement des algorithmes distribu´es tels que deux pro-
(cid:2) dans le mˆeme ´etat puissent eﬀectuer les mˆemes transitions. Cependant, si p
cessus p, p
(cid:2) ne pourra pas envoyer ou recevoir de
peut communiquer avec plus de processus que p
messages par le port deg(v) o`u v est le sommet correspondant `a p.
(cid:2) de
mˆeme degr´e, (cid:24)p=(cid:24)p(cid:2). Si on ne veut pas que deux processus correspondant `a des sommets
de mˆeme degr´e ex´ecutent les mˆemes transitions, on utilise l’´etiquetage initial des sommets
pour que les processus aient des comportements diﬀ´erents.

(cid:2) correspondant respectivement `a des sommets v, v

(cid:2) est le sommet tel que δv(v

Ainsi, pour tous processus p, p

(cid:2), p

(cid:2)), o`u v

(cid:2)) = out.

De cette mani`ere, un algorithme n’a pas besoin d’ˆetre d´eﬁni pour un r´eseau particulier,
mais il suﬃt de d´ecrire pour tout entier d, les transitions que peuvent eﬀectuer les processus
de degr´e d.

Par la suite, sauf si c’est explicitement indiqu´e, on ne consid`ere que des algorithmes

respectant cette propri´et´e.

Remarque 7.20 Si on consid`ere des syst`emes distribu´es dont les canaux de communica-
(cid:2))
tion pr´eservent l’ordre des messages (canaux FIFO), il faut voir chaque ensemble M(v, v
comme une ﬁle.

7.4. Codage du R´eseau

179

Lorsqu’une transition d’envoi (c, in, m) (cid:24)p (d, out, m

correspondant `a un sommet v, une occurrence de m
(cid:2) est le sommet tel que δv(v
(cid:2)) o`u v
pondant `a M(v, v
(c, in, m) (cid:24)p (d, out, m
(cid:2)) peut ˆetre eﬀectu´ee si m est le message en tˆete de la ﬁle M(v
(cid:2) est le sommet tel que δv(v
v

(cid:2)) = in ; auquel cas, la tˆete de la ﬁle M(v

(cid:2)) est eﬀectu´ee par un processus p
(cid:2) est ajout´e en queue de la ﬁle corres-
(cid:2)) = out. Une transition de r´eception
, v) o`u

, v) est supprim´ee.

(cid:2)

(cid:2)

Dans ce chapitre, sauf si c’est explicitement indiqu´e, on ne consid`ere que des syst`emes

distribu´es dont les canaux de communication pr´eservent l’ordre des messages.

Ex´ecution d’un Algorithme utilisant des ´Echanges de Messages

M0), (state1, M1), . . . , (statei, Mi), . . . telle que :

Une ex´ecution ρ d’un algorithme utilisant des messages est d´eﬁni par une suite (state0,
(cid:2)) de messages en transit entre les

– pour tout i, Mi est l’ensemble des ensembles Mi(v, v
(cid:2),
sommets v et v
(cid:2)} ∈ E(G), M0(v, v
, v) = ∅,
– pour toute {v, v
– pour tout i et tout processus p, statei(p) est l’´etat du processus p,
– pour tout processus p, state0(p) = λ(p) est l’´etat initial de p,
– pour toute ´etape i, il existe un unique processus p tel que :

(cid:2)) = M0(v

(cid:2)

(cid:2) (cid:12)= p, alors statei+1(p

(cid:2)) = statei(p

(cid:2)),

– si p
– statei+1(p) et Mi+1 sont obtenus `a partir de statei(p) et Mi par une transition

eﬀectu´ee par le processus p.
Par d´eﬁnition, (statei, Mi) est une conﬁguration du r´eseau. L’ex´ecution ρ de l’algorithme
est d´eﬁnie par E = (statei, Mi)i≥0.

Une conﬁguration ﬁnale est une conﬁguration dans laquelle aucune transition n’est
applicable. On suppose que dans une conﬁguration ﬁnale, aucun message n’est en transit.
Autrement dit, pour tout processus p correspondant `a un sommet v, pour tout ´etat c,
s’il n’existe aucune transition de la forme (c, 0,⊥) (cid:24)p (d, out, m) (i.e., lorsque p est dans
l’´etat c, il ne peut ni envoyer de message, ni eﬀectuer de transition interne), alors pour tout
message m et pour tout entier in ∈ [1, deg(v)], il existe une transition (c, in, m) (cid:24)p (d, 0,⊥).
´Etant donn´ee une ex´ecution qui atteint une conﬁguration ﬁnale, la longueur de l’ex´ecu-

tion est la longueur de la s´equence (state0, M0), (state1, M1), . . . , (statei, Mi), . . .
Remarque 7.21 Comme Tel l’explique ([Tel00] p. 46), les syst`emes de transition sont des
mod`eles th´eoriques de syst`emes distribu´es. Cependant, les algorithmes qu’on va ´etudier ne
seront pas d´ecrits par l’´enum´eration de leurs ´etats et de leurs transitions, mais en utilisant
le pseudo-code habituel. La mise `a jour de l’´etat d’un sommet se fera `a l’aide de variables
et les transitions d’envois et de r´eception de messages seront exprim´ees respectivement `a
l’aide des primitives envoyer et recevoir.

7.4 Codage du R´eseau

On explique dans cette section comment repr´esenter un r´eseau par un graphe dirig´e
sym´etrique aﬁn de pouvoir exprimer simplement les conditions n´ecessaires que doit v´eriﬁer
un r´eseau admettant un algorithme d’´election. On pr´esente ensuite un codage du r´eseau
sous la forme d’un graphe simple qui permet d’obtenir des r´esultats d’impossibilit´e en
utilisant les r´esultats du Chapitre 3.

180

Chapitre 7. ´Echanges de Messages en Mode Asynchrone

2

1

1

2

(G, δ)

←→
(
G , δ)

2

1

1

2

2

1

2

1

1

1

2

2

(2, 1)

(1, 2)

(2, 1)

(1, 2)

(1, 2)

(2, 1)

(1, 2)

(2, 1)

(Dir(G), δ)

2

2

1

1

1

2

1

2

Fig. 27 – Un graphe G avec un ´etiquetage de ports δ, sa repr´esentation sous forme de
graphe dirig´e et sa repr´esentation sous forme de graphe simple ´etiquet´e.

7.4.1

´Etiquetage des Ports et Graphes Dirig´es Sym´etriques

Un r´eseau est repr´esent´e par un graphe simple ´etiquet´e (G, δ) o`u G = (G, λ) est un
graphe simple dont seuls les sommets sont ´etiquet´es et o`u δ est une fonction d’´etiquetage
des ports.
`A chaque r´eseau (G, δ), on associe le graphe dirig´e sym´etrique (Dir(G), δ) o`u tout
sommet u ∈ V (Dir(G)) est ´etiquet´e comme dans G et o`u tout arc au,u(cid:2) ∈ A(Dir(G))
(cid:2)), δu(cid:2)(u)). On remarque que pour
tel que s(a) = u et t(a) = u
tout arc au,u(cid:2) ∈ A(Dir(G)) ´etiquet´e (p, q), l’arc sym´etrique Sym(au,u(cid:2)) est ´etiquet´e (q, p) :
l’´etiquetage des arcs du graphe dirig´e obtenu est sym´etrique. Par ailleurs, puisque δ est
une fonction d’´etiquetage des ports, on remarque que l’´etiquetage des arcs ainsi obtenu est
d´eterministe et cod´eterministe. Une telle repr´esentation d’un r´eseau (G, δ) est pr´esent´ee
sur la Figure 27.

(cid:2) est ´etiquet´e par (δu(u

7.4.2 Codage du R´eseau avec un Graphe Simple ´Etiquet´e

On consid`ere un graphe dirig´e ´etiquet´e D = (D, λ) o`u seuls les sommets sont ´etiquet´es.

On va maintenant associer un graphe simple ´etiquet´e `a D.

`A chaque arc a dont on note la source u et la cible v, on associe un sommet canal(a)

7.4. Codage du R´eseau

181

et deux arˆetes {u, canal(a)}, {canal(a), v}. On consid`ere maintenant le graphe simple non-
´etiquet´e
– V (

←→
←→
D d´eﬁnit de la mani`ere suivante :
D ) = V (D) ∪ (cid:4)
a∈A(D)
←→
{{s(a), canal(a)},{canal(a), t(a)}}.
D ) =
←→
D le graphe ´etiquet´e (

{canal(a)}

(cid:4)

– E(

a∈A(D)
←→
D ) ∪ E(

On note
Pour tout x ∈ V (
sinon. La fonction d’´etiquetage κ code la fonction de chaque sommet ou arˆete de
d´eﬁnie de la mani`ere suivante :

←→
←→
D , (κ, λ)) o`u λ et κ sont d´eﬁnies de la mani`ere suivante.
D ), λ(x) est l’´etiquette de x dans D si x ∈ V (D) et λ(x) = 
←→
D et est

– ∀u ∈ V (D), κ(u) = process,
– ∀a ∈ A(D), κ(canal(a)) = transmission,
– ∀a ∈ A(D), κ({s(a), canal(a)}) = send,
– ∀a ∈ A(D), κ({tran(a), s(a)}) = receive.
On suppose maintenant qu’il existe une fonction δ d’´etiquetage des arcs de D telle
que pour tout arc a ∈ A(D), il existe p, q tels que δ(a) = (p, q). On ´etend δ en une
←→
fonction d’´etiquetage partielle des arˆetes de
D de la mani`ere suivante. Pour tout arc
a ∈ A(D) ´etiquet´e (p, q) dont la source est u et la cible est v, on pose δ({u, canal(a)}) = p
et δ({canal(a), v}) = q.
On suppose maintenant que D est un graphe dirig´e sym´etrique D et on consid`ere une
fonction δ d’´etiquetage des arcs sym´etrique telle que pour tout arc a ∈ A(D), il existe
p, q tels que δ(a) = (p, q) et δ(Sym(a)) = (q, p). Dans ce cas, on remarque que pour tout
arc a dont la source est u et la cible est v, δ({u, canal(a)}) = δ({canal(Sym(a)), u}) et
δ({canal(a), v}) = δ({v, canal(Sym(a))}).

´Etant donn´e un r´eseau (G, δ) o`u G est un graphe simple et δ est une fonction d’´etique-
←→
G le graphe simple obtenu lorsque la construction d´ecrite pr´ec´e-

tage des ports, on note
demment est appliqu´ee sur le graphe dirig´e (Dir(G), δ).
Remarque 7.22 Sur les ﬁgures, on repr´esente les sommets avec des formes particuli`eres
d´ependant de leurs images par κ :

– chaque sommet u tel que κ(u) = process est repr´esent´e par un sommet rond,
– chaque sommet u tel que κ(u) = canal est repr´esent´e par un sommet carr´e,

←→
De plus, pour tout arˆete {u, v} ∈ E(
D ) telle que κ(u) = process et κ(v) = canal, on
repr´esente l’arˆete {u, v} par un arc allant de u `a v si κ({u, v}) = send et par un arc allant
de v `a u si κ({u, v}) = receive.

Sur les Figures 27 et 28, des exemples de graphes obtenus par cette construction sont

pr´esent´es.

7.4.3 Coder un Algorithme utilisant des ´echanges de Messages en Mode

Asynchrone

On explique dans cette partie comment tout algorithme utilisant des ´echanges de mes-
sages en mode asynchrone sur un r´eseau (G, δ) peut ˆetre transformer en un algorithme
utilisant des calculs locaux sur les arˆetes ´etiquet´ees sur le graphe (
On consid`ere un r´eseau (G, δ) et le graphe simple ´etiquet´e (

←→
G , δ).
←→
G , δ) obtenu `a partir
de (G, δ). On explique maintenant comment coder les diﬀ´erentes instructions que peut

182

Chapitre 7. ´Echanges de Messages en Mode Asynchrone

←→
ex´ecuter un processus de G ainsi que les ´ev´enements de transmission de messages en
utilisant des calculs locaux sur les arˆetes. L’´etiquette de chaque sommet v de
G est de la
forme (κ(v), λ(v)) et chaque r`egle de r´e´etiquetage ne peut modiﬁer que λ(v).

– Une instruction qui modiﬁe l’´etat d’un processus est cod´e par une r`egle de r´e´etique-
tage pouvant ˆetre appliqu´ee sur sommet v tel que κ(v) = process. Cette r`egle ne
modiﬁe que l’´etiquette d’un sommet v et ne d´epend que de l’´etiquette de ce sommet.
– Une instruction d’envoi de message est cod´e par une r`egle de r´e´etiquetage sur une
arˆete {u, v} telle que κ(u) = process, κ(v) = canal et κ({u, v}) = send. Cette r`egle
ne modiﬁe pas l’´etiquette de l’arˆete, mais seulement λ(u) et λ(v).
– Une instruction de r´eception de message est cod´e par une r`egle de r´e´etiquetage sur
une arˆete {u, v} telle que κ(u) = process, κ(v) = canal et κ({u, v}) = receive.
Cette r`egle ne modiﬁe pas l’´etiquette de l’arˆete, mais seulement λ(u) et λ(v).

(cid:2)).

, δ

(cid:2).

(cid:2)), alors (

, δ

(cid:2)

(cid:2)), le graphe simple (

, δ

←→
D , δ) est un revˆetement de (

←→
D (cid:2)

On montre d’abord que si un graphe dirig´e (D, δ) est un revˆetement dirig´e d’un graphe

(cid:2)).
, δ
(cid:2)) tels que (D, δ) est un revˆetement

(cid:2)) `a travers un homomorphisme γ. On d´eﬁnit un homomorphisme ϕ de
(cid:2)), δ
←→
, λ
(cid:2) de la mani`ere suivante. Pour tout sommet u ∈ V (
D

La m´ethode qu’on a pr´esent´e permet de coder un algorithme distribu´e o`u les processus
communiquent par ´echange de messages en mode asynchrone en utilisant des calculs locaux
←→
sur les arˆetes. Cependant, il existe des algorithmes utilisant des calculs locaux sur les
G , δ) ne correspondent pas forc´ement `a des
arˆetes dont les ex´ecutions sur le graphe (
ex´ecutions sur G d’un algorithme o`u les processus communiquent par ´echange de message.
N´eanmoins, cette construction nous permet d’obtenir un lemme de rel`evement et des
r´esultats d’impossibilit´e.
←→
←→
dirig´e (D(cid:2)
D (cid:2)
D , δ) est un revˆetement de (
Lemme 7.23 Pour tous graphes dirig´es (D, δ), (D(cid:2)
, δ
dirig´e de (D(cid:2)
←→
Preuve : On consid`ere un graphe dirig´e ((D, λ), δ) qui est un revˆetement dirig´e de
←→
((D
D
D ) tel que u ∈ V (D), alors
dans
ϕ(u) = γ(u). Pour tout arc a ∈ A(D), on pose ϕ(canal(a)) = canal(γ(a)). Il est clair que
←→
←→
ϕ est un homomorphisme de
D
D ) tel que u ∈ V (D), κ(u) = κ(γ(u)) = κ(ϕ(u)) =
process et λ(u) = λ(γ(u)) = λ(ϕ(u)). Puisque pour tout arc a, κ(canal(a)) =
κ(ϕ(canal(a))) = transmission et que λ(canal(a)) = λ(ϕ(canal(a))) = , l’homomor-
←→
phisme ϕ pr´eserve l’´etiquetage des sommets.
Par ailleurs, pour toute arˆete {u, v} ∈ E(
D ) telle que κ(u) = process, κ(v) = canal
et κ({u, v}) = send (resp. κ({u, v}) = send), il existe un arc a ∈ A(D) tel que s(a) =
u (resp. t(a) = u) et canal(a) = v. Puisque γ(u) = s(γ(a)) (resp. γ(u) = t(γ(a))),
κ({γ(u), canal(γ(a))}) = send (resp. κ({γ(u), canal(γ(a))}) = receive) et κ(ϕ({u, v})) =
κ({u, v}). De plus, pour tout arc a ∈ A(D), il existe (p, q) tels que δ(a) = (p, q) et on
sait que δ(γ(a)) = (p, q). Ainsi, δ({s(a), canal(a)}) = δ({ϕ(s(a)), ϕ(canal(a))}) = p et
δ({canal(a), t(a)}) = δ({ϕ(canal(a)), ϕ(t(a))}) = q. L’homomorphisme ϕ pr´eserve donc
l’´etiquetage.
D’autre part, pour tout sommet u ∈ V (D), pour tout arc a ∈ A(D) tel que s(a) = u
(cid:2)) = γ(u) (resp.
(cid:2)) = γ(u)).
D (u)) = ϕ({canal(a) |
Ainsi pour tout sommet u ∈ V (

←→
D dans
De plus, pour tout sommet u ∈ V (

(resp. t(a) = u), il existe exactement un arc a
t(a

(cid:2) = γ(a) ∈ A(D

(cid:2)) tel que s(a

←→
D ) tel que u ∈ V (D), ϕ(N←→

7.5. Un Algorithme d’´Enum´eration

183

(D, δ

(cid:2))

(2, 1)

(1, 2)

1

2

1

2

←→
(
D , δ

(cid:2))

Fig. 28 – Un graphe dirig´e D avec un ´etiquetage sym´etrique des arcs et sa repr´esentation
sous forme de graphe simple ´etiquet´e.

(cid:2) | s(a
s(a) = u ou t(a) = u}) = canal({γ(a) | s(a) = u ou t(a) = u}) = canal({a
(cid:2)) =
(cid:2) ∈ A(D
(cid:2)) | s(a) =
γ(u) ou t(a
D (u)|, l’homomor-
γ(u) ou t(a) = γ(u)}| = |{a ∈ A(D) | s(a) = uou t(a) = u}| = |N←→
phisme ϕ est bien localement bijectif.

D (cid:2)(γ(u)) et puisque |N←→

(cid:2)) = γ(u)}) = N←→

D (cid:2)(γ(u))| = |{a

←→
D , δ) est un revˆetement de (

←→
D (cid:2)

Ainsi, (

(cid:2)) `a travers ϕ.

, δ

2

Un corollaire int´eressant du Lemme 7.23 est le r´esultat d’impossibilit´e suivant qui est

obtenu `a partir de la Proposition 3.22.

Proposition 7.24 Soit G un graphe simple et δ une fonction d’´etiquetage des ports de G
tel que (Dir(G), δ) n’est pas minimal pour les revˆetements dirig´es sym´etriques. Il n’existe
pas d’algorithme o`u les processus communiquent par ´echange de message qui permette de
r´esoudre l’´election, l’´enum´eration ou le nommage dans le r´eseau (G, δ).

Exemple 7.25 Si on consid`ere le graphe G de la Figure 27 avec l’´etiquetage des ports
←→
δ indiqu´es sur la ﬁgure. Il est facile de voir que (Dir(G), δ) est un revˆetement dirig´e
←→
G , δ) est un revˆetement
sym´etrique du graphe (D, δ
(cid:2)) et il n’existe donc pas d’algorithme d’´election ou de nommage utilisant des ´echanges
(
D , δ
de messages pour le graphe G avec l’´etiquetage des ports δ.

(cid:2)) de la Figure 28. Ainsi, le graphe (

7.5 Un Algorithme d’´Enum´eration

On pr´esente maintenant un algorithme d’´enum´eration inspir´e de l’algorithme de Ma-

zurkiewicz et adapt´e au mod`ele ´etudi´e dans ce chapitre.
Durant l’ex´ecution de l’algorithme, chaque sommet u essaie d’obtenir une identit´e qui
est un num´ero entre 1 et |V (G)|. Chaque sommet u va ensuite envoyer son num´ero `a chacun
de ses voisins v, en leur indiquant le num´ero du port δu(v). Lorsqu’un sommet u re¸coit le
num´ero n d’un de ses voisins v, il m´emorise le triplet (n, δu(v), δv(u)) aﬁn de construire sa
vue locale. Ensuite, chaque sommet va diﬀuser dans tout le graphe son num´ero et sa vue
locale. Si un sommet u d´ecouvre qu’un autre sommet v a le mˆeme num´ero que lui, alors le
sommet u doit d´ecider s’il modiﬁe son identit´e. Pour cela, il compare son ´etiquette initiale
λ(u) et sa vue locale avec l’´etiquette initiale λ(v) et la vue locale de v : si l’´etiquette de
u est plus faible que l’´etiquette de v ou si les deux sommets ont la mˆeme ´etiquette et que
la vue locale de u est plus «faible» (pour un ordre qu’on expliquera par la suite), alors
le sommet u choisit un nouveau num´ero (sa nouvelle identit´e temporaire), en informe ses
voisins et diﬀuse `a nouveau son num´ero et sa vue locale. Lorsque l’ex´ecution est termin´ee,

184

Chapitre 7. ´Echanges de Messages en Mode Asynchrone

si le graphe (Dir(G), δ) est minimal pour les revˆetements dirig´es, alors chaque sommet a
un num´ero unique : l’algorithme permet de r´esoudre le probl`eme du nommage.

7.5.1

´Etiquettes

On consid`ere un graphe G = (G, λ) o`u λ: V (G) → L est un ´etiquetage initial des
sommets, qui ne sera pas modiﬁ´e par l’algorithme. On suppose qu’il existe une fonction
δ ´etiquetage des ports de G. Lors de l’ex´ecution, l’´etat de chaque sommet va ˆetre cod´e
par une ´etiquette de la forme (λ(v), n(v), N(v), M(v)) qui repr´esente les informations
suivantes :

l’ex´ecution.

l’algorithme,

l’information la plus r´ecente que v a de ses voisins. Si le sommet v a un voisin v
que δv(cid:2)(v) = p et δv(v
num´ero qu’avait v
est toujours un ensemble ﬁni de triplets de N3.

– la premi`ere composante λ(v) est l’´etiquette initiale et ne sera pas modiﬁ´ee lors de
– n(v) ∈ N est le num´ero courant du sommet v qui est modiﬁ´e lors de l’ex´ecution de
– N(v) ∈ Pﬁn(N3) est la vue locale du sommet v. Informellement, la vue locale contient
(cid:2) tel
(cid:2)) = q, alors le couple (n, p, q) apparaˆıt dans N(v) si n est le
(cid:2). Ainsi N(v)
– M(v) ⊆ N × L × Pﬁn(N3) est la boˆıte-aux-lettres de v. Elle va contenir toute l’infor-
mation re¸cue par v lors de l’ex´ecution de l’algorithme, i.e., les couples de num´eros
et de vues locales qui auront ´et´e diﬀus´ees par tous les sommets du graphe.
Initialement, chaque sommet a une ´etiquette de la forme (λ(v), 0,∅,∅) qui signiﬁe qu’au
d´ebut de l’algorithme, v n’a pas choisi de num´ero et qu’il n’a aucune information `a propos
de ses voisins, ni `a propos des autres sommets du graphe.

(cid:2) dans le dernier message re¸cu par v et envoy´e par v

Dans notre algorithme, les processus communiquent en ´echangeant des messages de la
(cid:2), alors

forme < (n, nold, M), p >. Si un processus v envoie un message `a un de ses voisins v
< (n, nold, M), p > contient les informations suivantes.

– n est le num´ero courant n(v) de v.
– nold est l’ancien num´ero de v, i.e., le num´ero que v avait lorsqu’il a envoy´e le message
(cid:2). Dans le cas o`u v n’a pas modiﬁ´e son message entre-temps, n = nold.

pr´ec´edent `a v

– M est la boˆıte-aux-lettres de v.
– p est le port par lequel le message a ´et´e envoy´e, i.e., p = δv(v

(cid:2)).

7.5.2 Un Ordre sur les Vues Locales

(cid:2), p = p

(cid:2), ou si n = n

Comme pour l’algorithme de Mazurkiewicz [Maz97] et les algorithmes pr´esent´es dans
les chapitres pr´ec´edents, les bonnes propri´et´es de l’algorithme reposent sur un ordre sur
les vues locales, i.e., sur les ensembles ﬁnis de triplets de N3. Pour cela, on consid`ere que
(cid:2)
(cid:2), ou si n = n
N3 est muni de l’ordre lexicographique usuel : (n, p, q) < (n
et p < p
Ensuite, on utilise le mˆeme ordre sur les ensembles que Mazurkiewicz : ´etant donn´es
deux ensembles N1, N2 ∈ Pﬁn(N3) distincts, on dit que N1 ≺ N2 si le maximum pour
l’ordre lexicographique sur N3 de la diﬀ´erence sym´etrique N1(cid:17) N2 = (N1\ N2)∪ (N2 \ N1)
appartient `a N2.
Si N(u) ≺ N(v), alors on dit que la vue locale N(v) de v est plus forte que celle de u
et que N(u) est plus faible que N(v). En utilisant l’ordre total <L de L, on ´etend l’ordre

(cid:2)) si n < n

(cid:2) et q < q

, p

, q

(cid:2).

(cid:2)

(cid:2)

7.5. Un Algorithme d’´Enum´eration

≺ pour obtenir un ordre total sur L×Pﬁn(N× L× N) : ((cid:8), N) ≺ ((cid:8)
si (cid:8) = (cid:8)

, N
(cid:2). Par la suite, on notera (cid:19) la clˆoture r´eﬂexive de ≺.

(cid:2) et N ≺ N

(cid:2)

(cid:2)) si (cid:8) <L (cid:8)

185

(cid:2) ou bien

7.5.3 L’Algorithme

L’algorithme d’´enum´eration est L’Algorithme 1. Cet algorithme est d´ecrit par deux
r`egles. La premi`ere r`egle I ne peut ˆetre appliqu´ee que par un processus v0 qui lorsqu’il se
r´eveille n’a encore re¸cu aucun message. Dans ce cas l`a, le sommet choisit le num´ero 1, met
`a jour sa boˆıte-aux-lettres et informe ses voisins de son nouveau num´ero et de sa nouvelle
boˆıte-aux-lettres.

(cid:2)

, n

(cid:2)
old, M

La seconde r`egle R explique les op´erations eﬀectu´ees par un processus v0 lorsqu’il re¸coit
(cid:2)), p > d’un de ses voisins par le port q. Il met d’abord `a jour sa
un message < (n
(cid:2). Il modiﬁe ensuite
boˆıte-aux-lettres en ajoutant `a sa boˆıte-aux-lettres les ´el´ements de M
son num´ero s’il existe un triplet (n(v0), (cid:8), N) ∈ M(v0) tel que (λ(v0), N(v0)) ≺ ((cid:8), N).
(cid:2)
old, p, q) de N(v0) (s’il ´etait pr´esent)
Puis, il met `a jour sa vue locale en eﬀa¸cant le triplet (n
, p, q). Il ajoute ensuite le triplet (n(v0), λ(v0), N(v0)) `a sa
et en y ajoutant le triplet (n
boˆıte-aux-lettres M(v0). Finalement, si sa boˆıte-aux-lettres a bien ´et´e modiﬁ´ee lors de
l’ex´ecution de cette suite d’instruction, il envoie son num´ero et sa boˆıte-aux-lettres `a tous
ses voisins.

(cid:2)

Si la boˆıte-aux-lettres d’un sommet n’est pas modiﬁ´ee lors de l’ex´ecution de la r`egle R,
cela signiﬁe que l’information `a propos du num´ero du voisin dont il a re¸cu un message ´etait
(cid:2) apparaissait d´ej`a dans M(v0) et
correcte, que toutes les informations contenues dans M
que pour tout (n(v0), (cid:8), N) ∈ M(v0), ((cid:8), N) (cid:19) (λ(v0), N(v0)).

7.5.4 Propri´et´es de l’Algorithme 1

On consid`ere un graphe G avec un ´etiquetage des ports δ et une ex´ecution ρ de
l’Algorithme 1 sur (G, δ). Pour chaque sommet v, une transition interne est le «traitement»
d’un message, i.e., l’ex´ecution des instructions de mise `a jour de son ´etat une fois qu’un
message a ´et´e re¸cu, mais pas les ex´ecutions d’envoi de message. Si un sommet ex´ecute
la r`egle I, la transition interne correspondante est la mise `a jour de son num´ero et de sa
boˆıte-aux-lettres.
L’ex´ecution ρ est donc d´ecrite par une suite (statei, Mi). Pour tout sommet v ∈ V (G),
on note (λ(v), ni(v), Ni(v), Mi(v)) les valeurs des variables λ(v), n(v), N(v) et M(v) apr`es
la i`eme ´etape de l’ex´ecution ρ. On remarque que si lors d’une ´etape i, une transition
d’envoi ou de r´eception est eﬀectu´ee, la valeur de (λ(v), n(v), N(v), M(v)) n’est modiﬁ´ee
pour aucun sommet.

Le lemme suivant, qui peut ˆetre facilement prouv´e par une r´ecurrence sur la longueur
de l’ex´ecution, rappelle quelque propri´et´es simples qui sont toujours satisfaites par l’´etat
de chaque sommet.
Lemme 7.26 Pour tout sommet v ∈ V (G

(cid:2)), et pour toute transition i,

(cid:2)) = q et δv(cid:2)(v) = p,

(cid:2) ∈ NG(v) tel que δv(v

1. ∃(n, p, q) ∈ Ni(v) ⇐⇒ ∃v
2. ni(v) (cid:12)= 0 =⇒ (ni(v), λ(v), Ni(v)) ∈ Mi(v),
3. ∀(n, p, q) ∈ Ni(v), n (cid:12)= 0 et ∃(n, (cid:8)
(cid:2)
(cid:2)) ∈ Ni(v), q (cid:12)= q
4. ∀(n, p, q), (n

(cid:2)) ∈ Mi(v),

, N
(cid:2),

, p

, q

(cid:2)

(cid:2)

186

Chapitre 7. ´Echanges de Messages en Mode Asynchrone

Algorithme 1 : L’algorithme d’´enum´eration.
I : {n(v0) = 0 et aucun message n’a ´et´e re¸cu par v0}
d´ebut

n(v0) := 1;
M(v0) := {(n(v0), λ(v0),∅)};
pour i := 1 `a deg(v0) faire

envoyer < (n(v0), 0, M(v0)), i > par le port i ;

ﬁn
R : {Un message < (n
d´ebut

(cid:2)

(cid:2)
old, M

, n

(cid:2)), p > est arriv´e `a v0 par le port q}

(cid:2);

Mold := M(v0);
nold := n(v0);
M(v0) := M(v0) ∪ M
si n(v0) = 0 ou ∃(n(v0), (cid:8), N) ∈ M(v0) tel que (λ(v0), N(v0)) ≺ ((cid:8), N) alors
n(v0) := 1 + max{n | ∃(n, (cid:8), N) ∈ M(v0)};
N(v0) := N(v0) \ {(n
, p, q)};
M(v0) := M(v0) ∪ {(n(v0), λ(v0), N(v0))};
si M(v0) (cid:12)= Mold alors

old, p, q)} ∪ {(n
(cid:2)

(cid:2)

pour i := 1 `a deg(v0) faire

envoyer < (n(v0), nold, M(v0)), i > par le port i;

ﬁn

5. ∀(n(v0), (cid:8), N) ∈ Mi(v), ((cid:8), N) (cid:19) (λ(v0), N(v0)),
6. (n, p, q) ∈ Ni(v) si et seulement si le dernier message re¸cu par v par le port q ´etait

de la forme < (n, M), p >.

L’Algorithme 1 a des propri´et´es de monotonicit´e int´eressantes qui sont donn´ees dans

le lemme suivant.
Lemme 7.27 Pour chaque sommet v et chaque transition i,

– ni(v) ≤ ni+1(v),
– Ni(v) (cid:19) Ni+1(v),
– Mi(v) ⊆ Mi+1(v).

Si ni(v) (cid:12)= ni+1(v), alors ni+1(v) > max{n

Preuve : On suppose qu’une transition interne est appliqu´ee `a l’´etape i + 1 sur un
sommet v. La propri´et´e est trivialement vraie pour les sommets distincts de v. qui ne sont
pas r´e´etiquet´es lors de la (i+1)`eme ´etape. De plus, il est facile de voir que Mi(v) ⊆ Mi+1(v).
(cid:2)) ∈ Mi(v)}. De plus, ou bien
ni(v) = 0 < ni+1(v), ou alors d’apr`es le Lemme 7.26, (ni(v), λ(v), Ni(v)) ∈ Mi(v) et donc
ni(v) < ni+1(v).
(cid:2)), p > par un port q
et Ni+1(v) = Ni(v) \{(n
(cid:2)) = q
old, p, q) /∈ Ni(v), cela signiﬁe que mes est le premier
(cid:2)
et on sait que δv(cid:2)(v) = p. Si (n
message re¸cu par v `a travers le port q et alors max Ni+1(v) (cid:17) Ni(v) = (n
, p, q) ∈ Ni+1(v)
et Ni(v) ≺ Ni+1(v).

Si Ni(v) (cid:12)= Ni+1(v), alors v a re¸cu un message mes =< (n

(cid:2) le voisin de v tel que δv(v

, p, q)}. On note v

old, p, q)} ∪{(n
(cid:2)

(cid:2) | ∃(n

(cid:2)

, (cid:8)

, N

(cid:2)

(cid:2)

(cid:2)

(cid:2)
old, M

, n

(cid:2)

7.5. Un Algorithme d’´Enum´eration

187

Si (n

old, p, q) ∈ Ni(v), alors n
(cid:2)

(cid:2)
old(cid:2)

le sommet v
max Ni+1(v) (cid:17) Ni(v) = (n

(cid:2) a envoy´e le message mes, on sait que n

old ≤ n
(cid:2)
, p, q) ∈ Ni+1(v) et Ni(v) ≺ Ni+1(v).

(cid:2)

(cid:12)= n

(cid:2). Si on consid`ere l’´etape j < i lors de laquelle
(cid:2)). Par cons´equent,

(cid:2) = nj(v

2

(cid:2).

(cid:2)) = m

(cid:2) tel que ni(v

(cid:2) tel que ni(v) = m

Les informations dont dispose chaque sommet v dans sa boˆıte-aux-lettres permettent
d’obtenir des informations v´eriﬁ´ees par la conﬁguration globale du graphe. Les deux
lemmes suivants permettent de prouver que si un sommet v connaˆıt un num´ero m `a
(cid:2) ≤ m, il
une ´etape i (i.e., il existe (cid:8), N tels que (m, (cid:8), N) ∈ Mi(v)), alors pour chaque m
(cid:2). On montre d’abord que si v connaˆıt un num´ero
existe un sommet v
m, alors il existe un sommet v
Lemme 7.28 Pour chaque sommet v ∈ V (G) et chaque ´etape i, pour tout (m, (cid:8), N) ∈
Mi(v), il existe un sommet w ∈ V (G) tel que ni(w) = m.
Preuve : On remarque d’abord qu’un triplet (m, (cid:8), N) est ajout´e `a une ´etape i dans
(cid:4)
Mi(v) seulement s’il existe un sommet v tel que ni(v) = m, λ(v) = (cid:8) et Ni(v) = N.
v∈V (G)
´Etant donn´e un sommet v, une ´etape i et un triplet (m, (cid:8), N) ∈ Mi(v), on note U =
{(u, j) ∈ V (G)× N | j ≤ i, nj(u) = m}. On consid`ere ensuite l’ensemble U
(cid:2) = {(u, j) ∈ U |
(cid:2) ≤
∀(u
(cid:2)), Nj(cid:2)(u
(cid:2)
j}. Puisque (m, (cid:8), N) ∈ Mi(v), U et U
(cid:2) sont deux ensembles non-vides. On remarque
ais´ement qu’il existe i0 tel que pour tout (u, j) ∈ U
(cid:2), j = i0.
Si i0 < i, on consid`ere un ´el´ement (u, i0) ∈ U
(cid:2). Le num´ero ni0(u) = m de u a donc
´et´e modiﬁ´e `a l’´etape i0 + 1, mais par maximalit´e de (λ(u), Ni0(u)), le sommet u n’a pas
pu modiﬁ´e son num´ero. Par cons´equent, i0 = i et il existe donc un sommet w tel que
ni(w) = m.
2

(cid:2))) ≺ (λ(u), Nj(u)) ou (λ(u

(cid:2))) = (λ(u), Nj(u)) et j

(cid:2)) ∈ U, (λ(u

(cid:2)), Nj(cid:2)(u

, j

Dans le lemme suivant, on montre que si un sommet v connaˆıt un num´ero m, alors il

connaˆıt tous les num´eros inf´erieurs `a m.
Lemme 7.29 Pour chaque sommet v et chaque ´etape i, pour tout (m, (cid:8), N) ∈ Mi(v), pour
tout m

(cid:2) ∈ [1, m], il existe (m

(cid:2)) ∈ Mi(v).

, N

, (cid:8)

(cid:2)

(cid:2)

Preuve : On montre ce lemme par r´ecurrence sur i. Initialement, la propri´et´e est tri-
vialement vraie. On suppose que la propri´et´e est v´eriﬁ´ee pour i ≥ 0. On suppose qu’une
transition interne est eﬀectu´ee par un sommet v lors de l’´etape i + 1.
Si le sommet v a appliqu´ee la r`egle I, alors, Mi(v) = {(1, λ(v0),∅)} et la propri´et´e est

trivialement vraie.

(cid:2)

(cid:2)
old, M

(cid:2)), p > d’un sommet v

(cid:2). On note j l’´etape lors de laquelle le sommet v

Si le sommet v a appliqu´ee la r`egle R, alors le sommet v a re¸cu un message mes =<
(cid:2) a envoy´e
, n
(cid:2)). Si le sommet v ne modiﬁe pas son num´ero lors de
(cid:2) = Mj(v
(cid:2)) et la propri´et´e est conserv´ee par hypoth`ese de
(cid:2) modiﬁe son num´ero, alors ni+1(v) = 1 + max{n | ∃(n, (cid:8), N) ∈
(cid:2)) ∪ {(ni+1(v), λ(v), Ni+1(v)}. Dans ce cas

(n
le message et on sait que M
l’´etape i+1, alors Mi+1(v) = Mi(v)∪Mj(v
r´ecurrence. Si le sommet v
Mi(v) ∪ Mj(v
aussi, la propri´et´e est donc conserv´ee.

(cid:2))} et Mi+1(v) = Mi(v) ∪ Mj(v

2

On veut maintenant montrer que toute ex´ecution de l’algorithme M termine sur G. On
sait qu’un sommet v peut envoyer un message apr`es avoir eﬀectuer une transition interne
seulement s’il a modiﬁ´e son ´etiquette lors de cette transition interne. Ainsi, il est suﬃsant

188

Chapitre 7. ´Echanges de Messages en Mode Asynchrone

de montrer qu’il existe une ´etape i `a partir de laquelle les sommets ne modiﬁent plus leurs
´etiquettes. D’apr`es les Lemmes 7.28 et 7.29, on voit qu’`a chaque ´etape de l’ex´ecution, les
num´eros des sommets forment un ensemble [1, k] ou un ensemble [0, k] avec k ≤ |V (G)|.
Par cons´equent, d’apr`es le Lemme 7.27, on sait qu’il existe une ´etape i0 telle que pour tout
sommet v et toute ´etape i ≥ i0, ni+1(v) = ni(v). De plus, on sait que pour tout sommet v,
Ni(v) ne peut prendre qu’un nombre ﬁni de valeurs et par cons´equent, pour tout sommet
v, Mi(v) ne peut prendre qu’un nombre ﬁni de valeurs. Ainsi, d’apr`es le Lemme 7.27, on
sait que toute ex´ecution de M sur G termine.

Propri´et´es Satisfaites par l’´Etiquetage Final

Puisqu’on sait que l’algorithme termine toujours, on s’int´eresse maintenant aux pro-
pri´et´es satisfaites par l’´etiquetage ﬁnal. On sait que lorsque l’algorithme est termin´e, tous
les messages envoy´es sont arriv´es `a destination.
Lemme 7.30 Toute ex´ecution ρ de l’algorithme M sur un graphe simple ´etiquet´e G =
(G, λ) avec un ´etiquetage des ports δ termine et l’´etiquetage ﬁnal (λ, nρ, Nρ, Mρ) des som-
mets v´eriﬁe les propri´et´es suivantes :

1. il existe un entier k ≤ |V (G)| tel que {nρ(v) | v ∈ V (G)} = [1, k],

et pour tous sommets v, v

(cid:2) :

(cid:2)),

2. Mρ(v) = Mρ(v
3. (nρ(v), λ(v), Nρ(v)) ∈ Mρ(v
4. si nρ(v) = nρ(v
5. (n, p, q) ∈ Nρ(v) si et seulement s’il existe un sommet w ∈ NG(v) tel que δv(w) = q,

(cid:2)), alors λ(v) = λ(v

(cid:2)) et Nρ(v) = Nρ(v

(cid:2)),

(cid:2)),

δw(v) = p et nρ(w) = n.

Preuve :

1. D’apr`es les Lemmes 7.28 et 7.29 et puisque tout sommet a appliqu´e au moins une

des r`egles I, R.

2. Puisque tous les messages envoy´es par chaque sommet sont arriv´es et qu’`a chaque

fois qu’un sommet modiﬁe sa boˆıte-aux-lettres, il l’envoie `a ses voisins.

3. C’est une cons´equence directe de la propri´et´e pr´ec´edente d’apr`es le Lemme 7.26.
4. D’apr`es le Lemme 7.26.
5. D’apr`es le Lemme 7.26 et puisque tous les messages envoy´es sont arriv´es.

2

(cid:2)).

Grˆace au Lemme 7.30, on peut prouver que l’´etiquetage ﬁnal permet de construire un
(cid:2)) tel que (Dir(G), δ) est un revˆetement dirig´e sym´etrique

graphe dirig´e sym´etrique (D, δ
de (D, δ
Proposition 7.31 ´Etant donn´e un graphe G = (G, λ) avec un ´etiquetage des ports δ,
on peut construire, `a partir de l’´etiquetage ﬁnal obtenu apr`es une ex´ecution ρ de l’Algo-
(cid:2) tel que (G, δ) est un
rithme 1, un graphe D avec un ´etiquetage sym´etrique des arcs δ
revˆetement dirig´e sym´etrique de (D, δ

(cid:2)).

7.5. Un Algorithme d’´Enum´eration

189

(cid:2)(Sym(a(n,p,q,m))) = δ

On d´eﬁnit un homomorphisme γ de (Dir(G), λ) dans (D, δ

Preuve : On utilise les notations du Lemme 7.30.
On consid`ere le graphe dirig´e D d´eﬁni par V (D) = {m ∈ N | ∃v ∈ V (G), nρ(v) = m},
A(D) = {a(n,p,q,m) | ∃{v, w} ∈ E(G) telle que nρ(v) = n, nρ(w) = m, δv(w) = p, δw(v) =
q} et pour tout arc a(n,p,q,m), s(a(n,p,q,m)) = n et t(a(n,p,q,m)) = m. On d´eﬁnit la fonc-
tion Sym : A(D) → A(D) de la mani`ere suivante : pour tout arc a(n,p,q,m) ∈ A(D),
Sym(a(n,p,q,m)) = a(m,q,p,n). On remarque que pour tout arc a(n,p,p,n), Sym(a(n,p,p,n)) =
a(n,p,p,n).
On d´eﬁnit un ´etiquetage η des sommets de D de la mani`ere suivante. Pour tout v ∈
(cid:2) ∈ V (G) ont le mˆeme
V (G), η(nρ(v)) = λ(v). D’apr`es le Lemme 7.30, si deux sommets v, v
(cid:2)) et par cons´equent, cet ´etiquetage est bien d´eﬁni. On d´eﬁnit
num´ero, alors λ(v) = λ(v
(cid:2) des arcs de D de la mani`ere suivante : pour tout arc a(n,p,q,m) ∈ A(D),
un ´etiquetage δ
(cid:2)(a(n,p,q,m)) = (p, q). Ainsi, pour tout arc a(n,p,q,m), δ
(cid:2)(a(m,q,p,n)) =
δ
(q, p) et l’´etiquetage des arcs de D est bien un ´etiquetage sym´etrique.
(cid:2)) de la mani`ere suivante.
Pour tout sommet v ∈ V (G), γ(v) = nρ(v) et pour tout arc a ∈ A(Dir(G)), γ(a) =
a(nρ(s(a)),δs(a)(t(a)),δt(a)(s(a)),nρ(t(a))). Puisque pour tout arc a ∈ A(Dir(G)), s(γ(a)) =
nρ(s(a)) = γ(s(a)) et t(γ(a)) = nρ(t(a)) = γ(t(a)), γ est un homomorphisme de Dir(G)
dans D. Puisque pour tout arc a ∈ A(Dir(G)), δ(a) = (δs(a)(t(a)), δt(a)(s(a))) = δ
(cid:2)(γ(a))
et puisque pour tout sommet v ∈ V (Dir(G)), λ(v) = η(γ(v)), l’homomorphisme γ est
(cid:2)). De plus, pour tout arc a ∈ A(Dir(G)),
un homomorphisme de (Dir(G), δ) dans (D, δ
γ(Sym(a)) = a(nρ(t(a)),δt(a)(s(a)),δs(a)(t(a)),nρ (s(a))) = Sym(γ(a)).
Pour tout arc a(n,p,q,m) ∈ A(D), il existe une arˆete {v, w} telle que nρ(v) = n, δv(w) =
q, δw(v) = p et nρ(w) = m. D’apr`es le Lemme 7.30, on sait que pour tout sommet
−1(n) (resp. u ∈ γ
u ∈ γ
−1(m)), Nρ(u) = Nρ(v) (resp. Nρ(u) = Nρ(w)) et par cons´equent,
d’apr`es le Lemme 7.30 et puisque δ est une bijection entre NG(u) et [1, degG(u)], il existe
(cid:2)) = q) et
un unique u
δu(cid:2)(u) = q (δu(cid:2)(u) = p). Ainsi, pour tout arc a(n,p,q,m) ∈ A(D), pour tout sommet u ∈
−1(t(a))), il existe un unique arc a ∈ Dir(G) tel que γ(a) = a(n,p,q,m)
−1(s(a)) (resp. u ∈ γ
γ
et s(a) = u (resp. t(a) = u). Par cons´equent, (Dir(G), δ) est un revˆetement sym´etrique
de (D, δ
2

(cid:2) ∈ NG(u) tel que nρ(u

(cid:2)) = m (resp. nρ(u

(cid:2)) = n), δu(u

(cid:2)) = p (δu(u

(cid:2)).

On consid`ere maintenant un graphe G avec un ´etiquetage des ports δ tel que
(Dir(G), δ) est minimal pour les revˆetements dirig´es sym´etriques. Pour chaque ex´ecution
ρ de l’Algorithme 1 sur (G, δ), le graphe dirig´e obtenu `a partir de l’´etiquetage ﬁnal est
isomorphe `a (Dir(G), δ). Par cons´equent, l’ensemble des num´eros des sommets est exac-
tement [1,|V (G)|] : chaque sommet a un identiﬁant unique.

L’Algorithme 1 permet donc r´esoudre le nommage sur tout graphe G avec un ´etiquetage
des ports δ tel que (Dir(G), δ) est minimal pour les revˆetements dirig´es sym´etriques.
Cependant, si aucune information n’est disponible `a propos de (G, δ), les sommets ne
peuvent pas d´etecter la terminaison.

N´eanmoins, il est possible de d´etecter la terminaison pour un r´eseau (G, δ) donn´e
(l’algorithme d´epend alors de (G, δ)). En eﬀet, une fois qu’un sommet a obtenu le num´ero
|V (G)|, d’apr`es les Lemmes 7.28 et 7.29, il sait que tous les sommets de G ont un num´ero
unique qui ne va plus ˆetre modiﬁ´e. Dans ce cas l`a, on peut aussi r´esoudre le probl`eme de
l’´election, puisque ce sommet peut prendre l’´etiquette ´elu et diﬀuser ensuite l’information
qu’un sommet a ´et´e ´elu.

190

Chapitre 7. ´Echanges de Messages en Mode Asynchrone

Par ailleurs, d’apr`es la Proposition 7.24, pour tout graphe G avec un ´etiquetage des
ports δ tel que (Dir(G), δ) n’est pas minimal pour les revˆetements dirig´es, il n’existe aucun
algorithme utilisant des ´echanges de messages qui permette de r´esoudre les probl`emes du
nommage ou de l’´election sur G. On a donc prouv´e le th´eor`eme suivant.
Th´eor`eme 7.32 Pour tout graphe simple ´etiquet´e G avec un ´etiquetage des ports δ, les
assertions suivantes sont ´equivalentes :

1. il existe un algorithme de nommage (ou d’´enum´eration) pour (G, δ) utilisant des

´echanges de message,

2. il existe un algorithme d’´election et un algorithme de nommage (ou d’´enum´eration)

avec d´etection de la terminaison pour (G, δ) utilisant des ´echanges de messages,

3. (Dir(G), δ) est minimal pour les revˆetements dirig´es sym´etriques.

Remarque 7.33 ´Etant donn´e un graphe G avec un ´etiquetage des ports δ tel que
(Dir(G), δ) est minimal pour les revˆetements dirig´es, pour d´etecter que l’Algorithme 1
a attribu´e un identiﬁant unique `a chaque sommet, il suﬃt de connaˆıtre le nombre de som-
mets de G. Ainsi, l’Algorithme 1 permet de r´esoudre l’´election ainsi que le nommage avec
d´etection de la terminaison sur les r´eseaux (G, δ) de taille donn´ee tels que (Dir(G), δ) est
minimal pour les revˆetements dirig´es.

Comme Yamashita et Kameda, on souhaite caract´eriser les graphes G dans lesquels
les probl`emes d’´election et de nommage peuvent ˆetre r´esolus quel que soit la fonction
d’´etiquetage des ports choisie. Cette caract´erisation, pr´esent´ee dans le th´eor`eme suivant,
est un corollaire de la Proposition 7.12 et du Th´eor`eme 7.32. On rappelle qu’un algorithme
d’´election pour un graphe G permet de r´esoudre l’´election sur G quel que soit l’´etiquetage
des ports.
Th´eor`eme 7.34 Pour tout graphe simple ´etiquet´e G, il existe un algorithme qui r´esout
l’´election (ou le nommage) sur G si et seulement si Dir(G) est minimal pour les revˆete-
ments dirig´es sym´etriques.

7.5.5 Remarques sur l’Algorithme

Contrairement aux algorithmes de Yamashita et Kameda [YK99] et de Boldi et al.
[BCG+96], l’Algorithme 1 est un algorithme totalement asynchrone, au sens o`u une fois
qu’un sommet a envoy´e un message `a tous ses voisins, il n’a pas besoin d’attendre d’avoir
re¸cu un message de chacun de ses voisins avant de pouvoir envoyer `a nouveau des messages.
Une cons´equence int´eressante est que certaines ex´ecutions de l’Algorithme 1 permettent
d’´elire dans des graphes qui ne sont pas minimaux pour les revˆetements dirig´es comme le
montre la proposition suivante.
Proposition 7.35 Pour tout r´eseau (G, δ), il existe une ex´ecution de l’Algorithme 1 sur
(G, δ) qui permet de r´esoudre nommage et ´election sur (G, δ).
Preuve : ´Etant donn´e un r´eseau (G, δ), on consid`ere une ex´ecution o`u un seul sommet
v0 applique la r`egle I et o`u tous les autres sommets commencent `a ex´ecuter l’algorithme
uniquement lorsqu’ils re¸coivent un message. En d’autres termes, tous les sommets sont
initialement endormis, et il y a un unique sommet v0 qui initie le calcul. Ainsi, pour tout
sommet v ∈ V (G) diﬀ´erent de v0, `a chaque fois que v modiﬁe son num´ero, il existe un triplet

7.5. Un Algorithme d’´Enum´eration

191

(1, λ(v0),∅) dans M(v) et par cons´equent, le sommet v ne prend jamais le num´ero 1. Ainsi,
si on consid`ere l’´etiquetage ﬁnal obtenu `a la ﬁn de l’ex´ecution, il existe un seul sommet
dont le num´ero est 1. Par cons´equent, d’apr`es la Proposition 7.14 et la Proposition 7.31,
on sait que chaque num´ero apparaissant dans l’´etiquetage ﬁnal des sommets est unique.
Ainsi, l’ex´ecution d´ecrite permet de r´esoudre le nommage et l’´election sur (G, δ).
2
Cependant, pour tout r´eseau (G, δ), il existe une ex´ecution «canonique» de l’Algo-
rithme 1 sur (G, δ) qui permet de r´esoudre le nommage sur (G, δ) si et seulement si
(Dir(G), δ) est minimal pour les revˆetements dirig´es sym´etriques.

Une ex´ecution est synchrone est ex´ecution en rondes. Lors d’une ronde, chaque som-
met re¸coit tous les messages qui lui ont ´et´e envoy´es lors de la ronde pr´ec´edente, puis il
modiﬁe son ´etat en fonction des messages re¸cus et il envoie ensuite autant de messages que
n´ecessaires `a ses voisins. En particulier, pour toute ex´ecution synchrone de l’Algorithme 1
sur un r´eseau (G, δ), tous les sommets de G ex´ecutent la r`egle I lors de la premi`ere ronde.
La proposition suivante est similaire aux r´esultats d’impossibilit´e pr´esent´es par Yama-

shita et Kameda [YK99] et Boldi et al. [BCG+96].
Proposition 7.36 Pour tout r´eseau (G, δ), si on consid`ere une ex´ecution synchrone ρ de
l’Algorithme 1 sur (G, δ), le graphe dirig´e reconstruit `a partir de l’´etiquetage ﬁnal est la
base minimale de (Dir(G), δ).
(cid:2)) la base minimale de (Dir(G), δ)
Preuve : ´Etant donn´e un r´eseau (G, δ), on note (D, δ
(cid:2)).
et γ l’homomorphisme localement bijectif de (Dir(G), δ) dans (D, δ
(cid:2)), les sommets v et v
(cid:2) ont initialement la
mˆeme ´etiquette et appliquent tous les deux la r`egle I et envoient les mˆemes messages `a
leurs voisins. De plus, pour tout sommet u ∈ NG(v), il existe un sommet u
(cid:2)) tel
(cid:2)). Par cons´equent, lors de toute ronde i, les sommets v
que δv(cid:2)(u
(cid:2) re¸coivent les mˆemes messages de leurs voisins, modiﬁent leurs ´etiquettes de la mˆeme
et v
mani`ere et envoient les mˆemes messages `a leurs voisins.
(cid:2) ∈ V (G) tels que
(cid:2)). Ainsi, le graphe dirig´e reconstruit `a partir de

Par cons´equent, dans la conﬁguration ﬁnale, pour tous sommets v, v

(cid:2)) = δv(u) et γ(u) = γ(u

(cid:2) tels que γ(v) = γ(v

Pour tous sommets v, v

(cid:2) ∈ NG(v

(cid:2)), n(v) = n(v
γ(v) = γ(v
l’´etiquetage ﬁnal est (D, δ

(cid:2)) et N(v) = N(v
(cid:2)).

2

(cid:2)

, N

, N

(cid:2)) ∈ M(v) tels que ((cid:8)

Comme dans les mod`eles ´etudi´es dans les chapitres pr´ec´edents, on se rend compte que
la boˆıte-aux-lettres de chaque sommet contient beaucoup d’informations inutiles. En eﬀet,
si un triplet (n, (cid:8), N) apparaˆıt dans la boˆıte-aux-lettres M(v) d’un sommet v, on peut
(cid:2)) ≺ ((cid:8), N). De cette
supprimer de M(v) tous les triplets (n, (cid:8)
mani`ere, la boˆıte-aux-lettres de chaque sommet contient au plus |V (G)| triplets (n, (cid:8), N).
Par ailleurs, il n’est pas forc´ement n´ecessaire d’assurer que les canaux de communi-
cation pr´eservent l’ordre des messages. En eﬀet, lorsqu’un sommet v re¸coit un message
> n, alors
< (n, M), p > par le port q, s’il existe un triplet (n
(cid:2)), p > `a travers le port q qui contenait une
v sait qu’il a d´ej`a re¸cu un message < (n
(cid:2)) = q. De plus, on
information plus `a jour `a propos de l’´etat de son voisin v
sait aussi que M ⊆ M
(cid:2) et par cons´equent, le sommet v peut tout simplement ignorer un
> n.
message < (n, M), p > par le port q s’il existe un triplet (n
Cependant, le fait de supposer que les canaux de communication pr´eservent l’ordre des
messages permet d’obtenir un algorithme n´ecessitant des messages de plus petite taille.
En eﬀet, `a chaque fois qu’un sommet modiﬁe sa boˆıte-aux-lettres, il envoie tout le contenu

(cid:2) tel que δv(v
(cid:2)

, p, q) ∈ N(v) tel que n

, p, q) ∈ N(v) tel que n

, M

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

192

Chapitre 7. ´Echanges de Messages en Mode Asynchrone

de sa boˆıte-aux-lettres `a tous ses voisins. Il est toutefois suﬃsant de ne renvoyer que les
informations qui ont ´et´e ajout´ees lorsque le sommet v0 a modiﬁ´e sa boˆıte-aux-lettres, i.e.,
dans l’Algorithme 1, il suﬃt d’envoyer les ´el´ements de M(v0) \ Mold.

L’Algorithme 1 a ´et´e impl´ement´e sous ViSiDiA en utilisant le fait que les canaux de
communication pr´eservent l’ordre des messages et en r´eduisant la taille des boˆıte-aux-
lettres et des messages comme on l’a indiqu´e.

7.5.6 Complexit´e

On s’int´eresse ici `a la complexit´e de l’Algorithme 1. Pour cela, on ´etudie la complexit´e
en message et la complexit´e en temps. On s’int´eresse aussi `a la taille des messages et `a la
taille de la m´emoire utilis´e par chaque sommet.

Comme dans [Tel00] (p.71), la complexit´e en temps est mesur´ee en supposant que
les transitions eﬀectu´ees par chaque sommet n´ecessitent z´ero unit´es de temps et que le
temps de transmission d’un message (i.e., le temps entre l’´emission et la r´eception d’un
message) se fait en une unit´e de temps. Cela correspond au nombre de rondes eﬀectu´ees
lors d’une ex´ecution synchrone de l’algorithme. On note que les propri´et´es de correction
de l’algorithme sont ind´ependantes de ces suppositions.
On suppose que l’´etiquetage initial λ du graphe G est tel que chaque ´etiquette initiale
(cid:8) a une taille en O(log |V (G)|) bits (ce qui est suﬃsant pour attribuer des ´etiquettes
diﬀ´erentes `a tous les sommets de G).

(cid:2)

(cid:2)

On consid`ere une ex´ecution, o`u chaque sommet n’envoie `a ses voisins que les triplets
qu’il a rajout´e dans sa boˆıte-aux-lettres, et non pas toute sa boˆıte-aux-lettres `a chaque
´etape. De plus, on suppose qu’il envoie ses triplets un par un, i.e., les messages ´echang´es
(cid:2))}), p > et si un sommet doit envoyer plusieurs triplets `a
sont de la forme < (n,{(n
ses voisins, il envoie plusieurs messages.
Proposition 7.37 Pour tout r´eseau (G, δ) `a n sommets, m arˆetes, de degr´e maximum
Δ et de diam`etre D, toute ex´ecution de l’Algorithme 1 sur (G, δ) n´ecessite O(Dn2) unit´es
de temps et O(m2n) messages de taille O(Δ log n) bits. De plus, chaque processus utilise
O(Δn log n) bits de m´emoire.

, N

, (cid:8)

Preuve : On consid`ere un r´eseau (G, δ) `a n sommets, m arˆetes, de degr´e maximum Δ
et de diam`etre D. On consid`ere une ex´ecution ρ de l’Algorithme 1 sur (G, δ). D’apr`es les
Lemmes 7.28 et 7.29, on sait que chaque sommet ne modiﬁe pas son num´ero plus de n
fois.

Pour tout sommet v, puisque les num´eros de v et de ses voisins ne peuvent qu’aug-
menter, le couple (n(v), N(v)) peut prendre au plus (d(v) + 1)n valeurs diﬀ´erentes. `A
chaque fois que le sommet v modiﬁe son num´ero ou sa vue locale, cela peut g´en´erer au
plus O(m) messages, puisqu’un sommet qui `a d´ej`a le triplet (n(v), λ(v), N(v)) dans sa
boˆıte-aux-lettres ne diﬀuse plus cette information. Ainsi, toute ex´ecution de l’algorithme
n´ecessite O(m2n) messages. Puisqu’on suppose que tous les messages utilis´es sont de la
(cid:2))}), p > et que pour tout sommet v, N(v) contient au plus Δ
forme < (n,{(n
´el´ements qui sont tous inf´erieurs `a n, la taille des messages utilis´es est O(Δ log n) bits.

`A chaque fois qu’un sommet v modiﬁe son num´ero ou sa vue locale, en D unit´es de
temps, tous les sommets de G connaissent le triplet (n(v), λ(v), N(v)). De plus, `a chaque
fois qu’un sommet v modiﬁe son num´ero, les voisins de v mettent `a jour leur vues locales en

, N

, (cid:8)

(cid:2)

(cid:2)

7.6. ´Election dans les Familles de Diam`etre Born´e

193

une unit´e de temps. Ainsi, une fois qu’un sommet a modiﬁ´e son num´ero, tous les sommets
de G ont la mˆeme boˆıte-aux-lettres au bout de D + 1 unit´es de temps si aucun sommet
ne modiﬁe son num´ero entre-temps. Si tous les sommets ont la mˆeme boˆıte-aux-lettres et
s’il n’y a plus de messages en transit, on sait d’apr`es le Lemme 7.26 que l’ex´ecution est
termin´ee. Par cons´equent, puisqu’il y a au plus n(n−1)
changements de num´eros lors de
l’ex´ecution de l’algorithme, il faut au plus O(Dn2) unit´es de temps pour que l’algorithme
termine.

2

Pour chaque sommet v, n(v) peut ˆetre repr´esent´e avec log n bits et N(v) peut ˆetre
repr´esent´e avec O(Δ log n) bits. Puisque chaque sommet v conserve que l’information utile
dans sa boˆıte-aux-lettres, il existe au plus n triplets (n0, (cid:8), N) dans M(v) et chacun de ces
triplets peut ˆetre repr´esent´e avec O(Δ log n) bits. Par cons´equent, on peut repr´esenter la
boˆıte-aux-lettres de chaque sommet avec O(Δn log n) bits. Ainsi, chaque sommet a besoin
de O(Δn log n) bits de m´emoire pour stocker son ´etat.
2

Remarque 7.38 Pour tout r´eseau (G, δ),
les algorithmes de Yamashita et Kameda
[YK96b] et de Boldi et al. [BCG+96] n´ecessitent O(n) unit´es de temps et O(mn) mes-
sages de taille 2O(n) bits ; de plus, chaque processus n´ecessite 2O(n) bits de m´emoire.

Ainsi, l’Algorithme 1 est un algorithme qui n´ecessite des messages et une m´emoire de
tailles polynomiales, alors que les algorithmes connus jusqu’`a pr´esent utilisaient des mes-
sages de taille exponentielle. Par ailleurs, l’Algorithme 1 utilise des structures de donn´ees
simples et a donc pu ˆetre impl´ement´e sous ViSiDiA.

7.6

´Election dans les Familles de Diam`etre Born´e

On montre dans cette partie que pour pouvoir ´elire dans un r´eseau (G, δ) minimal
pour les revˆetements dirig´es sym´etriques, il n’est pas n´ecessaire de connaˆıtre la taille de
G, mais qu’une borne sur le diam`etre suﬃt. On pr´esente une adaptation de l’algorithme
GSSP d´ecrit dans le Chapitre 2 qui permet de v´eriﬁer que tous les sommets du graphe
ont la mˆeme boˆıte-aux-lettres. L’algorithme SSP [SSP85] a ´et´e d´ecrit dans le cadre des
´echanges de messages et il n’est donc pas surprenant qu’on puisse obtenir un algorithme
GSSP dans ce cadre.

Comme dans les chapitres pr´ec´edents, chaque sommet dispose d’un rayon de conﬁance
a(v) et d’un ensemble A(v) contenant l’information dont v dispose `a propos du rayon de
conﬁance de ses voisins. Comme pr´ec´edemment, `a chaque fois qu’un sommet v modiﬁe sa
boˆıte-aux-lettres, le sommet v r´einitialise a(v) et A(v). Si un sommet v s’aper¸coit que son
rayon de conﬁance est inf´erieur ou ´egal au rayon de conﬁance de tous ses voisins, alors
il peut augmenter son propre rayon de conﬁance. De plus, `a chaque fois qu’un sommet v
modiﬁe son rayon de conﬁance, il en informe ses voisins, aﬁn que ceux-ci mettent `a jour
l’information dont ils disposent `a propos de v. Ainsi, les messages ´echang´es sont de la forme
< (n, nold, M, a), p > o`u la seule diﬀ´erence avec l’Algorithme 1 est le champ a qui contient
le rayon de conﬁance du sommet qui envoie le message. L’adaptation de l’Algorithme 1
prenant en compte ces modiﬁcations est l’Algorithme 2.

On s’int´eresse maintenant aux propri´et´es satisfaites par toute ex´ecution de l’Algo-
rithme 2. Comme pr´ec´edemment, on consid`ere une ex´ecution de l’algorithme sur un r´eseau
(G, δ). Pour tout sommet v ∈ V (G), on note (λ(v), ni(v), Ni(v), Mi(v), ai(v), Ai(v)) les va-
leurs des variables λ(v), n(v), N(v), M(v), a(v) et A(v) apr`es la i`eme ´etape de l’ex´ecution.

194

Chapitre 7. ´Echanges de Messages en Mode Asynchrone

envoie < (n(v0), 0, M(v0), a(v0)), i > par le port i ;

ﬁn
R : {Un message < (n
d´ebut

(cid:2)

(cid:2)
old, M

, n

(cid:2)

(cid:2)), p > est arriv´e `a v0 par le port q}
, a

(cid:2);

Mold := M(v0);
nold := n(v0);
aold := a(v0);
M(v0) := M(v0) ∪ M
si n(v0) = 0 ou ∃(n(v0), (cid:8), N) ∈ M(v0) tel que (λ(v0), N(v0)) ≺ ((cid:8), N) alors
n(v0) := 1 + max{n | ∃(n, (cid:8), N) ∈ M(v0)};
, p, q)};
N(v0) := N(v0) \ {(n
M(v0) := M(v0) ∪ {(n(v0), λ(v0), N(v0))};
si M(v0) (cid:12)= Mold alors

old, p, q)} ∪ {(n
(cid:2)

(cid:2)

Algorithme 2 : L’algorithme d’´enum´eration utilisant GSSP.
I : {n(v0) = 0 et aucun message n’a ´et´e re¸cu par v0}
d´ebut

n(v0) := 1;
M(v0) := {(n(v0), λ(v0),∅)};
a(v0) := 0;
A(v0) := {(q,−1) | q ∈ [1, degG(v0)]};
pour i := 1 `a deg(v0) faire

(cid:2) alors

a(v0) := 0 ;
A(v0) := {(q,−1) | q ∈ [1, degG(v0)]};
A(v0) := A(v0) \ {(q, a
a(v0) := 1 + max{a | ∃(p, a) ∈ A(v0)};

si M(v0) = M
(cid:2)(cid:2)) | (q, a
si ∀(p, a) ∈ A(v), a(v0) ≤ a alors
si M(v0) (cid:12)= Mold ou a(v0) (cid:12)= aold alors

(cid:2)(cid:2)) ∈ A(v0)} ∪ {(q, a

(cid:2))};

pour i := 1 `a deg(v0) faire

envoie < (n(v0), nold, M(v0), a(v0)), i > par le port i;

ﬁn

7.6. ´Election dans les Familles de Diam`etre Born´e

195

Le lemme suivant qui peut ˆetre facilement prouv´e par r´ecurrence sur le nombre d’´etapes
montre que le rayon de conﬁance d’un sommet ne peut qu’augmenter tant que sa boˆıte-
aux-lettres n’est pas modiﬁ´ee.
Lemme 7.39 Pour tout sommet v et toute ´etape i, si Mi(v) = Mi+1(v), alors ai+1(v) ≥
ai(v) et si ni(v) (cid:12)= 0, pour tout p ∈ [1, degG(v)], il existe (p, a) ∈ Ai(v) et (p, a
(cid:2)) ∈ Ai+1(v)
tels que a

(cid:2) ≥ a ≥ ai+1(v) − 1.

Dans le lemme suivant, on montre que le rayon de conﬁance d’un sommet permet d’ob-
tenir des informations sur le contenu des boˆıtes-aux-lettres d’autres sommets du graphe
lors d’´etapes pr´ec´edentes de l’ex´ecution. Cette propri´et´e correspond aux propri´et´es d´ecrites
dans les Lemmes 2.28 et 3.47 pour les algorithmes des Chapitres 2 et 3.
Lemme 7.40 Pour tout sommet v ∈ V (G) et toute ´etape i, pour tout sommet w ∈ V (G)
tel que distG(v, w) ≤ ai(v), il existe une ´etape j ≥ i telle que aj(w) ≥ ai(v) − distG(v, w)
et Mj(v) = Mi(v).

Preuve : On fait une d´emonstration par r´ecurrence sur la distance k entre v et w dans
G. Si k = 0, la propri´et´e est trivialement vraie. On suppose maintenant que la propri´et´e
est vraie pour tous sommets v, w tels que distG(v, w) ≤ k.
On consid`ere deux sommets v, w et une ´etape i tels que ai(v) ≥ k + 1 ≥ 1 et
distG(v, w) = k + 1. Il existe un sommet u ∈ NG(v) tels que distG(u, w) = k. On sait
qu’il existe (δv(u), a) ∈ Ai(v) tel que a ≥ ai(v) − 1 ≥ 0. On consid`ere l’´etape j
< i lors
de laquelle le dernier message re¸cu par v par le port δv(u) a ´et´e envoy´e par u. On sait que
Mj(cid:2)(u) = Mi(v) et aj(cid:2)(u) = a ≥ ai(v)− 1. Par hypoth`ese de r´ecurrence, on sait qu’il existe
(cid:2) telle que aj(w) ≥ aj(cid:2)(u)− k ≥ ai(v)−(k+1) et Mj(w) = Mj(cid:2)(u) = Mi(v).
une ´etape j < j
Ainsi, la propri´et´e est v´eriﬁ´ee pour tous sommets v, w `a distance k + 1 dans G.

2

(cid:2)

Comme dans l’algorithme GSSP des Chapitres 2 et 3, on montre que si `a un moment
donn´e, un sommet a un rayon de conﬁance sup´erieur au diam`etre du graphe, alors tous
les sommets du graphe ont la mˆeme boˆıte-aux-lettres et ont tous un rayon de conﬁance
sup´erieur `a 0.
Lemme 7.41 S’il existe un sommet v et une ´etape i telle que ai(v) ≥ D(G) + 1, alors
pour tout w ∈ V (G), Mi(w) = Mi(v) et ai(v) ≥ 0.
Preuve : Puisque ai(v) > D(G), on sait d’apr`es le Lemme 7.40 que pour tout sommet
w ∈ V (G), il existe une ´etape iw < i telle que aiw ≥ 1 et Miw(w) = Mi(v).
Supposons qu’il existe un sommet w tel que Mi(w) (cid:12)= Miw(w). Soit j l’´etape de
l’ex´ecution lors de laquelle pour la premi`ere fois, la boˆıte-aux-lettres d’un sommet w
qui valait Mi(v) a ´et´e modiﬁ´ee. Autrement dit, pour tout sommet w ∈ V (G), il existe
(cid:2) ≥ j − 1 telle que Mj(cid:2)(w) = Mi(v) et il existe un sommet w tel que
une ´etape j
Mj−1(w) = Mi(v) (cid:4) Mj(w). On consid`ere le message mes =< (n, nold, M, a), p > re¸cu
par w qui a ´et´e trait´e `a l’´etape j et on note q le port par lequel il est arriv´e et u le voisin
(cid:2) lors de
de w tel que δw(u) = q. En raison du choix de j, on sait que lors de l’´etape j
laquelle le message ´et´e envoy´e par u, Mj(cid:2)(u) = M ⊆ Mj(w).
On sait que aj−1(w) ≥ 1 et il existe donc un couple (δw(u), a) ∈ A(w) tel que a ≥ 0.
(cid:2)(cid:2) ≤ j − 1 lors de laquelle le sommet u a envoy´e un message
Ainsi, il existe une ´etape j
mes(cid:2) =< (n, nold, Mj−1(w), a), p > et alors, Mj(cid:2)(cid:2)(u) = Mj−1(w). Puisque le message mes(cid:2)
est arriv´e avant le message mes et que les canaux de communication pr´eservent l’ordre

196

Chapitre 7. ´Echanges de Messages en Mode Asynchrone

(cid:2)(cid:2)

(cid:2). Ainsi, Mj(cid:2)(cid:2)(u) = Mj(cid:2)(u) et alors nj(cid:2)(cid:2)(u) = nj(cid:2)(u). Par
des messages, on sait que j
cons´equent, lorsque le sommet w a re¸cu le message mes, M(w) et N(w) n’ont pas ´et´e
modiﬁ´es et d’apr`es le Lemme 7.26, n(w) n’a pas pu ˆetre modiﬁ´e non plus. Par cons´equent,
Mj(w) = Mj−1(w) et pour tout sommet w ∈ V (G), Mi(w) = Mi(v).
2

< j

Ainsi, si on connaˆıt une borne B sur le diam`etre de G, l’Algorithme 2 permet de
d´etecter que l’ex´ecution de l’algorithme `a la Mazurkiewicz sous-jacent est termin´e. En
eﬀet, une fois qu’un sommet a un rayon de conﬁance sup´erieur ou ´egal `a B + 1, il sait que
tous les sommets de G ont la mˆeme boˆıte-aux-lettres et qu’ils ont leurs num´eros et vues
locales ﬁnaux.

Si on sait que le r´eseau (G, δ) est minimal pour les revˆetements dirig´es sym´etriques,
on sait d’apr`es la Proposition 7.31 que tous les sommets ont un identiﬁant unique et
dans ce cas l`a, le sommet dont le num´ero est 1 peut prendre l’´etiquette ´elu et diﬀuser
l’information. On a par cons´equent montr´e le th´eor`eme suivant.
Th´eor`eme 7.42 Pour tout entier B, il existe un algorithme d’´election et un algorithme
de nommage avec d´etection de la terminaison utilisant des ´echanges de messages pour
la famille des r´eseaux (G, δ) minimaux pour les revˆetements dirig´es sym´etriques dont le
diam`etre est born´ee par B.

Ainsi, comme dans les mod`ele consid´er´e dans les Chapitres pr´ec´edents, il n’est pas
n´ecessaire de connaˆıtre la taille pour pouvoir ´elire dans un r´eseau (G, δ) que l’on sait
minimal pour les revˆetements dirig´es sym´etriques : une borne sur la taille ou le diam`etre
est suﬃsante.

Par ailleurs, en utilisant la mˆeme preuve que dans le Chapitre 3 et la Proposition 7.14,
on montre que la connaissance d’une borne serr´ee sur la taille d’un r´eseau (G, δ) permet
ou bien de r´esoudre le probl`eme de l’´election sur (G, δ), ou bien de d´etecter que (G, δ)
n’est pas minimal pour les revˆetements dirig´es sym´etriques.
Th´eor`eme 7.43 Pour tout entier B, il existe un algorithme eﬀectif d’´election et de nom-
mage avec d´etection de la terminaison utilisant des ´echanges de messages pour la classe
des r´eseaux (G, δ) tels que V (G) ≤ B < 2|V (G)|.
Remarque 7.44 L’Algorithme 2 utilise le fait que les canaux pr´eservent l’ordre des mes-
sages, mais cette hypoth`ese n’est pas forc´ement n´ecessaire. On peut adapter l’Algorithme 2
de la mˆeme fa¸con que l’Algorithme 1 aﬁn que les propri´et´es des Lemmes 7.27 et 7.39 soient
(cid:2)), p > par
(cid:2)
pr´eserv´ees. En eﬀet, si un sommet v re¸coit un message mes =< (n
(cid:2) ≤ n et
le port q et s’il existe (q, a) ∈ A(v) et (n, q, p) ∈ N(v) tels que M
(cid:2) ≤ a , alors v peut ignorer le message mes.
a

, n
, a
(cid:2) ⊆ M(v), n

(cid:2)
old, M

(cid:2)

7.7 Des ´Etiquetages des Ports plus Faibles

Dans [YK99], Yamashita et Kameda consid`erent le mod`ele ´etudi´e dans ce chapitre
ainsi que des mod`eles l´eg`erement diﬀ´erents. Les diﬀ´erences entre ces mod`eles r´esident dans
l’existence ou la non-existence de ports d’entr´ees et de sorties. Dans le mod`ele consid´er´e
ici, chaque sommet distingue les ports par lesquels il envoie des messages et les ports par
lesquels il re¸coit les messages ; ce mod`ele est donc appel´e un mod`ele port-`a-port (qu’on
appelle P P en abr´eg´e) par Yamashita et Kameda.

7.7. Des ´Etiquetages des Ports plus Faibles

197

Dans l’algorithme de Yamashita et Kameda pour ´elire dans le mod`ele port-`a-port, `a
chaque fois qu’un sommet envoie un message, il envoie un message `a tous ses voisins (les
messages diﬀ`erent uniquement par le port de sortie). On remarque que l’Algorithme 1
fonctionne de la mˆeme mani`ere. Ainsi, dans [YK99], Yamashita et Kameda consid`ere un
autre type d’´emissions de messages, qu’ils appellent diﬀusion. Dans ce mod`ele, `a chaque
fois qu’un sommet envoie un message, il envoie le mˆeme message `a tous ses voisins (il ne
peut pas ajouter un num´ero de port au message). Le mod`ele correspondant est le mod`ele
diﬀusion-`a-port (qu’on appelle DP en abr´eg´e).

Dans [YK99], Yamashita et Kameda consid`ere aussi des mod`eles o`u lorsqu’un sommet
re¸coit un message, il ne connaˆıt pas le num´ero du port par lequel ce message est arriv´e :
tous les messages re¸cus par un sommet v arrive dans une unique boˆıte. Les mod`eles cor-
respondants sont appel´es port-`a-boˆıte (qu’on appelle P B en abr´eg´e) et diﬀusion-`a-boˆıte
(qu’on appelle DB en abr´eg´e).

7.7.1 Nommage

De la mˆeme mani`ere que dans le mod`ele port-`a-port, on peut associer un graphe dirig´e
´etiquet´e `a tout graphe G dans les autres mod`eles. ´Etant donn´e un graphe G avec un
´etiquetage des ports δ, on consid`ere le graphe Dir(G) et pour chaque mod`ele, on lui
associe une fonction d’´etiquetage des arcs d´eﬁnie de la mani`ere suivante. Pour tout arc
a ∈ A(Dir(G)), δP P (a) = (p, q), δP B(a) = (p, 0), δDP (a) = (0, q), δDB(a) = (0, 0) o`u
p = δs(a)(t(a)) et q = δt(a)(s(a)). Comme leurs noms l’indiquent, les fonctions δP P , δP B,
δDP et δDB correspondent respectivement aux mod`eles port-`a-port, port-`a-boˆıte, diﬀusion-
`a-port, diﬀusion-`a-boˆıte.
Remarque 7.45 Dans le mod`ele port-`a-port, comme expliqu´e pr´ec´edemment, l’´etiquetage
des arcs ainsi obtenu est d´eterministe, cod´eterministe et sym´etrique. Dans le mod`ele port-`a-
boˆıte, l’´etiquetage des arcs ainsi obtenu est d´eterministe. Dans le mod`ele diﬀusion-`a-boˆıte,
l’´etiquetage des arcs ainsi obtenu est cod´eterministe.

Dans le mod`ele diﬀusion-`a-boˆıte, l’´etiquetage des arcs ainsi obtenu assigne la mˆeme
´etiquette `a tous les arcs, i.e., l’´etiquetage des ports initial est inutile, puisque les processus
n’ont pas acc`es aux num´eros de ports.

Avec un argument similaire `a celui utilis´e dans la Proposition 7.36, on obtient la
proposition suivante, qui dit que pour chaque mod`ele consid´er´e, il n’existe pas d’algorithme
de nommage (resp. d’´election) pour un graphe G avec un ´etiquetage des ports δ si le
graphe dirig´e correspondant n’est pas minimal pour les ﬁbrations (resp. minimal pour les
ﬁbrations non-triviales).
Proposition 7.46 ´Etant donn´e un graphe G avec un ´etiquetage des ports δ, pour tout
mod`ele M ∈ {DP, P B, DB}, il n’existe pas d’algorithme de nommage (resp. d’´election)
dans le mod`ele M pour le r´eseau (G, δ) si (Dir(G), δM ) n’est pas minimal pour les ﬁbra-
tions (resp. minimal pour les ﬁbrations non-triviales).

Dans le mod`ele port-`a-boˆıte, on sait que (Dir(G), δP B) a un ´etiquetage des ports
(cid:2)),
(cid:2)). Par cons´equent, dans ce mod`ele, les

d´eterministes et par cons´equent, si (Dir(G), δP B) est ﬁbr´e sur un graphe dirig´e (D, δ
alors (Dir(G), δP B) est un revˆetement de (D, δ
conditions n´ecessaires pour l’´election et le nommage sont les mˆemes.

198

Chapitre 7. ´Echanges de Messages en Mode Asynchrone

R´eciproquement, il n’est pas diﬃcile que l’Algorithme 1 peut ˆetre adapt´e `a chacun
des mod`eles port-`a-boˆıte, diﬀusion-`a-port et diﬀusion-`a-boˆıte. La seule diﬀ´erence r´eside
dans le fait o`u dans les mod`eles port-`a-boˆıte et diﬀusion-`a-boˆıte, la vue locale N(v) de
chaque sommet v est un multi-ensemble, puisque les sommets ne peuvent pas distinguer
les ports par lesquels les messages arrivent. On remarque cependant que pour que chaque
sommet puisse avoir une information correcte `a propos de ses voisins, on est oblig´e d’assurer
que dans ces mod`eles, les canaux de communication pr´eservent l’ordre des messages :
un sommet ne peut pas savoir d’o`u vient un message et il ne peut donc pas d´etecter
s’il est inutile ou pas. `A l’exception de cette propri´et´e, les algorithmes obtenus dans les
mod`eles port-`a-boˆıte, diﬀusion-`a-port et diﬀusion-`a-boˆıte ont les mˆeme propri´et´es que
l’Algorithme 1 d´ecrites dans les Sections 7.5.5 et 7.5.6.
Ainsi, pour toute ex´ecution ρ de l’algorithme dans un mod`ele M ∈ {DP, P B, DB},
(cid:2)) `a partir de l’´etiquetage ﬁnal de ρ tel que
on peut reconstruire un graphe dirig´e (D, δ
(cid:2)). Par ailleurs, dans le mod`ele port-`a-boˆıte, le graphe
(Dir(G), δM ) est ﬁbr´e sur (D, δ
dirig´e (Dir(G), δP B) a un ´etiquetage des arcs d´eterministe et d’apr`es la Proposition 7.9,
(cid:2)). Grˆace aux conditions n´ecessaires pr´e-
(Dir(G), δP B) est un revˆetement dirig´e de (D, δ
sent´ees dans la Proposition 7.46, on a donc le th´eor`eme suivant qui caract´erise les graphes
o`u on peut nommer dans chacun des trois mod`eles. On note que dans le mod`ele port-`a-
boˆıte, cette caract´erisation est aussi valable pour les graphes o`u on peut r´esoudre l’´election.

Th´eor`eme 7.47 Pour tout graphe simple ´etiquet´e G avec un ´etiquetage des ports δ, on
a les caract´erisations suivantes.

1. Il existe un algorithme de nommage (ou d’´enum´eration) avec d´etection de la ter-
minaison pour (G, δ) dans le mod`ele diﬀusion-`a-port (resp. diﬀusion-`a-boˆıte) si et
seulement si (Dir(G), δDP ) (resp. (Dir(G), δDB)) est minimal pour les ﬁbrations.
2. Il existe un algorithme d’´election et un algorithme de nommage (ou d’´enum´eration)
avec d´etection de la terminaison pour (G, δ) dans le mod`ele port-`a-boˆıte si et seule-
ment si (Dir(G), δP B) est minimal pour les revˆetements dirig´es.

On remarque que l’Algorithme 2 peut aussi ˆetre ´etendu aux mod`eles port-`a-boˆıte,
diﬀusion-`a-port et diﬀusion-`a-boˆıte. Ici aussi, il faut faire attention `a utiliser un multi-
ensemble A(v) pour stocker les rayons de conﬁance de chacun des voisins de v et lorsqu’un
sommet envoie un message `a l’un de ses voisins, il lui signiﬁe aussi quel ´etait son ancien
rayon de conﬁance, aﬁn que celui-ci puisse avoir une information correcte `a propos du rayon
de conﬁance de ses voisins. Par ailleurs, il est n´ecessaire que chaque sommet connaisse son
degr´e aﬁn de pouvoir d´ecider `a quel moment, il peut augmenter son rayon de conﬁance.
Ainsi, dans le mod`ele port-`a-boˆıte (resp. diﬀusion-`a-port, diﬀusion-`a-port), il est possible
de r´esoudre le nommage sur la famille des r´eseaux (G, δ) tels que (Dir(G), δP B) est mi-
nimal pour les revˆetements dirig´es (resp. (Dir(G), δDP ) est minimal pour les ﬁbrations,
(Dir(G), δDB) est minimal pour les ﬁbrations) dont le diam`etre est born´e. On a donc un
r´esultat ´equivalent au Th´eor`eme 7.42 pour le probl`eme du nommage.

Il faut noter que dans le mod`ele port-`a-boˆıte, ce r´esultat est aussi vrai pour le probl`eme
de l’´election et qu’avec les mˆemes techniques que dans la preuve du Th´eor`eme 7.43, on peut
montrer que pour tout entier B il existe un algorithme eﬀectif d’´election et de nommage
sur la famille des r´eseaux (G, δ) tels que |V (G)| ≤ B < 2|V (G)|. On a donc aussi un
r´esultat analogue au Th´eor`eme 7.43 dans le mod`ele port-`a-boˆıte.

7.7. Des ´Etiquetages des Ports plus Faibles

199

7.7.2

´Election

On consid`ere maintenant le probl`eme de l’´election dans les mod`eles diﬀusion-`a-port et
diﬀusion-`a-boˆıte. La Proposition 7.46 d´ecrit des conditions n´ecessaires pour qu’un r´eseau
(G, δ) admette un algorithme d’´election dans ces mod`eles. On va expliquer comment uti-
liser les techniques et r´esultats de la Section 7.6 et du Chapitre 4 pour montrer que ces
conditions sont suﬃsantes.

Dans le mod`ele diﬀusion-`a-port (resp. diﬀusion-`a-boˆıte), pour tout r´eseau (G, δ), on
(cid:2)) tel que
peut en connaissant une borne sur le diam`etre de G reconstruire un graphe (D, δ
(cid:2)). Ainsi, en utilisant les techniques
(Dir(G), δDP ) (resp. (Dir(G), δDB)) est ﬁbr´e sur (D(cid:2)
utilis´es dans la Section 4.5, on peut montrer le th´eor`eme suivant qui est analogue au
Th´eor`eme 4.33
Th´eor`eme 7.48 Pour tout graphe simple ´etiquet´e G avec un ´etiquetage des ports δ, il
existe un algorithme d’´election pour (G, δ) dans le mod`ele diﬀusion-`a-port (resp. diﬀusion-
`a-boˆıte) si et seulement si (Dir(G), δDP ) (resp. (Dir(G), δDB)) est minimal pour les ﬁ-
brations non-triviales.

, δ

Comme dans la Section 4.5, on peut aussi montrer que dans le mod`ele diﬀusion-`a-port
(resp. diﬀusion-`a-boˆıte), une connaissance d’une borne sur le diam`etre permet de r´esoudre
l’´election sur la famille des r´eseaux (G, δ) tels que (Dir(G), δDP ) (resp. (Dir(G), δDB)) est
minimal pour les ﬁbrations non-triviales. On a donc un r´esultat analogue au Th´eor`eme 7.42
pour l’´election dans les mod`eles diﬀusion-`a-port et diﬀusion-`a-boˆıte.

Par ailleurs, en utilisant les techniques mises en oeuvre dans la Section 4.5, on peut
aussi montrer que dans ces deux mod`eles, pour tout entier B il existe un algorithme eﬀectif
d’´election et de nommage sur la famille des r´eseaux (G, δ) tels que |V (G)| ≤ B < 2|V (G)|.
On a donc aussi un r´esultat analogue au Th´eor`eme 7.43 dans les mod`ele diﬀusion-`a-port
et diﬀusion-`a-boˆıte.

7.7.3 Caract´erisations

Comme Yamashita et Kameda, on souhaite caract´eriser les graphes G dans lesquels
les probl`emes d’´election et de nommage peuvent ˆetre r´esolus quel que soit la fonction
d’´etiquetage des ports choisie. Le th´eor`eme suivant est l’´equivalent du Th´eor`eme 7.34
pour les mod`eles port-`a-boˆıte, diﬀusion-`a-port et diﬀusion-`a-boˆıte. On rappelle qu’on dit
qu’il existe un algorithme d’´election (ou de nommage) pour un graphe G s’il existe un
algorithme qui permet de r´esoudre l’´election (ou le nommage) quel que soit la fonction
d’´etiquetage des ports de G.
Th´eor`eme 7.49 Pour tout graphe simple ´etiquet´e G, on a les caract´erisations suivantes.
1. Il existe un algorithme d’´election et de nommage pour G dans le mod`ele port-`a-boˆıte

si et seulement si Dir(G) est minimal pour les revˆetements dirig´es.

2. Il existe un algorithme de nommage pour G dans le mod`ele diﬀusion-`a-port (resp.

diﬀusion-`a-boˆıte) si et seulement si Dir(G) est minimal pour les ﬁbrations.

3. Il existe un algorithme d’´election pour G dans le mod`ele diﬀusion-`a-port (resp.
diﬀusion-`a-boˆıte) si et seulement si Dir(G) est minimal pour les ﬁbrations non-
triviales.

Chapitre 7. ´Echanges de Messages en Mode Asynchrone

200

Preuve :

1. C’est un corollaire du Th´eor`eme 7.47 et de la Proposition 7.8.
2. C’est un corollaire du Th´eor`eme 7.47 et de la Proposition 7.5.
3. C’est un corollaire du Th´eor`eme 7.48 et de la Proposition 7.5.

2

On pr´esente maintenant des ´etiquetages qui permettent de caract´eriser les graphes non-
´etiquet´es admettant un algorithme d’´election ou de nommage dans les mod`eles consid´er´es
ici. Ces caract´erisations en terme d’´etiquetages sont dues `a Yamashita et Kameda et vont
nous ˆetre utiles au Chapitre 9.
D´eﬁnition 7.50 Un ´etiquetage r´egulier sym´etrique d’un graphe simple connexe G est un
´etiquetage (cid:8) de G tel que
– pour tout i ∈ (cid:8)(V (G)), G[i] est un graphe r´egulier qui admet un couplage parfait si
– pour tout i, j ∈ (cid:8)(V (G)) avec i (cid:12)= j, G[i, j] est un stable, ou alors G[i, j] est un

ses sommets ont un degr´e impair,

graphe biparti r´egulier.

On remarque qu’une coloration r´eguli`ere (Deﬁnition 3.7) d’un graphe simple G est un

´etiquetage r´egulier sym´etrique de G.
D´eﬁnition 7.51 Un ´etiquetage r´egulier d’un graphe simple connexe G est un ´etiquetage
(cid:8) de G tel que

– pour tout i ∈ (cid:8)(V (G)), G[i] est un graphe r´egulier,
– pour tout i, j ∈ (cid:8)(V (G)) avec i (cid:12)= j, G[i, j] est un stable, ou alors G[i, j] est un

graphe biparti r´egulier.

On remarque qu’un ´etiquetage r´egulier sym´etrique d’un graphe simple G est un ´etique-

tage r´egulier de G.
D´eﬁnition 7.52 Un ´etiquetage semi-r´egulier d’un graphe simple connexe G est un ´etique-
tage (cid:8) de G tel que

– pour tout i ∈ (cid:8)(V (G)), G[i] est un graphe r´egulier,
– pour tout i, j ∈ (cid:8)(V (G)) avec i (cid:12)= j, G[i, j] est un stable, ou alors G[i, j] est un

graphe biparti semi-r´egulier.

On remarque qu’un ´etiquetage r´egulier d’un graphe simple G est un ´etiquetage semi-
r´egulier de G et qu’une coloration semi-r´eguli`ere (Deﬁnition 5.6) de G est un ´etiquetage
semi-r´egulier de G.

Dans [YK99], Yamashita et Kameda ont utilis´e ces notions d’´etiquetage aﬁn d’obtenir
une caract´erisation des graphes admettant un algorithme d’´election ou de nommage dans
les mod`eles port-`a-port, port-`a-boˆıte, diﬀusion-`a-port et diﬀusion-`a-boˆıte. On rappelle
qu’un ´etiquetage (cid:8) d’un graphe simple est propre si |(cid:8)(V (G))| < |V (G)|.
Th´eor`eme 7.53 ([YK99]) Pour tout graphe simple G, on a les caract´erisations sui-
vantes.

1. Il existe un algorithme d’´election (ou de nommage) pour G dans le mod`ele port-`a-port

si et seulement si G n’admet pas d’´etiquetage sym´etrique r´egulier propre.

7.8. Conclusion et Perspectives

201

2. Il existe un algorithme d’´election (ou de nommage) pour G dans le mod`ele port-`a-

boˆıte si et seulement si G n’admet pas d’´etiquetage r´egulier propre.

3. Il existe un algorithme de nommage pour G dans le mod`ele diﬀusion-`a-port (resp.

diﬀusion-`a-boˆıte) si et seulement G n’admet pas d’´etiquetage semi-r´egulier propre.

−1((cid:8)(v))| = 1.

4. Il existe un algorithme d’´election pour G dans le mod`ele diﬀusion-`a-port (resp.
diﬀusion-`a-boˆıte) si et seulement si pour tout ´etiquetage semi-r´egulier (cid:8) de G, il
existe v ∈ V (G) tel que |(cid:8)
Grˆace aux Th´eor`emes 7.34, 7.49 et 7.53, on peut caract´eriser les graphes simples non-
´etiquet´es minimaux pour les revˆetements dirig´es sym´etriques (resp. revˆetements dirig´es,
ﬁbrations non-triviales, ﬁbrations) comme les graphes `a l’aide des ´etiquetages sym´etriques
r´eguliers (resp. ´etiquetages r´eguliers, ´etiquetages semi-r´eguliers, ´etiquetages semi-r´eguliers).
Ces caract´erisations peuvent aussi ˆetre obtenues directement `a partir des travaux de Boldi
et Vigna [BV02a].

7.8 Conclusion et Perspectives

Dans ce chapitre, on a pr´esent´e une caract´erisation des graphes admettant un al-
gorithme de nommage ou d’´election utilisant des ´echange de messages quel que soit
l’´etiquetage des ports (Th´eor`eme 7.34). Les caract´erisations pr´esent´ees dans ce chapitre
sont bas´ees sur les notions de ﬁbrations et de revˆetements dirig´es. On a par ailleurs ´etudi´e
les connaissances initiales n´ecessaires pour r´esoudre ces probl`emes. Ainsi, la connaissance
initiale d’une borne sur le diam`etre permet de r´esoudre ´election et nommage sur un r´eseau
(G, δ) minimal pour les revˆetements dirig´es sym´etriques (Th´eor`eme 7.42). Par ailleurs,
la connaissance initiale d’une borne serr´ee sur la taille permet d’obtenir un algorithme
eﬀectif de nommage et d’´election (Th´eor`emes 7.43). On a ensuite montr´e qu’on pouvait
´etendre ces r´esultats `a d’autres mod`eles o`u les processus communiquent par ´echange de
messages et qui avaient ´et´e ´etudi´es par Yamashita et Kameda [YK99] (Th´eor`eme 7.49).

Les r´esultats obtenus dans ce mod`ele nous permettent de penser que les techniques
pr´esent´ees dans [GM03, GMM04] peuvent ˆetre adapt´ees dans les diﬀ´erents mod`eles ´etudi´es
dans ce chapitre. Il semble en particulier que lorsqu’aucune connaissance initiale n’est
disponible, les classes de graphes simples reconnaissables dans ces mod`eles doivent v´eriﬁer
les mˆemes propri´et´es que celles pr´esent´ees dans [GMM04]. Il semble aussi que l’utilisation
des techniques pr´esent´es dans [God02b] permettent d’obtenir un algorithme de nommage
auto-stabilisant dans un syst`eme synchrone dans lequel les processus communiquent par
´echange de messages.

Dans le travail r´ealis´e avec Emmanuel Godard, Yves M´etivier et Gerard Tel [CGMT07],
on pr´esente une caract´erisation des familles de graphes dans lesquelles on peut r´esoudre
un probl`eme avec d´etection de la terminaison dans le mod`ele ´etudi´e dans ce chapitre. Les
r´esultats pr´esent´es dans [CGMT07] sont bas´es sur les r´esultats pr´esent´es dans ce chapitre
et sur des g´en´eralisations des m´ethodes utilis´ees dans [GM02, MT00].

Dans le travail r´ealis´e avec Shantanu Das et Nicola Santoro [CDS06], on s’int´eresse `a
un probl`eme o`u on ne doit briser totalement les «sym´etries» initiales du r´eseau, comme
c’est le cas pour les probl`emes de l’´election ou du nommage. Dans ce travail, on cherche `a
former des «paires» dans le r´eseau : chaque sommet doit avoir un partenaire (dont il est lui-
mˆeme le partenaire) et il doit connaˆıtre les num´eros de ports apparaissant sur un chemin le

202

Chapitre 7. ´Echanges de Messages en Mode Asynchrone

reliant `a son partenaire. Si la taille du graphe est paire et qu’on a un algorithme d’´election,
il est possible pour le sommet ´elu de construire une carte du r´eseau et d’indiquer `a chaque
sommet quel est son partenaire. Cependant, il existe des graphes pour lesquels il n’existe
pas d’algorithme d’´election et dans lesquels on peut former des paires (on peut par exemple
consid´erer le graphe complet `a deux sommets). Dans [CDS06], on ´etudie les graphes dans
lesquels on peut r´esoudre ce probl`eme en fonction de la connaissance initiale disponible (la
topologie du graphe, la taille du graphe, une borne sur la taille). Un corollaire important
des r´esultats pr´esent´es dans [CDS06] est que selon la connaissance initiale disponible, on ne
peut pas r´esoudre le probl`eme dans les mˆemes graphes. En eﬀet, il existe des graphes pour
lesquels on peut r´esoudre ce probl`eme en connaissant la topologie (resp. la taille) du graphe
mais pour lesquels on ne peut pas r´esoudre ce probl`eme en connaissant seulement la taille
(resp. une borne sur la taille) du graphe. Les m´ethodes pr´esent´ees dans ce chapitre sont
utilis´ees dans [CDS06] aﬁn de permettre `a chaque sommet de reconstruire la base minimale
du r´eseau. Une ´etude des propri´et´es combinatoires des revˆetements dirig´es sym´etriques est
ensuite n´ecessaire pour obtenir les r´esultats pr´esent´es dans [CDS06].

Chapitre 8

Agents Mobiles

Syst`emes `a Agents Mobiles

Sommaire
8.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
8.2 Le Mod`ele . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
8.2.1
. . . . . . . . . . . . . . . . . . . . . 204
8.2.2 Algorithmes pour Syst`emes `a Agents Mobiles . . . . . . . . . . . 205
8.2.3 Ex´ecution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
8.2.4 D´etection de la Terminaison . . . . . . . . . . . . . . . . . . . . . 207
8.3 Des Agents Mobiles vers les Messages . . . . . . . . . . . . . . . 208
8.4 Des Messages vers les Agents Mobiles . . . . . . . . . . . . . . . 210
8.4.1 Calcul d’un arbre par un agent . . . . . . . . . . . . . . . . . . . 211
8.4.2 Coder les ´Echanges de Messages
. . . . . . . . . . . . . . . . . . 213
8.4.3

Simuler un algorithme utilisant des ´echanges de messages qui ter-
mine par un algorithme pour agents mobiles qui termine . . . . . 214
8.5 R´esultat d’´Equivalence et Applications . . . . . . . . . . . . . . 217
. . . . . . . . . . . . . . . . . . . . . . . . . . 217
´Election et Rendez-vous pour Agents Mobiles . . . . . . . . . . . 217
8.6 Conclusion et Perspectives . . . . . . . . . . . . . . . . . . . . . . 218

8.5.1 R´esultat Principal
8.5.2

8.1

Introduction

Le concept d’agents mobiles a ´et´e d´evelopp´e aﬁn de pouvoir r´esoudre des probl`emes
dans des environnements h´et´erog`enes et dynamiques [BR05]. Le mod`ele ´etudi´e dans ce
chapitre est assez g´en´eral : on consid`ere des agents qui peuvent migrer de places en places
dans un syst`eme de navigation qui peut ˆetre mod´elis´e par un graphe. Un agent mobile est
une entit´e qui ex´ecute un algorithme : il peut se d´eplacer d’une place `a une autre (avec des
donn´ees ainsi que son algorithme) `a travers un canal de communication et il peut ex´ecuter
des calculs lorsqu’il se trouve sur une place (une place fournit des moyens de calculs `a
l’agent ainsi que des donn´ees). Ainsi, un syst`eme `a agents mobiles est d´eﬁni par :

– un r´eseau, ou de mani`ere ´equivalente, un graphe simple ´etiquet´e (o`u les sommets

correspondent aux places) avec un ´etiquetage des ports,

– un ensemble d’agents,

203

204

Chapitre 8. Agents Mobiles

– un placement initial des agents sur le graphe.

Le syt`eme est asynchrone : il n’y a pas d’horloge globale, les agents migrent d’une place
`a une autre en un temps ﬁni mais arbitraire et les agents ex´ecutent les instructions `a des
vitesses arbitraires. Un cas particulier de notre mod`ele est lorsque le r´eseau et les agents
mobiles sont anonymes. Un algorithme pour un syst`eme `a agents mobiles est d´eﬁni par un
algorithme que chaque agent ex´ecute ind´ependamment des autres agents.

Des probl`emes classiques ´etudi´es dans ce cadre sont le rendez-vous, l’´election, l’explo-
ration, la d´ecouverte de la topologie, etc. De nombreux r´esultats existent dans diﬀ´erents
mod`eles [ABRS95, BFFS03b, BFFS06, BS94, DFNS05, DFNS06, DKP98, DFP03]
[GKKZ06, KKR06].

Dans ce chapitre, on s’int´eresse `a la puissance de calcul d’un syst`eme `a agents mobiles
et on souhaite plus particuli`erement la comparer avec celle d’un syst`eme distribu´e o`u
les processus communiquent en ´echangeant des messages. Il n’est pas diﬃcile de voir
que tout algorithme pour agents mobiles peut ˆetre simul´e par un algorithme distribu´e
o`u les processus communiquent par ´echange de messages : cette simulation est pr´esent´ee
dans la Section 8.3 et a ´et´e pour la premi`ere fois mise en ´evidence par Barri`ere et al.
dans [BFFS03a]. Dans la Section 8.4, on montre qu’on peut simuler un algorithme distribu´e
o`u les processus communiquent par ´echange de messages dans un syst`eme `a agents mobiles.
On obtient ainsi un th´eor`eme montrant que les deux mod`eles ont la mˆeme puissance de
calcul (Th´eor`eme 8.14).

La preuve d’´equivalence pr´esent´ee dans ce chapitre n’est pas tr`es diﬃcile `a obtenir,
mais ce r´esultat permet d’obtenir des corollaires int´eressants dans un mod`ele `a partir
de r´esultats existants dans l’autre. Dans la Section 8.5, on montre que grˆace `a notre
r´esultat d’´equivalence et aux r´esultats pr´esent´es dans le Chapitre 7, on peut caract´eriser
quels sont les syst`emes `a agents mobiles dans lesquels on peut r´esoudre le probl`eme du
rendez-vous. Les r´esultats obtenus par Das et al. [DFNS05, DFNS06] et par Barri`ere et
al. [BFFS03b, BFFS06] deviennent ainsi des corollaires de r´esultats existants pour les
syst`emes distribu´es o`u les processus communiquent par ´echange de messages.

Les r´esultats pr´esent´es dans ce chapitre ont ´et´e obtenus en collaboration avec Emma-
nuel Godard, Yves M´etiver et Rodrigue Ossamy ; ils ont ´et´e publi´es dans [CGMO06]. On
a obtenu d’autres r´esultats dans le cadre des syst`emes `a agents mobiles [Cha06] dans un
mod`ele l´eg`erement diﬀ´erent. Ils ne sont pas d´etaill´es ici mais ils sont pr´esent´es dans la
conclusion de ce chapitre.

8.2 Le Mod`ele

On pr´esente dans cette section une pr´esentation formelle d’un syst`eme `a agents mobiles.
Cette d´eﬁnition correspond `a la pr´esentation de tels syst`emes donn´es dans l’introduction
et nous sera utile pour prouver de mani`ere formelle notre r´esultat d’´equivalence.

8.2.1 Syst`emes `a Agents Mobiles

Un syst`eme `a agents mobiles est d´eﬁni par :
– un ensemble P de places d’ex´ecution (que l’on appellera places par la suite),
– un syst`eme de navigation S,
– un ensemble A d’agents mobiles (que l’on appellera agents par la suite),

8.2. Le Mod`ele

205

– une injection π0 : A → P d´ecrivant la position initiale de chaque agent,
– un ´etiquetage initial λ des places et des agents.

Remarque 8.1 L’´etiquetage λ des places (resp. des agents) permet de coder un ensemble
de places anonymes (resp. d’agents anonymes), d’attribuer des identit´es ou des identit´es
partielles aux diﬀ´erentes places (resp. aux diﬀ´erents agents), de distinguer certaines places
(resp. certains agents), etc.

Le syst`eme de navigation S est d´ecrit par un graphe simple connexe G dont les som-
mets repr´esentent les places d’ex´ecution et les arˆetes repr´esentent des canaux de navigation
bidirectionnels entre les places. Par la suite, on identiﬁe les places et les sommets corres-
pondants ainsi que les arˆetes et les canaux de communication. De plus, les agents peuvent
distinguer les diﬀ´erents canaux de communication incident `a un sommet. Ainsi, le graphe
G correspondant au syst`eme de navigation est muni d’un ´etiquetage des ports δ.

Le syst`eme est asynchrone : il n’y a pas d’horloge globale, les agents ex´ecutent leurs
instructions `a une vitesse arbitraire, le temps que met un agent `a traverser une arˆete est
ﬁni mais non-born´e.

8.2.2 Algorithmes pour Syst`emes `a Agents Mobiles

On associe `a chaque agent mobile un syst`eme de transitions qui interagit avec les places

d’ex´ecution et le syst`eme de navigation.

Pour toute arˆete {v, v

(cid:2)} ∈ E(G), on note M(v, v

`A tout moment de l’ex´ecution, chaque place a un ´etat appartenant `a un ensemble
r´ecursif QP d’´etats (commun `a toutes les places) et chaque agent a un ´etat appartenant
`a un ensemble r´ecursif d’´etats QA d’´etats (commun `a tous les agents). L’´etat initial de
chaque place p est λ(p) ∈ QP et l’´etat initial de chaque agent a est λ(a) ∈ QA. Pour toute
place p, on note state(p) l’´etat de p et pour tout agent a, on note state(a) l’´etat de a.
, v)) l’ensemble des agents
en train de migrer entre la place p (resp. p(cid:2)) correspondant au sommet v (resp. v
(cid:2)) et la
(cid:2) (resp. v). Initialement, tous les ensembles
place p(cid:2) (resp. p) correspondant au sommet v
(cid:2)) d’agents en transit.
M(v, v
Chaque agent a qui n’est pas en train de migrer entre deux places se trouve sur une place
p et on note π la fonction qui associe `a chaque agent qui n’est pas en train de migrer
la place sur laquelle il se trouve. Except´e dans la conﬁguration initiale, plusieurs agents
peuvent se trouver sur la mˆeme place au cours de l’ex´ecution.
Une transition associ´ee `a un agent a et une place p correspondant `a un sommet v ∈

(cid:2)) sont vides. On note M l’ensemble des ensembles M(v, v

(cid:2)) (resp. M(v

(cid:2)

V (G) est not´e

(s, q, in) (cid:24)a

p (s

(cid:2)

, q

(cid:2)

, out),

(cid:2) ∈ SA, q, q

(cid:2) ∈ QP et in, out ∈ [0, degG(v)]. Une telle transition a la signiﬁcation

o`u s, s
suivante.

– si in = 0 et out = 0, alors π et M ne sont pas modiﬁ´es. Cette transition ne peut ˆetre
eﬀectu´ee que si π(a) = p, si l’´etat de p est q et si l’´etat de a est s. Lorsque cette
transition est eﬀectu´ee, l’´etat de p devient q
– si in (cid:12)= 0, alors out = 0 (cela repr´esente une transition o`u l’agent a arrive sur la
place p). Cette r`egle ne peut ˆetre appliqu´ee que si l’´etat de p est q, si l’´etat de a
est s et si a ∈ M(v
(cid:2)) = in. Lorsque cette

(cid:2) est le voisin de v tel que δv(v

(cid:2) et l’´etat de a devient s

, v) o`u v

(cid:2).

(cid:2)

206

Chapitre 8. Agents Mobiles

transition est appliqu´ee, l’´etat de p devient q
M(v

, v) et π(a) = p.

(cid:2)

(cid:2), l’´etat de a devient s

(cid:2), a est eﬀac´e de

– Si out = 0, alors in = 0 (cela repr´esente une transition o`u l’agent a quitte la place
p). Cette r`egle ne peut ˆetre appliqu´ee que si π(a) = p, si l’´etat de p est q et si l’´etat
(cid:2), l’´etat de a
de a est s. Lorsque cette transition est appliqu´ee, l’´etat de p devient q
(cid:2) est le voisin de v tel
devient s
que δv(v

(cid:2), π(a) n’est plus d´eﬁni et a est ajout´e `a M(v, v
(cid:2)) = in.

(cid:2)) o`u v

8.2.3 Ex´ecution

M0, π0), (state1, M1, π1), . . . , (statei, Mi, πi), . . . telle que :

Une ex´ecution d’un algorithme pour agents mobiles est d´eﬁni par une suite (state0,
– M0 = ∅,
– pour chaque agent a, state0(a) = λ(a) est l’´etat initial de a,
– pour chaque place p, state0(p) = λ(p) est l’´etat initial de p,
– pour chaque ´etape i, il existe une unique place p et un unique agent a tel que

– si p(cid:2) (cid:12)= p, alors statei+1(p(cid:2)) = statei(p(cid:2)),
– si a(cid:2) (cid:12)= a, alors statei+1(a(cid:2)) = statei(a(cid:2)),
– (statei+1(a), statei+1(p), Mi+1, πi+1)

statei(p), Mi, πi) par une transition de la forme (s, q, in) (cid:24)a

est obtenu `a partir de
(cid:2)

p (s

, q

(cid:2)

, out).

(statei(a),

La conﬁguration du syst`eme `a l’´etape i est (statei, Mi). Une conﬁguration est ﬁnale
si aucune transition ne peut ˆetre eﬀectu´ee `a partir de cette conﬁguration. On suppose
que dans une conﬁguration ﬁnale, aucun agent n’est en train de migrer. Autrement dit,
pour tout agent a pour toute place p correspondant `a un sommet v, pour tout ´etat
s ∈ QA, pour tout ´etat q ∈ QP et pour tout entier in ∈ [1, deg(v)], il existe une transition
(s, q, in) (cid:24)a

, 0).

´Etant donn´ee une ex´ecution qui atteint une conﬁguration ﬁnale, la longueur de l’ex´ecu-
tion est la longueur de la s´equence (state0, M0, π0), (state1, M1, π1), . . . , (statei, Mi, πi),
. . .

p (s

, q

(cid:2)

(cid:2)

Si une place p est la place initiale d’un agent a (i.e., π0(a) = p), on dit que p est la
base de a. On suppose que le placement initial des agents est cod´e dans l’´etat des places,
i.e., `a partir de l’´etat d’une place, un agent qui est sur la place savoir si cette place est une
base ou non. Cependant, en g´en´eral, un agent ne peut pas savoir si une base est la sienne
ou celle d’un autre agent.

Ainsi, un syst`eme `a agents mobiles est d´eﬁni par :

(A, P, S, π0, λ),

un algorithme pour un tel syst`eme est d´eﬁni par

A = ((cid:24)a

p)a∈A,p∈P,

et une ex´ecution ρ est d´eﬁni par :

ρ = (statei, Mi, πi)i≥0.

Remarque 8.2 On consid`ere g´en´eralement des algorithmes pour agents mobiles tels que
deux agents a, a(cid:2) dans le mˆeme ´etat qui se trouvent respectivement sur deux places p, p(cid:2)

8.2. Le Mod`ele

207

dans le mˆeme ´etat peuvent appliquer les mˆemes transitions. Cependant, si p est reli´e `a
plus de places que p(cid:2), alors si l’agent a sort de p par le port degG(v) (o`u v est le sommet
correspondant `a p), l’agent a(cid:2) ne peut pas eﬀectuer la mˆeme transition.

(cid:2) de mˆeme degr´e, (cid:24)a

Ainsi, pour tous agents a, a(cid:2) et pour toutes places p, p(cid:2) correspondant respectivement
p(cid:2). Pour distinguer des agents ou des places
`a des sommets v, v
correspondant `a des sommets de mˆeme degr´e, on utilise l’´etiquetage initial λ des agents
ou des places.
De cette mani`ere, un algorithme A n’a pas besoin d’ˆetre d´eﬁni pour un syst`eme parti-
culier, mais il suﬃt de d´ecrire pour tout entier d, les transitions que peuvent eﬀectuer les
agents avec les places de degr´e d.

p=(cid:24)a(cid:2)

Par la suite, sauf si c’est explicitement indiqu´e, on ne consid`ere que des algorithmes

respectant cette propri´et´e.

Remarque 8.3 Si on consid`ere des syst`emes `a agents mobiles dont les liens de navigation
pr´eservent l’ordre de d´epart des agents (i.e., si deux agents partent successivement d’un
mˆeme sommet `a travers le mˆeme num´ero de port, alors ils arriveront dans le mˆeme ordre),
il faut voir chaque ensemble M(v,v(cid:2)) comme une ﬁle, comme dans le cadre des syst`emes
distribu´es avec communication par ´echanges de messages.

8.2.4 D´etection de la Terminaison

(cid:2)

(cid:2)

, q

p (s

Un agent a dans un ´etat s qui se trouve sur une place p dont l’´etat est q est dit passif s’il
ne peut ex´ecuter aucune transition `a partir de cette conﬁguration, i.e., il n’existe aucune
transition de la forme (s, q, 0) (cid:24)a
, out). Dans une conﬁguration ﬁnale, tous les agents
sont passifs. Comme dans les chapitres pr´ec´edents, on parle alors de terminaison implicite,
puisque les agents ne savent pas n´ecessairement que tous les autres agents sont passifs.
Comme dans les chapitres pr´ec´edents, on dit qu’un algorithme A pour agents mobiles
r´esout un probl`eme P avec d´etection de la terminaison sur une famille F de syst`emes `a
agents mobiles s’il existe une fonction res : QP → S et un ensemble Lf ⊆ QA tels que les
propri´et´es suivantes sont toujours v´eriﬁ´ees pour tout syst`eme S = (A, P, S, π0, λ) ∈ F.
– Toute ex´ecution ρ de A sur S termine et l’´etiquetage ﬁnal stateρ de P est tel que
– Pour toute ex´ecution ρ de A sur S, il existe un agent a ∈ A et une ´etape i tels que
– Pour toute ex´ecution ρ de A sur S, s’il existe un agent a ∈ A et une ´etape i telle
> i, pour tout p ∈ P res ◦ statei(cid:2)(p) =

l’´etiquetage res ◦ stateρ est une solution de P sur S.
statei(a) ∈ Lf .
que statei(a) ∈ Lf , alors pour tout i
(cid:2)
res ◦ statei(p).

On remarque qu’une fois que la terminaison a ´et´e d´etect´ee par un agent, alors les
valeurs correspondant aux ´etiquettes des places ne sont plus modiﬁ´ees, mais les agents
peuvent encore se d´eplacer. Ainsi, une fois qu’au moins un agent a d´etect´e la terminaison,
ces agents peuvent inscrire dans l’´etat de toutes les places du graphe que le r´esultat de
l’ex´ecution est calcul´e et ainsi, tous les agents peuvent savoir que l’algorithme est termin´e.

208

Chapitre 8. Agents Mobiles

8.3 Simuler un Algorithme pour Agents Mobiles par un Al-

gorithme utilisant des ´Echanges de Messages

On montre ici comment impl´ementer un algorithme pour agents mobiles dans un
syst`eme o`u les processus communiquent par ´echanges de messages. Pour cela, on montre
que chaque pas de calcul eﬀectu´e par un agent peut ˆetre simul´e dans un syst`eme o`u les
processus communiquent par ´echanges de messages. Les id´ees principales du r´esultat de
cette section apparaissent dans les travaux de Barri`ere et al. [BFFS03a].
On consid`ere un syst`eme `a agents mobiles (A, P, S, π0, λ) et un algorithme A = ((cid:24)a

p

)a∈A,p∈P impl´ement´e sur ce syst`eme.
On consid`ere le graphe (G, δ) correspondant au syst`eme de navigation S et on suppose
que |A| = k. On d´eﬁnit un ´etiquetage suppl´ementaire χπ0 des sommets de G tel que pour
tout v ∈ V (G), χπ0(v) = 1 s’il existe un agent a ∈ A tel que π0(a) = v et χπ0(v) = 0
sinon.

`A partir de (A, P, S, π0, λ), on construit un syst`eme distribu´e o`u les processus com-
(cid:2)) de la mani`ere suivante. Le graphe cor-
muniquent par ´echanges de messages (P, C, λ
respondant au syst`eme de communication C est le graphe (G, δ) et `a chaque sommet
v ∈ V (G) correspond un processus p ∈ P . On consid`ere un nouveau symbole (cid:17) et on d´eﬁnit
(cid:2) des processus de P de la mani`ere suivante. Pour tout sommet v ∈ V (G) cor-
l’´etiquetage λ
respondant `a une place p ∈ P et `a un processus p ∈ P , l’´etiquette λ
(cid:2)(p) contient l’´etiquette
λ(p), la valeur de χπ0(v) et dans le cas o`u p est une base (i.e., χπ0(v) = 1), l’´etiquette de
(cid:2)(p) = (λ(p), 1, λ(a)) si p est une base
l’agent correspondant `a p. Autrement dit,λ
(cid:2)(v) = λ
et λ
On construit un algorithme D utilisant des ´echanges de messages tel que chaque
ex´ecution ρ de D simule une ex´ecution ρ

(cid:2)(p) = (λ(p), 0, (cid:17))) sinon.

(cid:2)(v) = λ

(cid:2) de A.

Dans l’´etat d’un processus, on code l’´etat de la place correspondante, la pr´esence
´eventuelle d’agents mobiles et l’´etat des agents pr´esents. Pour coder la pr´esence d’agents
mobiles, on utilise des jetons qui contiennent les ´etats des agents correspondants.

La pr´esence d’un agent a sur un sommet v est repr´esent´e par un jeton t(a) situ´e sur le
sommet v. Chaque jeton a une base qui correspond `a la position initiale de l’agent corres-
pondant. `A chaque jeton t(a), on associe un ´etat qui est l’´etat de l’agent a correspondant.
L’´etat d’un processus p est donc un couple (q, A) o`u q est l’´etat de la place correspon-
dante `a p(a) et A est un ensemble de couples (t(a), s) tels que (t(a), s) ∈ A si et seulement
si a se trouve sur la place p dans l’´etat s.

Une transition

(s, q, in) (cid:24)a

p (s

(cid:2)

, q

(cid:2)

, out)

de l’algorithme pour agent mobile se traduit par une transition de l’algorithme utilisant
des ´echanges de messages de la forme

((q, A), in, m) (cid:24)p ((q

(cid:2)

(cid:2)
, A

), out, m

(cid:2)

)

o`u p est le processus correspondant `a p. Cette transition respecte les r`egles suivantes.

(cid:2) = ⊥. Cette transition ne peut ˆetre appliqu´ee
que si state(p) = (q, A) et (t(a), s) ∈ A. Lorsque cette r`egle est appliqu´ee, le nouvel
(cid:2) = A \ {(t(a), s)} ∪ {(t(a), s
´etat de p est state(p) = (q

– Si in = 0 et out = 0, alors m = m
(cid:2)) o`u A

(cid:2))}.

, A

(cid:2)

8.3. Des Agents Mobiles vers les Messages

209

(cid:2)

, A

(cid:2)

(cid:2)) o`u A

(cid:2) = {(t(a), s

(cid:2) = A \ {(t(a), s)} et m

– Si out (cid:12)= 0 et in = 0, alors m = ⊥. Cette transition ne peut ˆetre appliqu´ee que si
state(p) = (q, A) et (t(a), s) ∈ A. Lorsque cette r`egle est appliqu´ee, le nouvel ´etat
de p est state(p) = (q
(cid:2) = ⊥. Cette transition ne peut ˆetre appliqu´ee que si
– Si in (cid:12)= 0 et out = 0, alors m
m = {(t(a), s)}. Lorsque cette r`egle est appliqu´ee, le nouvel ´etat de p est state(p) =
(cid:2))}.
(cid:2) = A ∪ {(t(a), s
(cid:2)
(cid:2)) o`u A
(q
On note Dp l’algorithme obtenu en prenant l’union des r`egles obtenus `a partir de
(cid:2)
, out) pour tous les agents a o`u p est la place correspondante `a p.

, A
(s, q, in) (cid:24)a
L’algorithme D est alors (Dp)p∈P .
Remarque 8.4 Si on consid`ere un algorithme A pour agents mobiles qui respecte les
propri´et´es de la Remarque 8.2, on observe que l’algorithme D obtenu respecte la propri´et´e
de la Remarque 7.19.

(cid:2))}.

p (s

, q

Par r´ecurrence sur la longueur d’une ex´ecution, il est facile de montrer que pour toute
(cid:2)), il existe une ex´ecution de A sur (A, P, S, π0, λ) telle que
ex´ecution de D sur (P, C, λ
pour toute ´etape i, pour toute place p et pour tout agent a, les propri´et´es suivantes sont
satisfaites pour le processus p correspondant `a p.

toute ex´ecution de D termine sur (P, C, λ
(cid:2)).

(cid:2)) et statei(a) = s si et seulement si (t(a), s) ∈ Mi(v, v

– statei(p) = q si et seulement si statei(p) = (q, A),
– πi(a) = p et statei(a) = s si et seulement si statei(p) = (q, A) et (t(a), s) ∈ A.
– a ∈ Mi(v, v
Ainsi, il est facile de voir que si toute ex´ecution de A termine sur (A, P, S, π0, λ), alors
(cid:2) de A sur
De plus, pour toute ex´ecution ρ de D sur (P, C, λ
(cid:2) est exactement
(A, P, S, π0, λ) telle que l’´etiquetage ﬁnal des places de A obtenu apr`es ρ
l’´etiquetage ﬁnal des processus de P correspondants obtenu apr`es ρ `a projection sur la
premi`ere composante pr`es.
Par ailleurs, il est facile de voir que si A r´esout un probl`eme P avec d´etection de la
terminaison sur une famille F de syst`emes `a agents, alors D r´esout le probl`eme P avec
d´etection de la terminaison sur la famille de r´eseaux F(cid:2) qui correspond `a F.

(cid:2)), il existe une ex´ecution ρ

(cid:2)).

On a donc montr´e que tout algorithme pour agents mobiles pouvait ˆetre simul´e par un
algorithme utilisant des ´echanges de messages ; c’est ce qui est rappel´e dans la proposition
suivante.
Proposition 8.5 Pour tout algorithme pour agents mobiles A, l’algorithme D obtenu par
la construction pr´ec´edente utilise des ´echanges de messages et simule A.
De plus, si A permet de r´esoudre un probl`eme P sur une famille de syst`emes `a agents
mobiles F avec d´etection de la terminaison, alors l’algorithme D permet de de r´esoudre P
sur la famille de r´eseaux correspondants F(cid:2).

Remarque 8.6 Si on consid`ere un algorithme A pour agents mobiles qui n´ecessite que les
liens de navigation de (A, P, S, π0, λ) pr´eservent l’ordre de d´epart des agents, alors il suﬃt
(cid:2)) pr´eservent l’ordre des messages
de s’assurer que les liens de communication de (P, C, λ
pour que l’ex´ecution simul´ee soit une ex´ecution correcte de A.

210

Chapitre 8. Agents Mobiles

8.4 Simuler un algorithme utilisant des ´echanges de mes-

sages par un algorithme pour agents mobiles

Dans cette section, on montre comment impl´ementer un algorithme A pour agents
mobiles `a partir d’un algorithme utilisant des ´echanges de messages D de telle sorte que
pour tout r´eseau (G, δ) et pour tout ensemble non-vide A d’agents mobiles, toute ex´ecution
de A par les agents de A sur le syst`eme de navigation correspondant `a (G, δ) simule une
ex´ecution de D sur le r´eseau (G, δ).

Le principe de la simulation est le suivant : l’´etat de chaque place p correspondant `a
un sommet v dans (G, δ) contient l’´etat du processus p correspondant `a v (avec la mˆeme
valeur initiale). Initialement, chaque agent va acqu´erir un territoire, de telle sorte que tous
les sommets du graphe appartiennent `a exactement un agent. Ensuite, chaque agent va
ˆetre en charge de simuler tous les pas de calculs eﬀectu´es par les processus correspondants
aux places de son territoire.

inbuﬀer) o`u les diﬀ´erents champs ont les signiﬁcations suivantes.

L’´etat de chaque place p correspondant `a un sommet v est de la forme (mark, N, state,
– mark ∈ {N T, T} est un marqueur indiquant si la place a ´et´e visit´e ou non par un
agent ; mark = T si elle a ´et´e visit´e et mark = N T sinon.
– N est un ensemble de couples (p, mark) o`u p ∈ [1, deg(u)] et mark ∈ {N T, T}.
Si le couple (p, T ) apparaˆıt dans N, alors l’arˆete {v, δv(p)} appartient `a la forˆet
construite par les agents ; si le couple (p, N T ) apparaˆıt dans N, alors l’arˆete {v, δv(p)}
n’appartient pas `a la forˆet ; s’il n’existe pas de couple (p, mark) ∈ N, alors on ne
sait pas encore si l’arˆete {v, δv(p)} appartiendra ou non `a la forˆet.

– state est l’´etat du processus p correspondant `a p.
– inbuﬀer est un ensemble de couples (p, m) o`u p ∈ [1, deg(u)] et m est un message
de l’algorithme D. Si un couple (p, m) apparaˆıt dans inbuﬀer, cela signiﬁe qu’un
message m est arriv´e par le port p et que ce message n’a pas encore ´et´e trait´e.

Initialement, l’´etiquette de chaque place correspondant `a un sommet v de G = (G, λ)
est (N T,∅, state,∅) o`u state est l’´etat initial de v, i.e., state = λ(v). Cette ´etiquette
initiale signiﬁe que la place n’a pas ´et´e ajout´e `a l’arbre, qu’aucune arˆete incidente `a v n’a
´et´e explor´e par un agent et que v n’a re¸cu aucun message.
Remarque 8.7 Si le comportement du r´eseau (G, δ) assure que les canaux de commu-
nication pr´eserve l’ordre des messages, alors il faut voir l’ensemble inbuﬀer comme une
ﬁle.

Le principe g´en´eral de l’algorithme de simulation est l’Algorithme 3. Puisque les agents
et les places peuvent ˆetre anonymes, il faut s’assurer que chaque agent peut naviguer dans
le graphe, et en particulier qu’il peut retrouver sa base. Pour cela, on utilise une technique
utilis´ee par Das et al. dans [DFNS05]. Les agents vont utiliser les num´eros des ports pour
stocker l’´etiquetage d’un chemin qui va du sommet o`u ils se trouvent `a leur base.
`A chaque fois qu’un agent traverse une arˆete {u, v} de u vers v, il stocke dans sa
m´emoire le num´ero δv(u), aﬁn de pouvoir retourner au sommet visit´e pr´ec´edemment.
Ainsi, chaque agent a va disposer d’une suite ordonn´ee de ports qu’il doit traverser pour
rejoindre sa base ; cette suite est appel´ee ePath (chemin d’exploration) et est construite
de la mani`ere suivante. `A chaque fois qu’un agent a traverse une arˆete {u, v} de u vers v,
si δu(v) est le premier ´el´ement de la suite ePath de a, alors il est eﬀac´e, et sinon δv(u) est

8.4. Des Messages vers les Agents Mobiles

211

Algorithme 3 : Principe de l’algorithme de simulation de la Section 8.4

´Etape 1 : Au d´epart, chaque agent a construit un arbre Ta par une travers´ee
partielle du graphe. Lorsque tous les agents ont ﬁni cette ´etape, on obtient une
forˆet couvrante du graphe dont chaque arbre contient exactement une base, qui est
la base de l’agent qui a construit l’arbre correspondant.
´Etape 2 : Chaque agent a ex´ecute l’algorithme D sur les sommets de Ta.
Cette ex´ecution est constitu´ee de rondes telles que durant chaque ronde, chaque
sommet v de Ta est visit´e par a et si v doit ex´ecuter des pas de calculs de D, alors a
en simule au moins 1 et au plus d (d est une constante sup´erieure ou ´egale `a 1).
Ainsi, a est en charge de simuler tous les pas de calculs que doivent ex´ecuter les
processus correspondant aux places qui apparaissent dans son arbre.

ajout´e en tˆete de la suite ePath de v. Ainsi, `a tout moment de l’ex´ecution, la suite ePath
d’un agent a permet `a a de rejoindre sa base.

8.4.1 Calcul d’un arbre par un agent

On va expliquer comment chaque agent calcule l’arbre sur les sommets duquel il sera
en charge de simuler les instructions de l’algorithme D. L’algorithme pr´esent´e ici est le
mˆeme que l’algorithme de Das et al. pr´esent´e dans [DFNS05]. Pour chaque place, lors de
l’ex´ecution de cette premi`ere ´etape, seuls les champs mark et N de chaque place sont
modiﬁ´es.

`A partir de sa base, chaque agent a fait une travers´ee partielle du graphe en faisant un
parcours en profondeur. `A chaque fois qu’un agent a arrive sur un sommet v qui n’est pas
marqu´e (i.e., mark(v) = N T ), il le marque avec l’´etiquette T et il marque l’arˆete {u, v} par
laquelle il est arriv´ee avec l’´etiquette T , (i.e., il ajoute (δu(v), T ) dans N(u) et (δv(u), T )
dans N(v)). Si a arrive depuis un sommet u sur un sommet v qui est d´ej`a marqu´e (i.e.,
mark(v) = T ) ou qui est une base, il retourne imm´ediatement sur le sommet u et il marque
l’arˆete {u, v} avec l’´etiquette N T , (i.e., il ajoute (δu(v), N T ) dans N(u) et (δv(u), N T )
dans N(v)). Lorsque toutes les arˆetes incidentes au sommet courant u o`u se trouve un agent
a ont ´et´e explor´ees (i.e., pour chaque p ∈ [1, deg(u)], il existe (p, mark) ∈ N(u)), alors
a retourne au sommet par lequel il est arriv´e sur u (qu’il retrouve `a l’aide de eP ath(a)).
Lorsqu’un agent a est revenu `a sa base (i.e., eP ath(a) est vide), alors l’agent a sait qu’il
a ﬁni de calculer son arbre.

L’Algorithme 4 pr´esente une description de ces id´ees o`u les suites eP ath sont repr´esen-
t´ees par des listes. La liste est vide est appel´ee nil et les primitives sur les listes utilis´ees
sont car (pour acc´eder `a la tˆete de la liste), cdr (pour acc´eder `a la liste priv´ee de sa tˆete),
cons (pour ajouter un ´el´ement en tˆete d’une liste).

La proposition suivante r´esume quelques propri´et´es int´eressantes de l’Algorithme 4.

Proposition 8.8 Lors de toute ex´ecution de l’Algorithme 4 sur un graphe G avec un
´etiquetage des ports δ, les propri´et´es suivantes sont v´eriﬁ´ees :
– si une arˆete {u, v} est ´etiquet´e T , alors u et v ont ´et´e ´etiquet´es T par un mˆeme

agent,

212

Chapitre 8. Agents Mobiles

Algorithme 4 : Construction d’un arbre par un agent a

d´ebut

mark(u) := T ;
eP ath(a) := nil ;
r´ep´eter

tant que ∃p ∈ [1, deg(u)] tel que (cid:2)(p, mark) ∈ N(u) o`u u est le sommet
courant faire

N(u) := N(u) ∪ {(p, T )} ;
quitte u par le port p pour arriver par le port q au sommet v ;
eP ath(a) := cons(q, eP ath(a)) ;
si mark(v) = T ou si v est une base alors
N(v) := N(v) ∪ {(p, N T )} ;
quitte v par le port q pour retourner au sommet u ;
eP ath(a) := cdr(eP ath(a)) ;
N(u) := N(u) \ {(p, T )} ∪ {(p, N T )} ;

sinon

mark(v) := T ;
N(v) := N(v) ∪ {(p, T )} ;

si eP ath(a) (cid:12)= nil alors

quitte u par le port car(eP ath(a)) ;
eP ath(a) := cdr(eP ath(a)) ;

jusqu’`a eP ath(a) = nil et ∀p ∈ [1, deg(u)],∃(p, mark) ∈ N(u) ;

ﬁn

8.4. Des Messages vers les Agents Mobiles

213

– l’ensemble des sommets et des arˆetes de G ´etiquet´es T par un agent a forment un

arbre.

De plus, lorsque l’ex´ecution est termin´ee, on sait que chaque sommet a ´et´e ´etiquet´e T par
exactement un agent et que chaque agent a ´etiquet´e sa base.

Ainsi, lorsque l’ex´ecution de l’Algorithme 4 est termin´ee, l’ensemble des arˆetes et des
sommets ´etiquet´es T forment une forˆet contenant k arbres, o`u k est le nombre d’agents
mobiles.

8.4.2 Coder les ´Echanges de Messages

On s’int´eresse maintenant `a la deuxi`eme ´etape de l’Algorithme 3 o`u les agents si-
mulent les pas de calculs que doivent ex´ecuter les sommets de (G, δ). Pour cela, on utilise
les champs state et inbuﬀer de chaque place : state repr´esente l’´etat du sommet v et
inbuﬀer l’ensemble des messages parvenus au sommet v mais qui n’ont pas encore ´et´e
trait´es.

On montre maintenant comment impl´ementer les transitions internes ainsi que les

op´erations d’envoi et de r´eception de messages `a l’aide d’agents mobiles.

Simuler une transition interne. Un agent a qui se trouve sur un sommet u dans l’´etat
s peut facilement simuler l’application d’une transition interne par u, i.e., l’application
d’une transition de la forme

, 0,⊥).

(s, 0,⊥) (cid:24)p (s

(cid:2)

En eﬀet, puisqu’il suﬃt de modiﬁer l’´etat de u, l’agent a doit juste modiﬁer la valeur de
state(u) de telle sorte que state(u) = s

(cid:2).

Simuler une transition de la forme envoyer m par le port p. On consid`ere un
agent a qui se trouve sur un sommet u dans l’´etat s et qui doit simuler une transition
d’envoi d’un message m par le port p, i.e., une transition de la forme

(s, 0,⊥) (cid:24)p (s

(cid:2)

, p, m).

On note v le voisin de u tel que δu(v) = p. Pour simuler cette transition, l’agent a commence
(cid:2), puis il quitte le sommet u par le
par modiﬁer l’´etat de u de telle sorte que state(u) = s
port p et lorsqu’il arrive en v par un port q, il ajoute le couple (q, m) dans inbuﬀer(v).
Ensuite, l’agent a quitte le sommet v par le port q pour retourner sur le sommet u.

Simuler une transition de la forme recevoir m par le port q. On consid`ere un
agent a qui se trouve sur un sommet u dans l’´etat s et qui doit simuler une transition de
r´eception d’un message m par le port q, i.e., une transition de la forme

(s, q, m) (cid:24)p (s

(cid:2)

, 0,⊥).

Pour pouvoir simuler cette r`egle, l’agent a doit s’assurer qu’il existe un couple (q, m) ∈
inbuﬀer(u) (sinon, cela signiﬁe que le message m attendu n’est pas encore arriv´e par le
port q). Si un tel couple existe, alors l’agent a supprime une occurrence du message (q, m)
de inbuﬀer(u) et modiﬁe l’´etat de u de telle sorte que state(u) = s

(cid:2).

214

Chapitre 8. Agents Mobiles

Remarque 8.9 L’ex´ecution des transitions d’envoi de messages permet `a un agent a de
modiﬁer le champ inbuﬀer(u) d’un sommet u qui n’appartient pas `a Ta pour y ajouter de
l’information. Cependant, si un agent a modiﬁe la valeur de state(u), alors cela implique
que u est un sommet de Ta.
Remarque 8.10 Si l’algorithme D n´ecessite que l’ordre des messages soient conserv´es, il
suﬃt de modiﬁer l’algorithme de simulation de la mani`ere suivante. Pour chaque sommet
u ∈ V (G), on impl´emente l’ensemble inbuﬀer(u) sous forme d’une ﬁle. Lorsqu’un couple
(p, m) est ajout´e `a inbuﬀer(u), il est ajout´e en queue de ﬁle. Lorsqu’un agent doit simuler
(cid:2))
la r´eception d’un message m par le port q, il doit s’assurer que le premier couple (q, m
(cid:2) avant d’ex´ecuter la r`egle et il doit supprimer ce couple de
dans la ﬁle est tel que m = m
inbuﬀer(u).

Puisque pour chaque sommet v, un seul agent a peut simuler l’envoi d’un message par
v, il n’est pas n´ecessaire d’assurer que le syst`eme de navigation pr´eserve l’ordre de d´epart
des agents.

La proposition suivante permet de voir que pour toute ex´ecution de l’algorithme A
sur un syst`eme de navigation correspondant `a un r´eseau (G, δ), il existe une ex´ecution
correspondante de D sur le r´eseau (G, δ).
Proposition 8.11 Pour toute ex´ecution ρ de l’algorithme A pour agents mobiles sur
(cid:2) de
le syst`eme de navigation correspondant au r´eseau (G, δ), il existe une ex´ecution ρ
l’algorithme D telle que pour toute ´etape i de ρ, il existe une ´etape j de ρ
(cid:2) telle que les
propri´et´es suivantes sont v´eriﬁ´ees.

– Pour tout sommet v ∈ V (G), statej(v) = statei(v).
– Pour toute arˆete {v, v

(cid:2)}, l’ensemble des messages en transit `a l’´etape j de ρ de v
(cid:2) est le multi-ensemble {m | ∃(δv(cid:2)(v), m) ∈ inbuﬀeri(v)} si l’agent a auquel
vers v
appartient le sommet v n’est pas en train de simuler un envoi de message de v vers
(cid:2) et qu’il simule un envoi de message,
(cid:2). Dans le cas o`u a est en transit entre v et v
v
il faut y ajouter le message m dont l’agent a est en train de simuler l’envoi `a partir
du sommet v par port δv(v

(cid:2)).

Il suﬃt de consid´erer l’ex´ecution ρ

(cid:2) de D construite de la mani`ere suivante.
Preuve :
Initialement, les propri´et´es sont v´eriﬁ´ees. On suppose qu’`a l’´etape i de ρ, les propri´et´es
(cid:2). Si `a l’´etape i + 1, aucun agent n’applique une r`egle de
sont vraies pour l’´etape j de ρ
(cid:2) pour l’´etape j de ρ. Si `a
simulation, alors la propri´et´e est vraie apr`es l’´etape i + 1 de ρ
(cid:2) de
l’´etape i + 1, un agent simule une transition sur un sommet v, alors on peut ´etendre ρ
telle sorte qu’`a l’´etape j + 1, cette transition soit eﬀectu´ee par le sommet v.

2

8.4.3 Simuler un algorithme utilisant des ´echanges de messages qui ter-

mine par un algorithme pour agents mobiles qui termine

´Etant donn´e un algorithme D et un r´eseau (G, δ) tel que toute ex´ecution de D sur (G, δ)
termine, on sait d’apr`es la Proposition 8.11 que pour toute ex´ecution de A que (G, δ), il
existe une ´etape i `a partir de laquelle les ´etiquettes des places ne sont plus modiﬁ´ees. Par
ailleurs, on sait que la conﬁguration atteinte `a l’´etape i est une conﬁguration ﬁnale de D
sur (G, δ) (puisque sinon, au moins un agent pourrait appliquer une transition sur l’un
des sommets de son arbre).

8.4. Des Messages vers les Agents Mobiles

215

Cependant, l’algorithme de simulation A pr´esent´e pr´ec´edemment repose sur le fait
que les agents parcourent leurs arbres ind´eﬁniment. On va maintenant montrer qu’on
peut modiﬁer A pour s’assurer que toute ex´ecution de A sur (G, δ) termine dans une
conﬁguration ﬁnale o`u les ´etiquettes des places correspondent aux ´etats des sommets
correspondants dans une conﬁguration ﬁnale de D sur (G, δ).
Cas particulier o`u D permet de d´etecter la terminaison

> i et v

(cid:2) ∈ V (G), res ◦ statei(cid:2) = res ◦ statei.

On consid`ere d’abord le cas o`u l’algorithme D r´esout un probl`eme P sur une famille F
de r´eseaux avec d´etection de la terminaison. On va montrer que les agents peuvent alors
eux aussi d´etecter la terminaison de l’algorithme.
On note L l’ensemble d’´etiquette utilis´ee par D et on sait qu’il existe une fonction res,
un ensemble d’´etiquette Lf ⊆ L tels que pour tout r´eseau (G, δ) ∈ F, toute ex´ecution ρ
de D sur (G, δ) termine et l’´etiquetage res◦ state de G est une solution de P sur (G, δ).
Par ailleurs, il existe une ´etape i de ρ et un sommet v ∈ V (G) telle que statei(v) ∈ Lf et
(cid:2)
pour tous i
On modiﬁe A de la mani`ere suivante aﬁn d’assurer que A permet de r´esoudre P sur F
avec d´etection de la terminaison. Pour cela, `a chaque fois qu’un agent a modiﬁe l’´etat d’un
sommet v, il v´eriﬁe si le nouvel ´etat de v appartient `a Lf . Dans un tel cas, l’agent a marque
le sommet v pour indiquer que l’algorithme est termin´e. Il utilise ensuite un algorithme
similaire `a l’algorithme de construction d’arbre pr´esent´e pr´ec´edemment pour marquer tous
les sommets du graphe aﬁn d’indiquer que l’algorithme est termin´e. Lorsqu’un agent ne
peut plus marquer de sommet (il a ﬁni son parcours en profondeur du graphe), il retourne
`a sa base et s’endort.
Ainsi, pour toute ex´ecution ρ de A sur (G, δ), il existe une ´etape i de ρ lors de laquelle
l’´etat d’un sommet v appartient `a Lf et par cons´equent, il existe une ´etape j > i lors
de laquelle tous les sommets portent une marque indiquant que l’algorithme a calcul´e le
r´esultat souhait´e et o`u tous les agents sont endormis dans leurs bases et savent que le
r´esultat est calcul´e. Ainsi, l’algorithme de simulation A permet de r´esoudre P sur F avec
d´etection de la terminaison ; c’est ce qui est rappel´e dans la proposition suivante.
Proposition 8.12 Pour tout algorithme D utilisant des ´echanges de message, si l’algo-
rithme D r´esout un probl`eme P sur une famille de r´eseaux F avec d´etection de la ter-
minaison, alors l’algorithme A pour agents mobiles d´ecrit pr´ec´edemment r´esout P sur F
avec d´etection de la terminaison.

Cas G´en´eral

Dans le cas o`u les sommets de (G, δ) ne peuvent pas savoir si l’ex´ecution de D est
termin´ee, on ne peut pas utiliser la m´ethode pr´ec´edente qui repose sur l’apparition sur un
sommet d’une ´etiquette indiquant que l’algorithme D a calcul´e son r´esultat ﬁnal.

Aﬁn d’assurer l’arrˆet des agents mˆeme s’ils ne peuvent pas d´etecter la terminaison, on
consid`ere que l’arbre de chaque agent a est un arbre enracin´e dont la racine est a. On
ajoute des champs dans l’´etiquette des places de la mani`ere suivante.

– Dans l’´etiquette de chaque base v, on ajoute un bool´een ﬁnished qui indique `a
l’agent a dont v est la base s’il doit encore simuler des pas de calculs sur les sommets
de son arbre.

216

Chapitre 8. Agents Mobiles

– Dans l’´etiquette de chaque place v, on ajoute un entier father qui est le num´ero
du port permettant d’atteindre le p`ere de v dans l’arbre. L’entier father de chaque
base v est ´egal `a 0 puisque v est la racine de l’arbre.

Initialement, pour chaque base v, ﬁnished(v) = Faux et pour tout sommet v, father(v) =
0, puisque les arbres n’ont pas ´et´e construits et qu’aucun pas de l’algorithme n’a ´et´e simul´e.
L’Algorithme 3 est alors modiﬁ´ee de telle sorte que lors de la construction des arbres
dans l’´etape 1, les valeurs de father(v) est initialis´ee correctement et contient le num´ero
du port par lequel l’agent a qui a marqu´e v est arriv´e sur ce sommet.

aucun pas de calculs `a simuler sur les sommets de son arbre s’arrˆete.

L’´etape 2 de l’Algorithme 3 est aussi modiﬁ´ee de fa¸con `a ce qu’un agent qui n’a plus
Pour cela, chaque agent a ex´ecute l’´etape 2 de l’algorithme A en rondes, o`u chaque
ronde correspond `a un parcours par a de son arbre. Au d´ebut de chaque ronde, l’agent a
est toujours sur sa base v et il assigne la valeur Vrai `a ﬁnished(v). `A la ﬁn de chaque
ronde, l’agent a retourne `a sa base v. Si lors d’une ronde, un agent a a simul´e tous les pas
de calculs possibles sur tous les sommets de son arbre et si la valeur de ﬁnished(v) est
Vrai, alors a s’endort sur sa base. Dans le cas contraire, il a encore des pas de calculs `a
simuler et il passe `a la ronde suivante.
Il se peut qu’un agent a soit endormi sur sa base et qu’un autre agent a(cid:2) modiﬁe
l’´etiquette d’un sommet v de l’arbre Ta de l’agent a pour ajouter un couple (p, m) `a
inbuﬀer(v). Dans ce cas l`a, il faut aller r´eveiller l’agent a pour lui signiﬁer qu’il a encore
des pas de calculs `a eﬀectuer. Il se peut aussi que lorsqu’un agent a revient sur sa base
`a la ﬁn d’une ronde, il a simul´e tous les pas de calculs possibles sur chacun des sommets
de son arbre, mais qu’entre-temps un couple (p, m) a ´et´e ajout´e `a inbuﬀer(v) pour un
sommet v ∈ V (Ta). Le rˆole du champ ﬁnished de la base de chaque agent si un couple
(p, m) a ´et´e ajout´e `a inbuﬀer(v) pour un sommet v de l’arbre de a.

Ainsi, `a chaque fois qu’un agent a simule une transition d’envoi de message m d’un
(cid:2), a modiﬁe l’´etat de inbuﬀer(v) comme pr´ec´edemment, puis `a
sommet v vers un sommet v
(cid:2) et il
l’aide des champs father de chaque sommet il va `a la racine r de l’arbre contenant v
assigne la valeur Faux `a ﬁnished(r) (si un agent est endormi en r, il le r´eveille). Ensuite,
l’agent a retourne sur le sommet v et continue d’ex´ecuter l’algorithme de simulation.

Puisque les champs de state(v) et inbuﬀer(v) sont modiﬁ´ees exactement de la mˆeme
fa¸con que dans l’Algorithme 3, la Proposition 8.11 est toujours vraie pour cette adaptation
de l’algorithme et il suﬃt donc de prouver que toute ex´ecution de l’algorithme A termine
et que la conﬁguration ﬁnale de chaque ex´ecution de A est une conﬁguration ﬁnale de D.
Proposition 8.13 Pour tout algorithme D utilisant des ´echanges de messages, il existe
un algorithme A pour agents mobiles tels que A simule D.
´Etant donn´e un r´eseau (G, δ) sur lequel tout ex´ecution de D termine, on
Preuve :
consid`ere une ex´ecution ρ de A sur (G, δ) par un ensemble non-vides d’agents.
Puisque toute ex´ecution de D termine sur (G, δ), il existe d’apr`es la Proposition 8.11
une ´etape i1 de ρ telle que pour toute ´etape i ≥ i1 et pour tout sommet v ∈ V (G),
statei+1(v) = statei(v) et inbuﬀeri(v) = ∅. Par cons´equent, il existe une ´etape i2 ≥ i1
telle que pour toute ´etape i ≥ i1 et pour toute base v, ﬁnished(v) = Vrai. Ainsi, il
existe une ´etape i3 ≥ i2 lors de laquelle tous les agents sont endormis sur leurs bases et
l’ex´ecution est donc termin´ee.

On remarque que pour toute ronde i de ρ et pour tout agent a, si a est sur sa base

8.5. R´esultat d’ ´Equivalence et Applications

217

(cid:2) ∈ V (Ta),
v `a la ﬁn de la ronde i et que ﬁnished(v) = Vrai, alors ou bien pour tout v
(cid:2)) = ∅, ou bien il existe un agent a(cid:2) qui se trouve sur un sommet de Ta. Ainsi,
inbuﬀer(v
puisque dans la conﬁguration ﬁnale de ρ, chaque agent est sur sa base, on sait que pour
tout sommet v ∈ V (G), inbuﬀer(v) = ∅ et puisque tous les agents se sont endormis sur
leurs bases, aucune transition interne ou d’envoi de messages ne peut ˆetre simul´ee sur un
sommet v ∈ V (G). La conﬁguration ﬁnale de ρ correspond donc d’apr`es la Proposition 8.11
`a la conﬁguration ﬁnale d’une ex´ecution de D sur G.

2

8.5 R´esultat d’´Equivalence et Applications

On pr´esente dans cette section le th´eor`eme principal du chapitre obtenu grˆace aux
propositions prouv´ees dans les Sections 8.3 et 8.4. On pr´esente ensuite les corollaires
obtenus `a partir des r´esultats du Chapitre 7 pour les probl`emes de rendez-vous et d’´election
dans les syst`emes `a agents mobiles.

8.5.1 R´esultat Principal

(cid:2)(v) = (λ(p), 0, (cid:17))) sinon.

Grˆace aux Propositions 8.5, 8.12 et 8.13, on a donc montr´e les th´eor`emes suivants.

On rappelle qu’on associe `a tout syst`eme `a agents mobiles (A, P, S, π0, λ) dont le
syst`eme de navigation est un graphe G avec un ´etiquetage des ports δ, un r´eseau G(cid:2) =
(cid:2) est d´eﬁni de la mani`ere suivante. Pour tout
(cid:2)) avec un ´etiquetage des ports δ o`u λ
(G, λ
sommet v ∈ V (G) qui correspond `a une place p, λ
(cid:2)(v) = (λ(p), 1, λ(a)) si p est la base de
l’agent a et λ
Th´eor`eme 8.14 Il existe un algorithme A pour agents mobiles qui permet de r´esoudre un
probl`eme P sur un syst`eme `a agents mobiles (A, P, S, π0, λ) dont le syst`eme de navigation
est un graphe G avec un ´etiquetage des ports δ si et seulement s’il existe un algorithme
D utilisant des ´echanges de messages qui permet de r´esoudre P sur le r´eseau (G(cid:2)
, δ) o`u
G(cid:2) = (G, λ
Th´eor`eme 8.15 Il existe un algorithme A pour agents mobiles qui permet de r´esoudre
un probl`eme P (avec d´etection de la terminaison) sur une famille F de syst`emes `a agents
mobiles si et seulement s’il existe un algorithme D utilisant des ´echanges de messages
(avec d´etection de la terminaison) qui permet de r´esoudre P sur la famille F(cid:2) de r´eseaux
correspondants aux syst`emes de F.

(cid:2)) et λ

(cid:2) est l’´etiquetage de G obtenu `a partir de λ et de π0.

8.5.2

´Election et Rendez-vous pour Agents Mobiles

Dans le cadre des syst`emes `a agents mobiles, le but d’un algorithme d’´election est d’´elire
un agent qui prend l’´etiquette ´elu alors que les autres sommets prennent l’´etiquette non-
´elu. Ces ´etiquettes sont terminales et un agent qui a une de ces ´etiquettes ne peut donc
pas en changer.

Le probl`eme du rendez-vous a aussi ´et´e ´etudi´e dans ce cadre et le but d’un algorithme
de rendez-vous est d’arriver dans une conﬁguration o`u tous les agents sont r´eunis en un
mˆeme sommet du graphe correspondant au syst`eme de navigation. On demande de plus
que lors de l’ex´ecution, chaque agent d´etecte qu’il se trouve sur le sommet de rendez-vous
et qu’il ne bougera plus.

218

Chapitre 8. Agents Mobiles

Ces deux probl`emes sont ´equivalents puisqu’une fois qu’un agent a ´et´e ´elu, tous les
agents peuvent se retrouver sur la base de l’agent ´elu. R´eciproquement, une fois qu’un
agent est arriv´e sur le sommet o`u aura lieu le rendez-vous, il essaie de marquer la place
o`u il se trouve : s’il est le premier `a le faire, il prend l’´etiquette ´elu et sinon, il prend
l’´etiquette non-´elu.

Ces deux probl`emes et quelques autres probl`emes ´equivalents ont ´et´e ´etudi´es dans le
mod`ele consid´er´e dans ce chapitre [BFFS03b, BFFS06, DFNS05, DFNS06] ainsi que dans
des mod`eles plus faibles [DFP03, GKKZ06, KKR06].

On remarque que le probl`eme du rendez-vous revient `a attribuer une ´etiquette par-
ticuli`ere `a un unique sommet du graphe (qui est le sommet o`u se fait le rendez-vous),
i.e., `a ´elire un sommet du graphe. Ainsi, d’apr`es les Th´eor`emes 7.32 et 8.14, on a la ca-
ract´erisation suivante des syst`emes `a agents mobiles dans lesquels on peut r´esoudre les
probl`emes de l’´election et du rendez-vous.
Corollaire 8.16 ´Etant donn´e un syst`eme `a agents mobiles (A, P, S, π0, λ) correspondant
`a un graphe G(cid:2) = (G, λ
(cid:2)) avec un ´etiquetage des ports δ, il existe un algorithme d’´election
ou de rendez-vous pour (A, P, S, π0, λ) si et seulement si le graphe (Dir(G(cid:2)), δ) est minimal
pour les revˆetements dirig´es sym´etrique.

De mˆeme, on peut montrer grˆace au Th´eor`emes 7.42 et 8.15 qu’il suﬃt de connaˆıtre
une borne sur le diam`etre du graphe pour pouvoir r´esoudre ´election et nommage dans un
syst`eme `a agents mobiles qui v´eriﬁe les conditions du Corollaire 8.16.

Par ailleurs, grˆace aux Th´eor`emes 7.43 et 8.15, on sait que la connaissance d’une borne
serr´ee sur la taille du graphe permet ou bien d’´elire un agent (ou de r´esoudre le rendez-
vous) dans un syst`eme `a agents mobiles (A, P, S, π0, λ) ou de d´etecter qu’il n’existe pas
d’algorithme d’´election ou de rendez-vous pour (A, P, S, π0, λ).

Ainsi, les caract´erisations obtenues par Das et al. [DFNS05, DFNS06] deviennent des
corollaires des travaux pr´esent´es dans ce chapitre et dans le chapitre pr´ec´edent. De la
mˆeme mani`ere, en utilisant les r´esultats de Flocchini et al. [FRS03], on peut caract´eriser
les syst`emes `a agents mobiles o`u on peut r´esoudre ´election et rendez-vous lorsque le syst`eme
de navigation est muni d’un sens de la direction. Les r´esultats de Barri`ere et al. [BFFS03b,
BFFS06] deviennent alors des corollaires de ces caract´erisations.

8.6 Conclusion et Perspectives

Dans ce chapitre, on a montr´e que les syst`emes `a agents mobiles ont la mˆeme puis-
sance de calcul que les syst`emes distribu´es o`u les processus communiquent par ´echange
de messages (Th´eor`eme 8.14). On a montr´e que ce r´esultat permettait de caract´eriser les
syst`emes `a agents mobiles dans lesquels le probl`eme du rendez-vous pouvait ˆetre r´esolu.
Dans [BFFS03a], Barri`ere et al. consid`ere des syst`emes `a agents mobiles o`u chaque
agent `a une ´etiquette unique mais il n’existe pas d’ordre global sur ces ´etiquettes. Autre-
ment dit, chaque agent `a une couleur et son propre ordre sur l’ensemble des couleurs de
tous les agents, mais les ordres utilis´es par les diﬀ´erents agents peuvent ˆetre diﬀ´erents.
De mˆeme, chaque port est ´etiquet´e avec une couleur aﬁn de permettre `a chaque agent
de distinguer les arˆetes incidentes `a chaque sommet, mais il n’existe pas d’ordre global
sur les couleurs utilis´ees pour ´etiqueter les ports. Barri`ere et al. ´etudient les probl`emes
de l’´election et du rendez-vous dans ce mod`ele et ils exhibent des algorithmes eﬀectifs

8.6. Conclusion et Perspectives

219

d’´election pour certaines classes de graphes. Un probl`eme ouvert pr´esent´e dans [BFFS03a]
est de d´eterminer s’il existe un algorithme d’´election pour la classe de tous les graphes.

Dans [Cha06], on consid`ere un mod`ele a priori plus faible que celui de Barri`ere et al. En
eﬀet, on suppose de plus que lorsqu’un agent laisse un message sur un sommet, les autres
agents ne peuvent pas le comprendre mais peuvent juste d´eterminer quel est l’auteur du
message (i.e., sa couleur). On pr´esente dans ce mod`ele un algorithme eﬀectif d’´election pour
la classe de tous les graphes ainsi qu’une caract´erisation des syst`emes `a agents mobiles
dans lesquels on peut r´esoudre l’´election. Cette caract´erisation s’exprime `a l’aide de la
notion d’automorphismes «bien ´equilibr´es» qui ont ´et´e introduits par Boug´e dans [Bou88]
pour ´etudier le probl`eme de l’´election sym´etrique dans CSP. Il est important de noter
que les conditions n´ecessaires pr´esent´ees dans [Cha06] restent vraies dans le mod`ele ´etudi´e
dans [BFFS03a] : on r´epond donc positivement `a la question pos´ee par Barri`ere et al.

220

Chapitre 8. Agents Mobiles

Chapitre 9

Complexit´e

Sommaire
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
9.1
´Etiquetages Pseudo-R´eguliers . . . . . . . . . . . . . . . . . . . . 222
9.2
9.3 Colorations Semi-R´eguli`eres . . . . . . . . . . . . . . . . . . . . . 229
9.4 Colorations Connexes . . . . . . . . . . . . . . . . . . . . . . . . . 236
9.5 Conclusion et Perspectives . . . . . . . . . . . . . . . . . . . . . . 242

9.1

Introduction

Dans ce chapitre, on s’int´eresse `a la complexit´e de d´ecider si un graphe donn´e admet
un algorithme de nommage ou d’´election dans les diﬀ´erents mod`eles consid´er´es dans les
chapitres pr´ec´edents.

Des r´esultats existent d´ej`a pour les mod`eles ´etudi´es dans le Chapitre 7 ; ils ont ´et´e
obtenus par Boldi et Vigna [BV02a] et par Yamashita et Kameda [YK96c]. On rappelle
qu’un graphe G admet un algorithme d’´election (ou le nommage) dans un des mod`eles
utilisant des messages si cet algorithme permet de r´esoudre l’´election (ou le nommage) sur
G quel que soit l’´etiquetage des ports. Dans [BV02a], Boldi et Vigna montrent qu’on peut
d´ecider si un graphe est minimal pour les ﬁbrations en temps polynomial en calculant la
base minimale de ce graphe. De plus, une fois que cette base minimale est calcul´ee, on peut
v´eriﬁer qu’un graphe est minimal pour les ﬁbrations non-triviales en s’assurant qu’il existe
un sommet de la base minimale dont la ﬁbre est triviale. Ainsi, d’apr`es les Th´eor`emes 7.47
et 7.48, on sait qu’on peut v´eriﬁer en temps polynomial si on peut nommer ou ´elire dans
les mod`eles diﬀusion-`a-port et diﬀusion-`a-boˆıte. Par ailleurs, Yamashita et Kameda ont
montr´e dans [YK96c] qu’il est co-NP-complet de d´ecider si un graphe G donn´e admet un
algorithme d’´election dans le mod`ele port-`a-port.

Il est naturel de se demander quelle est la complexit´e de d´ecider si un graphe G donn´e
admet un algorithme de nommage ou d’´election dans les autres mod`eles consid´er´es dans ce
m´emoire. On montre dans ce chapitre que pour tous les mod`eles, `a l’exception des mod`eles
diﬀusion-`a-port et diﬀusion-`a-boˆıte, ces probl`emes sont co-NP-complets.

Aﬁn d’obtenir une preuve g´en´erale pour le plus grand nombre de mod`eles possibles,
on introduit la notion d’´etiquetage pseudo-r´egulier (D´eﬁnition 9.1) et on montre dans la

221

222

Chapitre 9. Complexit´e

Section 9.2 qu’il est co-NP-complet de d´ecider si un graphe G donn´e admet un algorithme
d’´election ou de nommage dans chacun des sept mod`eles (incluant le mod`ele port-`a-port
pour lequel ce r´esultat ´etait d´ej`a connu [YK96c]) ´etudi´es dans les chapitres pr´ec´edents
o`u ´election et nommage peuvent ˆetre r´esolus sur les mˆemes graphes (Corollaire 9.8). Il
faut noter que notre r´eduction pour montrer qu’il est NP-diﬃcile de d´ecider si un graphe
G admet un algorithme d’´election (ou de nommage) dans chacun de ces mod`eles est
totalement diﬀ´erente de la preuve de Yamashita et Kameda pour le mod`ele port-`a-port.
Dans les Sections 9.3 et 9.4, on montre qu’il est co-NP-complet de d´ecider si un graphe
G admet un algorithme de nommage (ou d’´election) dans les deux mod`eles restants : les
calculs locaux cellulaires sur les ´etoiles (Corollaire 9.19) et les calculs locaux cellulaires sur
les arˆetes non-´etiquet´ees (Corollaire 9.23).

Les r´esultats pr´esent´es dans ce chapitre ont ´et´e obtenus en collaboration avec Dani¨el

Paulusma et ont ´et´e publi´es dans [CP06].

9.2

´Etiquetages Pseudo-R´eguliers

Aﬁn de pouvoir obtenir des r´esultats de NP-compl´etude pour une classe de mod`eles la
plus large possible, on introduit la notion d’´etiquetage pseudo-r´egulier. Il faut noter que les
´etiquetages r´eguliers (D´eﬁnition 7.51) et les colorations pseudo-r´eguli`eres (D´eﬁnition 5.6)
sont des cas particuliers d’´etiquetages r´eguliers.

D´eﬁnition 9.1 Un ´etiquetage pseudo-r´egulier d’un graphe simple non-´etiquet´e connexe
G est un ´etiquetage (cid:8) de G tel que

– pour tout i ∈ (cid:8)(V (G)), G[i] est un graphe r´egulier,
– pour tout i, j ∈ (cid:8)(V (G)) avec i (cid:12)= j, G[i, j] est un stable, ou alors G[i, j] admet un

couplage parfait.

Grˆace `a cette notion, on va montrer qu’il est co-NP-complet de d´ecider si un graphe
simple G admet un algorithme de nommage ou d’´election dans tous les mod`eles consid´er´es
dans les chapitres pr´ec´edents o`u nommage et ´election sont ´equivalents.

Dans la proposition suivante, on montre que toutes les couleurs d’un ´etiquetage pseudo-

r´egulier d’un graphe simple connexe G apparaissent avec la mˆeme cardinalit´e dans G.
Proposition 9.2 ´Etant donn´e un graphe simple connexe G et un ´etiquetage pseudo-
−1(i)| = q.
r´egulier (cid:8) de G, il existe un entier constante q tel que pour tout i ∈ (cid:8)(V (G)), |(cid:8)
Preuve : ´Etant donn´e un graphe simple connexe G, un ´etiquetage pseudo-r´egulier (cid:8) de
G, et deux couleurs i, j ∈ (cid:8)(V (G)). S’il existe deux sommets voisins u, v ∈ V (G) tels que
−1(j)|. Puisque
(cid:8)(u) = i et (cid:8)(v) = j, G[i, j] admet un couplage parfait et alors |(cid:8)
|V (G)|
−1(i)| = |(cid:8)
G est connexe, pour toutes couleurs i, j ∈ (cid:8)(V (G)), |(cid:8)
|(cid:5)(V (G))| .

−1(i)| = |(cid:8)
−1(j)| =

2

Le probl`eme du H-Revˆetement est de d´ecider si un graphe simple G est un revˆete-

ment simple du graphe simple H qui est ﬁx´e.

H-Revˆetement
Instance : Un graphe simple G.
Question : Est-ce que G est un revˆetement simple de H ?

9.2. ´Etiquetages Pseudo-R´eguliers

223

c

a

b

e

d

Fig. 29 – Le graphe K.

Pour prouver qu’il est NP-diﬃcile de d´ecider si un graphe simple G admet un ´etiquetage
pseudo-r´egulier propre, on utilise la NP-compl´etude du probl`eme du K-Revˆetement, o`u
K est le graphe simple obtenu en supprimant une arˆete du graphe complet `a 5 sommets.
Kratochv´ıl et al. ont montr´e dans [KPT98] que le probl`eme du K-Revˆetement est NP-
complet. Le graphe K est repr´esent´e sur la Figure 29 : il contient deux sommets de degr´e
3 non-adjacents, not´es b et e, et trois sommets de degr´es 4 adjacents `a tous les autres
sommets, not´es a, c et d.

La proposition suivante pr´esente quelques propri´et´es que v´eriﬁe tout graphe simple qui

est un revˆetement simple de K.
Proposition 9.3 Pour tout graphe simple G qui est un revˆetement simple de K, on peut
partitionner V (G) en deux blocs B1 et B2 tels que les conditions suivantes sont v´eriﬁ´ees :

– il existe un entier k tel que |B1| = 2k et |B2| = 3k,
– pour tout u ∈ B1, |NG(u) ∩ B1| = 0 et |NG(u) ∩ B2| = 3,
– pour tout u ∈ B2, |NG(u) ∩ B1| = 2 et |NG(u) ∩ B2| = 2.

Preuve : On consid`ere un graphe simple G qui est un revˆetement simple de K `a travers
un homomorphisme ϕ. On sait d’apr`es la Proposition 2.6 qu’il existe un entier k tel que
pour tout v ∈ V (K), |ϕ

−1(v)| = k.

il suﬃt de consid´erer B1 = ϕ

−1({v | degK(v) = 3}) et B2 = ϕ

Puisque K contient deux sommets de degr´e 3 non-adjacents et 3 sommets de degr´e 4,
−1({v | degK(v) = 4}). 2
Un graphe simple G qui v´eriﬁe les conditions de la Proposition 9.3 est appel´e un
K-candidat. Puisque ces conditions peuvent ˆetre v´eriﬁ´ees en temps polynomial, on peut
supposer que toute instance du probl`eme du K-Revˆetement est un K-candidat.
Pour notre preuve de NP-compl´etude, on modiﬁe tout K-candidat G de la mani`ere sui-
vante. ´Etant donn´e deux sommets voisins u, v ∈ V (G) tels que degG(u) = 3 et degG(v) = 4,
on remplace l’arˆete {u, v} de G par une chaˆıne de q ≥ 1 diamants comme d´ecrit sur la
(cid:2) ainsi obtenu est le graphe-diamant de G respectivement `a
Figure 30. Le graphe simple G
(cid:2)[{ai, bi, ci, di, ei}] est un diamant
l’arˆete {u, v}. Pour tout i ∈ [1, q], le sous-graphe Di = G
(cid:2).
de G
Dans le lemme suivant, on montre que tout ´etiquetage pseudo-r´egulier d’un graphe-
diamant est localement injectif sur tous les sommets de chaque diamant.
Lemme 9.4 ´Etant donn´e un K-candidat G de taille 5k et deux sommets voisins u, v ∈
(cid:2) qui est
V (G) tels que degG(u) = 3 et degG(v) = 4, on consid`ere un graphe simple G

224

Chapitre 9. Complexit´e

u = e0 a1

e1

a2

b1

c1

d1

e2

aq

b2

c2

d2

bq

cq

dq

eq v = aq+1

Fig. 30 – La chaˆıne de q diamants qui remplace l’arˆete {u, v}.

le graphe-diamant de G respectivement `a {u, v} dont les diamants sont D1, . . . , Dq o`u
q > k + 2 et q + k n’est pas divisible par 2 ou 3.
(cid:2), alors pour tout i ∈ [1, q], |(cid:8)(V (Di))| = 5,
Si (cid:8) est un ´etiquetage pseudo-r´egulier de G
(cid:8)(ei−1) /∈ (cid:8)(V (Di) \ {ei}) et (cid:8)(ai+1) /∈ (cid:8)(V (Di) \ {ai}).
Preuve : On note p = q + k ; on a alors |V (G
3. On consid`ere un diamant Di avec i ∈ [1, q] et on rappelle que u = e0 et v = aq+1.

(cid:2))| = 5p et p n’est divisible ni par 2, ni par

On suppose sans perte de g´en´eralit´e que (cid:8)(ai) = 1.

Propri´et´e 1 : (cid:8)(bi) (cid:12)= 1
On prouve cette propri´et´e par l’absurde. On suppose que (cid:8)(bi) = 1.

Par sym´etrie, on sait que (cid:8)(di) (cid:12)= 1. Si (cid:8)(di) = 2, alors puisque G

Si (cid:8)(ci) = (cid:8)(di) = 1, alors |(cid:8)(V (G
(cid:2)))| = 1, ce qui est impossible, puisque G
(cid:2) n’est pas
un graphe r´egulier.
On suppose que (cid:8)(ci) = 1 et alors (cid:8)(di) (cid:12)= 1 ; on note (cid:8)(di) = 2. Puisque G
(cid:2)[1, 2] admet
(cid:2)))| = 2 et
un couplage parfait, il faut que (cid:8)(ei−1) = (cid:8)(ei) = 2. Par cons´equent, |(cid:8)(V (G
d’apr`es la Proposition 9.2, cela implique que 2 divise p, ce qui est impossible en raison de
nos hypoth`eses sur p. Ainsi, (cid:8)(ci) (cid:12)= 1 et on suppose sans perte de g´en´eralit´e que (cid:8)(ci) = 2.
(cid:2)[2, (cid:8)(ei)] admet un
couplage parfait, cela implique que (cid:8)(ei) = 1 ou (cid:8)(ei) = 2. Si (cid:8)(ei) = 1 (resp. (cid:8)(ei) = 2),
(cid:2)[1, 2] admet un couplage parfait.
(cid:8)(ai−1) = 2 ou (cid:8)(ai+1) = 2 (resp. (cid:8)(ai+1) = 1) puisque G
(cid:2)))| = 2, ce qui est impossible. Sans perte de g´en´eralit´e, on
Dans tous les cas, |(cid:8)(V (G
(cid:2)[1] est r´egulier, (cid:8)(ei−1) (cid:12)= 1. Si (cid:8)(ei−1) = i o`u
suppose donc que (cid:8)(di) = 3. Puisque G
(cid:2)[1, 5 − i] n’admet pas de couplage parfait. Si (cid:8)(ei−1) /∈ {1, 2, 3}, alors
i ∈ {2, 3}, alors G
(cid:2)[1, (cid:8)(ei−1)] n’admet pas de couplage parfait.
G
Par cons´equent, (cid:8)(bi) (cid:12)= 1 et sans perte de g´en´eralit´e, on suppose maintenant que

(cid:2)[1, 2] admet un couplage parfait ; mais alors |(cid:8)(V (G

(cid:8)(bi) = 2.
Propri´et´e 2 : (cid:8)(ci) /∈ {1, 2}
On prouve cette propri´et´e par l’absurde. On suppose que (cid:8)(ci) = 1. Si (cid:8)(di) = 1, alors
(cid:2)))| = 2,
(cid:8)(ei−1) = (cid:8)(ei) = 2 puisque G
(cid:2)[2] est 1-r´egulier, et (cid:8)(ei) = 1, mais cela implique
ce qui est impossible. Si (cid:8)(di) = 2, alors G
(cid:2)))| = 2, ce qui est impossible. Sans perte de g´en´eralit´e, on suppose donc que
que |(cid:8)(V (G
(cid:2)))| = 3, ce qui est impossible en raison de nos
(cid:8)(di) = 3. Si (cid:8)(ei) ∈ {1, 2, 3}, alors |(cid:8)(V (G
hypoth`eses sur p. Si (cid:8)(ei) /∈ {1, 2, 3}, il faut que (cid:8)(ei−1) = (cid:8)(ei) puisque G
(cid:2)[1, (cid:8)(ei)] admet
(cid:2)[1, 2] n’admet pas de couplage parfait.
un couplage parfait ; mais alors G
(cid:2)[1, 2]
n’admet pas de couplage parfait. Si (cid:8)(di) /∈ {1, 2}, (cid:8)(ei) = (cid:8)(di) puisque G
(cid:2)[2, (cid:8)(di)] admet
(cid:2)[1, 2] n’admet pas de couplage parfait.
un couplage parfait ; mais alors G

On suppose (cid:8)(ci) = 2. Par sym´etrie, on sait que (cid:8)(di) (cid:12)= 1. Si (cid:8)(di) = 2, G

9.2. ´Etiquetages Pseudo-R´eguliers

225

Par cons´equent, (cid:8)(ci) /∈ {1, 2} et sans perte de g´en´eralit´e, on suppose maintenant que

(cid:8)(ci) = 3.
Propri´et´e 3 : (cid:8)(di) /∈ {1, 2, 3}
On prouve cette propri´et´e par l’absurde. Par sym´etrie, on sait que (cid:8)(di) (cid:12)= 1 et (cid:8)(di) (cid:12)= 2.
(cid:2)[2, 3] admet un couplage parfait ; mais alors
Si (cid:8)(di) = 3, alors (cid:8)(ei) = 2 puisque G
(cid:2)[1, 3] n’admet pas de couplage parfait.
G
Par cons´equent, (cid:8)(di) /∈ {1, 2, 3} et sans perte de g´en´eralit´e, on suppose maintenant

que (cid:8)(di) = 4.
Propri´et´e 4 : (cid:8)(ei) /∈ {1, 2, 3, 4}
(cid:2)[1, 2]
On prouve cette propri´et´e par l’absurde. Si (cid:8)(ei) = 1, alors (cid:8)(ai+1) = 2 puisque G
(cid:2)))| = 4, ce qui est impossible en raison de
admet un couplage parfait ; mais alors |(cid:8)(V (G
nos hypoth`eses sur p.
(cid:2)[1, 2] admet un couplage parfait ; mais alors
Si (cid:8)(ei) = 2, alors (cid:8)(ai+1) = 1 puisque G
(cid:2)[2, 3] n’admet pas de couplage parfait.
G
(cid:2)[3, 4] admet un couplage parfait ; mais alors
Si (cid:8)(ei) = 3, alors (cid:8)(ai+1) = 4 puisque G
(cid:2)[2, 3] n’admet pas de couplage parfait. Par sym´etrie, on sait que (cid:8)(ei) ne peut pas non
G
plus ˆetre ´egal `a 4.
Par cons´equent, (cid:8)(ei) /∈ {1, 2, 3, 4} et sans perte de g´en´eralit´e, on suppose maintenant

que (cid:8)(ei) = 5.
Propri´et´e 5 : (cid:8)(ei−1) /∈ {1, 2, 3, 4}
On prouve cette propri´et´e par l’absurde. Si (cid:8)(ei−1) = 1 (resp. (cid:8)(ei−1) = 3, (cid:8)(ei−1) =
4), alors (cid:8)(NG(cid:2)(ei−1)) = {1, 2, 3, 4} (resp. (cid:8)(NG(cid:2)(ei−1)) = {1, 2, 4, 5}, (cid:8)(NG(cid:2)(ei−1)) =
{1, 2, 3, 5}) ; ce qui est impossible puisque degG(cid:2)(ei−1) = 3.

´etiquet´es par 3 et 4 ; mais alors G

Si (cid:8)(ei−1) = 2, alors les deux voisins de ei−1 qui n’appartiennent pas `a Di doivent ˆetre
Par cons´equent, (cid:8)(ei) /∈ {1, 2, 3, 4}.

(cid:2)[1, 2] n’admet pas de couplage parfait.

Propri´et´e 6 : (cid:8)(ai+1) /∈ {2, 3, 4, 5}
On prouve cette propri´et´e par l’absurde. Puisque 5 /∈ (cid:8)(NG(cid:2)(bi)) et que (cid:8)(bi) = 2, on sait
que (cid:8)(ai+1) (cid:12)= 2.

Si (cid:8)(ai+1) = 3, alors les trois voisins de ai+1 qui n’appartiennent pas `a Di doivent ˆetre
(cid:2)[1, 5] n’admet pas de couplage parfait. Par sym´etrie,

´etiquet´es par 1, 2 et 4 ; mais alors G
on sait que (cid:8)(ai+1) (cid:12)= 4.

Si (cid:8)(ai+1) = 5, alors les trois voisins de ai+1 qui n’appartiennent pas `a Di doivent ˆetre
(cid:2)[5] est 1-r´egulier. On sait que ai+1 a un voisin v de degr´e
´etiquet´es par 3 et 4, puisque G
3 et par cons´equent, (cid:8)(v) ∈ {3, 4} ; sans perte de g´en´eralit´e, on suppose que (cid:8)(v) = 3.
Cependant, cela implique que (cid:8)(NG(cid:2)(v)) = (cid:8)(NG(cid:2)(ci)) = {1, 2, 4, 5} ; ce qui est impossible,
puisque degG(cid:2)(v) = 3.

Par cons´equent, (cid:8)(ai+1) /∈ {2, 3, 4, 5}
Le lemme suivant d´ecrit la propri´et´e fondamentale qu’on utilise pour prouver qu’il est

2

NP-diﬃcile de d´ecider si un graphe simple G admet un ´etiquetage pseudo-r´egulier.

226

Chapitre 9. Complexit´e

Lemme 9.5 ´Etant donn´e un K-candidat G de taille 5k et deux sommets voisins u, v ∈
(cid:2) qui est
V (G) tels que degG(u) = 3 et degG(v) = 4, on consid`ere un graphe simple G
le graphe-diamant de G respectivement `a {u, v} dont les diamants sont D1, . . . , Dq o`u
q > k + 2 et q + k n’est pas divisible par 2 ou 3.
(cid:2) est un revˆetement simple

(cid:2) admet un ´etiquetage pseudo-r´egulier propre, alors G

Si G

(cid:2), tout sommet de G

(cid:2)) = (cid:8)(v

(cid:2)).

D’apr`es la Proposition 9.3 et la construction de G

(cid:2))) et E(H) = {{i, j} | ∃{u, v} ∈ E(G

Par ailleurs, s’il existe un sommet v ∈ V (G

On note H le graphe construit `a partir des couleurs apparaissant dans G

de K.
Preuve : On note p = q + k ; on a alors |V (G
(cid:2).
3. On consid`ere un ´etiquetage pseudo-r´egulier propre (cid:8) de G

(cid:2))| = 5p et p n’est divisible ni par 2, ni par
(cid:2) de la mani`ere
(cid:2)), (cid:8)(u) = i et (cid:8)(v) = j}.
suivante : V (H) = (cid:8)(V (G
(cid:2), on sait que H n’est pas isomorphe
Puisque (cid:8) est un ´etiquetage pseudo-r´egulier propre de G
(cid:2). On va montrer que (cid:8) induit un revˆetement simple de G dans H et que H est un
`a G
revˆetement simple de K.
(cid:2) a un degr´e ´egal
`a 3 ou 4. De plus, pour tout i ∈ [1, q], on sait d’apr`es le Lemme 9.4, que |(cid:8)(V (Di))| = 5 et
(cid:8)(ei−1) /∈ (cid:8)(V (Di) \ {ei}). Ainsi, pour tout sommet v ∈ V (G
(cid:2)) tel que (cid:8)(v) = (cid:8)(ai) (resp.
(cid:8)(v) = (cid:8)(ci), (cid:8)(v) = (cid:8)(di)), on sait que |(cid:8)(v)| = |(cid:8)(ai)| = 4 (resp. |(cid:8)(v)| = |(cid:8)(ci)| = 4,
|(cid:8)(v)| = |(cid:8)(di)| = 4) et par cons´equent, degG(cid:2)(v) = 4.
(cid:2)) tel que (cid:8)(v) = (cid:8)(bi) (resp. (cid:8)(v) = (cid:8)(ei)),
alors (cid:8)(NG(cid:2)(v)) = {(cid:8)(ai), (cid:8)(ci), (cid:8)(di)} (resp. (cid:8)(NG(cid:2)(v)) = {(cid:8)(ai+1), (cid:8)(ci), (cid:8)(di)}) et v doit
(cid:2), on
donc avoir trois voisins de degr´e 4. D’apr`es la Proposition 9.3 et la construction de G
sait alors que degG(cid:2)(v) = 3.
Ainsi, pour tout u ∈ V (Di) et pour tout v ∈ V (G
(cid:2)) tel que (cid:8)(v) = (cid:8)(u), (cid:8) est localement
bijectif en v, i.e., NH((cid:8)(v)) = (cid:8)(NG(cid:2)(v)) et |NH((cid:8)(v))| = |NG(cid:2)(v)|.
Puisque q > k + 2, il existe deux entiers i, j ∈ [1, q − 1] et deux sommets u ∈ V (Di) et
v ∈ V (Dj) tels que (cid:8)(u) = (cid:8)(v). D’apr`es le Lemme 9.4, on sait que les diamants Di et Dj
sont diﬀ´erents. On choisit u et v de telle sorte que i < j et qu’il n’existe pas deux sommets
(cid:2) ∈ V (Di) ∪ . . . ∪ V (Dj−1) tels que (cid:8)(u
(cid:2)
, v
u
D’apr`es le Lemme 9.4, on peut supposer sans perte de g´en´eralit´e que (cid:8)(ai) = 1, (cid:8)(bi) =
2, (cid:8)(ci) = 3, (cid:8)(di) = 4, (cid:8)(ei) = 5 et on sait que (cid:8)(ei−1) /∈ {1, 2, 3, 4}.
On suppose que (cid:8)(aj) = 1. En raison du choix de Di et Dj, on sait que (cid:8)(ej−1) /∈
{2, 3, 4} et par cons´equent, (cid:8)(ej−1) = (cid:8)(ei−1). De plus, on sait que pour tous u, v ∈
V (Di), . . . , V (Dj−1), (cid:8)(u) (cid:12)= (cid:8)(v). Ainsi, V (H) = (cid:8)(V (G)) = {(cid:8)(u) | u ∈ V (Dk), k ∈
[i, j − 1]}. Par cons´equent, pour tout sommet v ∈ V (G
(cid:2)), (cid:8) est localement bijectif en v. On
(cid:2) est un revˆetement simple de H.
a donc montr´e que G
De plus, on sait que E(H) est l’ensemble constitu´e de l’arˆete {1, (cid:8)(ej−1)} et des arˆetes
{(cid:8)(u), (cid:8)(v)} telles qu’il existe une arˆete {u, v} ∈ V (G
(cid:2)) dont les extr´emit´es u et v appar-
tiennent `a V (Di) ∪ . . . ∪ V (Dj−1). Puisque tous les sommets de V (Di) ∪ . . . ∪ V (Dj−1)
ont des couleurs diﬀ´erentes, H est isomorphe au graphe simple G[V (Di) ∪ . . . ∪ V (Dj−1)]
auquel l’arˆete {ai, ej−1} a ´et´e ajout´ee. Si on consid`ere l’homomorphisme ϕ de H dans K
qui envoie chaque sommet ai (resp. bi, ci, di, ei) sur le sommet a (resp. b, c, d, e) de K, il
est clair que H est un revˆetement simple de K.
(cid:2) est un revˆetement simple de H et H est un revˆetement simple de

Par cons´equent, G

K : on sait d’apr`es la Proposition 2.4 que G

(cid:2) est un revˆetement de K.

9.2. ´Etiquetages Pseudo-R´eguliers

227

On suppose maintenant que (cid:8)(aj) (cid:12)= 1. Si (cid:8)(ei−1) = 5, alors (cid:8)(ai+1) = 1 et par
(cid:2) est un revˆetement de K. On suppose donc sans
cons´equent j = i + 1 et on sait d´ej`a que G
perte de g´en´eralit´e que (cid:8)(ei−1) = 6.
On montre que 1 /∈ (cid:8)(V (Dj)). On sait d´ej`a que (cid:8)(aj) (cid:12)= 1 et que 1 /∈ (cid:8)({bj, ej}),
puisque degG(cid:2)(bj) = degG(cid:2)(ej) = 3. Si (cid:8)(cj) = 1, alors (cid:8)(dj) ∈ {3, 4} et par cons´equent,
(cid:8)({bj, ej}) = {2, 6}. Mais cela implique qu’il existe un sommet avec une ´etiquette 3 ou
4 qui est voisin d’un sommet ´etiquet´e 6, ce qui est impossible. Par sym´etrie, on sait que
(cid:8)(dj) (cid:12)= 1.
On montre que 2 /∈ (cid:8)(V (Dj)). On sait d´ej`a que 2 /∈ (cid:8)({aj, cj , dj}) puisque degG(cid:2)(aj) =
degG(cid:2)(cj) = degG(cid:2)(dj) = 4. Si (cid:8)(bj) = 2, alors 1 ∈ (cid:8)({aj, cj, dj}), ce qui est impossible. Si
(cid:8)(ej) = 2, alors ou bien 1 ∈ (cid:8)({cj , dj}), ou bien (cid:8)({cj, dj}) = {3, 4} et (cid:8)(aj) = 1.
On montre que 3 /∈ (cid:8)(V (Dj)). On sait d´ej`a que 3 /∈ (cid:8)({bj, ej}). Si (cid:8)(aj) = 3, alors ou
bien 1 ∈ (cid:8)({cj, dj}), ou bien (cid:8)(ej−1) = 1, ce qui est impossible en raison de notre choix de
Di et de Dj. Si 3 ∈ (cid:8)({cj , dj}), alors 1 ∈ (cid:8)(V (Dj)).

Par sym´etrie, on sait que 4 /∈ (cid:8)(V (Dj)).
On montre que 5 /∈ (cid:8)(V (Dj)). On sait d´ej`a que seuls les sommets bj et ej peuvent ˆetre
´etiquet´es 5 et dans les deux cas, au moins une des ´etiquettes 3 ou 4 est l’´etiquette d’un
sommet de Dj.
2

Dans le lemme suivant, on montre qu’un graphe simple G est un revˆetement simple de

K si et seulement si tout graphe-diamant de G est un revˆetement simple de K.
Lemme 9.6 ´Etant donn´e un graphe simple G qui contient deux sommets voisins u, v ∈
(cid:2) qui est le
V (G) tels que degG(u) = 3 et degG(v) = 4, on consid`ere un graphe simple G
graphe-diamant de G respectivement `a {u, v}.
(cid:2) est un

Le graphe simple G est un revˆetement simple de K si et seulement si G

revˆetement simple de K.
Preuve : On consid`ere un graphe simple G contenant deux sommets voisins u, v ∈ V (G)
tels que degG(u) = 3 et degG(v) = 4 et un graphe diamant de G respectivement `a {u, v}
dont les diamants sont D1, . . . , Dq.
On rappelle que V (K) = {a, b, c, d, e} et que E(K) est l’ensemble constitu´e des arˆetes
{a, b},{a, c},{a, d},{a, e},{b, c},{b, d},{c, d},{c, e},{d, e}.

Si G est un revˆetement simple de K `a travers un homomorphisme ϕ, on sait que
degK(ϕ(u)) = 3 et degK(ϕ(v)) = 4. Sans perte de g´en´eralit´e, on suppose que ϕ(u) = e et
(cid:2) dans K, tel que pour tout w ∈ V (G),
(cid:2) de G
ϕ(v) = a. On consid`ere l’homomorphisme ϕ
(cid:2), ϕ(ai) = a, ϕ(bi) = b, ϕ(ci) = c, ϕ(di) = d,
(cid:2)(w) = ϕ(w) et pour tout diamant Di de G
ϕ
(cid:2) est un
ϕ(ei) = e. Puisque G est un revˆetement simple de K `a travers ϕ, il est clair que G
revˆetement de K `a travers ϕ.
(cid:2), alors il facile de voir
R´eciproquement, si G
que pour tout i ∈ [1, q], ϕ
(cid:2)(ei+1). Par cons´equent, ϕ(a1) =
(cid:2) aux sommets de G
ϕ(aq+1) = ϕ(v) et ϕ(eq) = ϕ(e0) = ϕ(u). Ainsi, la restriction ϕ de ϕ
est un homomorphisme tel que G est un revˆetement de K `a travers ϕ.

(cid:2) est un revˆetement de K `a travers ϕ
(cid:2)(ai) = ϕ

2

(cid:2)(ai+1) et ϕ

(cid:2)(ei) = ϕ

On peut maintenant montrer le r´esultat principal de cette section. On montre qu’il est
NP-complet de d´ecider si un graphe simple G admet un ´etiquetage pseudo-r´egulier propre,
un ´etiquetage r´egulier propre, un ´etiquetage r´egulier sym´etrique propre, une coloration

228

Chapitre 9. Complexit´e

pseudo-r´eguli`ere propre, une coloration r´eguli`ere propre ou une coloration r´eguli`ere parfaite
propre.

Th´eor`eme 9.7 Le probl`eme de d´ecider si un graphe simple G donn´e admet un ´etiquetage
pseudo-r´egulier propre, (resp. un ´etiquetage r´egulier propre, un ´etiquetage r´egulier sym´e-
trique propre, une coloration pseudo-r´eguli`ere propre, une coloration r´eguli`ere propre, une
coloration r´eguli`ere parfaite propre) est NP-complet.

Preuve : Puisqu’il suﬃt de deviner un ´etiquetage (cid:8) (et un ensemble de couplages parfaits
dans certains cas) d’un graphe simple G donn´e tel que |(cid:8)(V (G))| < |(V (G)|, puis de v´eriﬁer
des conditions locales, tous ces probl`emes sont clairement dans NP.

Pour montrer que ces probl`emes sont NP-diﬃciles, on fait une r´eduction du probl`eme

du K-Revˆetement qui est NP-complet [KPT98].

On consid`ere un graphe simple G et on veut d´ecider si G est un revˆetement simple de K.
Puisque les conditions de la Proposition 9.2 peuvent ˆetre v´eriﬁ´ees en temps polynomial,
on peut supposer que G est un K-candidat et ainsi G contient deux sommets voisins
u, v ∈ V (G) tels que degG(u) = 3 et degG(v) = 4. On consid`ere un graphe simple G
(cid:2) qui
est le graphe-diamant de G respectivement `a {u, v} dont les diamants sont D1, . . . , Dq o`u
(cid:2) est bien
q > k + 2 et q + k n’est pas divisible par 2 ou 3. On remarque que la taille de G
polynomiale en la taille de G.

On montre que les assertions suivantes sont ´equivalentes :

(1) G est un revˆetement simple de K,
(cid:2) est un revˆetement simple de K,
(2) G
(cid:2) admet une coloration r´eguli`ere parfaite propre,
(3) G
(cid:2) admet une coloration r´eguli`ere propre,
(4) G
(cid:2) admet une coloration pseudo-r´eguli`ere propre,
(5) G
(cid:2) admet un ´etiquetage r´egulier sym´etrique propre,
(6) G
(cid:2) admet un ´etiquetage r´egulier propre,
(7) G
(cid:2) admet un ´etiquetage pseudo-r´egulier propre.
(8) G

Les assertions (1) et (2) sont ´equivalentes d’apr`es le Lemme 9.6. D’apr`es la Proposi-
tion 2.11, on sait que (2) implique (3). De par la d´eﬁnition des ´etiquetages et colorations
consid´er´es, (2) implique (3), (3) implique (4), (4) implique (5), (4) implique (6), (5) im-
plique (8), (6) implique (7) et (7) implique (8). De plus, d’apr`es le Lemme 9.5, on sait que
(8) implique (2).

On a donc montr´e qu’il est NP-diﬃcile de d´ecider si un graphe simple G admet
un ´etiquetage pseudo-r´egulier propre (resp. un ´etiquetage r´egulier propre, un ´etiquetage
r´egulier sym´etrique propre, une coloration pseudo-r´eguli`ere propre, une coloration r´eguli`ere
propre, une coloration r´eguli`ere parfaite propre).
2

Le th´eor`eme pr´ec´edent permet d’obtenir un corollaire sur la complexit´e de d´ecider si
un graphe simple G admet un algorithme d’´election ou de nommage dans les mod`eles
consid´er´es dans les Chapitres 2, 3, 5 et 7. Ces mod`eles sont exactement les mod`eles ou
nommage et ´election sont ´equivalents.

9.3. Colorations Semi-R´eguli`eres

229

a1

g0

u

b1

(cid:2)
b
1

c1

(cid:2)
c
1

d1

e1
(cid:2)
e
1

(cid:2)
d
1

f1

(cid:2)
1

f

g1 ak+1

bk+1

(cid:2)
b
k+1

dk+1

ck+1

fk+1

ek+1
(cid:2)
e
k+1

(cid:2)
d
k+1

(cid:2)
c
k+1

(cid:2)
k+1

f

gk+1 ak+2

v

Fig. 31 – La chaˆıne de k + 1 multi-diamants qui remplace l’arˆete ek = {u, v}.

Corollaire 9.8 Le probl`eme de d´ecider si on peut ´elire (ou nommer) dans un graphe
simple G donn´e en utilisant des calculs locaux sur les ´etoiles ferm´ees (resp. sur les arˆetes
´etiquet´ees, sur les arˆetes non-´etiquet´ees) est co-NP-complet.

Le probl`eme de d´ecider si on peut ´elire (ou nommer) dans un graphe simple G en
utilisant des messages dans le mod`ele port-`a-port (resp. port-`a-boˆıte) est co-NP-complet.

Preuve : C’est un corollaire des Propositions 2.11, 3.8 et 5.7, des Th´eor`emes 2.21, 3.29
5.19 et 7.53 et du Th´eor`eme 9.7.
2

9.3 Colorations Semi-R´eguli`eres

On s’int´eresse maintenant au probl`eme de d´ecider si un graphe simple G admet une
coloration semi-r´eguli`ere propre, i.e., d´ecider si un graphe simple G n’admet pas d’algo-
rithme de nommage utilisant des calculs locaux cellulaires sur les ´etoiles. On montre aussi
que notre r´eduction permet aussi de prouver qu’il est co-NP-complet de d´ecider si un
graphe simple G admet un algorithme d’´election utilisant des calculs locaux cellulaires sur
les ´etoiles.

Pour montrer qu’il est NP-diﬃcile de d´ecider si un graphe simple G admet une colora-
tion semi-r´eguli`ere propre, on fait une r´eduction du probl`eme du K4-Revˆetement o`u K4
est le graphe complet `a 4 sommets. Kratochv´ıl a montr´e que ce probl`eme ´etait NP-complet
dans [Kra91].
Remarque 9.9 ´Etant donn´e un graphe simple G, on sait que si G est un revˆetement de
K4 `a travers un homomorphisme ϕ, alors G est un graphe 3-r´egulier, puisque ϕ pr´eserve
le degr´e.

Puisque cette propri´et´e peut ˆetre v´eriﬁ´ee en temps polynomial, on sait que le probl`eme
du K4-Revˆetement est NP-complet mˆeme si on se restreint aux graphes simples 3-
r´eguliers.

´Etant donn´e un graphe G, on note e1, . . . , em les arˆetes de G. On va modiﬁer le
graphe G de la mani`ere suivante. Pour chaque k ∈ [1, m], on remplace l’arˆete ek par
une chaˆıne de k + 1 multi-diamants D1(k), . . . , Dk+1(k), comme repr´esent´e sur la Fi-
(cid:2) ainsi obtenu est un graphe-multi-diamants de G et est not´e G
(cid:2).
gure 31. Le graphe G
Les sommets du i`eme multi-diamant de la chaˆıne qui remplace l’arˆete ek sont not´es

230

Chapitre 9. Complexit´e

(cid:2)
(cid:2)
(cid:2)
(cid:2)
i(k), ei(k), e
i(k), di(k), d
i(k), ci(k), c
ai(k), bi(k), b
i(k), fi(k), f
fusion n’est possible, on note ai `a la place de ai(k), bi `a la place de bi(k), etc.

(cid:2)
i(k), gi(k). Lorsqu’aucune con-
Pour toute arˆete ek ∈ E(G), on note u l’extr´emit´e de ek qui est un voisin de a1 dans G
(cid:2)
(cid:2). On note alors g0 = u et ak+2 = v.
(cid:2) n’admet pas de

On va montrer que G est un revˆetement de K4 si et seulement si G

et v l’extr´emit´e de ek incidente au sommet gk+1 dans G

coloration semi-r´eguli`ere propre.

Le lemme suivant permet de montrer que pour tous diamants, si les mˆemes couleurs
apparaissent `a une extr´emit´e de chaque diamant, alors les autres extr´emit´es de chaque
diamant ont les mˆemes couleurs.

Lemme 9.10 Pour toute coloration semi-r´eguli`ere (cid:8) d’un graphe-multi-diamants G
(cid:2))) et (cid:8)(ai+1(k)) = (cid:8)(aj+1(k
pour tout multi-diamants Di(k), Dj(k
et seulement si (cid:8)(gi−1(k)) = (cid:8)(gj−1(k

(cid:2)), (cid:8)(gi(k)) = (cid:8)(gj(k
(cid:2))) et (cid:8)(ai(k)) = (cid:8)(aj(k

(cid:2))).
Preuve : On consid`ere une coloration semi-r´eguli`ere (cid:8) de G
gj(k

(cid:2)), ai+1(k), aj+1(k
Puisque (cid:8) est une coloration semi-r´eguli`ere, (cid:8)({fi(k), f

(cid:2)) tels que (cid:8)(gi(k)) = (cid:8)(gj(k

(cid:2) et quatre sommets gi(k),
(cid:2))).
(cid:2))) et (cid:8)(ai+1(k)) = (cid:8)(aj+1(k
(cid:2))}). Sans
(cid:2)
(cid:2)), f
j(k
(cid:2))). Par
(cid:2))) et que (cid:8)(f
(cid:2)
(cid:2)
i(k)) = (cid:8)(f
j(k
(cid:2))}) et (cid:8)(ci(k)) = (cid:8)(cj(k
(cid:2))). Ainsi, (cid:8)(bi(k)) =
(cid:2))). Par cons´equent, (cid:8)(ai(k)) = (cid:8)(aj(k
(cid:2))) et

i(k)}) = (cid:8)({fj(k
(cid:2)

perte de g´en´eralit´e, on suppose que (cid:8)(fi(k)) = (cid:8)(fj(k
cons´equent, (cid:8)({di(k), ei(k)}) = (cid:8)({dj(k
(cid:8)(bj(k
(cid:8)(gi−1(k)) = (cid:8)(gj−1(k

(cid:2)), ej(k
(cid:2)
(cid:2)
i(k)) = (cid:8)(b
j(k

(cid:2))) et par sym´etrie, (cid:8)(b

(cid:2))).

(cid:2) et
(cid:2))) si

De la mˆeme mani`ere, on obtient la r´eciproque.

2

On montre dans la proposition suivante qu’un graphe simple G est un revˆetement de

K4 si et seulement si tout graphe-multi-diamants de G est un revˆetement de K4.

Proposition 9.11 Pour tout graphe simple G et pour tout graphe-multi-diamants G
G, G est un revˆetement de K4 si et seulement si G

(cid:2) est un revˆetement de K4.
(cid:2) de G. On
Preuve : On consid`ere un graphe simple G et un graphe-multi-diamants G
suppose que G est un revˆetement de K4 `a travers un homomorphisme ϕ. ´Etant donn´ee une
arˆete ek = {u, v} ∈ E(G) telle que u = g0 et v = ak+2, on ´etend ϕ en un homomorphisme
(cid:2) de la mani`ere suivante. On note a = ϕ(u) et b = ϕ(v) et on note c, d les deux
(cid:2) de G
ϕ
autres sommets de K4. Pour tout i ∈ [1, k + 1], on d´eﬁnit ϕ
(cid:2)
(cid:2)(b
i) = d,
(cid:2)(f
(cid:2)(ci) = a, ϕ
(cid:2)(ei) = b, ϕ
(cid:2)
i) = d
ϕ
(cid:2)(gi) = a. Cette extension est repr´esent´ee sur la Figure 32. L’homomorphisme ϕ
(cid:2) ainsi
et ϕ
construit est un homomorphisme localement bijectif de G
(cid:2) est un revˆetement de K4 `a travers un homo-
(cid:2). On consid`ere l’homomorphisme ϕ de G dans K4 tel que pour tout v ∈
(cid:2))) et que
(cid:2) est un homomorphisme localement bijectif,

morphisme ϕ
V (G), ϕ(v) = ϕ
|ϕ(NG(v))| = |ϕ
ϕ est un homomorphisme localement bijectif et G est un revˆetement de K4.

(cid:2)(v). D’apr`es le Lemme 9.10, on sait que ϕ(NG(v)) = ϕ
(cid:2)(NG(v

(cid:2)(ai) = b, ϕ
(cid:2)(e
(cid:2)
i) = b, ϕ
(cid:2) dans K4.

R´eciproquement, on suppose que G

(cid:2)))|. Ainsi, puisque ϕ

(cid:2)(bi) = c, ϕ
(cid:2)(fi) = c, ϕ

(cid:2)
(cid:2)(c
i) = a, ϕ

(cid:2)
(cid:2)(d
i) = c, ϕ

(cid:2)(di) = d, ϕ

(cid:2)(NG(v

(cid:2) de

2

Par cons´equent, si un graphe G est un revˆetement de K4, alors tout graphe-multi-
(cid:2) de G est un revˆetement de K4 et il admet donc une coloration r´eguli`ere
diamants G
parfaite propre qui est une coloration semi-r´eguli`ere. On suppose maintenant que le graphe
(cid:2)
G n’est pas un revˆetement de K4 et on veut montrer que tout graphe-multi-diamants G
de G n’admet pas de coloration semi-r´eguli`ere propre.

9.3. Colorations Semi-R´eguli`eres

231

a

b

c

d

a

a

d

b
b

c

c

d

a

b

Fig. 32 – ´Etendre un homomorphisme localement bijectif de G dans K4 en un homomor-
phisme de G

(cid:2) dans K4.

Dans le lemme suivant, on montre que si G

les sommets de chaque multi-diamant de G
Lemme 9.12 Si un graphe-multi-diamants G
toute coloration semi-r´eguli`ere (cid:8) de G
12.

(cid:2) n’est pas un revˆetement de K4, alors pour
(cid:2), pour tout k et pour tout i ∈ [1, k + 1], |(cid:8)(Di(k))| =

(cid:2) n’est pas un revˆetement de K4, alors tous

(cid:2) ont des couleurs diﬀ´erentes.

On consid`ere un multi-diamant Di de G

Preuve : On consid`ere un graphe-multi-diamants G
et une coloration semi-r´eguli`ere (cid:8) de G.

(cid:2) qui n’est pas un revˆetement de K4
(cid:2). Puisque deux sommets voisins ont des cou-
leurs diﬀ´erentes, on sait que ci, di et ei ont des couleurs diﬀ´erentes. Sans perte de g´en´eralit´e,
on suppose que (cid:8)(di) = 1, (cid:8)(ei) = 2 et (cid:8)(ci) = 3.
Propri´et´e 1 : (cid:8)(bi) /∈ {1, 2, 3} et (cid:8)(b
i) /∈ {(cid:8)(c
i)}.
(cid:2)
(cid:2)
(cid:2)
(cid:2)
i), (cid:8)(e
i), (cid:8)(d
On sait que (cid:8)(bi) (cid:12)= 3. On note x = (cid:8)(fi) et y = (cid:8)(gi). Si (cid:8)(bi) = 1, alors ou bien (cid:8)(ai) = 2
(cid:2)
(cid:2)
(cid:2)
i) = y et alors
i) = 2. Dans le premier cas, (cid:8)(c
i) = x, ou bien (cid:8)(ai) = x et (cid:8)(b
et (cid:8)(b
i) ∈ {(cid:8)(d
i)}, ce qui est impossible. Dans le second cas, (cid:8)(c
(cid:2)
(cid:2)
(cid:2)
(cid:2)
i), (cid:8)(e
i) = 3, mais alors
(cid:8)(f
i) = 1 ; ce qui est impossible. Par sym´etrie, on sait que (cid:8)(bi) (cid:12)= 2.
(cid:2)
(cid:2)
i) = (cid:8)(e
(cid:8)(d
i) /∈ {(cid:8)(c
On a donc montr´e que (cid:8)(bi) /∈ {1, 2, 3} et par sym´etrie, on a (cid:8)(b
i)}.
(cid:2)
(cid:2)
(cid:2)
(cid:2)
i), (cid:8)(e
i), (cid:8)(d
On suppose donc sans perte de g´en´eralit´e que (cid:8)(bi) = 4.

(cid:2)
i) = (cid:8)(ai), ou bien (cid:8)(f

Propri´et´e 2 : (cid:8)(fi) /∈ {1, 2, 3, 4} et (cid:8)(c
i)}.
i) /∈ {(cid:8)(b
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
i), (cid:8)(e
i), (cid:8)(d
i), (cid:8)(c
(cid:2))) = {1, 2, 3, 4} et (cid:8) d´eﬁnit un
On sait que (cid:8)(fi) /∈ {1, 2}. Si (cid:8)(fi) = (cid:8)(bi) = 4, alors (cid:8)(V (G
(cid:2) dans K4 ; ce qui est impossible. On suppose que
homomorphisme localement bijectif de G
(cid:8)(fi) = (cid:8)(ci) = 3. Puisque 4 ∈ (cid:8)(NG(cid:2)(fi)) = (cid:8)(NG(cid:2)(ci)), on a (cid:8)(gi) = 4. Par cons´equent,
i) ∈ (cid:8)({d
i}) ; ce
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
i). Dans le premier cas, (cid:8)(b
i) = (cid:8)(b
ou bien (cid:8)(f
i, e
i}) ; ce qui est
i) ∈ (cid:8)({d
(cid:2)
(cid:2)
(cid:2)
qui est impossible d’apr`es la Propri´et´e 1. Dans le second cas, (cid:8)(c
i, e
impossible.
On a donc montr´e que (cid:8)(fi) /∈ {1, 2, 3, 4} et par sym´etrie, on a (cid:8)(f
i) /∈ {(cid:8)(b
(cid:2)
(cid:2)
(cid:2)
i),
i), (cid:8)(c
i)}.
(cid:2)
(cid:2)
i), (cid:8)(e
(cid:8)(d
On suppose donc sans perte de g´en´eralit´e que (cid:8)(fi) = 5.
i)}.
(cid:2)

Propri´et´e 3 : (cid:8)(ai) /∈ {1, 2, 3, 4, 5, (cid:8)(b
(cid:2)
(cid:2)
(cid:2)
(cid:2)
i), (cid:8)(f
i), (cid:8)(e
i), (cid:8)(d
i), (cid:8)(c

232

Chapitre 9. Complexit´e

On sait que (cid:8)(ai) (cid:12)= 4. Puisque 4 ∈ (cid:8)(NG(cid:2)(ai)) et 4 /∈ (cid:8)(NG(cid:2)(ci) ∪ NG(cid:2)(di)), on sait que
i) ∈ {1, 2} et sans perte
(cid:8)(ai) /∈ {1, 2}. On suppose que (cid:8)(ai) ∈ {3, 5}. Par cons´equent, (cid:8)(b
(cid:2)
(cid:2)
i) = 1. Mais alors, (cid:8)(bi) = 4 apparaˆıt dans (cid:8)(NG(cid:2)(di)) ; ce
de g´en´eralit´e, on suppose que (cid:8)(b
i)}.
qui est impossible. Par sym´etrie, (cid:8)(ai) /∈ {(cid:8)(b
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
i), (cid:8)(e
i), (cid:8)(d
i), (cid:8)(c
i), (cid:8)(f

On suppose donc sans perte de g´en´eralit´e que (cid:8)(ai) = 6.

i) /∈ {1, 2, 3, 4, 5, 6}.
(cid:2)
Propri´et´e 4 : (cid:8)(b
i) /∈ {1, 2, 3, 4, 6} puisque (cid:8) est une coloration semi-r´eguli`ere. Si (cid:8)(b
(cid:2)
(cid:2)
i) = 5,
On sait que (cid:8)(b
(cid:2)
alors les couleurs 1, 2, 4 et 6 appartiennent `a (cid:8)(NG(cid:2)(b
i)) = (cid:8)(NG(cid:2)(fi)) ; ce qui est impossible
(cid:2)
puisque degG(cid:2)(b
i) = 3.
(cid:2)
i) = 7.

On suppose donc sans perte de g´en´eralit´e que (cid:8)(b

i) /∈ {1, 2, 3, 4, 5, 6, 7}.
(cid:2)
Propri´et´e 5 : (cid:8)(c
i) /∈ {1, 2, 3, 4, 7} puisque (cid:8) est une coloration semi-r´eguli`ere et que (cid:8)(c
i) (cid:12)= 6
(cid:2)
(cid:2)
On sait que (cid:8)(c
i}) = {1, 2}. Mais alors,
i) = 5, alors (cid:8)(gi) = 7 et (cid:8)({d
(cid:2)
(cid:2)
(cid:2)
d’apr`es la Propri´et´e 3. Si (cid:8)(c
i, e
(cid:8)(f

i) = 3 ; ce qui est impossible puisque 7 /∈ (cid:8)(NG(cid:2)(ci)).
(cid:2)
(cid:2)
i) = 8.
On suppose donc sans perte de g´en´eralit´e que (cid:8)(c

i) /∈ {1, 2, 3, 4, 5, 6, 7, 8}.
(cid:2)
(cid:2)
Propri´et´e 6 : (cid:8)(d
i), (cid:8)(e
i) (cid:12)= 7
i) /∈ {1, 2, 3, 4, 8} puisque (cid:8) est une coloration semi-r´eguli`ere, que (cid:8)(d
(cid:2)
(cid:2)
On sait que (cid:8)(d
i) ∈
i) (cid:12)= 6 d’apr`es la Propri´et´e 3. Si (cid:8)(d
(cid:2)
(cid:2)
(cid:2)
i) = 5, alors (cid:8)(e
d’apr`es la Propri´et´e 2 et que (cid:8)(d
i) = 8 /∈ (cid:8)(NG(cid:2)(di)) ∪ (cid:8)(NG(cid:2)(ei)). Par sym´etrie, on
{1, 2} ; ce qui est impossible puisque (cid:8)(c
(cid:2)
i) /∈ {1, 2, 3, 4, 5, 6, 7, 8}.
(cid:2)
sait que (cid:8)(e
(cid:2)
(cid:2)
i sont voisins, il sont des couleurs diﬀ´erentes, et on suppose donc sans
i et d
Puisque e

(cid:2)
(cid:2)
i) = 10.
i) = 9 et (cid:8)(e
perte de g´en´eralit´e que (cid:8)(d
i) /∈ {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}.
(cid:2)
Propri´et´e 7 : (cid:8)(f
i) /∈ {1, 2, 3, 4, 9, 10} puisque (cid:8) est une coloration semi-r´eguli`ere, que (cid:8)(f
i) (cid:12)=
(cid:2)
(cid:2)
i) (cid:12)= 6 d’apr`es la
(cid:2)
(cid:2)
i)) =

On sait que (cid:8)(f
8 d’apr`es la Propri´et´e 1, que (cid:8)(f
Propri´et´e 3. Si (cid:8)(f
(cid:8)(NG(cid:2)(fi)) ; ce qui est impossible puisque degG(cid:2)(f

(cid:2)
i) = 5, alors les couleurs 1, 2, 9 et 10 appartiennent `a (cid:8)(NG(cid:2)(f

i) (cid:12)= 7 d’apr`es la Propri´et´e 2 et que (cid:8)(f
(cid:2)

(cid:2)
i) = 3.

On suppose donc sans perte de g´en´eralit´e que (cid:8)(f

(cid:2)
i) = 11.

Propri´et´e 8 : (cid:8)(gi) /∈ {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}.
S’il existe un sommet u ∈ V (Di) tel que (cid:8)(u) = (cid:8)(gi), alors {5, 11} ⊆ (cid:8)(NG(cid:2)(u)) ; ainsi,
(cid:8)(gi) /∈ {1, 2, 3, 4, 5, 7, 8, 9, 10, 11}. Si (cid:8)(gi) = (cid:8)(ai) = 6, alors {4, 5, 7, 11} ⊆ (cid:8)(NG(cid:2)(gi)) ; ce
qui est impossible puisque degG(cid:2)(gi) = 3.

On a donc montr´e que pour tout multi-diamant Di de G

(cid:2), |(cid:8)(V (Di))| = 12.

2

Dans le lemme suivant, on montre que si un graphe-multi-diamants G

(cid:2) n’est pas un
revˆetement de K4, alors une couleur apparaissant sur un sommet gi(k) ne peut apparaˆıtre
dans un autre multi-diamant Dj(k
Lemme 9.13 Si un graphe-multi-diamants G
toute coloration semi-r´eguli`ere (cid:8) de G
[1, k

(cid:2) n’est pas un revˆetement de K4, alors pour
(cid:2) et pour tous i ∈ [1, k + 1], j ∈

(cid:2) + 1], pour tout u ∈ V (Di(k)) \ {gi(k)}, (cid:8)(u) (cid:12)= (cid:8)(gj(k

(cid:2), pour tous k, k

(cid:2)) que sur gj(k

(cid:2))).

(cid:2)).

9.3. Colorations Semi-R´eguli`eres

233

x

6

4

7

3

8

1

2
10

9

5

11

12

y

ai

bi

(cid:2)
b
i

ci

(cid:2)
c
i

di

(cid:2)
ei
e
i

(cid:2)
d
i

fi

(cid:2)
i

f

gi

Fig. 33 – Les deux multi-diamants consid´er´es dans la preuve du Lemme 9.14.

Preuve : On suppose qu’il existe un sommet u ∈ V (Di(k)) \ {gi(k)} tel que (cid:8)(u) =
(cid:2))). Puisque u ∈ V (Di(k)) \ {gi(k)}, u a deux voisins v, w ∈ V (Di(k)) tels que
(cid:8)(gj(k
{v, w} ∈ E(G
(cid:2)).
(cid:2)))} (cid:12)= ∅ ; sans perte de g´en´eralit´e, on
(cid:2)))} ; sans perte de g´en´eralit´e,
(cid:2))), (cid:8)(ej(k
(cid:2))),

(cid:2)
(cid:2))), (cid:8)(f
j(k
(cid:2))). Ainsi, (cid:8)(w) ∈ {(cid:8)(dj(k
(cid:2))) = (cid:8)(u) ∈ (cid:8)(NG(cid:2)(w)) = (cid:8)(NG(cid:2)(dj(k

Par cons´equent, {(cid:8)(v), (cid:8)(w)} ∩ {(cid:8)(fj(k

suppose que (cid:8)(v) = (cid:8)(fj(k
on suppose que (cid:8)(w) = (cid:8)(dj(k

Par cons´equent, (cid:8)(gj(k

(cid:2)))) = {(cid:8)(cj(k

(cid:2))), (cid:8)(ej(k

(cid:2))).

(cid:8)(fj(k

(cid:2)))} ; ce qui est impossible d’apr`es le Lemme 9.12.

2

graphe-multi-diamants G
sur un sommet ai(k) ne peut apparaˆıtre dans un autre multi-diamant Dj(k

Le lemme suivant est l’´equivalent du lemme pr´ec´edent pour les sommets ai(k) : si un
(cid:2) n’est pas un revˆetement de K4, alors une couleur apparaissant
(cid:2)).
(cid:2) n’est pas un revˆetement de K4, alors pour
(cid:2) et pour tous i ∈ [1, k + 1], j ∈

(cid:2), pour tous k, k

Lemme 9.14 Si un graphe-multi-diamants G
toute coloration semi-r´eguli`ere (cid:8) de G
[1, k

(cid:2) + 1], pour tout u ∈ V (Di(k)) \ {ai(k)}, (cid:8)(u) (cid:12)= (cid:8)(aj(k

(cid:2)) que sur aj(k

(cid:2))).

(cid:2))) = 4, (cid:8)(fj(k
(cid:2)
(cid:2))) = 10, (cid:8)(f
j(k

(cid:2)) de G
(cid:2))) = 1, (cid:8)(ej(k
(cid:2)
(cid:2))) = 7, (cid:8)(c
j(k

(cid:2), une coloration semi-r´eguli`ere (cid:8) de
(cid:2). D’apr`es le Lemme 9.12, on peut supposer sans perte
(cid:2))) = 3, (cid:8)(bj(k
(cid:2))) =
(cid:2))) = 9, (cid:8)(e
(cid:2)
(cid:2))) = 6, (cid:8)(b
(cid:2))) =
(cid:2)
j(k
j(k
(cid:2))) = 12, comme repr´esent´e `a gauche sur la Figure 33. On note par ailleurs

Preuve : On consid`ere un graphe-multi-diamants G
(cid:2) et un multi-diamant Dj(k
G
(cid:2))) = 2, (cid:8)(cj(k
de g´en´eralit´e que (cid:8)(dj(k
(cid:2)
(cid:2))) = 8, (cid:8)(d
5, (cid:8)(aj(k
j(k
11, (cid:8)(gj(k
x = (cid:8)(gi−1) et y = (cid:8)(ai+1).
Par la suite, on note ai le sommet ai(k), bi le sommet bi(k), etc. Il suﬃt de montrer
que pour tout sommet v ∈ {bi, ci, di, fi, gi}, (cid:8)(v) (cid:12)= 6. D’apr`es le Lemme 9.13, on sait d´ej`a
que (cid:8)(gi) (cid:12)= 6.
On suppose que (cid:8)(ci) = 6 (resp. (cid:8)(fi) = 6). Dans ce cas l`a, {(cid:8)(di), (cid:8)(ei)} ∩ {4, 7} (cid:12)= ∅.
Sans perte de g´en´eralit´e, on suppose donc que (cid:8)(di) = 4. Dans ce cas l`a, ci (resp. fi) et
di doivent tous les deux avoir un voisin ´etiquet´e par 7. D’apr`es le Lemme 9.12, on a donc
(cid:8)(ei) = 7. Puisque ei doit alors avoir un voisin ´etiquet´e 8, cela implique que (cid:8)(fi) = 8
(resp. (cid:8)(ci) = 8) ; ce qui est impossible, puisque le sommet fi (resp. ci), ´etiquet´e 8 ne peut
pas ˆetre voisin du sommet di ´etiquet´e 4.
On suppose que (cid:8)(di) = 6. Dans ce cas l`a, {(cid:8)(ci), (cid:8)(fi)} ∩ {4, 7} (cid:12)= ∅. Sans perte de
g´en´eralit´e, on suppose donc que (cid:8)(ci) = 4 (resp. (cid:8)(fi) = 4). Dans ce cas l`a, ci (resp. fi)
et di doivent tous les deux avoir un voisin ´etiquet´e par 7. D’apr`es le Lemme 9.12, on a
alors (cid:8)(ei) = 7. Puisque ei doit alors avoir un voisin ´etiquet´e 8, cela implique que (cid:8)(fi) = 8

234

Chapitre 9. Complexit´e

On suppose que (cid:8)(bi) = 6. Si j ≥ 2, bi doit avoir un voisin ´etiquet´e x = (cid:8)(gj−1(k

(resp. (cid:8)(ci) = 8) ; ce qui est impossible, puisque le sommet fi (resp. ci), ´etiquet´e 8 ne peut
pas ˆetre voisin du sommet di ´etiquet´e 6.
(cid:2))) ;
ce qui est impossible d’apr`es le Lemme 9.13. On suppose maintenant que j = 1. On sait
que bi a deux voisins ´etiquet´es 4 et 7, et d’apr`es le Lemme 9.12, ces deux sommets sont
i}) = {4, 7} et sans perte de g´en´eralit´e, on suppose que (cid:8)(ai) = 7
adjacents. Ainsi, (cid:8)({ai, b
(cid:2)
i) = 3, (cid:8)({d
i}) = {1, 2}, (cid:8)(f
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
i) = 5, (cid:8)(gi) = 12 et
i) = 4. Dans ce cas l`a, (cid:8)(c
et (cid:8)(b
i, e
(cid:8)(fi) ∈ {11, y}. On sait d´ej`a qu’il est impossible que (cid:8)(fi) = (cid:8)(a2(k
(cid:2))) = y, puisque k = 1
(cid:2)) appartient `a un diamant. Si (cid:8)(fi) = 11, alors (cid:8)({di, ei}) = {9, 10} et (cid:8)(ci) = 8 ;
et que a2(k
ce qui est impossible puisque ci ´etiquet´e 8 ne peut pas avoir ˆetre voisin de bi ´etiquet´e 6.
2

(cid:2) n’est pas un
(cid:2) ne peut

Dans le lemme suivant, on montre que si un graphe-multi-diamants G

(cid:2) n’est pas un revˆetement de K4, alors pour
(cid:2), pour tout sommet v ∈ V (Di(k)) pour k ∈ [1, m] et

revˆetement de K4, alors un sommet qui n’est pas dans un multi-diamant de G
(cid:2).
pas avoir la mˆeme couleur qu’un sommet d’un multi-diamant de G
Lemme 9.15 Si un graphe-multi-diamants G
toute coloration semi-r´eguli`ere (cid:8) de G
i ∈ [1, k + 1] et pour tout sommet u ∈ V (G
Preuve : On consid`ere un graphe-multi-diamants G
(cid:2) et un sommet u n’apparaissant pas dans un multi-diamant de G
(cid:2).
G
(cid:2) tel que ou bien u
Pour tout sommet u
(cid:2) = gk(cid:2)+1(k
u
(cid:2) ∈ V (Di(k)) \ {ai(k), gi(k)}. Si (cid:8)(u) = (cid:8)(v), alors il existe un sommet u
v
que (cid:8)(u

(cid:2), une coloration semi-r´eguli`ere (cid:8) de
(cid:2)), ou bien
(cid:2)). ´Etant donn´e un sommet v d’un multi-diamant Di(k), il existe un sommet
(cid:2) ∈ NG(cid:2)(u) tel

(cid:2)) ; ce qui est impossible d’apr`es les Lemmes 9.13 et 9.14.

(cid:2)) tel que ∀k,∀i, u /∈ V (Di(k)), (cid:8)(u) (cid:12)= (cid:8)(v).

(cid:2) ∈ NG(cid:2)(u), il existe k

(cid:2) = a1(k

(cid:2)) = (cid:8)(v

2

Dans le lemme suivant, on montre que pour tout graphe-multi-diamants G

(cid:2) qui n’est
(cid:2) est une coloration r´eguli`ere

(cid:2) et pour tout sommet v ∈ V (G

(cid:2) qui n’est pas un revˆetement de K4

(cid:2) n’est pas un revˆetement de K4, alors pour
(cid:2)), |(cid:8)(NG(cid:2)(v))| =

pas un revˆetement de K4, toute coloration semi-r´eguli`ere de G
(cid:2).
parfaite de G
Lemme 9.16 Si un graphe-multi-diamants G
toute coloration semi-r´eguli`ere (cid:8) de G
|NG(cid:2)(v)|.
Preuve : On consid`ere un graphe-multi-diamants G
(cid:2).
et une coloration semi-r´eguli`ere (cid:8) de G
On consid`ere un sommet v apparaissant dans un multi-diamant Di(k). D’apr`es le
Lemme 9.12, on sait que |(cid:8)(NG(cid:2)(v))| = |NG(cid:2)(v)| si v /∈ {ai(k), gi(k)}. D’apr`es les Lemmes
9.13, 9.14 et 9.15, on a aussi |(cid:8)(NG(cid:2)(v))| = |NG(cid:2)(v)| si v ∈ {ai(k), gi(k)}.
(cid:2)) qui n’appartient pas `a un multi-
(cid:2) ∈ NG(cid:2)(u) tels que (cid:8)(v) = (cid:8)(v
(cid:2)).
(cid:2) tels que ou bien, v = a1(k)
(cid:2) est le graphe-multi-
(cid:2) et sans perte de g´en´eralit´e, on suppose
(cid:2)) (resp.
(cid:2)))). Dans le premier cas, on sait que ak+2(k) (resp. g0(k)) n’appartient
(cid:2))) est un sommet d’un multi-

diamant de G
D’apr`es les Lemmes 9.13 et 9.14, il existe deux entiers k, k
(cid:2) = a1(k
et v
diamants d’un graphe simple G, on sait que k (cid:12)= k
que k < k
(cid:8)(g0(k)) = (cid:8)(gk(cid:2)−k(k
pas `a un multi-diamant alors que ak+2(k
diamant ; on a donc une contradiction d’apr`es le Lemme 9.15.

(cid:2). On suppose qu’il existe deux sommets v, v
(cid:2)), ou bien v = gk+1(k) et v

(cid:2). Si on applique k + 1 fois le Lemme 9.10, on a (cid:8)(ak+2(k)) = (cid:8)(ak+2(k

On consid`ere maintenant un sommet u ∈ V (G

(cid:2)) (resp. gk(cid:2)−k(k

(cid:2)). Puisque G

(cid:2) = gk(cid:2)+1(k

2

9.3. Colorations Semi-R´eguli`eres

235

(cid:2))|.

suppose qu’il existe un sommet u
on sait que u
Puisque G
(cid:2) = a1(k

(cid:2) n’appartient pas non plus `a un multi-diamant de G
(cid:2).
(cid:2) ne contient pas de sommets isol´es, il existe v ∈ NG(cid:2)(u) et v
(cid:2)). D’apr`es les Lemmes 9.13 et 9.14, i existe k, k
(cid:2)), ou v = gk+1(k) et v

(cid:2)). Puisque G

(cid:2) = gk(cid:2)+1(k

(cid:2)) tel que (cid:8)(u) = (cid:8)(u

Dans le lemme suivant, on montre que si un graphe multi-diamant de G
(cid:2) n’admet pas de coloration semi-r´eguli`ere propre.

(cid:2) sans sommets isol´es qui n’est
(cid:2)))| =

revˆetement de K4, alors G
Lemme 9.17 On consid`ere un graphe-multi-diamants G
pas un revˆetement de K4. Pour toute coloration semi-r´eguli`ere (cid:8) de G
|V (G
Preuve : On consid`ere un graphe-multi-diamants G
(cid:2).
et une coloration semi-r´eguli`ere (cid:8) de G
On consid`ere un sommet u ∈ V (G
(cid:2)) qui n’appartient pas `a un multi-diamant de G
(cid:2) ∈ V (G

(cid:2) qui n’est pas un revˆetement de K4
(cid:2). On
(cid:2)). D’apr`es le Lemme 9.15,
(cid:2) ∈ NG(cid:2)(u
(cid:2))
(cid:2) tels que v = a1(k)
(cid:2) est le graphe-multi-diamants
(cid:2) et avec le mˆeme raisonnement que dans la preuve
−1((cid:8)(u))| = 1 et d’apr`es le Lemme 9.16, on sait que (cid:8) est une colora-
−1((cid:8)(v))| = 1.
(cid:2). 2
On peut maintenant montrer le r´esultat principal de cette section. On montre qu’il est
NP-complet de d´ecider si un graphe simple G admet une coloration semi-r´eguli`ere propre.
Th´eor`eme 9.18 Le probl`eme de d´ecider si un graphe simple G donn´e admet une colora-
tion semi-r´eguli`ere propre est NP-complet.

tels que (cid:8)(v) = (cid:8)(v
et v
d’un graphe simple G, on sait que k (cid:12)= k
du Lemme 9.16, on aboutit `a une contradiction.

(cid:2). Par cons´equent, pour tout sommet v ∈ V (G
(cid:2))| et (cid:8) n’est pas une coloration semi-r´eguli`ere propre de G

Par cons´equent, |(cid:8)

tion r´eguli`ere parfaite de G
(cid:2)))| = |V (G
Ainsi, |(cid:8)(V (G

(cid:2) n’est pas un

(cid:2), |(cid:8)(V (G

(cid:2)), |(cid:8)

Preuve : Puisqu’il suﬃt de deviner un ´etiquetage (cid:8) d’un graphe simple G donn´e tel que
|(cid:8)(V (G))| < |(V (G)|, puis de v´eriﬁer des conditions locales pour s’assurer que (cid:8) est une
coloration semi-r´eguli`ere, le probl`eme est clairement dans NP.

Pour montrer que ce probl`eme est NP-diﬃcile, on fait une r´eduction du probl`eme du

K4-Revˆetement qui est NP-complet [Kra91].

On consid`ere un graphe simple G et on veut d´ecider si G est un revˆetement simple
de K4. D’apr`es la Remarque 9.9, on peut supposer que G est 3-r´egulier. On consid`ere un
(cid:2)
(cid:2) qui est un graphe-multi-diamants de G. On remarque que la taille de G
graphe simple G
est bien polynomiale en la taille de G.
(cid:2)
D’apr`es la Proposition 9.11, on sait que G est un revˆetement de K4 si et seulement si G
(cid:2) est un revˆetement de K4,
est un revˆetement de K4. De plus, si un graphe-multi-diamants G
alors il admet une coloration r´eguli`ere parfaite propre qui est une coloration semi-r´eguli`ere.
(cid:2) n’est pas un revˆetement de K4, on sait d’apr`es le Lemme 9.17 que
R´eciproquement, si G
(cid:2) n’admet pas de coloration semi-r´eguli`ere propre.
G
On a donc montr´e qu’il est NP-diﬃcile de d´ecider si un graphe simple G admet une
2

coloration semi-r´eguli`ere propre.

Le th´eor`eme pr´ec´edent permet d’obtenir un corollaire sur la complexit´e de d´ecider si
un graphe simple G admet un algorithme de nommage ou d’´election utilisant des calculs
locaux cellulaires sur les ´etoiles.

236

Chapitre 9. Complexit´e

Corollaire 9.19 Le probl`eme de d´ecider si on peut ´elire (resp. nommer) dans un graphe
simple G connexe donn´e en utilisant des calculs locaux sur les ´etoiles est co-NP-complet.

Preuve : Pour le nommage, c’est un corollaire de la Proposition 4.9, du Th´eor`eme 4.22
et du Th´eor`eme 9.18.

On consid`ere le probl`eme de l’´election. On rappelle qu’on ne peut pas ´elire dans un
graphe simple G en utilisant des calculs locaux cellulaires sur les ´etoiles si et seulement si
G admet une coloration semi-r´eguli`ere (cid:8) telle que pour tout v ∈ V (G), |(cid:8)
Puisqu’il suﬃt de deviner un ´etiquetage (cid:8) d’un graphe simple G donn´e, puis de v´eriﬁer
−1((cid:8)(v))| > 1 et de v´eriﬁer des conditions locales pour s’assurer
que pour tout v ∈ V (G), |(cid:8)
que (cid:8) est une coloration semi-r´eguli`ere, le probl`eme de d´ecider si un graphe simple G
admet un algorithme d’´election utilisant des calculs locaux cellulaires sur les ´etoiles est
clairement dans co-NP.

−1((cid:8)(v))| > 1.

Pour montrer que ce probl`eme est NP-diﬃcile, comme dans la preuve du Th´eor`eme 9.18,

on fait une r´eduction du probl`eme du K4-Revˆetement qui est NP-complet [Kra91].

´Etant donn´e un graphe simple G qui est 3-r´egulier, on consid`ere un graphe-multi-
(cid:2) de G, dont la taille est polynomiale en la taille de G. Si G est un revˆetement
diamants G
(cid:2) est un revˆetement de K4 et admet une coloration r´eguli`ere parfaite propre
de K4, alors G
(cid:8). Puisque (cid:8) est une coloration r´eguli`ere parfaite propre, il existe un entier q > 1 tel que
−1((cid:8)(v))| = q > 1. Ainsi, si G est un revˆetement de K4, alors
pour tout v ∈ V (G
(cid:2) en utilisant des calculs locaux
on ne peut pas r´esoudre le probl`eme de l’´election sur G
(cid:2)
cellulaires sur les ´etoiles. R´eciproquement, si G n’est pas un revˆetement de K4, alors G
n’admet pas de coloration semi-r´eguli`ere propre d’apr`es le Lemme 9.17. On peut alors
(cid:2) en utilisant des calculs locaux cellulaires sur les
r´esoudre le probl`eme de l’´election sur G
´etoiles.

(cid:2)), |(cid:8)

On a donc montr´e qu’il est NP-diﬃcile de d´ecider si un graphe simple G admet un
2

algorithme d’´election utilisant des calculs locaux cellulaires sur les ´etoiles.

9.4 Colorations Connexes

On s’int´eresse maintenant au probl`eme de d´ecider si un graphe simple G admet une
coloration connexe propre, i.e., d´ecider si un graphe simple G n’admet pas d’algorithme de
nommage utilisant des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees. On montre
aussi que notre r´eduction permet aussi de prouver qu’il est co-NP-complet de d´ecider si
un graphe simple G admet un algorithme d’´election utilisant des calculs locaux cellulaires
sur les arˆetes non-´etiquet´ees.

Pour prouver qu’il est NP-diﬃcile de d´ecider si un graphe simple G admet une colo-
ration connexe propre, on utilise la NP-compl´etude du probl`eme de la 2-Colorabilit´e
d’Hypergraphe.
Un hypergraphe (Q,S) est d´eﬁni par un ensemble Q = {q1, . . . , qm} et un ensemble
S = {S1, . . . , Sn} de sous-ensembles de Q. Une 2-coloration d’un hypergraphe (Q,S) est
une partition de Q en deux ensembles Q1 et Q2 tels que pour tout ensemble Sj ∈ S,
Q1 ∩ Sj (cid:12)= ∅ et Q2 ∩ Sj (cid:12)= ∅. Pour notre preuve de NP-compl´etude, on fait une r´eduction
du probl`eme de la 2-Colorabilit´e d’Hypergraphe qui est NP-complet (cf. [GJ79]).

9.4. Colorations Connexes

237

v

S1

I

C3

q1

(cid:2)
1

S

Sn

(cid:2)
n

S

qm

Fig. 34 – La construction du graphe I

(cid:2)(Q,S).

´Etant donn´e un hypergraphe (Q,S), on lui associe son graphe d’incidence I qui est un

2-Colorabilit´e d’Hypergraphe
Instance : Un hypergraphe (Q,S).
Question : Est-ce qu’il existe une 2-coloration de (Q,S) ?
graphe simple biparti d´eﬁni par V (I) = Q ∪ S et E(I) = {{q, S} | q ∈ S}.
Remarque 9.20 On sait que le probl`eme de la 2-Colorabilit´e d’Hypergraphe est
NP-complet, mˆeme lorsqu’on consid`ere seulement les hypergraphes dont le graphe d’in-
cidence est connexe. Si le graphe d’incidence d’un hypergraphe (Q,S) n’est pas connexe,
,S(cid:2)(cid:2))
d´ecider si (Q,S) est 2-coloriable revient `a d´ecider si deux hypergraphes (Q
sont 2-coloriables o`u Q = Q
mˆeme si on suppose que pour tout hypergraphe (Q,S), pour tous S, S
En eﬀet, s’il existe deux ensembles ´egaux S, S
(cid:2)}) et r´eciproquement.
2-coloration de (Q,S \ {S

Par ailleurs, le probl`eme de la 2-Colorabilit´e d’Hypergraphe est NP-complet,
(cid:2) ∈ S, S (cid:12)= S
(cid:2).
(cid:2) ∈ S, une 2-coloration de (Q,S) est une

(cid:2)(cid:2) et S = S(cid:2) ∪ S(cid:2)(cid:2).

,S(cid:2)) et (Q

(cid:2) ∪ Q

(cid:2)

(cid:2)(cid:2)

Pour notre preuve de NP-compl´etude, on modiﬁe le graphe d’incidence de tout hyper-
graphe (Q,S) de la mani`ere suivante.
On consid`ere un ensemble S(cid:2) = {S
n} de sommets tels que pour tout i ∈ [1, m]
(cid:2)
(cid:2)
1, . . . , S
j} existe si et seulement si l’arˆete {qi, Sj} existe. On
et pour tout j ∈ [1, n], l’arˆete {qi, S
(cid:2)
ajoute ensuite un sommet v qui est voisin de tous les sommets de S.
Puis, pour tout i ∈ [1, m], on consid`ere un cycle Cqi de longueur 6i−3 dont on identiﬁe
un sommet avec qi. Enﬁn, on ajoute un cycle Cv de longueur 6m + 3 dont on identiﬁe
(cid:2)(Q,S). Un exemple de cette
un sommet avec v. Le graphe simple ainsi obtenu est not´e I
construction est pr´esent´e sur la Figure 34.
(cid:2)(Q,S) admet une coloration
connexe propre, alors cette coloration utilise 3 couleurs. C’est la propri´et´e fondamentale
qui va nous ˆetre utile dans notre preuve de NP-compl´etude.
Lemme 9.21 On consid`ere un hypergraphe (Q,S) o`u S = {S1, . . . , Sn} dont le graphe
d’incidence est connexe et tel que pour tous entiers distincts j, k ∈ [1, n], Sj (cid:12)= Sk. Si le
graphe I
Preuve : On consid`ere un hypergraphe (Q,S) dont le graphe d’incidence est connexe o`u
Q = {q1, . . . , qm} et S = {S1, . . . , Sn} De plus, on suppose que pour tous entiers distincts
j, k ∈ [1, n], Sj (cid:12)= Sk. On consid`ere une coloration connexe (cid:8) de I

(cid:2)(Q,S) admet une coloration connexe propre (cid:8), alors |(cid:8)(V (I

Dans le lemme suivant, on montre que si le graphe simple I

(cid:2)(Q,S)))| = 3.

(cid:2)(Q,S).

238

Chapitre 9. Complexit´e

(cid:2)(Q,S) est connexe.

(cid:2)(Q,S)))| = |V (I

Par d´eﬁnition, on sait que deux sommets voisins ont des couleurs diﬀ´erentes. On note
(cid:8)(q1) = 1 et on note 2 et 3 les deux autres couleurs apparaissant dans Qq1 (qui est de
(cid:2)(Q,S))) = {1, 2, 3}
longueur 3). Si la couleur de chaque voisin de q1 est 2 ou 3, alors (cid:8)(V (I
puisque I
On suppose maintenant que q1 a un voisin dont la couleur n’appartient pas `a {2, 3}.
Par cons´equent, tous les sommets dont la couleur est 1 ont un degr´e sup´erieur ou ´egal `a
(cid:2)(Q,S))|, et alors (cid:8) n’est pas
3. On va montrer que dans ce cas l`a, |(cid:8)(V (I
(cid:2)(Q,S).
une coloration propre de I
Propri´et´e 1 : Pour tout w ∈ V (I
V (Cq1) tel que (cid:8)(w) = 2. On sait que (cid:8)(NI(cid:2)(Q,S)) = {1, 3}.

(cid:2)(Q,S)) \
On montre cette propri´et´e par l’absurde. On consid`ere un sommet w ∈ V (I
Si w est le sommet d’un cycle Cp distinct de p, o`u p ∈ Q \ {q1} ∪ {v}, alors w a
un voisin u ´etiquet´e 1. Puisqu’un sommet ´etiquet´e 1 a un degr´e sup´erieur ou ´egal `a 3,
(cid:2) ´etiquet´e 1 ; ce qui est
u = p. Cependant, w a aussi un voisin ´etiquet´e 3 qui a un voisin u
impossible car Cp contient au moins 6 sommets puisque p (cid:12)= q1.
Si w = p ∈ Q \ {q1} ∪ {v}, alors w a un voisin u ∈ V (Cp) de degr´e 2. Par cons´equent,
Si w = S ∈ S ∪S(cid:2), alors w doit avoir un voisin p
(cid:2) ´etiquet´e 3. De par la construction de
(cid:2) appartient `a Q∪{v} ; ce qui est impossible pour les mˆemes raisons

(cid:8)(u) = 3 ; ce qui est impossible pour les mˆemes raisons que pr´ec´edemment.
(cid:2)(Q,S), on sait que p
I
que pr´ec´edemment.

(cid:2)(Q,S)) \ V (Cq1), (cid:8)(w) /∈ {2, 3}.

On a donc montr´e que les couleurs 2 et 3 apparaissent seulement sur le cycle Cq1.

Propri´et´e 2 : Pour tout p ∈ Q ∪ {v},|(cid:8)(V (Cp))| = |V (Cp)|.

(cid:2)(Q,S))) telles que
(cid:2)(Q,S)[aj , aj+1] n’est pas un stable. Pour tout sommet r1 tel que
(cid:2)(Q,S) tel que pour tout j ∈ [1, k],

La condition est v´eriﬁ´ee pour p = q1. Dans les autres cas, on montre la propri´et´e par
l’absurde. Pour cela, on utilise l’observation suivante qui peut ˆetre facilement montr´ee par
r´ecurrence.
Observation : On consid`ere k couleurs distinctes a1, a2, . . . , ak ∈ (cid:8)(V (I
pour tout j ∈ [1, k], I
(cid:8)(r1) = a1, il existe un chemin (r1, r2, . . . , rk) dans I
(cid:8)(rj) = aj.
On consid`ere maintenant un sommet u ∈ V (Cp) \ {p} tel que (cid:8)(u) = (cid:8)(p). D’apr`es la
Propri´et´e 1, aucun sommet de Cp n’est ´etiquet´e 2 et par cons´equent, tout chemin entre
(cid:2)) = 2 contient le sommet p ; ce qui est impossible d’apr`es
u et un sommet u
l’observation pr´ec´edente.
Pour tous sommets u1, u2 ∈ V (Cp)\{p} tels que (cid:8)(u1) = (cid:8)(u2), il est facile de montrer
par r´ecurrence sur distCp(u1, p) que distCp(u1, p) = distCp(u2, p). Parmi tous les couples
de sommets distincts (u1, u2) tels que (cid:8)(u1) = (cid:8)(u2), on choisit le couple (u1, u2) tel que
distCp(u1) = k est maximum. Puisque u1 et u2 ne peuvent pas ˆetre voisins, u1 a un voisin
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
2) = (cid:8)(u
2 tel que (cid:8)(u
1) = k + 1 et u2 a un voisin u
1 tel que distCp(u
1). De par notre
u
2 et cela implique que |Cp| = 2 distu1,p +2, ce qui est
(cid:2)
(cid:2)
choix de (u1, u2), on sait que u
1 = u
impossible, puisque Cp est un cycle de longueur impaire.

(cid:2) tel que (cid:8)(u

On a donc montr´e que pour tout p ∈ Q ∪ {v},|(cid:8)(V (Cp))| = |V (Cp)|.

Propri´et´e 3 : Pour tout p, q ∈ Q ∪ {v} tels que p (cid:12)= q, (cid:8)(V (Cp)) ∩ (cid:8)(V (Cq)) = ∅.
On montre cette propri´et´e par l’absurde. On consid`ere deux cycles distincts Cp, Cq tels
que (cid:8)(V (Cp)) ∩ (cid:8)(V (Cq)) (cid:12)= ∅. On sait que Cp et Cq ont des longueurs diﬀ´erentes et on

9.4. Colorations Connexes

239

suppose donc que |V (Cp)| < |V (Cq)|. On sait d’apr`es la Propri´et´e 2 que les deux voisins de
p qui appartiennent `a Cp ont des couleurs diﬀ´erentes a et b. Si pour tout u ∈ NI(cid:2)(Q,S)(p),
(cid:8)(u) ∈ {a, b}, alors |(cid:8)(V (I(Q,S)))| = |(cid:8)(V (Cp))|, ce qui est impossible puisque d’apr`es la
Propri´et´e 2, |(cid:8)(V (I(Q,S)))| ≥ |V (Cv)| = 6m + 3 > |V (Cp)|. Par cons´equent, pour tout
sommet u ∈ V (I(Q,S)) tel que (cid:8)(u) = (cid:8)(p), le degr´e de u est sup´erieur ou ´egal `a 3.
On consid`ere une couleur a ∈ (cid:8)(Cp) ∩ (cid:8)(Cq). Si a (cid:12)= (cid:8)(p), on consid`ere le sommet
u ∈ V (Cq) tel que (cid:8)(u) = a. Il existe deux chemins disjoints dans Cp entre u et p.
Puisque Cq contient au moins trois sommets de plus que Cp, on sait d’apr`es l’observation
(cid:2) ∈ V (Cq)\{q} tel que (cid:8)(u) = (cid:8)(p) ; ce qui est impossible
pr´ec´edente qu’il existe un sommet u
puisque u est un sommet de degr´e 2. Par cons´equent, on sait que a = (cid:8)(p) = (cid:8)(q) et que
(cid:8)(V (Cp)) ∩ (cid:8)(V (Cq)) = {a}.
On consid`ere un sommet u1 ∈ NCp(p) qui est un voisin de p dans Cp et on note u2
le voisin de u1 diﬀ´erent de p. Ainsi, (cid:8)(u1) est la couleur d’un voisin de q qui appartient `a
S∪S(cid:2) et il existe donc un sommet q
(cid:2)) = (cid:8)(u2). D’apr`es la Propri´et´e 2,
on sait que (cid:8)(u2) (cid:12)= (cid:8)(p) ; mais en consid´erant les cycles Cp et Cq(cid:2) `a la place de Cp et Cq,
on obtient une contradiction.

(cid:2) ∈ Q∪{v} tel que (cid:8)(q

Par cons´equent, pour tout p, q ∈ Q ∪ {v} tels que p (cid:12)= q, (cid:8)(V (Cp)) ∩ (cid:8)(V (Cq)) = ∅.
D’apr`es les Propri´et´es 2 et 3, on sait que pour tous sommets u, u

p∈Q∪{v} V (Cp),
(cid:2)). De plus, si un sommet S ∈ S∪S(cid:2) a la mˆeme couleur qu’un sommet u ∈ V (Cp)
(cid:8)(u) (cid:12)= (cid:8)(u
o`u p ∈ Q ∪ {v}, alors les couleurs des voisins de u appartenant `a Cp apparaissent dans
le voisinage de S qui est constitu´e de sommets de Q ∪ {v}, ce qui est impossible. Par
cons´equent les couleurs des sommets de S ∪ S(cid:2) sont disjointes des couleurs apparaissant
sur tout cycle Cp o`u p ∈ Q ∪ {v}.
Par ailleurs, puisque pour tous entiers diﬀ´erents j, k ∈ [1, n], les ensembles Sj et Sk
sont diﬀ´erents, on sait que pour tous sommets distincts Sj, Sk ∈ S, (cid:8)(NI(cid:2)(Q,S)(Sj)) (cid:12)=
k ∈ S(cid:2),
(cid:2)
(cid:2)
(cid:8)(NI(cid:2)(Q,S)(Sk)). De mˆeme, on sait que pour tous sommets distincts S
j, S
k)). Par ailleurs, pour tous sommets Sj ∈ S et S
k ∈ S(cid:2),
(cid:2)
(cid:2)
(cid:8)(NI(cid:2)(Q,S)(S
k)). Ainsi, tous les sommets de S ∪ S(cid:2) ont des
(cid:8)(v) ∈ (cid:8)(NI(cid:2)(Q,S)(Sj)) et (cid:8)(v) /∈ (cid:8)(NI(cid:2)(Q,S)(S
(cid:2)
couleurs diﬀ´erentes.
(cid:2)(Q,S) ont des couleurs diﬀ´erentes et par

On a donc montr´e que tous les sommets de I

j)) (cid:12)= (cid:8)(NI(cid:2)(Q,S)(S
(cid:2)

(cid:2) ∈ (cid:4)

cons´equent, (cid:8) n’est pas une coloration connexe propre de I

2

(cid:2)(Q,S).

On peut maintenant montrer le r´esultat principal de cette section. On montre qu’il est

NP-complet de d´ecider si un graphe simple G admet une coloration connexe propre.

Th´eor`eme 9.22 Le probl`eme de d´ecider si un graphe simple connexe G donn´e admet une
coloration connexe propre est NP-complet.

Preuve : Puisqu’il suﬃt de deviner un ´etiquetage (cid:8) d’un graphe simple G donn´e, puis
de v´eriﬁer que des conditions locales pour s’assurer que (cid:8) est une coloration connexe, le
probl`eme est clairement dans NP.

Pour montrer que ce probl`eme est NP-diﬃcile, on fait une r´eduction du probl`eme de
la 2-Colorabilit´e d’Hypergraphe qui est NP-complet [GJ79].
´Etant donn´e un hypergraphe (Q,S) o`u Q = {q1, . . . , qm} et S = {S1, . . . , Sn}, on peut
supposer d’apr`es la Remarque 9.20 que le graphe d’incidence de (Q,S) est connexe et que

240

Chapitre 9. Complexit´e

pour tous entiers distincts j, k ∈ [1, n], Sj (cid:12)= Sk. On va montrer que (Q,S) admet une
2-coloration si et seulement si I
On consid`ere un hypergraphe (Q,S) qui admet une 2-coloration Q1 ∪ Q2. On d´eﬁnit

(cid:2)(Q,S) admet une coloration connexe propre.

un ´etiquetage (cid:8) de la mani`ere suivante.

– (cid:8)(v) = 1,
– pour tout q ∈ Q1, (cid:8)(q) = 1,
– pour tout q ∈ Q2, (cid:8)(q) = 2
– pour tout S ∈ S ∪ S(cid:2), (cid:8)(S) = 3,
– pour tout p ∈ Q ∪ {v}, on ´etiquette Cp avec 1, 2, 3 en respectant la couleur de p
et de telle sorte que pour tout sommet u ´etiquet´e 1 (resp. 2, 3), les couleurs 2 et 3
(resp. 1 et 3, 1 et 2) apparaissent dans (cid:8)(NCp(u) ; ce qui est possible puisque pour
tout p ∈ Q ∪ {v}, |V (Cp)| est divisible par 3.

L’´etiquetage ainsi obtenu assure bien que deux sommets voisins ont des couleurs diﬀ´erentes
et de plus, c’est une coloration connexe. En eﬀet, tous les sommets apparaissant dans un
cycle Cp ont deux couleurs diﬀ´erentes dans leurs voisinages et tous les sommets S ∈ S ∪S(cid:2)
sont ´etiquet´es 3 et ont un voisin q1 ∈ Q1 ´etiquet´e 1 et un voisin q2 ∈ Q2 ´etiquet´e 2.
On consid`ere maintenant un hypergraphe (Q,S) o`u Q = {q1, . . . , qm} et S = {S1, . . . ,
Sn} dont le graphe d’incidence est connexe et tel que pour tous entiers distincts j, k ∈ [1, n],
(cid:2)(Q,S) admet une coloration connexe propre (cid:8). D’apr`es le
Sj (cid:12)= Sk. On suppose que I
(cid:2)(Q,S)))| = 3 et on note 1, 2 et 3 les couleurs utilis´ees. Si
Lemme 9.21, on sait que |(cid:8)(V (I
on consid`ere le cycle Cq1 de longueur 3, dont tous les sommets ont des couleurs distinctes,
on sait que tout sommet ´etiquet´e 1 (resp. 2, 3) a des voisins ´etiquet´es 2 et 3 (resp. 1 et 3,
1 et 2).
On suppose que (cid:8)(v) = 1 et ainsi, on peut supposer sans perte de g´en´eralit´e que pour
tout j ∈ [1, n], (cid:8)(Sj) ∈ {2, 3}. S’il existe un entier j tel que (cid:8)(S
(cid:2)
j a un
voisin q2 ´etiquet´e 2 et un voisin q3 ´etiquet´e 3 qui sont tous les deux adjacents `a Sj, ce
j) ∈ {2, 3}. On d´eﬁnit alors
qui est impossible. Par cons´equent, pour tout j ∈ [1, n], (cid:8)(S
(cid:2)
Q1 = {q ∈ Q | (cid:8)(q) = 1} et Q2 = Q\ Q1. Puisque tout sommet S
(cid:2)
j a au moins deux voisins
avec des couleurs diﬀ´erentes et au moins un voisin ´etiquet´e 1, la partition Q1 ∪ Q2 est bien
une 2-coloration de (Q,S).

(cid:2)
j) = 1, alors S

On a donc montr´e qu’il est NP-diﬃcile de d´ecider si un graphe simple G admet une
2

coloration connexe propre.

Le th´eor`eme pr´ec´edent permet d’obtenir un corollaire sur la complexit´e de d´ecider si
un graphe simple G admet un algorithme de nommage ou d’´election utilisant des calculs
locaux cellulaires sur les arˆetes non-´etiquet´ees.
Corollaire 9.23 Le probl`eme de d´ecider si on peut ´elire (resp. nommer) dans un graphe
simple G connexe donn´e en utilisant des calculs locaux cellulaires sur les arˆetes non-
´etiquet´ees est co-NP-complet.

Preuve : Pour le nommage, c’est un corollaire de la Proposition 6.4, du Th´eor`eme 6.16
et du Th´eor`eme 9.22.

On consid`ere le probl`eme de l’´election. On rappelle qu’on ne peut pas ´elire dans un
graphe simple G en utilisant des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees si
et seulement si l’une des deux conditions suivantes est satisfaite.

– il existe un graphe simple H tel que G est une submersion de H et tel que pour

9.4. Colorations Connexes

241

tout sommet v ∈ V (H), il existe un sous-graphe G
localement surjectif ϕ

(cid:2) dans G tel que |ϕ

(cid:2) de G

(cid:2) de G et un homomorphisme

(cid:2)−1(v)| > 1.

– il existe deux graphes simples H1, H2 tels que G est une submersion de H1 et de H2
et tels qu’il existe deux sous-graphes disjoints G1, G2 de G qui sont respectivement
des submersions de H1 et H2.

On montre que ce probl`eme est dans NP. On devine d’abord laquelle de ces deux conditions
n’est pas satisfaite.
Dans le premier cas, on devine ensuite un graphe simple H et une fonction de V (G) dans
V (H). Puisque G doit ˆetre une submersion de H, on v´eriﬁe que |V (H)| ≤ |V (G)|. Pour
tout sommet v ∈ V (H), on devine ensuite un sous graphe G
(cid:2)(v) de G et une fonction de
(cid:2)(v)) dans V (H). Ainsi, il faut deviner au plus |V (G)| sous-graphes de G et |V (G)|+1
V (G
fonctions : on devine donc un nombre polynomial de graphes et de fonctions qui sont toutes
de tailles polynomiales en |V (G)|. Il suﬃt ensuite de v´eriﬁer des conditions locales sur G et
(cid:2)(v) pour s’assurer que les fonctions devin´ees sont bien des homomorphismes
sur chaque G
localement surjectifs ; ce qui se fait en temps polynomial.

Dans le second cas, on devine deux graphes simples H1, H2, une fonction de V (G) dans
V (H1) et une fonction de V (G) dans V (H2). On devine ensuite deux sous-graphe G1 et
G2 de G ainsi qu’une fonction de V (G1) dans V (H1) et une fonction de V (G) dans V (H2).
Il suﬃt ensuite de v´eriﬁer des conditions locales sur G, G1 et G2 pour s’assurer que les
fonctions devin´ees sont bien des homomorphismes localement surjectifs ; ce qui se fait en
temps polynomial.

Par cons´equent, si I

Pour montrer qu’il est NP-diﬃcile de d´ecider si un graphe simple G admet un algo-
rithme d’´election, on consid`ere la mˆeme r´eduction que dans le Th´eor`eme 9.22.
On consid`ere un hypergraphe (Q,S) o`u Q = {q1, . . . , qm} et S = {S1, . . . , Sn}. On
suppose de plus que le graphe d’incidence de (Q,S) est connexe et que pour tout entiers
(cid:2)(Q,S) associ´e `a (Q,S)
distincts j, k ∈ [1, n], Sj (cid:12)= Sk. On remarque que si le graphe I
(cid:2)(Q,S)))| = 3. De plus, puisque le
admet une coloration connexe propre (cid:8), alors |(cid:8)(V (I
graphe d’incidence est connexe, Q est non-vide et le cycle Cv contient donc au moins 9
(cid:2)(Q,S))) apparaˆıt au moins trois fois sur
sommets et chacune des trois couleurs de (cid:8)(V (I
Cv.
(cid:2)(Q,S) est
une submersion du cycle `a 3 sommets `a travers l’homomorphisme induit par (cid:8) et pour
(cid:2)(Q,S) admet une coloration connexe propre,
tout u ∈ V (C3), |(cid:8)
(cid:2)(Q,S) en utilisant des calculs locaux cellulaires
on ne peut pas r´esoudre l’´election sur I
(cid:2)(Q,S) n’admet pas de coloration connexe propre, on
sur les arˆetes non-´etiquet´ees et si I
(cid:2)(Q,S) en utilisant des calculs locaux
peut r´esoudre le nommage et donc l’´election sur I
cellulaires sur les arˆetes non-´etiquet´ees.
Ainsi, en utilisant la mˆeme technique que dans la preuve du Th´eor`eme 9.22, on peut
montrer que (Q,S) admet une 2-coloration si et seulement s’il n’existe pas d’algorithme
(cid:2)(Q,S) utilisant des calculs locaux cellulaires sur les arˆetes
d’´election pour le graphe I
non-´etiquet´ees.

(cid:2)(Q,S) admet une coloration connexe propre, alors I

−1(u)| > 1. Ainsi, si I

On a donc montr´e qu’il est co-NP-complet de d´ecider si un graphe simple G admet un
algorithme d’´election utilisant des calculs locaux cellulaires sur les arˆetes non-´etiquet´ees.
2

242

Chapitre 9. Complexit´e

9.5 Conclusion et Perspectives

Dans ce chapitre, on a montr´e que pour tous les mod`eles ´etudi´es dans ce m´emoire
`a l’exception du mod`ele diﬀusion-`a-port et diﬀusion-`a-boˆıte, il ´etait co-NP-complet de
d´ecider si un graphe G donn´e admettait un algorithme d’´election ou de nommage.

Il est int´eressant de remarquer que les algorithmes de nommage pr´esent´es dans les Cha-
pitres 2, 3 et 4 sont des algorithmes distribu´es d´eterministes qui n´ecessitent un nombre
polynomial de pas de r´e´etiquetages et o`u chaque sommet dispose d’une m´emoire polyno-
miale. Cela met en ´evidence le non-d´eterminisme qui est du `a l’ex´ecution d’un algorithme
distribu´e dans ces mod`eles. Par ailleurs, cela permet aussi d’expliquer pourquoi dans ces
mod`eles, il existe des ex´ecutions de nos algorithmes qui permettent de r´esoudre ´election
et nommage dans des graphes qui ne sont pas minimaux (pour les revˆetements simples,
les revˆetements ou les ﬁbrations discr`etes).

De mˆeme, les algorithmes propos´es pour les mod`eles port-`a-port et port-`a-boˆıte dans le
Chapitre 7 sont des algorithmes qui n´ecessitent un nombre polynomial de messages de taille
polynomiale. Cependant, le non-d´eterminisme ne vient pas que de l’ex´ecution, puisqu’on
sait d’apr`es la Proposition 7.36 que pour tout graphe (G, δ), il existe une ex´ecution «cano-
nique» (l’ex´ecution synchrone) qui permet d’´elire un sommet de G si et seulement si (G, δ)
est minimal pour les revˆetements dirig´es sym´etriques. En fait, dans ces mod`eles, le non-
d´eterminisme provient de l’´etiquetage des ports du r´eseau, puisqu’un algorithme d’´election
pour un graphe G doit permettre d’´elire un sommet de G quel que soit l’´etiquetage des
ports. Cela permet de mettre en ´evidence le rˆole que peut avoir l’´etiquetage des ports d’un
graphe pour briser les «sym´etries» du graphe.

Conclusion et Perspectives

Dans ce m´emoire, on a consid´er´e diﬀ´erents mod`eles d’algorithmique distribu´e. On a
´etudi´e les relations entre ces mod`eles `a travers l’´etude des probl`emes du nommage et de
l’´election. Pour chacun de ces mod`eles, on a caract´eris´e quels ´etaient les graphes dans
lesquels on pouvait r´esoudre le nommage et l’´election. Les caract´erisations obtenues sont
constructives : pour chaque mod`ele, on a exhib´e des algorithmes qui permettaient de
r´esoudre le nommage ou l’´election pour tous les graphes pour lesquels on n’avait pas
obtenu de r´esultat d’impossibilit´e.

Une des motivations de cette th`ese ´etait de d´eterminer si les r´esultats existants qui
sont bas´es sur l’algorithme de Mazurkiewicz ´etaient propre au mod`ele consid´er´e par Ma-
zurkiewicz, ou si on pouvait obtenir des r´esultats similaires dans d’autres mod`eles. On a
montr´e qu’on pouvait obtenir des algorithmes «`a la Mazurkiewicz» dans tous les mod`eles
consid´er´es dans ce m´emoire. Cela permet de mettre en ´evidence la robustesse du principe
de l’algorithme de Mazurkiewicz, puisque mˆeme si un sommet ne parvient pas `a distinguer
ses voisins (comme c’est le cas dans les mod`eles utilisant des calculs locaux sur les arˆetes
non-´etiquet´ees), chaque sommet arrive `a obtenir le maximum d’informations possibles `a
propos du graphe auquel il appartient. Cela permet de penser que les r´esultats obtenus par
Godard, M´etivier et Muscholl [GM03, GMM04] sur les familles de graphes reconnaissables
de mani`ere distribu´ee peuvent eux aussi ˆetre ´etendus aux diﬀ´erents mod`eles consid´er´es
dans ce m´emoire.

On a par ailleurs montr´e que dans tous ces mod`eles, si les sommets connaissaient
initialement leur degr´e, il existait des algorithmes de nommage universels sur les familles
de graphes minimaux de diam`etre born´e. `A l’aide des outils utilis´es dans [GM02], on
pense pouvoir caract´eriser, dans chaque mod`ele, les familles de graphes qui admettent des
algorithmes universels de nommage, ou de mani`ere ´equivalente, d´eterminer quelles sont les
connaissances initiales dont il faut disposer `a propos d’un graphe pour pouvoir r´esoudre
le probl`eme du nommage sur ce graphe.

De plus, pour tous les mod`eles consid´er´es `a l’exception des calculs locaux (cellulaires)
sur les arˆetes non-´etiquet´ees ´etudi´es aux Chapitres 5 et 6, les algorithmes de nommage
pr´esent´es sont polynomiaux, comme l’est l’algorithme de Mazurkiewicz. Dans ces mˆemes
mod`eles, on a adapt´e les outils utilis´es par Godard, M´etivier et Tel [GM02, MT00] pour
montrer que si les sommets connaissaient initialement leurs degr´es, il ´etait possible d’ob-
tenir des algorithmes eﬀectifs d’´election en connaissant une borne serr´ee sur la taille du
graphe. Ainsi, il est raisonnable de penser qu’on puisse ´etendre les techniques utilis´ees
dans [MT00] pour caract´eriser dans ces mod`eles les familles de graphes sur lesquelles
on puisse transformer tout algorithme distribu´e `a terminaison implicite en algorithme `a
terminaison explicite comme cela a ´et´e fait dans [CGMT07].

243

244

Conclusion et Perspectives

d1
d1

d2
d2

≡

d1
d1

≡

d2
d2

≡

d1

d2

d1

d2

d1

d2

d1

d2

P P ≡ AM

P B

DP ≡ DB

Fig. 35 – Une hi´erarchie des diﬀ´erents mod`eles ´etudi´es dans ce m´emoire.

Un autre objectif de cette th`ese ´etait de pr´esenter un nouvel algorithme d’´election pour
le mod`ele o`u les processus communiquent par ´echange de messages. Il faut noter que l’al-
gorithme d’´election pr´esent´e au Chapitre 7 est le premier algorithme polynomial d’´election
pour des r´eseaux de topologie arbitraire dans ce mod`ele. Cette am´elioration par rapport
aux algorithmes existants repose sur une bonne compr´ehension de la notion de revˆetements
dirig´es. Plus g´en´eralement, au vu des r´esultats obtenus, on pense que les diﬀ´erents types
d’homomorphismes utilis´es dans ce m´emoire sont les bons outils pour d´eterminer ce qui
est calculable de mani`ere distribu´ee dans les diﬀ´erents mod`eles consid´er´es.

Par ailleurs, on a montr´e au Chapitre 9 que pour chaque mod`ele consid´er´e dans ce
m´emoire, `a l’exception des mod`eles diﬀusion-`a-port et diﬀusion-`a-boˆıte, il est co-NP-
complet de d´ecider si un graphe G admet un algorithme d’´election ou de nommage dans
ce mod`ele. Ce r´esultat et le fait que la plupart des algorithmes de nommage et d’´election
pr´esent´es sont polynomiaux permet de mettre en ´evidence l’aspect non-d´eterministe d’une
ex´ecution d’un algorithme distribu´e.

Sch´ema R´ecapitulatif

Sur la Figure 35, on a repr´esent´e les diﬀ´erents mod`eles ´etudi´es dans ce m´emoire.
Les mod`eles ´etudi´es au Chapitre 7 utilisant des messages sont not´es P P, P B, DP, DB
et correspondent respectivement aux mod`eles port-`a-port, port-`a-boˆıte, diﬀusion-`a-port et
diﬀusion-`a-boˆıte. Le mod`ele de syst`eme `a agents mobiles ´etudi´e au Chapitre 8 utilisant
des agents mobiles est not´e AM.

Les mod`eles utilisant des calculs locaux ´etudi´es aux Chapitres 2, 3, 4, 5 et 6 sont
repr´esent´es par la forme des r`egles utilis´ees. Les sommets noirs sont les sommets actifs
dont les ´etiquettes peuvent ˆetre modiﬁ´ees lors de l’application de la r`egle. Les sommets
blancs sont les sommets passifs qui permettent l’application d’une r`egle, mais dont les
´etiquettes ne sont pas modiﬁ´ees. Lorsque les arˆetes sont marqu´ees, cela signiﬁe que dans
le mod`ele correspondant, les ´etiquettes des arˆetes peuvent ˆetre modiﬁ´ees par l’application
d’une r`egle. Lorsque les sommets sont ´etiquet´es d1 et d2, cela signiﬁe que dans le mod`ele

245

correspondant, chaque sommet connaˆıt initialement son degr´e.

S’il existe une ﬂ`eche m → m

Figure 35, cela signiﬁe qu’on peut simuler le mod`ele m dans m
fausse. Cette relation est ´evidemment transitive. Lorsque m ≡ m
signiﬁe que les mod`eles m et m
de chemin dirig´e entre les repr´esentations de deux mod`eles m et m
signiﬁe que les puissances de calcul de m et de m

(cid:2) sont incomparables.

(cid:2) entre les repr´esentations de deux mod`eles m et m

(cid:2) sur la
(cid:2) mais que la r´eciproque est
(cid:2) sur la Figure 35, cela
(cid:2) ont la mˆeme puissance de calcul. Lorsqu’il n’existe pas
(cid:2) sur la Figure 35, cela

Perspectives

Dans le cadre des calculs locaux, il peut ˆetre int´eressant de caract´eriser quels sont les
graphes dans lesquels on peut ´elire en utilisant des algorithmes qui n´ecessitent une m´emoire
ﬁnie pour chaque sommet. L’algorithme d’´election pour la famille des arbres pr´esent´e dans
le Chapitre 1 est un exemple d’algorithme de ce type, puisque les ´etiquettes des sommets
du graphe peuvent prendre seulement trois valeurs (A,Non-´elu, ´Elu). D’apr`es les travaux
d’Angluin et al. [AAER05], on sait qu’il existe un algorithme utilisant une m´emoire ﬁnie
qui permet de distinguer un sommet dans un graphe complet dans le mod`ele ´etudi´e au Cha-
pitre 6. Cependant, dans les mod`eles consid´er´es par Angluin et al., les processus ne peuvent
pas d´etecter que l’algorithme est termin´e et on ne peut donc pas obtenir un v´eritable al-
gorithme d’´election `a partir de ces r´esultats. Dans [Maz06], Mazurkiewicz consid`ere un
mod`ele, o`u en un pas de calcul, un sommet peut observer son voisinage «ferm´e» (i.e., ses
voisins et les ´eventuelles arˆetes entre ses voisins), et modiﬁer son ´etat en cons´equence. Dans
ce mod`ele, Mazurkiewicz d´eﬁnit la famille des graphes ferm´es qui contient en particulier
les graphes triangul´es et qui contient donc les graphes complets et les arbres. Il pr´esente
ensuite un algorithme universel d’´election pour cette famille. Cet algorithme est un algo-
rithme de «d´emontage» du graphe, comme l’est l’algorithme d’´election pour la famille des
arbres pr´esent´e au Chapitre 1 : un sommet peut prendre l’´etiquette Non-´elu si lorsque
ce sommet est supprim´e du graphe, le graphe obtenu est toujours connexe et reste dans
la famille des graphes ferm´es. Dans l’algorithme pr´esent´e dans [Maz06], chaque sommet
peut avoir seulement trois ´etiquettes diﬀ´erentes : son ´etiquette initiale, l’´etiquette ´Elu et
l’´etiquette Non-´elu.

Dans le cadre des algorithmes utilisant des ´echanges de messages, il semble ˆetre possible
d’obtenir de nouveaux algorithmes en exploitant le r´esultat d’´equivalence entre les syst`emes
`a agents mobiles et les syst`emes o`u les processus communiquent par ´echange de messages.
En particulier, Das et al. pr´esentent dans [DFNS06] un algorithme eﬀectif d’´election pour
les syst`emes `a agents mobiles de taille donn´ee. Mˆeme si les preuves des r´esultats pr´esent´es
dans ce travail reposent sur la notion de vues de Yamashita et Kameda, l’algorithme
pr´esent´e est polynomial. Cet algorithme est tr`es diﬀ´erent de l’algorithme pr´esent´e au
Chapitre 7 et n’a pas du tout les mˆemes propri´et´es. Cependant, il est possible d’exhiber
des liens entre l’algorithme de Das et al. et la construction de Reidemeister pr´esent´ee au
Chapitre 2 : il semble donc possible de d´ecrire l’algorithme de Das et al. en utilisant les
notions de revˆetements dirig´es pr´esent´ees au Chapitre 7.

246

Conclusion et Perspectives

Bibliographie

[AAD+04] D. Angluin, J. Aspnes, Z. Diamadi, M.J. Fischer, and R. Peralta. Computation
in networks of passively mobile ﬁnite-state sensors. In Proc. of the 23rd An-
nual ACM Symposium on Principles of Distributed Computing (PODC 2004),
pages 290–299. ACM press, 2004.

[AAD+06] D. Angluin, J. Aspnes, Z. Diamadi, M.J. Fischer, and R. Peralta. Computation
in networks of passively mobile ﬁnite-state sensors. Distributed Computing,
18(4) :235–253, 2006.

[AAE06a] D. Angluin, J. Aspnes, and D. Eisenstat. Fast computation by population
protocols with a leader. In Proc. of Distributed Computing, 20th International
Conference (DISC 2006), 2006.

[AAE06b] D. Angluin, J. Aspnes, and D. Eisenstat. Stably computable predicates are
In Proc. of the 25th annual ACM symposium on Principles of

semilinear.
distributed computing (PODC 2006), pages 292–299. ACM Press, 2006.

[AFS91]

[AAER05] D. Angluin, J. Aspnes, D. Eisenstat, and E. Ruppert. On the power of anony-
mous one-way communication. In Proc. of the 9th International Conference
on Principles of Distributed Systems (OPODIS 2005), pages 307–318, 2005.
[ABRS95] B. Awerbuch, M. Betke, R. Rivest, and M. Singh. Piecemeal graph exploration
by a mobile robot (extended abstract). In Proc. of the 8th annual conference
on Computational learning theory (COLT 1995), pages 321–328. ACM Press,
1995.
J. Abello, M.R. Fellows, and J.C. Stillwell. On the complexity and combi-
natorics of covering ﬁnite complexes. Australasian Journal of Combinatorics,
4 :103–112, 1991.
D. Angluin and A. Gardiner. Finite common coverings of pairs of regular
graphs. J. Combin. Theory, Ser. B, 30(2) :183–187, 1981.
D. Angluin. Local and global properties in networks of processors. In Proc.
of the 12th Symposium on Theory of Computing (STOC 1980), pages 82–93,
1980.
H. Attiya and J. Welch. Distributed computing : fundamentals, simulations,
and advanced topics. John Wiley and Sons, 2004.

[AW04]

[AG81]

[Ang80]

[BCG+96] P. Boldi, B. Codenotti, P. Gemmell, S. Shammah, J. Simon, and S. Vigna.
Symmetry breaking in anonymous networks : characterizations. In Proc. of the
4th Israeli Symposium on Theory of Computing and Systems (ISTCS 1996),
pages 16–26. IEEE Press, 1996.

247

248

BIBLIOGRAPHIE

[BFFS03a] L. Barri`ere, P. Flocchini, P. Fraigniaud, and N. Santoro. Can we elect if we
cannot compare ? In Proc. of the 15th annual ACM Symposium on Parallel
Algorithms and Architectures, (SPAA 2003), pages 324–332. ACM Press, 2003.
[BFFS03b] L. Barri`ere, P. Flocchini, P. Fraigniaud, and N. Santoro. Election and rendez-
vous in fully anonymous systems with sense of direction. In Proc. of the 10th
International Colloquium on Structural Information Complexity (SIROCCO
2003), volume 17, pages 17–32. Carleton Scientiﬁc, 2003.

[Bod89]

[Bou88]

[BR05]

[BS94]

[BFFS06] L. Barri`ere, P. Flocchini, P. Fraigniaud, and N. Santoro. Rendezvous and
election of mobile agents : impact of sense of direction. Theory of Computing
Systems, to appear, 2006.
H.L. Bodlaender. The classiﬁcation of coverings of processor networks. Journal
of parallel and distributed computing, 6(1) :166–182, 1989.
L. Boug´e. On the existence of symmetric algorithms to ﬁnd leaders in net-
works of communicating sequential processes. Acta Informatica, 25(2) :179–
201, 1988.
P. Braun and W. Rossak. Mobile agents : basic concepts, mobility models and
the tracy toolkit. Morgan Kaufman, 2005.
M. Bender and D. Slonim. The power of team exploration : two robots can
learn unlabeled directed graphs. In Proc. of the 35th Annual Symposium on
Foundations of Computer Science (FOCS 1994), pages 75–85, 1994.
P. Boldi and S. Vigna. Computing anonymously with arbitrary knowledge.
In Proc. of the 18th ACM Symposium on principles of distributed computing
(PODC 1999), pages 181–188. ACM Press, 1999.
P. Boldi and S. Vigna. An eﬀective characterization of computability in anony-
mous networks. In Proc. of Distributed Computing, 15th International Confe-
rence (DISC 2001), volume 2180 of Lecture Notes in Computer Science, pages
33–47. Springer-Verlag, 2001.
P. Boldi and S. Vigna. Fibrations of graphs. Discrete Mathematics, 243(1-
3) :21–66, 2002.
P. Boldi and S. Vigna. Universal dynamic synchronous self-stabilization. Dis-
tributed Computing, 15(3) :137–153, 2002.

[BV02b]

[BV02a]

[BV99]

[BV01]

[CDS06]

[CBMT96] B. Charron-Bost, F. Mattern, and G. Tel. Synchronous, asynchronous and
causally ordered communication. Distributed Computing, 9(4) :173–191, 1996.
J. Chalopin, S. Das, and N. Santoro. Groupings and pairings in anonymous
networks. In Proc. of Distributed Computing, 20th International Conference
(DISC 2006), volume 4167 of Lecture Notes in Computer Science, pages 105–
119. Springer-Verlag, 2006.

[CGMO06] J. Chalopin, E. Godard, Y. M´etivier, and R. Ossamy. Mobile agent algorithms
versus message passing algorithms. In Proc. of the 10th International Confe-
rence on Principles of Distributed Systems (OPODIS 2006), volume 4305 of
Lecture Notes in Computer Science, pages 187–201. Springer-Verlag, 2006.

BIBLIOGRAPHIE

249

[Cha05]

[CM04]

[CM05]

[Cha06]

[CGMT07] J. Chalopin, E. Godard, Y. M´etivier, and G. Tel. About the termination detec-
tion in the asynchronous message passing model. In Proc. of the 33rd Confe-
rence on Current Trends in Theory and Practice of Informatics (SOFSEM
2007), volume 4362 of Lecture Notes in Computer Science, pages 200–211.
Springer-Verlag, 2007.
J. Chalopin. Local computations on closed unlabelled edges : the election
problem and the naming problem. In Proc. of the 31st Conference on Current
Trends in Theory and Practice of Informatics (SOFSEM 2005), volume 3381
of Lecture Notes in Computer Science, pages 81–90. Springer-Verlag, 2005.
J. Chalopin. Election in the qualitative world. In Proc. of Structural Infor-
mation and Communication Complexity, 13th International Colloquium (SI-
ROCCO 2006), volume 4056 of Lecture Notes in Computer Science, pages
85–99. Springer-Verlag, 2006.
J. Chalopin and Y. M´etivier. Election and local computations on edges. In
Proc. of Foundations of Software Science and Computation Structures, 7th
International Conference (FOSSACS 2004), volume 2987 of Lecture Notes in
Computer Science, pages 90–104. Springer-Verlag, 2004.
J. Chalopin and Y. M´etivier. A bridge between the asynchronous message
passing model and local computations in graphs. In Proc. of the 30th Interna-
tional Symposium on Mathematical Foundations of Computer Science (MFCS
2005), volume 3618 of Lecture Notes in Computer Science, pages 212–223.
Springer-Verlag, 2005.
J. Chalopin, Y. M´etivier, and W. Zielonka. Election, naming and cellular edge
local computations. In Proc. of the 2nd International Conference on Graph
Transformations (ICGT 2004), volume 3256 of Lecture Notes in Computer
Science, pages 242–256. Springer-Verlag, 2004.
J. Chalopin, Y. M´etivier, and W. Zielonka. Local computations in graphs : the
case of cellular edge local computations. Fundamenta Informaticae, 74(1) :85–
114, 2006.
J. Chalopin and D. Paulusma. Graphs labelings derived from models in distri-
buted computing. In Proc. of Graph-Theoretic Concepts in Computer Science,
32nd International Workshop (WG 2006), volume 4271 of Lecture Notes in
Computer Science, pages 301–312. Springer-Verlag, 2006.
B. Derbel. Local aspects in distributed algorithms. PhD thesis, Universit´e
Bordeaux 1, 2006.

[CMZ04]

[CMZ06]

[CP06]

[Der06]

[DFNS05] S. Das, P. Flocchini, A. Nayak, and N. Santoro. Distributed exploration of
an unknown graph. In Proc. of Structural Information and Communication
Complexity, 12th International Colloquium (SIROCCO 2005), volume 3499 of
Lecture Notes in Computer Science, pages 99–114. Springer, 2005.

[DFNS06] S. Das, P. Flocchini, A. Nayak, and N. Santoro. Eﬀective elections for ano-
In Proc. of Algorithms and Computation, 17th In-
nymous mobile agents.
ternational Symposium (ISAAC 2006), Lecture Notes in Computer Science.
Springer, 2006.

250

[DFP03]

BIBLIOGRAPHIE

A. Dessmark, P. Fraigniaud, and A. Pelc. Deterministic rendezvous in graphs.
In Proc. of the 11th Annual European Symposium (ESA 2003), volume 2832
of Lecture Notes in Computer Science, pages 184–195, 2003.

[DKP98] X. Deng, T. Kameda, and C. Papadimitriou. How to learn an unknown envi-

[EB91]

[FP03]

[FP05]

[FRS03]

[GJ79]

ronment. i : the rectilinear case. J. ACM, 45(2) :215–245, 1998.
M. Everett and S. Borgatti. Role colouring a graph. Mathematical Social
Sciences, 21(2) :183–188, 1991.
J. Fiala and D. Paulusma. The computational complexity of the role assign-
ment problem. In Proc. of the 30th International Colloquium on Automata,
Languages and Programming (ICALP 2003), volume 2719 of Lecture Notes in
Computer Science, pages 817–828. Springer-Verlag, 2003.
J. Fiala and D. Paulusma. A complete complexity classiﬁcation of the role
assignment problem. Theoretical Computer Science, 349(1) :67–81, 2005.
P. Flocchini, A. Roncato, and N. Santoro. Computing on anonymous networks
with sense of direction. Theoretical Computer Science, 301(1-3) :355–379,
2003.
M.R. Garey and D.S. Johnson. Computers and Intractability. W.H. Freeman
and Co., New York, 1979.

[GM02]

[GKKZ06] L. Gasieniec, E. Kranakis, D. Krizanc, and X. Zhang. Optimal memory rendez-
vous of anonymous mobile agents in a unidirectional ring. In Proc. of Theory
and Practice of Computer Science, 32nd Conference on Current Trends in
Theory and Practice of Computer Science (SOFSEM 2006), volume 3831 of
Lecture Notes in Computer Science, pages 282–292. Springer, 2006.
E. Godard and Y. M´etivier. A characterization of families of graphs in which
election is possible (ext. abstract). In Proc. of Foundations of Software Science
and Computation Structures, 5th International Conference (FOSSACS 2002),
volume 2303 of Lecture Notes in Computer Science, pages 159–172. Springer-
Verlag, 2002.
E. Godard and Y. M´etivier. Deducible and equivalent structural knowledges in
distributed algorithms. Theory of Computing Systems, 36(2) :631–654, 2003.
[GMM04] E. Godard, Y. M´etivier, and A. Muscholl. Characterization of classes of graphs
recognizable by local computations. Theory of Computing Systems, 37(2) :249–
293, 2004.

[GM03]

[God02a] E. Godard. R´e´ecritures de Graphes et Algorithmique Distribu´ee. PhD thesis,

Universit´e Bordeaux 1, 2002.

[God02b] E. Godard. A self-stabilizing enumeration algorithm. Information Processing

[Hal35]
[Hoa78]

[HU79]

Letters, 82(6) :299–305, 2002.
P. Hall. On representation of subsets. J. London Math. Soc., 10 :26–30, 1935.
C.A.R. Hoare. Communicating sequential processes. Commun. ACM,
21(8) :666–677, 1978.
J. Hopcroft and J. Ullman. Introduction to automata theory, languages and
computation. Addison-Wesley, 1979.

BIBLIOGRAPHIE

251

[KKR06]

[KPT94]

[KPT97]

[KPT98]

[Kra91]
[KT00]

[Lei82]

[LeL77]

[Lyn96]
[Maz87]

[Maz97]

[Maz06]
[Mil99]

E. Kranakis, D. Krizanc, and S. Rajsbaum. Mobile agent rendezvous : A sur-
vey. In Proc. of Structural Information and Communication Complexity, 13th
International Colloquium (SIROCCO 2006), volume 4056 of Lecture Notes in
Computer Science, pages 1–9. Springer, 2006.
J. Kratochv´ıl, A. Proskurowski, and J.A. Telle. Complexity of graph covering
problems. In Proc. of Graph-Theoretic Concepts in Computer Science, 20th
International Workshop (WG 1994), volume 903 of Lecture Notes in Computer
Science, pages 93–105. Springer, 1994.
J. Kratochv´ıl, A. Proskurowski, and J.A. Telle. Covering regular graphs. J.
Comb. Theory, Ser. B, 71(1) :1–16, 1997.
J. Kratochv´ıl, A. Proskurowski, and J.A. Telle. Complexity of graph covering
problems. Nordic Journal of Computing, 5(3) :173–195, 1998.
J. Kratochv´ıl. Perfect codes in general graphs. Academia Praha, 1991.
P. Kristiansen and J.A. Telle. Generalized H-coloring of graphs. In Proc. of
the 11th International Conference on Algorithms and Computation (ISAAC
2000), volume 1969 of Lecture Notes in Computer Science, pages 456–466.
Springer-Verlag, 2000.
F.T. Leighton. Finite common coverings of graphs. J. Combin. Theory, Ser.
B, 33(3) :231–238, 1982.
G. LeLann. Distributed systems, towards a formal approach. In Information
processing 1977, pages 155–160. North-Holland, 1977.
N. Lynch. Distributed algorithms. Morgan Kaufman, 1996.
A. Mazurkiewicz. Trace theory.
Lecture notes in computer science, pages 279–324. Spinger, 1987.
A. Mazurkiewicz. Distributed enumeration. Information Processing Letters,
61(5) :233–239, 1997.
A. Mazurkiewicz. Locally derivable graphs. manuscript, 2006.
R. Milner. Communicating and mobile systems : the π-calculus. Cambridge
University Press, 1999.

In Advances in Petri Nets, volume 255 of

[MMW97] Y. M´etivier, A. Muscholl, and P.-A. Wacrenier. About the local detection
of termination of local computations in graphs. In Proc. of the 4th Interna-
tional Colloquium on Structural Information and Communication Complexity
(SIROCCO 1997), Proceedings in Informatics, pages 188–200. Carleton Scien-
tiﬁc, 1997.
M. Mosbah and A. Sellami. Implementation of an enumeration protocol al-
In Proc. of Second International
gorithm using local graph computations.
Workshop on Graph Transformation and Visual Modeling Techniques, 2001.
Y. M´etivier, N. Saheb, and A. Zemmari. Randomized local elections. Infor-
mation Processing Letters, 82(6) :313–320, 2002.
Y. M´etivier, N. Saheb, and A. Zemmari. Analysis of a randomized rendezvous
algorithm. Inf. Comput., 184(1) :109–128, 2003.

[MSZ02]

[MS01]

[MSZ03]

252

[MT00]

BIBLIOGRAPHIE

Y. M´etivier and G. Tel. Termination detection and universal graph recons-
truction. In Proc. of 7th International Colloquium on Structural Information
and Communication Complexity (SIROCCO 2000), Proceedings in Informa-
tics, pages 237–251. Carleton Scientiﬁc, 2000.

[NMR01] C. Nichitiu, J. Mazoyer, and E. R´emila. Algorithms for leader election by

[Nor95]

[NPR04]

[Pal03]

[Rei32]

[RFH72]

[Sak99]

[Sel04]

[SSP85]

[Tel00]

cellular automata. J. Algorithms, 41(2) :302–329, 2001.
N. Norris. Universal covers of graphs : isomorphism to depth n − 1 implies
isomorphism to all depths. Discrete Applied Math., 56(1) :61–74, 1995.
C. Nichitiu, C. Papazian, and E. R´emila. Leader election in plane cellular au-
tomata, only with left-right global convention. Theoretical Computer Science,
319(1-3) :367–384, 2004.
C. Palamidessi. Comparing the expressive power of the synchronous and
the asynchronous π-calculus. Mathematical Structures in Computer Science,
13(5) :685–719, 2003.
K. Reidemeister. Einf¨uhrung in die kombinatorische topologie. Vieweg, Bruns-
wick, 1932.
P. Rosenstiehl, J.-R. Fiksel, and A. Holliger. Intelligent graphs. In R. Read,
editor, Graph theory and computing, pages 219–265. Academic Press (New
York), 1972.
N. Sakamoto. Comparison of initial conditions for distributed algorithms on
anonymous networks. In Proc. of the 18th Annual ACM Symposium on Prin-
ciples of Distributed Computing (PODC 1999), pages 173–179. ACM Press,
1999.
A. Sellami. Des calculs locaux aux algorithmes distribu´es. PhD thesis, Univer-
sit´e Bordeaux 1, 2004.
B. Szymanski, Y. Shy, and N. Prywes. Terminating iterative solutions of
simultaneous equations in distributed message passing systems. In Proc. of the
4th Annual ACM Symposium on Principles of Distributed Computing (PODC
1985), pages 287–292. ACM Press, 1985.
G. Tel. Introduction to distributed algorithms. Cambridge University Press,
2000.

