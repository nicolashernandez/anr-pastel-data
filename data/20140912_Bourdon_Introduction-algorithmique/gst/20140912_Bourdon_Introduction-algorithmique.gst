* gran_2 20140912 1 inter_segment_gap 0.000 0.552 <o,f0,> inter_segment_gap
* * 20140912 1 20140912_Locuteur_1 0.552 2.883 <o,f0,male> alors maintenant on va passer à la
* * 20140912 1 20140912_Locuteur_1 2.883 5.770 <o,f0,male> à la *deuxième, donc on a on a nommé les variables
* * 20140912 1 20140912_Locuteur_1 5.770 12.450 <o,f0,male> on a vu que c'est () donner un nom, ça permettait d'accéder à un ensemble de cases mémoires
* * 20140912 1 20140912_Locuteur_1 12.450 17.482 <o,f0,male> mais là, je vous avais dit que le nombre de cases mémoires réservées et associées à chaque nom
* * 20140912 1 20140912_Locuteur_1 17.482 20.834 <o,f0,male> dépendait de ce qu'on stockait dans la variable.
* * 20140912 1 20140912_Locuteur_1 20.834 28.080 <o,f0,male> autrement dit, ça dépendait du type qu'on allait attribuer à la variable.
* * 20140912 1 20140912_Locuteur_1 28.080 30.592 <o,f0,male> donc c'est important de se poser ce genre de questions
* * 20140912 1 20140912_Locuteur_1 30.592 32.846 <o,f0,male> et là on va v() on va parler euh
* * 20140912 1 20140912_Locuteur_1 32.846 35.120 <o,f0,male> on va parler des différents types de bases.
* * 20140912 1 20140912_Locuteur_1 35.120 37.963 <o,f0,male> donc euh j'avais dit les n() les nombres
* * 20140912 1 20140912_Locuteur_1 37.963 39.905 <o,f0,male> les chaînes de caractères,
* * 20140912 1 20140912_Locuteur_1 39.905 43.360 <o,f0,male> les booléens,
* * 20140912 1 20140912_Locuteur_1 43.360 45.301 <o,f0,male> eh ben on va les faire tous un par un.
* * 20140912 1 20140912_Locuteur_1 45.301 49.600 <o,f0,male> et on va aller même un peu plus dans le détail, puisque là on va commencer par les nombres entiers.
* * 20140912 1 20140912_Locuteur_1 49.600 52.792 <o,f0,male> ou numériques entiers
* gran_1 20140912 1 20140912_Locuteur_1 52.792 56.181 <o,f0,male> alors qu'est-ce que c'est qu'un numérique entier en informatique ?
* * 20140912 1 20140912_Locuteur_1 56.181 59.094 <o,f0,male> ben déjà, je vous rappelle ce que c'est qu'en maths :
* * 20140912 1 20140912_Locuteur_1 59.094 61.412 <o,f0,male> en maths, c'est un élément de z
* * 20140912 1 20140912_Locuteur_1 61.412 63.997 <o,f0,male> moins l'infini plus l'infini.
* * 20140912 1 20140912_Locuteur_1 63.997 66.046 <o,f0,male> c'est pas ça en informatique :
* * 20140912 1 20140912_Locuteur_1 66.046 73.978 <o,f0,male> en informatique, on est toujours limité au fait que votre machine, vous la posez sur un bureau, elle est () elle a une taille fixée.
* * 20140912 1 20140912_Locuteur_1 73.978 77.527 <o,f0,male> donc vous pourrez pas mettre un nombre infini, vous pourrez pas définir
* * 20140912 1 20140912_Locuteur_1 77.527 79.495 <o,f0,male> un nombre infini
* * 20140912 1 20140912_Locuteur_1 79.495 80.500 <o,f0,male> de valeurs
* * 20140912 1 20140912_Locuteur_1 80.500 82.820 <o,f0,male> dans un es() dans un ensemble fini,
* * 20140912 1 20140912_Locuteur_1 82.820 87.170 <o,f0,male> dans une boîte f() de taille finie.
* * 20140912 1 20140912_Locuteur_1 87.170 90.471 <o,f0,male> donc en informatique, c'est pas tous les entiers des maths
* * 20140912 1 20140912_Locuteur_1 90.471 92.895 <o,f0,male> mais c'est qu'un sous-ensemble de ces entiers
* * 20140912 1 20140912_Locuteur_1 92.895 98.354 <o,f0,male> autrement dit, c'est l'ensemble tous les entiers qu'on peut écrire selon une règle qu'on se fixe.
* * 20140912 1 20140912_Locuteur_1 98.354 99.627 <o,f0,male> la règle
* * 20140912 1 20140912_Locuteur_1 99.627 104.816 <o,f0,male> elle est fixée au niveau international, par une norme euh iso et cetera et cetera
* * 20140912 1 20140912_Locuteur_1 104.816 106.532 <o,f0,male> mais en tout cas
* * 20140912 1 20140912_Locuteur_1 106.532 110.251 <o,f0,male> elle est donnée, et elle est donnée pour chaque langage informatique. donc il y a une règle
* * 20140912 1 20140912_Locuteur_1 110.251 112.211 <o,f0,male> d'écriture,
* * 20140912 1 20140912_Locuteur_1 112.211 114.485 <o,f0,male> et en appliquant cette règle d écriture,
* * 20140912 1 20140912_Locuteur_1 114.485 119.782 <o,f0,male> on sait combien d'entiers on va pouvoir euh écrire.
* * 20140912 1 20140912_Locuteur_1 119.782 124.133 <o,f0,male> si on suit la règle d'écriture des entiers dans un langage euh c
* * 20140912 1 20140912_Locuteur_1 124.133 128.647 <o,f0,male> un langage euh c'est un langage informatique très connu et très très utilisé,
* * 20140912 1 20140912_Locuteur_1 128.647 129.893 <o,f0,male> en c et
* * 20140912 1 20140912_Locuteur_1 129.893 131.743 <o,f0,male> et sur mon mac,
* * 20140912 1 20140912_Locuteur_1 131.743 134.059 <o,f0,male> puisque le c sur euh
* * 20140912 1 20140912_Locuteur_1 134.059 136.354 <o,f0,male> une autre machine ça peut être différent,
* * 20140912 1 20140912_Locuteur_1 136.354 137.481 <o,f0,male> alors
* * 20140912 1 20140912_Locuteur_1 137.481 138.054 <o,f0,male> on ()
* * 20140912 1 20140912_Locuteur_1 138.054 141.416 <o,f0,male> un entier en informatique du c
* * 20140912 1 20140912_Locuteur_1 141.416 146.430 <o,f0,male> ce sera toutes les valeurs entre moins
* * 20140912 1 20140912_Locuteur_1 146.430 153.002 <o,f0,male> deux milliards cent quarante-sept millions et cetera, donc qui z() qui est en fait moins deux à la puissance trente et un
* * 20140912 1 20140912_Locuteur_1 153.002 154.216 <o,f0,male> et
* * 20140912 1 20140912_Locuteur_1 154.216 157.542 <o,f0,male> la même chose en positif
* * 20140912 1 20140912_Locuteur_1 157.542 162.774 <o,f0,male> ou aut() ou plutôt deux à la puissance trente et un moins un.
* * 20140912 1 20140912_Locuteur_1 162.774 165.985 <o,f0,male> donc c'est () les entiers en c, c'est tous ces nombres-là
* * 20140912 1 20140912_Locuteur_1 165.985 167.136 <o,f0,male> c'est pas
* * 20140912 1 20140912_Locuteur_1 167.136 171.153 <o,f0,male> c'est pas tous les nombres d() entre moins l'infini et plu() et plus l'infini, c'est tous ces nombres-là.
* gran_1 20140912 1 inter_segment_gap 171.153 172.056 <o,f0,> inter_segment_gap
* * 20140912 1 20140912_Locuteur_1 172.056 176.464 <o,f0,male> donc javascript, l'avantage du javascript c'est que c'est euh
* * 20140912 1 20140912_Locuteur_1 176.464 178.146 <o,f0,male> la même représentation
* * 20140912 1 20140912_Locuteur_1 178.146 181.110 <o,f0,male> des nombres quelle que que soit l'architecture
* * 20140912 1 20140912_Locuteur_1 181.110 184.810 <o,f0,male> et là, des nombres entiers on peut en représenter un petit peu plus
* * 20140912 1 20140912_Locuteur_1 184.810 187.167 <o,f0,male> donc on peut peut en représenter
* * 20140912 1 20140912_Locuteur_1 187.167 188.929 <o,f0,male> je sais pas lire ce nombre
* * 20140912 1 20140912_Locuteur_1 188.929 190.610 <o,f0,male> vous savez peut-être le lire vous
* * 20140912 1 20140912_Locuteur_1 190.610 193.585 <o,f0,male> mais ce nombre, c'est moins deux à la puissance cinquante-trois
* * 20140912 1 20140912_Locuteur_1 193.585 198.038 <o,f0,male> jusqu() d() on peut représenter tous les entiers entre moins deux à la puissance cinquante-trois
* * 20140912 1 20140912_Locuteur_1 198.038 200.962 <o,f0,male> et plus deux à la puissance cinquante-trois.
* * 20140912 1 20140912_Locuteur_1 200.962 205.758 <o,f0,male> donc on peut représenter tout ceux-là, et puis en fait on peut en représenter quelques-uns mais ils sont plus consécutifs
* * 20140912 1 20140912_Locuteur_1 205.758 210.430 <o,f0,male> quelques-uns supplémentaires, mais ils sont plus consécutifs.
* * 20140912 1 20140912_Locuteur_1 210.430 212.930 <o,f0,male> donc euh
* * 20140912 1 20140912_Locuteur_1 212.930 215.508 <o,f0,male> voilà. donc premier type de base, les entiers
* * 20140912 1 20140912_Locuteur_1 215.508 220.120 <o,f0,male> et c'est important de savoir utiliser des entiers

deb_slide * 20140912 1 20140912_Locuteur_1 220.120 226.532 <o,f0,male> et de ma() c'est important de savoir euh j() mu() manipuler des entiers parce que c'est vraiment un type de base.
* gran_1 20140912 1 20140912_Locuteur_1 226.532 229.161 <o,f0,male> alors en réalité
* * 20140912 1 20140912_Locuteur_1 229.161 233.890 <o,f0,male> en informatique, on utilise pas vraiment des entiers. le type de base de l'informatique, c'est
* * 20140912 1 20140912_Locuteur_1 233.890 237.060 <o,f0,male> le nombre binaire : zéro ou un.
* * 20140912 1 20140912_Locuteur_1 237.060 239.209 <o,f0,male> mais c'est pas grave, parce que euh
* * 20140912 1 20140912_Locuteur_1 239.209 243.655 <o,f0,male> pour représenter un entier avec un nombre binaire, donc ça c'est un nombre binaire
* * 20140912 1 20140912_Locuteur_1 243.655 246.984 <o,f0,male> qui représente l'entier cent trente-cinq, il suffit de le réécrire comme ça
* * 20140912 1 20140912_Locuteur_1 246.984 250.056 <o,f0,male> donc qu'est-ce que c'est que cent trente-cinq ? c'est une fois
* * 20140912 1 20140912_Locuteur_1 250.056 251.427 <o,f0,male> cent vingt-huit
* * 20140912 1 20140912_Locuteur_1 251.427 253.643 <o,f0,male> cent vingt huit, c'est deux à la puissance sept
* * 20140912 1 20140912_Locuteur_1 253.643 255.619 <o,f0,male> et ça c'est une valeur fixée,
* * 20140912 1 20140912_Locuteur_1 255.619 259.887 <o,f0,male> plus zéro fois soixante-quatre ; soixante-quatre, c'est deux à la puissance six,
* * 20140912 1 20140912_Locuteur_1 259.887 263.779 <o,f0,male> plus zéro fois s() trente-deux, plus et cetera plus et cetera
* * 20140912 1 20140912_Locuteur_1 263.779 266.162 <o,f0,male> plus une fois quatre, plus une fois deux, plus une fois un.
* * 20140912 1 20140912_Locuteur_1 266.162 270.682 <o,f0,male> donc deux à la puissance zéro, deux à la puissance un, deux à la puissance deux, il manque deux à la puissance trois, et cetera.
* * 20140912 1 20140912_Locuteur_1 270.682 273.386 <o,f0,male> donc on on est capable de représenter
* * 20140912 1 20140912_Locuteur_1 273.386 275.258 <o,f0,male> le nombre cent trente-cinq
* * 20140912 1 20140912_Locuteur_1 275.258 284.090 <o,f0,male> par cette suite de uns et de zéros qui est utilisée pour reconstruire cent trente-cinq comme ça.
* * 20140912 1 20140912_Locuteur_1 284.090 291.980 <o,f0,male> si on [mic-] utilise [-mic]
* * 20140912 1 20140912_Locuteur_1 291.980 297.794 <o,f0,male> si on utilise huit euh bits, donc huit zéros ou () des suites de huit zéros ou uns,
* * 20140912 1 20140912_Locuteur_1 297.794 300.829 <o,f0,male> on pourra écrire tous les nombres entre
* * 20140912 1 20140912_Locuteur_1 300.829 304.986 <o,f0,male> zéro et deux cent cinquante-cinq
* * 20140912 1 20140912_Locuteur_1 304.986 306.519 <o,f0,male> hein
* * 20140912 1 20140912_Locuteur_1 306.519 311.610 <o,f0,male> si on fait ce calcul-là, on () c'est c'est facile de s'en rendre compte.
* * 20140912 1 20140912_Locuteur_1 311.610 317.012 <o,f0,male> si on en utilise cinquante euh trois, on pourra représenter tous les nombres de
* * 20140912 1 20140912_Locuteur_1 317.012 318.713 <o,f0,male> tous les nombres consécutifs
* * 20140912 1 20140912_Locuteur_1 318.713 322.836 <o,f0,male> du javascript.
* * 20140912 1 20140912_Locuteur_1 322.836 325.746 <o,f0,male> mais vous avez vu qu'il y avait des nombres négatifs, *mais c'est pas grave.
* * 20140912 1 20140912_Locuteur_1 325.746 327.490 <o,f0,male> en fait, on se permet d'en représenter
* * 20140912 1 20140912_Locuteur_1 327.490 328.843 <o,f0,male> que la moitié
* * 20140912 1 20140912_Locuteur_1 328.843 330.198 <o,f0,male> de positifs
* * 20140912 1 20140912_Locuteur_1 330.198 332.102 <o,f0,male> et on se sert d'un bit
* * 20140912 1 20140912_Locuteur_1 332.102 334.520 <o,f0,male> qui définira le signe.
* * 20140912 1 20140912_Locuteur_1 334.520 337.511 <o,f0,male> donc euh si je réserve ce signe-là,
* * 20140912 1 20140912_Locuteur_1 337.511 338.620 <o,f0,male> ce bit-là
* * 20140912 1 20140912_Locuteur_1 338.620 340.880 <o,f0,male> comme signe, je peux représenter
* * 20140912 1 20140912_Locuteur_1 340.880 345.520 <o,f0,male> tous les nombres entre moins cent vingt-huit et plus cent vingt-sept, au lieu de tous les nombres entre zéro et deux cent cinquante.
* * 20140912 1 20140912_Locuteur_1 345.520 347.405 <o,f0,male> bon, bref, moralité :
* * 20140912 1 20140912_Locuteur_1 347.405 350.028 <o,f0,male> on peut coder les entiers avec uniquement des bits
* * 20140912 1 20140912_Locuteur_1 350.028 350.743 <o,f0,male> zéro un.
* * 20140912 1 20140912_Locuteur_1 350.743 355.252 <o,f0,male> et ça c'est bien, parce qu'en mémoire on ne peut représenter que des bits ; c'est () il y a que des interrupteurs en mémoire.
* * 20140912 1 20140912_Locuteur_1 355.252 357.712 <o,f0,male> donc le fait qu'on sache représenter des entiers
* * 20140912 1 20140912_Locuteur_1 357.712 361.485 <o,f0,male> par des interrupteurs, c'est bien.

deb_slide * 20140912 1 20140912_Locuteur_1 361.485 362.653 <o,f0,male> c'est la moralité.
* gran_2 20140912 1 20140912_Locuteur_1 362.653 366.807 <o,f0,male> deuxième type de base : le nombre réel.
* * 20140912 1 20140912_Locuteur_1 366.807 371.915 <o,f0,male> alors les réels en mathématiques, je fais encore la même analogie, c'est tous les éléments de l'ensemble r.
* * 20140912 1 20140912_Locuteur_1 371.915 374.145 <o,f0,male> là j'invente rien
* * 20140912 1 20140912_Locuteur_1 374.145 375.809 <o,f0,male> par contre en informatique,
* * 20140912 1 20140912_Locuteur_1 375.809 377.757 <o,f0,male> pour la même raison
* * 20140912 1 20140912_Locuteur_1 377.757 383.371 <o,f0,male> c'est pas tous les nombres de r ; c'est qu'un sous-ensemble qu'on appelle les flottants.
* * 20140912 1 20140912_Locuteur_1 383.371 385.852 <o,f0,male> donc l() les flottants,
* * 20140912 1 20140912_Locuteur_1 385.852 393.970 <o,f0,male> ce sont ceux qu'on peut écrire *selon une règle d'écriture donnée et qui dépend du langage informatique.
* * 20140912 1 20140912_Locuteur_1 393.970 399.572 <o,f0,male> les flottants en c sont certains réels, donc pas tous les réels parce que évidemment entre deux
* * 20140912 1 20140912_Locuteur_1 399.572 402.557 <o,f0,male> réels, on peut mettre une infinité de réels
* * 20140912 1 20140912_Locuteur_1 402.557 404.731 <o,f0,male> r est un ensemble dense
* * 20140912 1 20140912_Locuteur_1 404.731 410.030 <o,f0,male> donc on n'a on n'a pas cette propriété pour euh dans les règles d'écriture
* * 20140912 1 20140912_Locuteur_1 410.030 420.147 <o,f0,male> mais ce sont d() voilà, ce qu'on dit c'est qu'en c, ce sont certains réels dont les posi() les nombres positifs sont compris entre un nombre très petit : trois point quatre à la () dix à la puissance moins trente-huit
* * 20140912 1 20140912_Locuteur_1 420.147 424.887 <o,f0,male> et un nombre très grand : trois point quatre fois dix à la puissance trente-huit.
* * 20140912 1 20140912_Locuteur_1 424.887 429.697 <o,f0,male> et puis la même chose pour les nombres négatifs
* * 20140912 1 20140912_Locuteur_1 429.697 431.716 <o,f0,male> voilà, donc on pourra se rapprocher très
* * 20140912 1 20140912_Locuteur_1 431.716 434.445 <o,f0,male> près de zéro
* * 20140912 1 20140912_Locuteur_1 434.445 437.356 <o,f0,male> au point qu'on pourra dire que c'est zéro
* * 20140912 1 20140912_Locuteur_1 437.356 439.212 <o,f0,male> on pourra avoir un très grand nombre
* * 20140912 1 20140912_Locuteur_1 439.212 441.342 <o,f0,male> et puis on aura un certain nombre de nombres réels
* * 20140912 1 20140912_Locuteur_1 441.342 442.555 <o,f0,male> codés
* gran_1 20140912 1 20140912_Locuteur_1 442.555 443.782 <o,f0,male> entre les deux.

deb_slide * 20140912 1 20140912_Locuteur_1 443.782 451.653 <o,f0,male> euh en javascript, les nombres réels s'appellent les numbers.
* * 20140912 1 20140912_Locuteur_1 451.653 454.338 <o,f0,male> et ce sont ceux-là
* * 20140912 1 20140912_Locuteur_1 454.338 456.206 <o,f0,male> en javascript
* * 20140912 1 20140912_Locuteur_1 456.206 457.740 <o,f0,male> donc euh
* * 20140912 1 20140912_Locuteur_1 457.740 464.983 <o,f0,male> comment on fait pour les définir, ces numbers ? et puis c'est comment on fait pour définir les flottants aussi, c'est à peu près la même norme.
* * 20140912 1 20140912_Locuteur_1 464.983 469.633 <o,f0,male> eh ben on se souvient qu'un ordinateur ne sait nativement manipuler que des entiers
* * 20140912 1 20140912_Locuteur_1 469.633 472.435 <o,f0,male> même plus précisément, que des zéros et des uns, c'est ce qu'on a vu jusqu'à présent
* * 20140912 1 20140912_Locuteur_1 472.435 477.410 <o,f0,male> donc nativement, on ne sait manipuler que des entiers, donc on va essayer de s'en sortir avec des entiers.
* * 20140912 1 20140912_Locuteur_1 477.410 480.429 <o,f0,male> et l'astuce pour représenter un nombre réel,
* * 20140912 1 20140912_Locuteur_1 480.429 482.787 <o,f0,male> c'est de le noter sous une notation ingénieur
* * 20140912 1 20140912_Locuteur_1 482.787 485.676 <o,f0,male> vous connaissez la notation ingénieur, j'imagine ?
* * 20140912 1 20140912_Locuteur_1 485.676 487.748 <o,f0,male> on prend n'importe quel nombre réel
* * 20140912 1 20140912_Locuteur_1 487.748 488.838 <o,f0,male> qu'on écrit
* * 20140912 1 20140912_Locuteur_1 488.838 491.554 <o,f0,male> de toute façon il va falloir l'écrire un jour,
* * 20140912 1 20140912_Locuteur_1 491.554 497.497 <o,f0,male> zéro point zéro zéro zéro zéro un deux un un deux trois,
* * 20140912 1 20140912_Locuteur_1 497.497 500.942 <o,f0,male> qui s'écrit en notation ingénieur : un point cent vingt-trois
* * 20140912 1 20140912_Locuteur_1 500.942 503.266 <o,f0,male> e moins cinq
* * 20140912 1 20140912_Locuteur_1 503.266 505.860 <o,f0,male> ou qui s'écrit aussi
* * 20140912 1 20140912_Locuteur_1 505.860 510.351 <o,f0,male> euh mille cent vingt-trois e moins huit
* * 20140912 1 20140912_Locuteur_1 510.351 512.582 <o,f0,male> eh bah là on a gagné,
* * 20140912 1 20140912_Locuteur_1 512.582 514.250 <o,f0,male> parce qu'on a deux entiers :
* * 20140912 1 20140912_Locuteur_1 514.250 519.431 <o,f0,male> on a un premier entier, mille cent vingt-trois, et un deuxième entier, moins huit
* * 20140912 1 20140912_Locuteur_1 519.431 522.057 <o,f0,male> ouais, c'est comme ça qu'on fait pour représenter les réels.
* * 20140912 1 20140912_Locuteur_1 522.057 524.291 <o,f0,male> le nombre cent vingt-trois en informati()
* * 20140912 1 20140912_Locuteur_1 524.291 527.186 <o,f0,male> en informatique, on appellera ça la mantisse ;
* * 20140912 1 20140912_Locuteur_1 527.186 529.364 <o,f0,male> le moins huit, on appellera ça l'exposant.
* * 20140912 1 20140912_Locuteur_1 529.364 530.580 <o,f0,male> ce sont des entiers
* * 20140912 1 20140912_Locuteur_1 530.580 533.370 <o,f0,male> donc comme ce sont des entiers, on peut les coder en machine
* * 20140912 1 20140912_Locuteur_1 533.370 537.540 <o,f0,male> donc on peut coder les réels en machine.
* * 20140912 1 20140912_Locuteur_1 537.540 539.200 <o,f0,male> et en javascript
* * 20140912 1 20140912_Locuteur_1 539.200 540.783 <o,f0,male> si on peut coder
* * 20140912 1 20140912_Locuteur_1 540.783 543.065 <o,f0,male> les les nombres qu'on peut coder, ce sont ceux
* * 20140912 1 20140912_Locuteur_1 543.065 546.131 <o,f0,male> qu'on peut coder avec une mantisse
* * 20140912 1 20140912_Locuteur_1 546.131 551.768 <o,f0,male> comprise entre moins deux à la puissance cinquante-trois et plus deux à la puissance cinquante-trois moins un.
* * 20140912 1 20140912_Locuteur_1 551.768 554.841 <o,f0,male> ça, c'est les entiers qu'on peut représenter,
* * 20140912 1 20140912_Locuteur_1 554.841 557.300 <o,f0,male> tous les entiers qu'on peut représenter,
* * 20140912 1 20140912_Locuteur_1 557.300 561.886 <o,f0,male> et dont l'exposant est compris, alors là on a un peu moins d'exposants mais c'est quand même pas mal,
* * 20140912 1 20140912_Locuteur_1 561.886 567.987 <o,f0,male> moins deux à la puissance dix et plus deux à la puissance dix ; alors deux à la puissance dix, c'est mille vingt quatre.
* * 20140912 1 20140912_Locuteur_1 567.987 572.167 <o,f0,male> donc ça fait quand même beaucoup de nombres réels qu'on peut représenter.
* * 20140912 1 20140912_Locuteur_1 572.167 575.496 <o,f0,male> le plus grand nombre réel, c'est un nombre
* * 20140912 1 20140912_Locuteur_1 575.496 578.419 <o,f0,male> qui a trois cent huit chiffres
* * 20140912 1 20140912_Locuteur_1 578.419 580.061 <o,f0,male> il me semble à peu près

deb_slide * 20140912 1 20140912_Locuteur_1 580.061 585.137 <o,f0,male> ça se trouve euh enfin on peut le calculer facilement, dont trois cent huit chiffres.
* * 20140912 1 20140912_Locuteur_1 585.137 588.418 <o,f0,male> voilà, donc moralité : on peut coder les flottants avec deux entiers,
* gran_2 20140912 1 20140912_Locuteur_1 588.418 593.770 <o,f0,male> et donc on peut les coder avec des zéros et des uns.
* * 20140912 1 20140912_Locuteur_1 593.770 594.733 <o,f0,male> le troisième

deb_slide * 20140912 1 20140912_Locuteur_1 594.733 597.482 <o,f0,male> type de base, ça va être le caractère
* * 20140912 1 20140912_Locuteur_1 597.482 599.141 <o,f0,male> parce que
* * 20140912 1 20140912_Locuteur_1 599.141 603.300 <o,f0,male> finalement on veut pas forcément faire que des calculs avec un ordinateur ;
* * 20140912 1 20140912_Locuteur_1 603.300 607.421 <o,f0,male> une autre finalité de l'informatique, c'est de communiquer
* * 20140912 1 20140912_Locuteur_1 607.421 611.960 <o,f0,male> fatalement : sciences de l'information, on veut communiquer.
* * 20140912 1 20140912_Locuteur_1 611.960 613.376 <o,f0,male> donc les caractères
* * 20140912 1 20140912_Locuteur_1 613.376 616.440 <o,f0,male> en informatique,
* * 20140912 1 20140912_Locuteur_1 616.440 620.116 <o,f0,male> ça va être tout ce qu'on souhaite écrire
* * 20140912 1 20140912_Locuteur_1 620.116 622.317 <o,f0,male> et tout ce qu'on souhaite écrire, en fait ça s()
* * 20140912 1 20140912_Locuteur_1 622.317 624.251 <o,f0,male> ça change
* * 20140912 1 20140912_Locuteur_1 624.251 629.173 <o,f0,male> ça change pas d'une année sur l'autre, mais ça change d'une décennie à l'autre finalement.
* * 20140912 1 20140912_Locuteur_1 629.173 631.990 <o,f0,male> parce que avant quatre-vingts,
* * 20140912 1 20140912_Locuteur_1 631.990 635.432 <o,f0,male> ce qu'on souhaitait écrire, c'était des messages en anglais
* * 20140912 1 20140912_Locuteur_1 635.432 638.896 <o,f0,male> l'informatique était plutôt un domaine dominé par la
* * 20140912 1 20140912_Locuteur_1 638.896 640.863 <o,f0,male> les américains.
* * 20140912 1 20140912_Locuteur_1 640.863 645.004 <o,f0,male> donc ce qu'ils *souhaitaient, c'était s'échanger des messages écrits en anglais.
* * 20140912 1 20140912_Locuteur_1 645.004 648.059 <o,f0,male> quel est l() l'avantage de l'anglais ? ben c'est un alphabet latin
* * 20140912 1 20140912_Locuteur_1 648.059 650.632 <o,f0,male> et il y a pas d'accents.
* * 20140912 1 20140912_Locuteur_1 650.632 652.561 <o,f0,male> donc euh par contre, on a
* * 20140912 1 20140912_Locuteur_1 652.561 657.774 <o,f0,male> on a besoin de mettre des virgules, on a besoin de mettre des x() de mettre des *points d'exclamation et cetera et cetera.
* * 20140912 1 20140912_Locuteur_1 657.774 662.448 <o,f0,male> donc on avait p() avant quatre-vingts, on souhaitait commu() envoyer des messages comme ça.
* * 20140912 1 20140912_Locuteur_1 662.448 665.503 <o,f0,male> après quatre-vingts,
* * 20140912 1 20140912_Locuteur_1 665.503 667.590 <o,f0,male> l'europe s'y est mis
* * 20140912 1 20140912_Locuteur_1 667.590 669.436 <o,f0,male> la norvège aussi
* * 20140912 1 20140912_Locuteur_1 669.436 674.110 <o,f0,male> avec tous ses accents bizarres,
* * 20140912 1 20140912_Locuteur_1 674.110 678.348 <o,f0,male> et puis euh et puis aujourd'hui, c'est même plus que
* * 20140912 1 20140912_Locuteur_1 678.348 681.223 <o,f0,male> c'est même plus que les accents bizarres qu'on veut, c'est euh
* * 20140912 1 20140912_Locuteur_1 681.223 684.853 <o,f0,male> on veut écrire des choses dans des cara() on veut écrire des caractères
* * 20140912 1 20140912_Locuteur_1 684.853 687.395 <o,f0,male> dans des alphabets qui ne sont pas des alphabets latins
* * 20140912 1 20140912_Locuteur_1 687.395 689.219 <o,f0,male> à à la base latins.
* * 20140912 1 20140912_Locuteur_1 689.219 694.698 <o,f0,male> donc euh euh en alphabet chinois, en kanjis et cetera, donc on veut écrire des choses comme ça.
* * 20140912 1 20140912_Locuteur_1 694.698 696.519 <o,f0,male> donc
* * 20140912 1 20140912_Locuteur_1 696.519 700.244 <o,f0,male> comme pour coder les réels
* * 20140912 1 20140912_Locuteur_1 700.244 702.726 <o,f0,male> pour coder des caractères, il faut des normes.
* * 20140912 1 20140912_Locuteur_1 702.726 705.409 <o,f0,male> et ces normes, elles s'appellent normes ascii
* * 20140912 1 20140912_Locuteur_1 705.409 708.216 <o,f0,male> elles s'appelaient normes ascii dans les années quatre-vingts
* * 20140912 1 20140912_Locuteur_1 708.216 710.938 <o,f0,male> elles s'appellent normes unicode maintenant

deb_slide * 20140912 1 20140912_Locuteur_1 710.938 712.578 <o,f0,male> qu'est-ce que c'est que ces normes ?
* * 20140912 1 20140912_Locuteur_1 712.578 715.723 <o,f0,male> ben c'est tout simplement
* * 20140912 1 20140912_Locuteur_1 715.723 718.264 <o,f0,male> une euh une norme
* * 20140912 1 20140912_Locuteur_1 718.264 719.564 <o,f0,male> qui dit
* * 20140912 1 20140912_Locuteur_1 719.564 724.006 <o,f0,male> à tel caractère, j'associe tel entier.
* * 20140912 1 20140912_Locuteur_1 724.006 728.640 <o,f0,male> la norme ascii
* * 20140912 1 20140912_Locuteur_1 728.640 730.791 <o,f0,male> disait : au caractère
* * 20140912 1 20140912_Locuteur_1 730.791 734.849 <o,f0,male> soixante euh quatorze,
* * 20140912 1 20140912_Locuteur_1 734.849 737.620 <o,f0,male> j'associe le j majuscule.
* * 20140912 1 20140912_Locuteur_1 737.620 742.716 <o,f0,male> donc cette table le () la table que je vous ai mise ici, elle se lit comme ça : soixante-douze plus
* * 20140912 1 20140912_Locuteur_1 742.716 749.070 <o,f0,male> deux, ça fait soixante-quatorze, et le caractère donc à soixante-quatorze, c'est j majuscule.
* * 20140912 1 20140912_Locuteur_1 749.070 753.206 <o,f0,male> voilà. donc qu'est-ce que c'est qu'une norme ? k() comment on code un caractère ?
* * 20140912 1 20140912_Locuteur_1 753.206 755.426 <o,f0,male> ben c'est simple : on le code par un entier
* * 20140912 1 20140912_Locuteur_1 755.426 760.818 <o,f0,male> mais pour pouvoir le coder par un entier, il faut une une norme qui associe un caractère à un entier.
* * 20140912 1 20140912_Locuteur_1 760.818 763.126 <o,f0,male> et regardez bien dans la norme
* * 20140912 1 20140912_Locuteur_1 763.126 767.488 <o,f0,male> le j majuscule et le j minuscule, c'est pas () se sont pas associés au même nombre.
* * 20140912 1 20140912_Locuteur_1 767.488 770.550 <o,f0,male> donc ce sont deux caractères différents.
* * 20140912 1 20140912_Locuteur_1 770.550 773.764 <o,f0,male> il y a rien qui les distingue ; ils sont différents.

deb_slide * 20140912 1 20140912_Locuteur_1 773.764 779.090 <o,f0,male> voilà, donc ça c'est la norme ascii.
* * 20140912 1 20140912_Locuteur_1 779.090 781.056 <o,f0,male> cette norme ascii, vous pouvez la manipuler
* * 20140912 1 20140912_Locuteur_1 781.056 785.560 <o,f0,male> dans l'interface euh par le biais de deux fonctions :
* * 20140912 1 20140912_Locuteur_1 785.560 789.433 <o,f0,male> une fonction ascii vers caractère, qui prend en paramètre
* * 20140912 1 20140912_Locuteur_1 789.433 791.852 <o,f0,male> un entier et qui renvoie le caractère
* * 20140912 1 20140912_Locuteur_1 791.852 793.320 <o,f0,male> et la fonction inverse,
* * 20140912 1 20140912_Locuteur_1 793.320 798.850 <o,f0,male> qui prend un caractère, et qui va le transformer vers un caractère ascii.
* * 20140912 1 20140912_Locuteur_1 798.850 799.546 <o,f0,male> ok ?
* * 20140912 1 20140912_Locuteur_1 799.546 802.408 <o,f0,male> donc ces euh ces deux fonctions permettent de manipuler
* * 20140912 1 20140912_Locuteur_1 802.408 805.960 <o,f0,male> les caractères de la table ascii.

deb_slide gran_1 20140912 1 20140912_Locuteur_1 805.960 810.480 <o,f0,male> alors on veut aller plus loin,
* * 20140912 1 20140912_Locuteur_1 810.480 812.549 <o,f0,male> mais c'est pas plus compliqué.
* * 20140912 1 20140912_Locuteur_1 812.549 814.579 <o,f0,male> la norme unicode,
* * 20140912 1 20140912_Locuteur_1 814.579 818.237 <o,f0,male> c'est juste une sorte de table ascii, mais très grande.
* * 20140912 1 20140912_Locuteur_1 818.237 825.558 <o,f0,male> donc au lieu de coder par des petits nombres euh entiers, entre zéro et cent vingt-sept, on va se permettre de prendre des plus grands nombres entiers
* * 20140912 1 20140912_Locuteur_1 825.558 827.970 <o,f0,male> donc là par exemple, c'est des nombres
* * 20140912 1 20140912_Locuteur_1 827.970 830.430 <o,f0,male> ça, c'est le nombre vingt mille
* * 20140912 1 20140912_Locuteur_1 830.430 832.427 <o,f0,male> vingt mille un, vingt mille deux, vingt mille trois
* * 20140912 1 20140912_Locuteur_1 832.427 834.069 <o,f0,male> et cetera, donc c'est toujours des nombres
* * 20140912 1 20140912_Locuteur_1 834.069 835.340 <o,f0,male> qui permettent d'associer
* * 20140912 1 20140912_Locuteur_1 835.340 837.298 <o,f0,male> un caractère
* * 20140912 1 20140912_Locuteur_1 837.298 838.877 <o,f0,male> à un code.
* * 20140912 1 20140912_Locuteur_1 838.877 839.592 <o,f0,male> donc pa()
* * 20140912 1 20140912_Locuteur_1 839.592 841.295 <o,f0,male> par exemple, le code
* * 20140912 1 20140912_Locuteur_1 841.295 843.720 <o,f0,male> le caractère
* * 20140912 1 20140912_Locuteur_1 843.720 847.854 <o,f0,male> associé au code vingt mille cent six,
* * 20140912 1 20140912_Locuteur_1 847.854 850.525 <o,f0,male> c'est celui-là.
* * 20140912 1 20140912_Locuteur_1 850.525 851.364 <o,f0,male> un code
* * 20140912 1 20140912_Locuteur_1 851.364 856.280 <o,f0,male> de de l'alphabet euh j() japonais.
* * 20140912 1 20140912_Locuteur_1 856.280 863.293 <o,f0,male> et comme on est () on peut se permettre d'avoir des très très grandes tables d'association, enfin c'est c'est c'est très extensible.
* * 20140912 1 20140912_Locuteur_1 863.293 866.331 <o,f0,male> dans le cours de traitement automatique des langues naturelles, vous reviendrez là-dessus.

deb_slide * 20140912 1 20140912_Locuteur_1 866.331 871.500 <o,f0,male> on vous pa() on vous dira pourquoi c'est utile d'avoir ce genre de de table.
* * 20140912 1 20140912_Locuteur_1 871.500 873.364 <o,f0,male> voilà
* * 20140912 1 20140912_Locuteur_1 873.364 876.476 <o,f0,male> euh à noter quand même
* * 20140912 1 20140912_Locuteur_1 876.476 878.680 <o,f0,male> que en javascript
* * 20140912 1 20140912_Locuteur_1 878.680 881.320 <o,f0,male> et dans le langage algorithmique qu'on utilisera,
* * 20140912 1 20140912_Locuteur_1 881.320 884.254 <o,f0,male> un caractère ça se notera :
* * 20140912 1 20140912_Locuteur_1 884.254 887.590 <o,f0,male> un quote,
* * 20140912 1 20140912_Locuteur_1 887.590 889.374 <o,f0,male> le () apostrophe,
* * 20140912 1 20140912_Locuteur_1 889.374 890.687 <o,f0,male> une apostrophe,
* * 20140912 1 20140912_Locuteur_1 890.687 892.018 <o,f0,male> un caractère,
* * 20140912 1 20140912_Locuteur_1 892.018 893.510 <o,f0,male> une apostrophe.

deb_slide * 20140912 1 20140912_Locuteur_1 893.510 900.260 <o,f0,male> c'est la manière de noter les caractères.
* * 20140912 1 20140912_Locuteur_1 900.260 902.315 <o,f0,male> voilà, donc moralité :
* * 20140912 1 20140912_Locuteur_1 902.315 904.653 <o,f0,male> on peut coder les caractères avec un entier,
* * 20140912 1 20140912_Locuteur_1 904.653 908.138 <o,f0,male> éventuellement un entier très grand,
* * 20140912 1 20140912_Locuteur_1 908.138 910.284 <o,f0,male> en utilisant une table de correspondance
* * 20140912 1 20140912_Locuteur_1 910.284 921.960 <o,f0,male> normalisée au niveau international ; c'est pas nous qui avons décidé de de créer cette table de correspondance, c'est des organismes qui les standardisent au niveau international,
* * 20140912 1 20140912_Locuteur_1 921.960 926.513 <o,f0,male> et comme on peut les coder par des entiers, on peut les coder uniquement par des bits.
* * 20140912 1 20140912_Locuteur_1 926.513 929.548 <o,f0,male> donc ça ça marche, on peut communiquer avec un ordinateur.

deb_slide * 20140912 1 20140912_Locuteur_1 929.548 934.004 <o,f0,male> si ça marchait pas, ça se saurait.
* gran_2 20140912 1 20140912_Locuteur_1 934.004 937.770 <o,f0,male> mais ça marche comme ça.
* * 20140912 1 20140912_Locuteur_1 937.770 939.594 <o,f0,male> le type s()
* * 20140912 1 20140912_Locuteur_1 939.594 941.844 <o,f0,male> quatrième type de base, hein ici j'ai noté trois
* * 20140912 1 20140912_Locuteur_1 941.844 943.155 <o,f0,male> faudra que je corrige
* * 20140912 1 20140912_Locuteur_1 943.155 946.498 <o,f0,male> ce sont les chaînes de caractères.
* * 20140912 1 20140912_Locuteur_1 946.498 950.211 <o,f0,male> qu'est-ce que c'est qu'une chaîne de caractères ? eh ben c'est un ensemble de caractères mis bout à bout.
* * 20140912 1 20140912_Locuteur_1 950.211 952.894 <o,f0,male> une suite de caractères
* * 20140912 1 20140912_Locuteur_1 952.894 955.285 <o,f0,male> alors la
* * 20140912 1 20140912_Locuteur_1 955.285 959.663 <o,f0,male> j'attire votre *attention sur le fait que ça peut aussi être : pas de caractère du tout
* * 20140912 1 20140912_Locuteur_1 959.663 964.787 <o,f0,male> une chaîne de caractères, ça peut être pas de caractère, un caractère, deux caractères, mille caractères
* * 20140912 1 20140912_Locuteur_1 964.787 968.007 <o,f0,male> cent mille caractères, ça dépend de ce qu'on veut envoyer.
* * 20140912 1 20140912_Locuteur_1 968.007 971.296 <o,f0,male> c'est un texte, en fait
* * 20140912 1 20140912_Locuteur_1 971.296 973.758 <o,f0,male> donc par exemple
* * 20140912 1 20140912_Locuteur_1 973.758 981.673 <o,f0,male> vous avez des exemples de textes ici : bonjour au revoir avec un espace, première ligne, un caractère bizarre qui permet de passer à la ligne, deuxième ligne,
* * 20140912 1 20140912_Locuteur_1 981.673 982.390 <o,f0,male> *et *cetera.
* * 20140912 1 20140912_Locuteur_1 982.390 989.412 <o,f0,male> donc en javascript et dans le langage algorithmique, les chaînes de caractères sont notées comme une suite de caractères entourés de deux quotes.
* * 20140912 1 20140912_Locuteur_1 989.412 991.388 <o,f0,male> ça ressemble beaucoup aux caractères
* * 20140912 1 20140912_Locuteur_1 991.388 992.740 <o,f0,male> de toute façon
* * 20140912 1 20140912_Locuteur_1 992.740 999.908 <o,f0,male> en javascript, il y a pas de distinction entre un caractère et une chaîne de caractères
* * 20140912 1 20140912_Locuteur_1 999.908 1005.120 <o,f0,male> donc euh ça, c'est aussi une chaîne de caractères.
* * 20140912 1 20140912_Locuteur_1 1005.120 1008.417 <o,f0,male> donc il y a pas de () donc c'est c'est c'est noté comme ça
* * 20140912 1 20140912_Locuteur_1 1008.417 1010.285 <o,f0,male> ça
* * 20140912 1 20140912_Locuteur_1 1010.285 1014.795 <o,f0,male> quote quote, avec rien au milieu, c'est aussi une chaîne de caractères
* * 20140912 1 20140912_Locuteur_1 1014.795 1020.296 <o,f0,male> et on reviendra dessus euh bien souvent parce que s() elle joue un rôle très très important
* * 20140912 1 20140912_Locuteur_1 1020.296 1022.962 <o,f0,male> en algorithmique.
* * 20140912 1 20140912_Locuteur_1 1022.962 1028.640 <o,f0,male> quand on va chercher à coller deux chaînes de caractères, il y a une opération qui s'appelle la concaténation de chaînes de caractères
* * 20140912 1 20140912_Locuteur_1 1028.640 1036.053 <o,f0,male> ben euh ça, c'est l'élément neutre de l'opération, si on parle de () en en termes mathématiques, c'est l'élément neutre de l'opération concaténation.

deb_slide * 20140912 1 20140912_Locuteur_1 1036.053 1041.506 <o,f0,male> et c'est pour ça que c'est une chaîne de caractères importante.
* * 20140912 1 20140912_Locuteur_1 1041.506 1042.610 <o,f0,male> voilà
* * 20140912 1 20140912_Locuteur_1 1042.610 1052.089 <o,f0,male> donc moralité : comme on peut coder les chaînes de caractères par une suite de plusieurs enti() enfin par () de plusieurs caractères, donc une suite de plusieurs entiers
* * 20140912 1 20140912_Locuteur_1 1052.089 1054.996 <o,f0,male> il suffit de les mettre bout à bout en mémoire
* * 20140912 1 20140912_Locuteur_1 1054.996 1058.602 <o,f0,male> eh ben et que des entiers, on peut les coder par des zéros et des uns

deb_slide * 20140912 1 20140912_Locuteur_1 1058.602 1065.360 <o,f0,male> pas de problème : une chaîne de caractères, ça se code en mémoire.
* gran_2 20140912 1 20140912_Locuteur_1 1065.360 1068.085 <o,f0,male> dernier type
* * 20140912 1 20140912_Locuteur_1 1068.085 1070.622 <o,f0,male> c'est les booléens. alors un booléen, c'est vrai ou faux
* * 20140912 1 20140912_Locuteur_1 1070.622 1074.250 <o,f0,male> zéro ou un
* * 20140912 1 20140912_Locuteur_1 1074.250 1076.074 <o,f0,male> c'est un type qui est important,
* * 20140912 1 20140912_Locuteur_1 1076.074 1079.358 <o,f0,male> parce que ça va être le résultat de toutes les comparaisons qu'on va avoir à faire
* * 20140912 1 20140912_Locuteur_1 1079.358 1082.453 <o,f0,male> on va avoir à faire plein de comparaisons
* * 20140912 1 20140912_Locuteur_1 1082.453 1083.047 <o,f0,male> donc
* * 20140912 1 20140912_Locuteur_1 1083.047 1086.610 <o,f0,male> le type booléen, ce sont les valeurs vrai et faux, ou true ou false

deb_slide * 20140912 1 20140912_Locuteur_1 1086.610 1087.962 <o,f0,male> et finalement
* * 20140912 1 20140912_Locuteur_1 1087.962 1090.090 <o,f0,male> moralité :
* * 20140912 1 20140912_Locuteur_1 1090.090 1094.740 <o,f0,male> on a mis tout ce temps pour arriver au type de base de l'informatique qui est le booléen.
* * 20140912 1 20140912_Locuteur_1 1094.740 1097.713 <o,f0,male> celui-là, il se représente
* * 20140912 1 20140912_Locuteur_1 1097.713 1099.148 <o,f0,male> naturellement
* * 20140912 1 20140912_Locuteur_1 1099.148 1100.747 <o,f0,male> par des zéros et des uns
* * 20140912 1 20140912_Locuteur_1 1100.747 1104.969 <o,f0,male> zéro quand c'est faux, un quand c'est vrai.
* * 20140912 1 20140912_Locuteur_1 1104.969 1108.101 <o,f0,male> donc on peut le considérer comme le type de base unique de l'informatique
* * 20140912 1 20140912_Locuteur_1 1108.101 1110.770 <o,f0,male> même si évidemment,

deb_slide * 20140912 1 20140912_Locuteur_1 1110.770 1114.170 <o,f0,male> on en a () on a besoin d'un peu plus () d'aller un peu plus loin.
* gran_1 20140912 1 20140912_Locuteur_1 1114.170 1116.193 <o,f0,male> bon, bref
* * 20140912 1 20140912_Locuteur_1 1116.193 1118.750 <o,f0,male> pourquoi on a porté autant d'attention
* * 20140912 1 20140912_Locuteur_1 1118.750 1121.220 <o,f0,male> à () aux types
* * 20140912 1 20140912_Locuteur_1 1121.220 1123.517 <o,f0,male> alors que tout peut se coder par des bits ?
* * 20140912 1 20140912_Locuteur_1 1123.517 1127.332 <o,f0,male> alors là, je vais apporter un certain nombre de réponses
* * 20140912 1 20140912_Locuteur_1 1127.332 1129.588 <o,f0,male> toutes bêtes : ben parce que
* * 20140912 1 20140912_Locuteur_1 1129.588 1133.800 <o,f0,male> c'est plus pratique d'écrire la chaîne de caractères bonjour que d'écrire
* * 20140912 1 20140912_Locuteur_1 1133.800 1138.500 <o,f0,male> euh zéro un zéro zéro zéro un zéro zéro un zéro enfin un un et cetera.
* * 20140912 1 20140912_Locuteur_1 1138.500 1142.058 <o,f0,male> croyez-moi sur parole : ça, ça veut dire bonjour.
* * 20140912 1 20140912_Locuteur_1 1142.058 1142.612 <o,f0,male> c'est
* * 20140912 1 20140912_Locuteur_1 1142.612 1145.001 <o,f0,male> c'est la manière de coder bonjour en mémoire
* * 20140912 1 20140912_Locuteur_1 1145.001 1147.663 <o,f0,male> avec des interrupteurs.
* * 20140912 1 20140912_Locuteur_1 1147.663 1149.447 <o,f0,male> mais évidemment,
* * 20140912 1 20140912_Locuteur_1 1149.447 1151.958 <o,f0,male> vous avez plutôt envie d'avoir ça
* * 20140912 1 20140912_Locuteur_1 1151.958 1157.011 <o,f0,male> donc on a *apporté beaucoup d'attention aux types, parce que
* * 20140912 1 20140912_Locuteur_1 1157.011 1162.395 <o,f0,male> on veut s'*abstraire du codage de ces noms () de ces de ces choses-là.
* * 20140912 1 20140912_Locuteur_1 1162.395 1172.700 <o,f0,male> on se moque de comment javascript va coder ces ces caractères ou ces chaînes de caractères ; on veut juste savoir qu'il existe un type chaîne de caractères.
* * 20140912 1 20140912_Locuteur_1 1172.700 1178.748 <o,f0,male> pourquoi le langage de programmation a besoin de savoir ce qu'il a en mémoire ? ben tout simplement parce que lui, il se préoccupe de
* * 20140912 1 20140912_Locuteur_1 1178.748 1181.326 <o,f0,male> gérer la mémoire, justement.
* * 20140912 1 20140912_Locuteur_1 1181.326 1187.570 <o,f0,male> donc savoir ce qu'il a () ce qu'il stocke dans une variable, ça lui permet de réserver la bonne quantité de mémoire
* * 20140912 1 20140912_Locuteur_1 1187.570 1190.958 <o,f0,male> pour stocker euh s() le contenu de la variable.
* * 20140912 1 20140912_Locuteur_1 1190.958 1193.706 <o,f0,male> donc c'est important pour lui d'avoir cette notion de type.
* * 20140912 1 20140912_Locuteur_1 1193.706 1196.537 <o,f0,male> et c'est pour ça que dans
* * 20140912 1 20140912_Locuteur_1 1196.537 1198.623 <o,f0,male> tous les langages, j'essaye de pas me tromper,
* * 20140912 1 20140912_Locuteur_1 1198.623 1202.270 <o,f0,male> dans tous les langages il y a une notion de type
* * 20140912 1 20140912_Locuteur_1 1202.270 1208.560 <o,f0,male> y compris en javascript : il y a une notion de type en javascript.
* * 20140912 1 20140912_Locuteur_1 1208.560 1212.280 <o,f0,male> et puis euh dernier argument : c'est parce que euh
* * 20140912 1 20140912_Locuteur_1 1212.280 1214.328 <o,f0,male> les calculs qu'on peut faire
* * 20140912 1 20140912_Locuteur_1 1214.328 1217.277 <o,f0,male> sur quel() sur une valeur, sur euh
* * 20140912 1 20140912_Locuteur_1 1217.277 1219.567 <o,f0,male> sur quelque chose, dépendent d'un type à l'autre.
* * 20140912 1 20140912_Locuteur_1 1219.567 1222.391 <o,f0,male> on pourra pas faire les mêmes opérations
* * 20140912 1 20140912_Locuteur_1 1222.391 1224.411 <o,f0,male> sur des entiers
* * 20140912 1 20140912_Locuteur_1 1224.411 1225.890 <o,f0,male> et sur des chaînes de caractères.
* * 20140912 1 20140912_Locuteur_1 1225.890 1230.057 <o,f0,male> ça vous s() s() ça vous semblera ça vous semble assez évident.

deb_slide * 20140912 1 20140912_Locuteur_1 1230.057 1237.138 <o,f0,male> mais c'est important, justement d'avoir cette notion de type parce que c'est ce qui va nous différencier les opérations.
* gran_2 20140912 1 20140912_Locuteur_1 1237.138 1238.050 <o,f0,male> voilà
* * 20140912 1 20140912_Locuteur_1 1238.050 1239.886 <o,f0,male> eh ben on en vient justement
* * 20140912 1 20140912_Locuteur_1 1239.886 1242.616 <o,f0,male> aux opérations qu'on va pouvoir écrire,
* * 20140912 1 20140912_Locuteur_1 1242.616 1245.337 <o,f0,male> qu'on appelle une expression.
* * 20140912 1 20140912_Locuteur_1 1245.337 1248.083 <o,f0,male> donc l'expression, ça va être
* * 20140912 1 20140912_Locuteur_1 1248.083 1252.789 <o,f0,male> obtenu en combinant des opérations de base sur les types
* * 20140912 1 20140912_Locuteur_1 1252.789 1256.193 <o,f0,male> et il y aura des syntaxes

deb_slide * 20140912 1 20140912_Locuteur_1 1256.193 1261.456 <o,f0,male> à utiliser.
* * 20140912 1 20140912_Locuteur_1 1261.456 1262.571 <o,f0,male> voilà
* * 20140912 1 20140912_Locuteur_1 1262.571 1265.396 <o,f0,male> eh ben je vais faire comme les types.
* * 20140912 1 20140912_Locuteur_1 1265.396 1268.359 <o,f0,male> je vous ai dit : les opérations qu'on peut faire dépendent des types.
* * 20140912 1 20140912_Locuteur_1 1268.359 1272.944 <o,f0,male> eh ben on va reprendre les types un par un, et puis on va voir quelles opérations on peut faire sur chacun de ces types.
* gran_1 20140912 1 20140912_Locuteur_1 1272.944 1276.577 <o,f0,male> sur les types entiers
* * 20140912 1 20140912_Locuteur_1 1276.577 1279.057 <o,f0,male> bah dé() les entiers, ce sont des nombres.
* * 20140912 1 20140912_Locuteur_1 1279.057 1282.645 <o,f0,male> on peut manipuler des nombres comme on le fe() on pourrait le faire en mathématiques
* * 20140912 1 20140912_Locuteur_1 1282.645 1284.588 <o,f0,male> et des entiers, ça s'additionne,
* * 20140912 1 20140912_Locuteur_1 1284.588 1286.343 <o,f0,male> ça se soustrait,
* * 20140912 1 20140912_Locuteur_1 1286.343 1288.076 <o,f0,male> ça se multiplie,
* * 20140912 1 20140912_Locuteur_1 1288.076 1292.986 <o,f0,male> ça se divise, mais quand on est en en() on parle d'entiers, on a la division entière
* * 20140912 1 20140912_Locuteur_1 1292.986 1295.910 <o,f0,male> qu'on notera div
* * 20140912 1 20140912_Locuteur_1 1295.910 1300.434 <o,f0,male> et puis la division entière, il y a il y a aussi le reste de la division entière, qu'on notera mod
* * 20140912 1 20140912_Locuteur_1 1300.434 1305.157 <o,f0,male> modulo
* * 20140912 1 20140912_Locuteur_1 1305.157 1308.127 <o,f0,male> donc par exemple, ça c'est une opération valide :
* * 20140912 1 20140912_Locuteur_1 1308.127 1312.440 <o,f0,male> cinq plus trois qui vaut huit.
* * 20140912 1 20140912_Locuteur_1 1312.440 1317.807 <o,f0,male> donc on aura le droit d'écrire des expressions comme ça : dix-sept div cinq
* * 20140912 1 20140912_Locuteur_1 1317.807 1321.079 <o,f0,male> ça vaut trois, puisque dix-sept c'est trois fois cinq plus deux.
* * 20140912 1 20140912_Locuteur_1 1321.079 1323.713 <o,f0,male> donc dix-sept mod cinq, ça vaut deux.
* * 20140912 1 20140912_Locuteur_1 1323.713 1328.486 <o,f0,male> il y a ces opérations de calcul, et puis il faut pas oublier toutes les opérations de comparaison
* * 20140912 1 20140912_Locuteur_1 1328.486 1330.241 <o,f0,male> entre deux nombres.
* * 20140912 1 20140912_Locuteur_1 1330.241 1332.786 <o,f0,male> donc est-ce que euh
* * 20140912 1 20140912_Locuteur_1 1332.786 1336.070 <o,f0,male> douze est égal à quatre fois trois ? ça va valoir vrai.
* * 20140912 1 20140912_Locuteur_1 1336.070 1341.553 <o,f0,male> est-ce que douze est plus petit que sept ? ça va valoir faux. donc le résultat de ces comparaisons, ça va être un booléen.
* * 20140912 1 20140912_Locuteur_1 1341.553 1343.849 <o,f0,male> donc on aura des opérations
* * 20140912 1 20140912_Locuteur_1 1343.849 1345.131 <o,f0,male> additions
* * 20140912 1 20140912_Locuteur_1 1345.131 1347.730 <o,f0,male> qui vont prendre deux nombres et qui vont donner un nombre,
* * 20140912 1 20140912_Locuteur_1 1347.730 1351.560 <o,f0,male> et on aura des opérations de comparaisons qui vont prendre deux nombres et qui vont donner
* * 20140912 1 20140912_Locuteur_1 1351.560 1354.864 <o,f0,male> un booléen.
* * 20140912 1 20140912_Locuteur_1 1354.864 1361.070 <o,f0,male> donc ce sont les deux types d'opérations de base qu'on va avoir sur les nombres.

deb_slide gran_1 20140912 1 20140912_Locuteur_1 1361.070 1363.524 <o,f0,male> sur les réels, en fait ça change pas
* * 20140912 1 20140912_Locuteur_1 1363.524 1364.647 <o,f0,male> c'est la même chose.
* * 20140912 1 20140912_Locuteur_1 1364.647 1366.172 <o,f0,male> on aura
* * 20140912 1 20140912_Locuteur_1 1366.172 1368.156 <o,f0,male> les opérations
* * 20140912 1 20140912_Locuteur_1 1368.156 1370.239 <o,f0,male> entre deux réels qui donnent un réel :
* * 20140912 1 20140912_Locuteur_1 1370.239 1378.060 <o,f0,male> addition, soustraction, multiplication, division réelles
* * 20140912 1 20140912_Locuteur_1 1378.060 1386.420 <o,f0,male> et on aura les comparaisons.
* * 20140912 1 20140912_Locuteur_1 1386.420 1387.739 <o,f0,male> alors attention :
* * 20140912 1 20140912_Locuteur_1 1387.739 1389.456 <o,f0,male> j'ai parlé de réels, là
* * 20140912 1 20140912_Locuteur_1 1389.456 1390.738 <o,f0,male> vous m'avez pas repris.
* * 20140912 1 20140912_Locuteur_1 1390.738 1392.771 <o,f0,male> ce sont pas des réels ;
* * 20140912 1 20140912_Locuteur_1 1392.771 1396.522 <o,f0,male> ce sont des flottants
* * 20140912 1 20140912_Locuteur_1 1396.522 1401.861 <o,f0,male> eh ben mine de rien, ça joue p() s() c'est important de savoir que c'est () ce sont des flottants

deb_slide * 20140912 1 20140912_Locuteur_1 1401.861 1406.065 <o,f0,male> est-ce que j'ai l'exemple ? j'espère que je vous ai mis l'exemple ; voilà
* * 20140912 1 20140912_Locuteur_1 1406.065 1411.140 <o,f0,male> ce sont des flottants, la preuve :
* * 20140912 1 20140912_Locuteur_1 1411.140 1414.483 <o,f0,male> on peut pas tout représenter avec des flottants
* * 20140912 1 20140912_Locuteur_1 1414.483 1417.155 <o,f0,male> ça on l'a on l'a déjà vu
* * 20140912 1 20140912_Locuteur_1 1417.155 1417.610 <o,f0,male> et
* * 20140912 1 20140912_Locuteur_1 1417.610 1419.325 <o,f0,male> et notamment, il y a des nombres
* * 20140912 1 20140912_Locuteur_1 1419.325 1423.620 <o,f0,male> qu'on ne peut pas représenter.
* * 20140912 1 20140912_Locuteur_1 1423.620 1425.125 <o,f0,male> et si on écrit
* * 20140912 1 20140912_Locuteur_1 1425.125 1428.035 <o,f0,male> ça en javascript
* * 20140912 1 20140912_Locuteur_1 1428.035 1435.020 <o,f0,male> un point deux cent cinquante-sept multiplié par quarante-trois fois mille divisé par quarante-trois
* * 20140912 1 20140912_Locuteur_1 1435.020 1439.920 <o,f0,male> est-ce que vous êtes d'accord avec moi ? ça vaut combien, ça ?
* * 20140912 1 20140912_Locuteur_1 1439.920 1442.607 <o,f0,male> en maths
* * 20140912 1 20140912_Locuteur_1 1442.607 1444.206 <o,f0,male> mille deux cent cinquante-sept
* * 20140912 1 20140912_Locuteur_1 1444.206 1446.807 <o,f0,male> je multiplie par quarante-trois, je divise par quarante-trois
* * 20140912 1 20140912_Locuteur_1 1446.807 1447.964 <o,f0,male> ça s'élimine
* * 20140912 1 20140912_Locuteur_1 1447.964 1449.128 <o,f0,male> je multiplie par mille :
* * 20140912 1 20140912_Locuteur_1 1449.128 1451.749 <o,f0,male> ça vaut mille deux cent cinquante-sept.
* * 20140912 1 20140912_Locuteur_1 1451.749 1453.193 <o,f0,male> bon
* * 20140912 1 20140912_Locuteur_1 1453.193 1456.429 <o,f0,male> je regarde si c'est égal à
* * 20140912 1 20140912_Locuteur_1 1456.429 1461.522 <o,f0,male> un point deux cent cinquante-sept divisé par quarante-trois multiplié par quarante-trois fois mille
* * 20140912 1 20140912_Locuteur_1 1461.522 1464.992 <o,f0,male> ça vaut combien ?
* * 20140912 1 20140912_Locuteur_1 1464.992 1469.725 <o,f0,male> mille deux cent cinquante-sept ?
* * 20140912 1 20140912_Locuteur_1 1469.725 1473.871 <o,f0,male> vous êtes d'accord, en maths ?
* * 20140912 1 20140912_Locuteur_1 1473.871 1477.640 <o,f0,male> mille deux cent cinquante-sept
* * 20140912 1 20140912_Locuteur_1 1477.640 1480.486 <o,f0,male> eh ben le résultat du de l'é() du calcul,
* * 20140912 1 20140912_Locuteur_1 1480.486 1484.270 <o,f0,male> il dit : les deux nombres sont différents.
* * 20140912 1 20140912_Locuteur_1 1484.270 1487.144 <o,f0,male> tout simplement parce que dans le
* * 20140912 1 20140912_Locuteur_1 1487.144 1490.817 <o,f0,male> dans la suite d'opérations qui vont () qu'on fait,
* * 20140912 1 20140912_Locuteur_1 1490.817 1493.767 <o,f0,male> il y a un nombre qu'il va se mettre à pas être capable de représenter ;
* * 20140912 1 20140912_Locuteur_1 1493.767 1495.485 <o,f0,male> exactement, c'est celui-là.
* * 20140912 1 20140912_Locuteur_1 1495.485 1496.807 <o,f0,male> celui-là
* * 20140912 1 20140912_Locuteur_1 1496.807 1499.749 <o,f0,male> il est pas capable de le représenter en mémoire.
* * 20140912 1 20140912_Locuteur_1 1499.749 1507.661 <o,f0,male> comme il est pas capable de le représenter en mémoire, il représente un nombre arrondi très proche.
* * 20140912 1 20140912_Locuteur_1 1507.661 1508.660 <o,f0,male> mais
* * 20140912 1 20140912_Locuteur_1 1508.660 1513.372 <o,f0,male> en f() en l'ayant arrondi, on a perdu quelque chose.
* * 20140912 1 20140912_Locuteur_1 1513.372 1517.307 <o,f0,male> donc une fois qu'on remultiplie par quarante-trois et par mille, on a perdu quelque chose.
* * 20140912 1 20140912_Locuteur_1 1517.307 1519.973 <o,f0,male> et ce qu'on a perdu, ben ça ()
* * 20140912 1 20140912_Locuteur_1 1519.973 1523.341 <o,f0,male> ce qu'on a perdu, ça nous () ça fait en sorte que le [pi]
* * 20140912 1 20140912_Locuteur_1 1523.341 1525.538 <o,f0,male> où on a des nombres qu'on aurait dû
* * 20140912 1 20140912_Locuteur_1 1525.538 1530.230 <o,f0,male> avoir euh égaux ben ils sont plus égaux.
* * 20140912 1 20140912_Locuteur_1 1530.230 1532.265 <o,f0,male> donc on a perdu des choses dans la représentation.
* * 20140912 1 20140912_Locuteur_1 1532.265 1534.658 <o,f0,male> ça, c'est très important de le savoir
* * 20140912 1 20140912_Locuteur_1 1534.658 1538.471 <o,f0,male> c'est pas anodin de () c'est pas anodin ces erreurs-là hein.
* * 20140912 1 20140912_Locuteur_1 1538.471 1542.320 <o,f0,male> vous les ferez, certainement, parce que ce sont ce sont des petits bugs
* * 20140912 1 20140912_Locuteur_1 1542.320 1544.875 <o,f0,male> mais euh il y a des fusées qui se cassent la figure à cause de ça
* * 20140912 1 20140912_Locuteur_1 1544.875 1548.194 <o,f0,male> hein donc euh
* * 20140912 1 20140912_Locuteur_1 1548.194 1550.622 <o,f0,male> sur ces erreurs d'arrondis.

deb_slide * 20140912 1 20140912_Locuteur_1 1550.622 1556.244 <o,f0,male> donc c'est vraiment pas anodin : attention à la représentation des nombres réels.
* gran_1 20140912 1 20140912_Locuteur_1 1556.244 1560.502 <o,f0,male> alors quelles opérations on peut faire sur les caractères, maintenant ?
* * 20140912 1 20140912_Locuteur_1 1560.502 1564.962 <o,f0,male> alors des caractères, ça se compare
* * 20140912 1 20140912_Locuteur_1 1564.962 1568.240 <o,f0,male> à votre avis, comment on va faire pour comparer des caractères ?
* * 20140912 1 20140912_Locuteur_1 1568.240 1569.989 <o,f0,male> est-ce que
* * 20140912 1 20140912_Locuteur_1 1569.989 1577.645 <o,f0,male> a minuscule est plus petit que b minuscule ? la réponse est
* * 20140912 1 20140912_Locuteur_1 1577.645 1578.310 <o,f0,male> vrai.
* * 20140912 1 20140912_Locuteur_1 1578.310 1582.670 <o,f0,male> a minuscule est plus petit que b minuscule
* * 20140912 1 20140912_Locuteur_1 1582.670 1584.430 <o,f0,male> euh
* * 20140912 1 20140912_Locuteur_1 1584.430 1585.903 <o,f0,male> a majuscule
* * 20140912 1 20140912_Locuteur_1 1585.903 1590.592 <o,f0,male> est-ce que a majuscule est plus petit que b() a minuscule ?
* * 20140912 1 20140912_Locuteur_1 1590.592 1592.411 <o,f0,male> ah là, c'est plus difficile.
* * 20140912 1 20140912_Locuteur_1 1592.411 1595.292 <o,f0,male> en français, on se dirait : non c'est pa() c'est pareil
* * 20140912 1 20140912_Locuteur_1 1595.292 1599.185 <o,f0,male> on s'en fout, de majuscule et minuscule. bah en informatique, on s'en moque pas
* * 20140912 1 20140912_Locuteur_1 1599.185 1601.272 <o,f0,male> parce que ce sont deux caractères différents ;
* * 20140912 1 20140912_Locuteur_1 1601.272 1606.109 <o,f0,male> ce sont deux caractères différents parce qu'ils ont un code ascii différent.
* * 20140912 1 20140912_Locuteur_1 1606.109 1609.149 <o,f0,male> la comparaison de caractères, en informatique,
* * 20140912 1 20140912_Locuteur_1 1609.149 1615.748 <o,f0,male> revient à comparer les codes ascii de ces caractères. on a deux nombres : c'est facile de comparer des nombres.
* * 20140912 1 20140912_Locuteur_1 1615.748 1628.867 <o,f0,male> donc le résultat de : est-ce que a g() a majuscule est plus petit que a minuscule ? la réponse est vrai car le code ascii de a, c'est soixante-cinq ; celui de a minuscule, c'est quatre-vingt-dix-sept.
* * 20140912 1 20140912_Locuteur_1 1628.867 1629.831 <o,f0,male> voilà.
* * 20140912 1 20140912_Locuteur_1 1629.831 1631.872 <o,f0,male> si on cherche à comparer
* * 20140912 1 20140912_Locuteur_1 1631.872 1637.550 <o,f0,male> e sans accent et e avec accent, ben le résultat est faux.
* * 20140912 1 20140912_Locuteur_1 1637.550 1638.716 <o,f0,male> car le ()
* * 20140912 1 20140912_Locuteur_1 1638.716 1639.953 <o,f0,male> ces deux lettres
* * 20140912 1 20140912_Locuteur_1 1639.953 1642.607 <o,f0,male> ces deux caractères ont des codes
* * 20140912 1 20140912_Locuteur_1 1642.607 1646.800 <o,f0,male> de représentation différents.
* * 20140912 1 20140912_Locuteur_1 1646.800 1651.221 <o,f0,male> ok ?
* * 20140912 1 20140912_Locuteur_1 1651.221 1654.870 <o,f0,male> donc euh
* * 20140912 1 20140912_Locuteur_1 1654.870 1660.134 <o,f0,male> ça, ce sont les comparaisons et puis il y aura un certain nombre de fonctions, de manipulations des caractères que vous avez déjà vues.
* * 20140912 1 20140912_Locuteur_1 1660.134 1662.264 <o,f0,male> caractères vers ascii, ascii vers caractères.
* * 20140912 1 20140912_Locuteur_1 1662.264 1665.299 <o,f0,male> on peut pas faire grand-chose avec un caractère
* * 20140912 1 20140912_Locuteur_1 1665.299 1669.727 <o,f0,male> mais c'est important de savoir comment on les compare.

deb_slide gran_1 20140912 1 20140912_Locuteur_1 1669.727 1672.700 <o,f0,male> allez, quatri() hop, je suis allé trop vite.
* * 20140912 1 20140912_Locuteur_1 1672.700 1679.496 <o,f0,male> quatrième chose : les chaînes de caractères.
* * 20140912 1 20140912_Locuteur_1 1679.496 1680.780 <o,f0,male> bon
* * 20140912 1 20140912_Locuteur_1 1680.780 1682.901 <o,f0,male> là, il y a une opération qui est importante
* * 20140912 1 20140912_Locuteur_1 1682.901 1686.986 <o,f0,male> dans les chaînes de caractères : l'opération, elle s'appelle la concaténation.
* * 20140912 1 20140912_Locuteur_1 1686.986 1689.238 <o,f0,male> elle est importante et pourtant elle est simple.
* * 20140912 1 20140912_Locuteur_1 1689.238 1697.718 <o,f0,male> concaténer deux chaînes de caractères, c'est juste construire une chaîne de caractères composée des deux chaînes mises bout à bout.
* * 20140912 1 20140912_Locuteur_1 1697.718 1698.700 <o,f0,male> donc
* * 20140912 1 20140912_Locuteur_1 1698.700 1702.735 <o,f0,male> la concaténation de la chaîne de caractères "bon"
* * 20140912 1 20140912_Locuteur_1 1702.735 1704.745 <o,f0,male> et de la chaîne de caractères "jour"
* * 20140912 1 20140912_Locuteur_1 1704.745 1712.293 <o,f0,male> qu'on notera bon plus jour dans le langage algorithmique et dans le langage javascript, et dans plein d'autres langages,
* * 20140912 1 20140912_Locuteur_1 1712.293 1714.540 <o,f0,male> le résultat, c'est une chaîne de caractères
* * 20140912 1 20140912_Locuteur_1 1714.540 1718.315 <o,f0,male> composée des caractères b, o, n, j, o, u, r.
* * 20140912 1 20140912_Locuteur_1 1718.315 1722.100 <o,f0,male> bonjour
* * 20140912 1 20140912_Locuteur_1 1722.100 1727.900 <o,f0,male> donc c'est l'opération la plus importante.
* * 20140912 1 20140912_Locuteur_1 1727.900 1730.565 <o,f0,male> il y a d'autres fonctions qui permettent de manipuler
* * 20140912 1 20140912_Locuteur_1 1730.565 1732.762 <o,f0,male> des chaînes de caractères.
* * 20140912 1 20140912_Locuteur_1 1732.762 1738.654 <o,f0,male> ce qu'on a souvent envie de faire, c'est d'avoir la longueur de la chaîne de caractères.
* * 20140912 1 20140912_Locuteur_1 1738.654 1739.677 <o,f0,male> donc il y a une o()
* * 20140912 1 20140912_Locuteur_1 1739.677 1744.165 <o,f0,male> une opération qui prend en paramètres une chaîne et qui renvoie
* * 20140912 1 20140912_Locuteur_1 1744.165 1745.148 <o,f0,male> un entier
* * 20140912 1 20140912_Locuteur_1 1745.148 1748.402 <o,f0,male> qui s'appelle longueur ; longueur d'une chaîne de caractères,
* * 20140912 1 20140912_Locuteur_1 1748.402 1755.602 <o,f0,male> ça renvoie à la longueur de la chaîne de caractères. donc pour longueur de bonjour, il y a sept lettres dans bonjour : ça vaut sept.
* * 20140912 1 20140912_Locuteur_1 1755.602 1758.138 <o,f0,male> évidemment, on compte tous les caractères, même les espaces hein ;
* * 20140912 1 20140912_Locuteur_1 1758.138 1763.381 <o,f0,male> même les virgules [pi] la chaîne de caractères ne fait pas la distinction entre le contenu de la k()
* * 20140912 1 20140912_Locuteur_1 1763.381 1767.250 <o,f0,male> de la chaîne [pi] on se on se moque de ce que veut dire la chaîne.
* * 20140912 1 20140912_Locuteur_1 1767.250 1771.850 <o,f0,male> avec une chaîne de caractères, on a aussi envie de travailler sur les caractères,
* * 20140912 1 20140912_Locuteur_1 1771.850 1775.168 <o,f0,male> notamment extraire un caractère d'une chaîne de caractères.
* * 20140912 1 20140912_Locuteur_1 1775.168 1777.687 <o,f0,male> ben ça, il y a une notation pour ça
* * 20140912 1 20140912_Locuteur_1 1777.687 1781.038 <o,f0,male> ça s'écrit c h entre crochets.
* * 20140912 1 20140912_Locuteur_1 1781.038 1785.157 <o,f0,male> donc si euh j'ai une variable qui contient
* * 20140912 1 20140912_Locuteur_1 1785.157 1787.783 <o,f0,male> une chaîne de caractères,
* * 20140912 1 20140912_Locuteur_1 1787.783 1790.590 <o,f0,male> alors si j'écris c h entre crochets
* * 20140912 1 20140912_Locuteur_1 1790.590 1793.231 <o,f0,male> bah ici là, j'ai bonjour
* * 20140912 1 20140912_Locuteur_1 1793.231 1797.603 <o,f0,male> c h contient () a pour valeur la chaîne de caractères bonjour
* * 20140912 1 20140912_Locuteur_1 1797.603 1800.657 <o,f0,male> c h entre crochets trois
* * 20140912 1 20140912_Locuteur_1 1800.657 1804.402 <o,f0,male> a pour valeur la
* * 20140912 1 20140912_Locuteur_1 1804.402 1807.310 <o,f0,male> la lettre à l'indice trois dans bonjour.
* * 20140912 1 20140912_Locuteur_1 1807.310 1810.180 <o,f0,male> *alors j'ai bien dit lettre à l'indice trois et pas troisième lettre
* * 20140912 1 20140912_Locuteur_1 1810.180 1811.820 <o,f0,male> tout simplement parce que
* * 20140912 1 20140912_Locuteur_1 1811.820 1814.132 <o,f0,male> le premier indice, c'est l'indice zéro.
* * 20140912 1 20140912_Locuteur_1 1814.132 1817.459 <o,f0,male> donc la lettre à l'indice trois, c'est la quatrième lettre.
* * 20140912 1 20140912_Locuteur_1 1817.459 1819.301 <o,f0,male> [pi] retenir ça
* * 20140912 1 20140912_Locuteur_1 1819.301 1821.534 <o,f0,male> première lettre étant à l'indice zéro,
* * 20140912 1 20140912_Locuteur_1 1821.534 1824.139 <o,f0,male> la lettre à l'indice trois, c'est la quatrième lettre.
* * 20140912 1 20140912_Locuteur_1 1824.139 1825.142 <o,f0,male> donc c j ;
* * 20140912 1 20140912_Locuteur_1 1825.142 1831.717 <o,f0,male> ça, ça permet d'extraire les caractères d'une chaîne de caractères.
* * 20140912 1 20140912_Locuteur_1 1831.717 1833.092 <o,f0,male> et enfin
* * 20140912 1 20140912_Locuteur_1 1833.092 1836.101 <o,f0,male> il y a aussi des comparaisons entre deux chaînes de caractères,
* * 20140912 1 20140912_Locuteur_1 1836.101 1841.740 <o,f0,male> des comparaisons automatiques entre deux chaînes de caractères.
* * 20140912 1 20140912_Locuteur_1 1841.740 1843.525 <o,f0,male> et là, vous avez un
* * 20140912 1 20140912_Locuteur_1 1843.525 1848.490 <o,f0,male> une idée de comment on compare les chaînes de caractères ?
* * 20140912 1 20140912_Locuteur_1 1848.490 1850.787 <o,f0,male> donc qui a la réponse hein, c'est euh
* * 20140912 1 20140912_Locuteur_1 1850.787 1856.180 <o,f0,male> l'ordre du dictionnaire ou l'ordre lexicographique.
* * 20140912 1 20140912_Locuteur_1 1856.180 1862.268 <o,f0,male> autrement dit, je () si je veux comparer deux chaînes de caractères, je vous pose la question : et si je les mettais dans un dictionnaire, où elles seraient ?
* * 20140912 1 20140912_Locuteur_1 1862.268 1864.463 <o,f0,male> est-ce que l'une serait avant l'autre ?
* * 20140912 1 20140912_Locuteur_1 1864.463 1870.447 <o,f0,male> alors c'est pas tout à fait un dictionnaire ordinaire, c'est un dictionnaire qui tient compte de l'ordre des caractères eux-mêmes.
* * 20140912 1 20140912_Locuteur_1 1870.447 1878.887 <o,f0,male> donc les l() les chaînes de caractères qui commencent par des a majuscules seront avant celles qui commencent par des a minuscules,
* * 20140912 1 20140912_Locuteur_1 1878.887 1884.151 <o,f0,male> et les chaînes de caractères qui commencent par des z majuscules seront avant celles qui commencent par des a minuscules.
* * 20140912 1 20140912_Locuteur_1 1884.151 1887.226 <o,f0,male> *voilà donc c'est un c'est un dictionnaire un peu bizarre
* * 20140912 1 20140912_Locuteur_1 1887.226 1889.686 <o,f0,male> qui tient compte de l'ordre des caractères
* * 20140912 1 20140912_Locuteur_1 1889.686 1892.452 <o,f0,male> donc l'ordre as() l'ordre ascii
* * 20140912 1 20140912_Locuteur_1 1892.452 1893.149 <o,f0,male> mais
* * 20140912 1 20140912_Locuteur_1 1893.149 1898.602 <o,f0,male> qui classe selon un ordre lexicographique, donc euh
* * 20140912 1 20140912_Locuteur_1 1898.602 1902.371 <o,f0,male> l'ordre du dictionnaire. l'ordre *lexicographique, c'est : je compare les deux premières lettres ;
* * 20140912 1 20140912_Locuteur_1 1902.371 1906.946 <o,f0,male> si elles sont différentes, c'est bon je trie mes mes deux chaînes. si n() si elles sont égales,
* * 20140912 1 20140912_Locuteur_1 1906.946 1908.728 <o,f0,male> je suis obligé de regarder la lettre suivante
* * 20140912 1 20140912_Locuteur_1 1908.728 1916.635 <o,f0,male> et cetera, et cetera.

deb_slide * 20140912 1 20140912_Locuteur_1 1916.635 1918.890 <o,f0,male> voilà
* gran_1 20140912 1 20140912_Locuteur_1 1918.890 1920.200 <o,f0,male> et enfin
* * 20140912 1 20140912_Locuteur_1 1920.200 1922.564 <o,f0,male> le dernier type qu'on a vu, c'était les booléens.
* * 20140912 1 20140912_Locuteur_1 1922.564 1925.228 <o,f0,male> ben les opérations de base sur les booléens,
* * 20140912 1 20140912_Locuteur_1 1925.228 1929.429 <o,f0,male> vous les connaissez probablement déjà : c'est les opérations logiques.
* * 20140912 1 20140912_Locuteur_1 1929.429 1934.013 <o,f0,male> le et logique, le ou logique, le non logique

deb_slide * 20140912 1 20140912_Locuteur_1 1934.013 1935.834 <o,f0,male> et puis euh
* * 20140912 1 20140912_Locuteur_1 1935.834 1938.190 <o,f0,male> on on va faire ça très rapidement
* * 20140912 1 20140912_Locuteur_1 1938.190 1945.801 <o,f0,male> mais les opérations de base sur les booléens, en général on les représente par des tables de vérité, qui sont ces tableaux, là
* * 20140912 1 20140912_Locuteur_1 1945.801 1950.287 <o,f0,male> où on on on met la va() toutes les valeurs possibles pour euh
* * 20140912 1 20140912_Locuteur_1 1950.287 1951.826 <o,f0,male> l'entrée
* * 20140912 1 20140912_Locuteur_1 1951.826 1956.210 <o,f0,male> et là, on met toutes les valeurs possibles pour la sortie de non a ;
* * 20140912 1 20140912_Locuteur_1 1956.210 1958.198 <o,f0,male> pour a et pour la sortie de non a.
* * 20140912 1 20140912_Locuteur_1 1958.198 1962.611 <o,f0,male> on peut le faire pour les booléens, parce que ça fait ça fait jamais des tableaux très très grands.
* * 20140912 1 20140912_Locuteur_1 1962.611 1964.313 <o,f0,male> comme il y a que deux valeurs,
* * 20140912 1 20140912_Locuteur_1 1964.313 1969.671 <o,f0,male> au pire il y a deux variables, donc il y aura quatre ca() quatre lignes au tableau, mais il y en aura jamais beaucoup plus.
* * 20140912 1 20140912_Locuteur_1 1969.671 1971.574 <o,f0,male> donc
* * 20140912 1 20140912_Locuteur_1 1971.574 1974.115 <o,f0,male> si a vaut vrai, que vaut non a ?

deb_slide * 20140912 1 20140912_Locuteur_1 1974.115 1974.894 <o,f0,male> faux
* * 20140912 1 20140912_Locuteur_1 1974.894 1977.610 <o,f0,male> que vaut euh faux non faux ?

deb_slide * 20140912 1 20140912_Locuteur_1 1977.610 1979.123 <o,f0,male> vrai

deb_slide * 20140912 1 20140912_Locuteur_1 1979.123 1982.569 <o,f0,male> on va le faire, hein euh
* * 20140912 1 20140912_Locuteur_1 1982.569 1986.189 <o,f0,male> a et b

deb_slide * 20140912 1 20140912_Locuteur_1 1986.189 1990.033 <o,f0,male> vrai

deb_slide * 20140912 1 20140912_Locuteur_1 1990.033 1991.345 <o,f0,male> faux

deb_slide * 20140912 1 20140912_Locuteur_1 1991.345 1994.471 <o,f0,male> pour le ou ?

deb_slide * 20140912 1 inter_segment_gap 1994.471 1996.960 <o,f0,> inter_segment_gap

deb_slide * 20140912 1 20140912_Locuteur_1 1996.960 1998.022 <o,f0,male> ok
* * 20140912 1 20140912_Locuteur_1 1998.022 2001.189 <o,f0,male> vous savez tout ça par coeur.
* * 20140912 1 20140912_Locuteur_1 2001.189 2001.940 <o,f0,male> donc
* * 20140912 1 20140912_Locuteur_1 2001.940 2006.249 <o,f0,male> il y a ces opérations euh de base, et puis vous savez très bien
* * 20140912 1 20140912_Locuteur_1 2006.249 2010.729 <o,f0,male> que ces opérations-là, elles vont se combiner donc euh quand vous parlerez de réseaux sociaux
* * 20140912 1 20140912_Locuteur_1 2010.729 2014.590 <o,f0,male> [pi] vous reviendrez là-dessus, sur ces opérations logiques
* * 20140912 1 20140912_Locuteur_1 2014.590 2016.482 <o,f0,male> et vous verrez la
* * 20140912 1 20140912_Locuteur_1 2016.482 2018.370 <o,f0,male> l'implication
* * 20140912 1 20140912_Locuteur_1 2018.370 2021.197 <o,f0,male> en opérations logiques, et des choses comme ça.

deb_slide * 20140912 1 20140912_Locuteur_1 2021.197 2026.487 <o,f0,male> ce sont des opérations qui ne se notent pas dans le langage, donc c'est pour ça que je me limite à ça.
* * 20140912 1 20140912_Locuteur_1 2026.487 2028.650 <o,f0,male> voilà
* gran_2 20140912 1 20140912_Locuteur_1 2028.650 2035.304 <o,f0,male> et on en vient aux é() on a vu les opérations de base, on en vient à une expression. qu'est-ce que c'est qu'une expression ?
* * 20140912 1 20140912_Locuteur_1 2035.304 2037.336 <o,f0,male> bah une expression, c'est simple :
* * 20140912 1 20140912_Locuteur_1 2037.336 2040.420 <o,f0,male> c'est soit une valeur
* * 20140912 1 20140912_Locuteur_1 2040.420 2041.956 <o,f0,male> un, dix,
* * 20140912 1 20140912_Locuteur_1 2041.956 2044.905 <o,f0,male> la valeur d'une variable,
* * 20140912 1 20140912_Locuteur_1 2044.905 2047.769 <o,f0,male> autre-chose, une chaîne de caractères
* * 20140912 1 20140912_Locuteur_1 2047.769 2050.803 <o,f0,male> donc c'est soit une valeur,
* * 20140912 1 20140912_Locuteur_1 2050.803 2053.700 <o,f0,male> soit de la forme
* * 20140912 1 20140912_Locuteur_1 2053.700 2056.422 <o,f0,male> entre parenthèses une expression
* * 20140912 1 20140912_Locuteur_1 2056.422 2057.609 <o,f0,male> une opération
* * 20140912 1 20140912_Locuteur_1 2057.609 2059.592 <o,f0,male> entre parenthèses une expression.
* * 20140912 1 20140912_Locuteur_1 2059.592 2065.576 <o,f0,male> ça, c'est pour les opérations qui sont binaires. et puis il y a tout t() ce qu'on peut écrire pour les opérations de type longueur, et des choses comme ça
* * 20140912 1 20140912_Locuteur_1 2065.576 2067.455 <o,f0,male> qui sont pas les opérations binaires.
* * 20140912 1 20140912_Locuteur_1 2067.455 2069.852 <o,f0,male> donc autrement dit, quand on a cette syntaxe-là
* * 20140912 1 20140912_Locuteur_1 2069.852 2071.939 <o,f0,male> et que expression, là,
* * 20140912 1 20140912_Locuteur_1 2071.939 2076.090 <o,f0,male> dans la parenthèse, ça peut aussi être une expression avec une opération,
* * 20140912 1 20140912_Locuteur_1 2076.090 2077.461 <o,f0,male> cette syntaxe-là
* * 20140912 1 20140912_Locuteur_1 2077.461 2081.294 <o,f0,male> permet de construire récursivement toutes les expressions possibles
* * 20140912 1 20140912_Locuteur_1 2081.294 2084.680 <o,f0,male> et imaginables.
* * 20140912 1 20140912_Locuteur_1 2084.680 2087.629 <o,f0,male> et vous savez, puisque vous avez fait des
* * 20140912 1 20140912_Locuteur_1 2087.629 2093.587 <o,f0,male> vous avez déjà () s() s() c'est la syntaxe des opérations mathématiques, hein. je j'inv() on n'invente rien, en informatique
* * 20140912 1 20140912_Locuteur_1 2093.587 2097.132 <o,f0,male> et vous savez très bien que là, j'ai mis les parenthèses
* * 20140912 1 20140912_Locuteur_1 2097.132 2100.451 <o,f0,male> mais il y a plein de fois où on peut se passer des parenthèses :
* * 20140912 1 20140912_Locuteur_1 2100.451 2104.447 <o,f0,male> quand il y a pas d'ambiguïté, on n'est pas obligé de mettre les parenthèses
* * 20140912 1 20140912_Locuteur_1 2104.447 2107.298 <o,f0,male> ça vous le savez très bien.
* * 20140912 1 20140912_Locuteur_1 2107.298 2109.927 <o,f0,male> donc tout ce qui suit
* * 20140912 1 20140912_Locuteur_1 2109.927 2113.450 <o,f0,male> représente des expressions valides.
* * 20140912 1 20140912_Locuteur_1 2113.450 2116.958 <o,f0,male> euh et dans ce qui suit, on suppose que x est une variable. donc quinze,
* * 20140912 1 20140912_Locuteur_1 2116.958 2119.055 <o,f0,male> c'est une expression valide ;
* * 20140912 1 20140912_Locuteur_1 2119.055 2125.797 <o,f0,male> trois plus huit, c'est une expression valide puisque trois est une expression, huit est une expression. on fait une opération entre deux expressions,
* * 20140912 1 20140912_Locuteur_1 2125.797 2130.327 <o,f0,male> on se rend compte que les parenthèses sont pas utiles dans ce cas-là, donc on ne les écrit pas ;
* * 20140912 1 20140912_Locuteur_1 2130.327 2132.005 <o,f0,male> c'est donc une expression.
* * 20140912 1 20140912_Locuteur_1 2132.005 2136.059 <o,f0,male> un plus entre parenthèses deux fois x moins un,
* * 20140912 1 20140912_Locuteur_1 2136.059 2139.302 <o,f0,male> ça c'est une expression parce que
* * 20140912 1 20140912_Locuteur_1 2139.302 2141.638 <o,f0,male> d'une part, là on a une valeur,
* * 20140912 1 20140912_Locuteur_1 2141.638 2146.557 <o,f0,male> là on a une expression sans les parenthèses, et puis là on a une expression dans les parenthèses avec une opération,
* * 20140912 1 20140912_Locuteur_1 2146.557 2148.223 <o,f0,male> *donc on est bien dans la syntaxe.
* * 20140912 1 20140912_Locuteur_1 2148.223 2156.000 <o,f0,male> mais pour que ce soit une ex() une expression valide, il faut que ça ce soit une expression valide, donc on est bien on a bien une opération avec une expression et une expression,
* * 20140912 1 20140912_Locuteur_1 2156.000 2160.402 <o,f0,male> mais pour que ce soit une expression valide, ben il faut que ça ce soit une expression, donc deux fois x
* * 20140912 1 20140912_Locuteur_1 2160.402 2163.046 <o,f0,male> c'est encore une expression. donc récursivement,
* * 20140912 1 20140912_Locuteur_1 2163.046 2167.191 <o,f0,male> on est capable d'*analyser le fait que ce soit une expression valide ou pas.
* * 20140912 1 20140912_Locuteur_1 2167.191 2170.666 <o,f0,male> et puis on peut avoir des expressions valides entre des chaînes de caractères,
* * 20140912 1 20140912_Locuteur_1 2170.666 2172.592 <o,f0,male> entre des combinaisons comme ça,
* * 20140912 1 20140912_Locuteur_1 2172.592 2174.908 <o,f0,male> là on peut avoir des longues suites,
* * 20140912 1 20140912_Locuteur_1 2174.908 2181.118 <o,f0,male> mais c'est comme si on () on a juste enlevé les parenthèses ; si on peut rajouter les parenthèses dans cette expression, et cetera et cetera.
* * 20140912 1 20140912_Locuteur_1 2181.118 2185.639 <o,f0,male> trois plus longueur de bonjour, c'est aussi une expression.
* * 20140912 1 20140912_Locuteur_1 2185.639 2189.109 <o,f0,male> il y a des questions là-dessus ?
* * 20140912 1 20140912_Locuteur_1 2189.109 2190.201 <o,f0,male> c'est s()
* * 20140912 1 20140912_Locuteur_1 2190.201 2191.369 <o,f0,male> on n'invente rien
* * 20140912 1 20140912_Locuteur_1 2191.369 2192.010 <o,f0,male> oui ?
* * 20140912 1 inter_segment_gap 2192.010 2194.539 <o,f0,> inter_segment_gap
* * 20140912 1 20140912_Locuteur_1 2194.539 2197.730 <o,f0,male> les priorités d'opérations,
* * 20140912 1 20140912_Locuteur_1 2197.730 2200.150 <o,f0,male> c'est la multiplication qui est avant le plus.
* * 20140912 1 20140912_Locuteur_1 2200.150 2206.323 <o,f0,male> il y a des petites subtilités, mais ça vous ve() vous travaillerez là-dessus en td, sur la concaténation parce que c'est le même signe entre le plus
* * 20140912 1 20140912_Locuteur_1 2206.323 2208.908 <o,f0,male> quand il y a des ambiguïtés dans l'expression
* * 20140912 1 20140912_Locuteur_1 2208.908 2212.902 <o,f0,male> et qu'on cherche à évaluer quand même l'expression, parce que c'est le but, mais je crois que j'ai un transparent là-dessus,
* * 20140912 1 20140912_Locuteur_1 2212.902 2215.020 <o,f0,male> il y a des euh
* * 20140912 1 20140912_Locuteur_1 2215.020 2216.454 <o,f0,male> changement de types

deb_slide * 20140912 1 20140912_Locuteur_1 2216.454 2223.592 <o,f0,male> adaptés pour que () pour répondre euh pour évaluer l'expression. mais je crois que j'en parle là ; ben voilà, c'est là !
* gran_1 20140912 1 20140912_Locuteur_1 2223.592 2224.968 <o,f0,male> donc une expression
* * 20140912 1 20140912_Locuteur_1 2224.968 2230.718 <o,f0,male> représente un calcul valide qu'on peut utiliser au sein des instructions de l'algorithme,
* * 20140912 1 20140912_Locuteur_1 2230.718 2234.056 <o,f0,male> une expression possède une valeur
* * 20140912 1 20140912_Locuteur_1 2234.056 2239.233 <o,f0,male> ce qu'on veut, c'est décrire un calcul qui amène à une valeur
* * 20140912 1 20140912_Locuteur_1 2239.233 2244.065 <o,f0,male> qui est obtenue après l'évaluation de cette expression.
* * 20140912 1 20140912_Locuteur_1 2244.065 2251.177 <o,f0,male> attention : il y a des ambiguïtés dans une express() quand il y a des ambiguïtés, elles sont levées en imposant les préférences ;
* * 20140912 1 20140912_Locuteur_1 2251.177 2253.930 <o,f0,male> c'est ce qu'on disait tout à () tout de suite.
* * 20140912 1 20140912_Locuteur_1 2253.930 2258.107 <o,f0,male> donc on préfère faire une concaténation plutôt qu'une addition
* * 20140912 1 20140912_Locuteur_1 2258.107 2261.735 <o,f0,male> et pourtant, c'est le même signe. donc il y a un moment
* * 20140912 1 20140912_Locuteur_1 2261.735 2267.917 <o,f0,male> s() surtout si on s'est trompé euh dans le l'écriture de l'expression () j'ai un exemple, là
* * 20140912 1 20140912_Locuteur_1 2267.917 2271.580 <o,f0,male> dans le cas de l'expression douze plus bonjour,
* * 20140912 1 20140912_Locuteur_1 2271.580 2275.575 <o,f0,male> le plus représente quoi ? représente une addition ou représente une concaténation ?
* * 20140912 1 20140912_Locuteur_1 2275.575 2277.545 <o,f0,male> c'est le même signe.
* * 20140912 1 20140912_Locuteur_1 2277.545 2281.413 <o,f0,male> on aura la même chose quand on cherchera à comparer
* * 20140912 1 20140912_Locuteur_1 2281.413 2286.098 <o,f0,male> un nombre et une chaîne de caractères, c'est les mêmes signes.
* * 20140912 1 20140912_Locuteur_1 2286.098 2287.760 <o,f0,male> eh bah le choix
* * 20140912 1 20140912_Locuteur_1 2287.760 2289.562 <o,f0,male> qui est toujours fait
* * 20140912 1 20140912_Locuteur_1 2289.562 2293.371 <o,f0,male> quand () dès qu'il y a une chaîne de caractères d'un côté ou de l'autre, ça va être de
* * 20140912 1 20140912_Locuteur_1 2293.371 2296.731 <o,f0,male> choisir la concaténation, tout simplement parce que
* * 20140912 1 20140912_Locuteur_1 2296.731 2300.554 <o,f0,male> on peut toujours transformer un entier en une chaîne de caractères,
* * 20140912 1 20140912_Locuteur_1 2300.554 2303.854 <o,f0,male> alors qu'on peut pas toujours transformer une chaîne de caractères en un nombre.
* * 20140912 1 20140912_Locuteur_1 2303.854 2306.130 <o,f0,male> bonjour, ça ne se transforme pas en un nombre ;
* * 20140912 1 20140912_Locuteur_1 2306.130 2309.153 <o,f0,male> c'est pour ça que la concaténation est prioritaire.
* * 20140912 1 20140912_Locuteur_1 2309.153 2310.805 <o,f0,male> donc il y a des priorités comme ça,
* * 20140912 1 20140912_Locuteur_1 2310.805 2314.470 <o,f0,male> mais sinon c'est toujours les priorités des mathématiques.
* * 20140912 1 20140912_Locuteur_1 2314.470 2318.802 <o,f0,male> mais vous reviendrez dessus en td, voilà c'est ce que je dis là : cf td pour plus de détails [pi]

deb_slide * 20140912 1 20140912_Locuteur_1 2318.802 2322.738 <o,f0,male> il est bien préparé mon cours finalement, il répond à vos questions.
* gran_1 20140912 1 20140912_Locuteur_1 2322.738 2325.062 <o,f0,male> alors
* * 20140912 1 20140912_Locuteur_1 2325.062 2332.901 <o,f0,male> on va maintenant voir comment ça s'écrit en javascript, tout ça.
* * 20140912 1 20140912_Locuteur_1 2332.901 2336.672 <o,f0,male> parce qu'attention, les notations en javascript sont des fois un petit peu bizarres.
* * 20140912 1 20140912_Locuteur_1 2336.672 2339.684 <o,f0,male> pourquoi elles sont bizarres ? ben tout simplement parce qu'on n'a pas le droit
* * 20140912 1 20140912_Locuteur_1 2339.684 2341.918 <o,f0,male> à tous les signes
* * 20140912 1 20140912_Locuteur_1 2341.918 2345.085 <o,f0,male> qu'on écrit euh sur une feuille de papier
* * 20140912 1 20140912_Locuteur_1 2345.085 2347.546 <o,f0,male> notamment, on s'est servi
* * 20140912 1 20140912_Locuteur_1 2347.546 2352.319 <o,f0,male> de la flèche pour l'affectation
* * 20140912 1 20140912_Locuteur_1 2352.319 2356.208 <o,f0,male> en algo() dans le langage algorithmique, c'est une flèche ;
* * 20140912 1 20140912_Locuteur_1 2356.208 2360.354 <o,f0,male> dans le langage javascript, je vous ai dit c'est un égal
* * 20140912 1 20140912_Locuteur_1 2360.354 2364.420 <o,f0,male> parce que sur le clavier, on trouvera pas la flèche.
* * 20140912 1 20140912_Locuteur_1 2364.420 2368.745 <o,f0,male> bon ben mince, comme on a pris le égal pour l'affectation
* * 20140912 1 20140912_Locuteur_1 2368.745 2369.790 <o,f0,male> eh ben
* * 20140912 1 20140912_Locuteur_1 2369.790 2372.432 <o,f0,male> il faut trouver un autre signe pour la comparaison ;
* * 20140912 1 20140912_Locuteur_1 2372.432 2375.721 <o,f0,male> on peut plus utiliser le égal.
* * 20140912 1 20140912_Locuteur_1 2375.721 2378.341 <o,f0,male> voilà, donc attention : les notations en javascript
* * 20140912 1 20140912_Locuteur_1 2378.341 2381.005 <o,f0,male> euh j'ai dit javascript, mais c'est commun à
* * 20140912 1 20140912_Locuteur_1 2381.005 2384.138 <o,f0,male> à tous les langages de type c, c plus plus, java
* * 20140912 1 20140912_Locuteur_1 2384.138 2386.180 <o,f0,male> il y a des difficultés pour écrire le égal.
* * 20140912 1 20140912_Locuteur_1 2386.180 2390.932 <o,f0,male> et le é() test d'égalité s'écrit pas égal, mais s'écrit égal égal.
* * 20140912 1 20140912_Locuteur_1 2390.932 2392.818 <o,f0,male> pour tester
* * 20140912 1 20140912_Locuteur_1 2392.818 2397.874 <o,f0,male> si x est égal à cinq, on écrit x égal égal cinq.
* * 20140912 1 20140912_Locuteur_1 2397.874 2399.225 <o,f0,male> le différent
* * 20140912 1 20140912_Locuteur_1 2399.225 2403.720 <o,f0,male> ça, c'est un signe qui se trouve pas sur le clavier, donc il faut pas () on va pas chercher euh
* * 20140912 1 20140912_Locuteur_1 2403.720 2405.840 <o,f0,male> à taper un signe compliqué
* * 20140912 1 20140912_Locuteur_1 2405.840 2407.888 <o,f0,male> on va ra() écrire différent comme ça :
* * 20140912 1 20140912_Locuteur_1 2407.888 2414.010 <o,f0,male> différent, c'est point d'exclamation égal.
* * 20140912 1 20140912_Locuteur_1 2414.010 2418.209 <o,f0,male> les signes ou égal, donc inférieur ou égal et supérieur ou égal
* * 20140912 1 20140912_Locuteur_1 2418.209 2421.857 <o,f0,male> là encore, on les trouve pas sur le clavier donc faut inventer
* * 20140912 1 20140912_Locuteur_1 2421.857 2423.476 <o,f0,male> et les gens ont inventé ça :
* * 20140912 1 20140912_Locuteur_1 2423.476 2425.667 <o,f0,male> on est inférieur égal
* * 20140912 1 20140912_Locuteur_1 2425.667 2429.875 <o,f0,male> ou on écrit supérieur égal.
* * 20140912 1 20140912_Locuteur_1 2429.875 2435.443 <o,f0,male> attention, le inférieur égal ça f() ça ressemble à une flèche, des fois c'est con()
* * 20140912 1 20140912_Locuteur_1 2435.443 2438.043 <o,f0,male> ça rend les les choses un peu confuses.
* * 20140912 1 20140912_Locuteur_1 2438.043 2442.895 <o,f0,male> et ça, c'est bien inférieur ou égal

deb_slide * 20140912 1 20140912_Locuteur_1 2442.895 2445.499 <o,f0,male> [pi] *donc attention
* * 20140912 1 20140912_Locuteur_1 2445.499 2447.729 <o,f0,male> attention aux opérations de comparaison
* gran_1 20140912 1 20140912_Locuteur_1 2447.729 2449.777 <o,f0,male> attention aussi
* * 20140912 1 20140912_Locuteur_1 2449.777 2452.752 <o,f0,male> aux opérations booléennes en javascript, où là le
* * 20140912 1 20140912_Locuteur_1 2452.752 2455.271 <o,f0,male> le signe
* * 20140912 1 20140912_Locuteur_1 2455.271 2459.211 <o,f0,male> euh est totalement contre-intuitif
* * 20140912 1 20140912_Locuteur_1 2459.211 2462.666 <o,f0,male> tout simplement parce que et logique,
* * 20140912 1 20140912_Locuteur_1 2462.666 2464.854 <o,f0,male> ça pourrait s'écrire and
* * 20140912 1 20140912_Locuteur_1 2464.854 2469.708 <o,f0,male> puisqu'on est dans un langage euh anglais, mais ça ne s'écrit pas and
* * 20140912 1 20140912_Locuteur_1 2469.708 2474.480 <o,f0,male> dans les langages de type c, javascript et cetera, ça s'écrit pas and, ça s'écrit
* * 20140912 1 20140912_Locuteur_1 2474.480 2476.519 <o,f0,male> et commercial et commercial,
* * 20140912 1 20140912_Locuteur_1 2476.519 2478.189 <o,f0,male> comme ça.
* * 20140912 1 20140912_Locuteur_1 2478.189 2482.731 <o,f0,male> voilà, donc le et logique s'écrit et commercial et commercial
* * 20140912 1 20140912_Locuteur_1 2482.731 2484.376 <o,f0,male> qu'on retrouvera ici.
* * 20140912 1 20140912_Locuteur_1 2484.376 2486.730 <o,f0,male> le ou logique s'écrira
* * 20140912 1 20140912_Locuteur_1 2486.730 2488.165 <o,f0,male> deux barres
* * 20140912 1 20140912_Locuteur_1 2488.165 2493.302 <o,f0,male> alors les barres, vous les trouverez sur le clavier des pc sur euh
* * 20140912 1 20140912_Locuteur_1 2493.302 2494.488 <o,f0,male> euh au cie
* * 20140912 1 20140912_Locuteur_1 2494.488 2498.030 <o,f0,male> en faisant alt graphic plus
* * 20140912 1 20140912_Locuteur_1 2498.030 2500.772 <o,f0,male> un des caractères, je crois que c'est le huit
* * 20140912 1 20140912_Locuteur_1 2500.772 2503.335 <o,f0,male> mais j'en suis pas sûr.
* * 20140912 1 20140912_Locuteur_1 2503.335 2506.770 <o,f0,male> on les retrouve sur le clavier, ceux-là.
* * 20140912 1 20140912_Locuteur_1 2506.770 2509.640 <o,f0,male> le non logique s'écli() s'écrit point d'exclamation
* * 20140912 1 20140912_Locuteur_1 2509.640 2512.435 <o,f0,male> donc non x inférieur à un,
* * 20140912 1 20140912_Locuteur_1 2512.435 2516.015 <o,f0,male> ça s'écrit comme ça
* * 20140912 1 20140912_Locuteur_1 2516.015 2518.368 <o,f0,male> ok ?
* * 20140912 1 20140912_Locuteur_1 2518.368 2521.364 <o,f0,male> donc toutes les opérations logiques on peut les faire, voilà.
* * 20140912 1 20140912_Locuteur_1 2521.364 2525.078 <o,f0,male> on peut les écrire en javascript et on peut les écrire avec le clavier,

deb_slide * 20140912 1 20140912_Locuteur_1 2525.078 2530.680 <o,f0,male> ça c'était important.
* * 20140912 1 20140912_Locuteur_1 2530.680 2533.234 <o,f0,male> voilà, donc on en a fini avec les instructions
* * 20140912 1 20140912_Locuteur_1 2533.234 2535.202 <o,f0,male> euh avec les expressions.
* * 20140912 1 20140912_Locuteur_1 2535.202 2539.114 <o,f0,male> à quoi elles nous servent, ces expressions ?
* gran_2 20140912 1 20140912_Locuteur_1 2539.114 2543.851 <o,f0,male> ben elles nous servent à écrire les instructions, les bases des instructions.

deb_slide * 20140912 1 20140912_Locuteur_1 2543.851 2548.604 <o,f0,male> donc là on va parler de ça
* * 20140912 1 20140912_Locuteur_1 2548.604 2556.070 <o,f0,male> on va parler de ça maintenant
* * 20140912 1 20140912_Locuteur_1 2556.070 2560.799 <o,f0,male> donc ce qu'on a vu jusqu'à présent, c'est que un algorithme
* * 20140912 1 20140912_Locuteur_1 2560.799 2563.810 <o,f0,male> c'était une suite d'instructions
* * 20140912 1 20140912_Locuteur_1 2563.810 2567.700 <o,f0,male> et quand on a construit l'a() notre algorithme, on avait
* * 20140912 1 20140912_Locuteur_1 2567.700 2569.996 <o,f0,male> une instruction pour la saisie,
* * 20140912 1 20140912_Locuteur_1 2569.996 2572.308 <o,f0,male> une instruction pour l'affichage
* * 20140912 1 20140912_Locuteur_1 2572.308 2575.869 <o,f0,male> et des instructions pour le calcul.
* * 20140912 1 20140912_Locuteur_1 2575.869 2576.544 <o,f0,male> ben voilà
* * 20140912 1 20140912_Locuteur_1 2576.544 2579.250 <o,f0,male> on a tout on a tout dit là, quand on a dit ça.
* * 20140912 1 20140912_Locuteur_1 2579.250 2582.665 <o,f0,male> pour écrire un algorithme, il faut trois instructions de base :
* * 20140912 1 20140912_Locuteur_1 2582.665 2585.289 <o,f0,male> les affectations qui permettent de faire les calculs
* * 20140912 1 20140912_Locuteur_1 2585.289 2588.509 <o,f0,male> affectation d'une valeur à une variable,
* * 20140912 1 20140912_Locuteur_1 2588.509 2589.677 <o,f0,male> les saisies,
* * 20140912 1 20140912_Locuteur_1 2589.677 2594.131 <o,f0,male> les affichages.
* * 20140912 1 20140912_Locuteur_1 2594.131 2599.251 <o,f0,male> un algorithme, ce sera une suite d'instructions
* * 20140912 1 20140912_Locuteur_1 2599.251 2602.823 <o,f0,male> et chaque instruction
* * 20140912 1 20140912_Locuteur_1 2602.823 2608.644 <o,f0,male> avant de s'exécuter, trouvera la mémoire dans un certain état,
* * 20140912 1 20140912_Locuteur_1 2608.644 2610.287 <o,f0,male> *il fera son petit travail
* * 20140912 1 20140912_Locuteur_1 2610.287 2613.460 <o,f0,male> modifi() elle modifiera éventuellement une variable
* * 20140912 1 20140912_Locuteur_1 2613.460 2619.740 <o,f0,male> et donc elle laissera la mémoire dans un autre état.
* * 20140912 1 20140912_Locuteur_1 2619.740 2625.998 <o,f0,male> et on réussira à résoudre un problème en écrivant une suite d'instructions qui modifient petit à petit l'état de la mémoire
* * 20140912 1 20140912_Locuteur_1 2625.998 2632.710 <o,f0,male> en la trouvant dans un état et en la rendant dans un autre état.
* * 20140912 1 20140912_Locuteur_1 2632.710 2635.085 <o,f0,male> donc ça c'est im() c'est important de retenir

deb_slide * 20140912 1 20140912_Locuteur_1 2635.085 2640.350 <o,f0,male> cette phrase-là.
* gran_1 20140912 1 20140912_Locuteur_1 2640.350 2646.388 <o,f0,male> donc trois instructions de base : première instruction de base, ce sont les affectations.
* * 20140912 1 20140912_Locuteur_1 2646.388 2649.417 <o,f0,male> donc qu'est-ce que je dois vous donner ? ben
* * 20140912 1 20140912_Locuteur_1 2649.417 2654.813 <o,f0,male> je dois vous dire ce que ça fait. donc ce sont les instructions qui décrivent les changements de l'état de la mémoire,
* * 20140912 1 20140912_Locuteur_1 2654.813 2658.315 <o,f0,male> elles s'écrivent comme ça, elles ont s() la syntaxe est la suivante :
* * 20140912 1 20140912_Locuteur_1 2658.315 2660.990 <o,f0,male> nom de variable, flèche d'affectation,
* * 20140912 1 20140912_Locuteur_1 2660.990 2665.211 <o,f0,male> expression.
* * 20140912 1 20140912_Locuteur_1 2665.211 2666.906 <o,f0,male> donc
* * 20140912 1 20140912_Locuteur_1 2666.906 2671.277 <o,f0,male> quand on exécute cette instruction,
* * 20140912 1 20140912_Locuteur_1 2671.277 2673.200 <o,f0,male> il y a plusieurs étapes :
* * 20140912 1 20140912_Locuteur_1 2673.200 2676.495 <o,f0,male> la première étape, ça va consister à évaluer
* * 20140912 1 20140912_Locuteur_1 2676.495 2679.467 <o,f0,male> calculer la valeur de cette expression
* * 20140912 1 20140912_Locuteur_1 2679.467 2682.245 <o,f0,male> et une fois qu'on connaît la valeur de cette expression,
* * 20140912 1 20140912_Locuteur_1 2682.245 2685.584 <o,f0,male> on modifie la case mémoire portant ce nom-là :
* * 20140912 1 20140912_Locuteur_1 2685.584 2688.112 <o,f0,male> nom de variable.
* * 20140912 1 20140912_Locuteur_1 2688.112 2690.142 <o,f0,male> par exemple, x reçoit cinq,
* * 20140912 1 20140912_Locuteur_1 2690.142 2692.189 <o,f0,male> c'est une instruction
* * 20140912 1 20140912_Locuteur_1 2692.189 2695.692 <o,f0,male> valide qui va modifier la case mémoire
* * 20140912 1 20140912_Locuteur_1 2695.692 2700.038 <o,f0,male> associée à la valeur x, et qui va lui mettre cinq.
* * 20140912 1 20140912_Locuteur_1 2700.038 2703.109 <o,f0,male> nom reçoit bourdon,
* * 20140912 1 20140912_Locuteur_1 2703.109 2706.139 <o,f0,male> ça va modifier la case mémoire correspondant à nom
* * 20140912 1 20140912_Locuteur_1 2706.139 2709.178 <o,f0,male> enfin les cases mémoires correspondant à nom
* * 20140912 1 20140912_Locuteur_1 2709.178 2713.128 <o,f0,male> et ça va leur ass() attribuer la valeur bourdon.
* * 20140912 1 20140912_Locuteur_1 2713.128 2714.369 <o,f0,male> donc x
* * 20140912 1 20140912_Locuteur_1 2714.369 2720.870 <o,f0,male> c'est une variable de type numérique et non est une variable de type chaîne de caractères. donc vraiment,
* * 20140912 1 20140912_Locuteur_1 2720.870 2722.510 <o,f0,male> il faut retenir cette syntaxe :
* * 20140912 1 20140912_Locuteur_1 2722.510 2724.399 <o,f0,male> on aura une instruction
* * 20140912 1 20140912_Locuteur_1 2724.399 2728.227 <o,f0,male> quand on aura un nom de variable, une flèche qui va vers la droite
* * 20140912 1 20140912_Locuteur_1 2728.227 2730.072 <o,f0,male> vers la gauche, pardon,
* * 20140912 1 20140912_Locuteur_1 2730.072 2733.379 <o,f0,male> et une expression.
* * 20140912 1 20140912_Locuteur_1 2733.379 2736.034 <o,f0,male> attention s() je vois très souvent,
* * 20140912 1 20140912_Locuteur_1 2736.034 2739.310 <o,f0,male> donc c'est une confusion, des écritures de type : une expression,
* * 20140912 1 20140912_Locuteur_1 2739.310 2744.148 <o,f0,male> la flèche qui va vers la droite, un nom de variable ; donc le contraire.
* * 20140912 1 20140912_Locuteur_1 2744.148 2747.104 <o,f0,male> c'est pas la bonne écriture.
* * 20140912 1 20140912_Locuteur_1 2747.104 2748.353 <o,f0,male> et
* * 20140912 1 20140912_Locuteur_1 2748.353 2751.918 <o,f0,male> éventuellement, on peut le comprendre dans le langage algorithmique
* * 20140912 1 20140912_Locuteur_1 2751.918 2754.783 <o,f0,male> si vous écrivez ça dans le langage ava() informatique,
* * 20140912 1 20140912_Locuteur_1 2754.783 2759.308 <o,f0,male> s() il y aura il y aura probablement une erreur
* * 20140912 1 20140912_Locuteur_1 2759.308 2763.571 <o,f0,male> parce qu'il comprendra pas pourquoi on met une expression
* * 20140912 1 20140912_Locuteur_1 2763.571 2765.823 <o,f0,male> euh du côté euh
* * 20140912 1 20140912_Locuteur_1 2765.823 2770.298 <o,f0,male> du côté euh gauche de l'express() de l'instruction d'affectation.

deb_slide * 20140912 1 20140912_Locuteur_1 2770.298 2772.840 <o,f0,male> c'est [pi]
* gran_1 20140912 1 20140912_Locuteur_1 2772.840 2773.810 <o,f0,male> alors
* * 20140912 1 20140912_Locuteur_1 2773.810 2777.460 <o,f0,male> deuxième instruction de base, ce sont les saisies ;
* * 20140912 1 20140912_Locuteur_1 2777.460 2781.945 <o,f0,male> donc ce sont les instructions qui permettent d'interagir en entrée avec l'utilisateur
* * 20140912 1 20140912_Locuteur_1 2781.945 2785.100 <o,f0,male> qui va entrer des valeurs.
* * 20140912 1 20140912_Locuteur_1 2785.100 2789.030 <o,f0,male> donc euh elles s'écrivent comme ça : un nom de variable reçoit
* * 20140912 1 20140912_Locuteur_1 2789.030 2790.217 <o,f0,male> saisie.
* * 20140912 1 20140912_Locuteur_1 2790.217 2794.174 <o,f0,male> c'est prè() ça ressemble beaucoup à une affectation, hein
* * 20140912 1 20140912_Locuteur_1 2794.174 2801.062 <o,f0,male> en javascript ça ressemble beaucoup à une affectation, dans le langage algorithmique ça ressemble beaucoup à une affectation ; c'est une affectation d'une valeur saisie par l'utilisateur.
* * 20140912 1 20140912_Locuteur_1 2801.062 2802.515 <o,f0,male> on les distingue
* * 20140912 1 20140912_Locuteur_1 2802.515 2807.605 <o,f0,male> euh par exemple x reçoit saisie.
* * 20140912 1 20140912_Locuteur_1 2807.605 2809.169 <o,f0,male> en tp
* * 20140912 1 20140912_Locuteur_1 2809.169 2810.990 <o,f0,male> donc en javascript,
* * 20140912 1 20140912_Locuteur_1 2810.990 2813.406 <o,f0,male> dans le langage () en javascript enrichi,
* * 20140912 1 20140912_Locuteur_1 2813.406 2821.220 <o,f0,male> on fera la distinction entre les *différents types de valeurs qu'on peut saisir.
* * 20140912 1 20140912_Locuteur_1 2821.220 2826.267 <o,f0,male> et euh pour les différencier, ces valeurs qu'on va saisir, [pi] il y a trois varia() trois
* * 20140912 1 20140912_Locuteur_1 2826.267 2831.205 <o,f0,male> trois manières de saisir, trois fonctions de saisie : il y a saisie entier, saisie réelle, saisie
* * 20140912 1 20140912_Locuteur_1 2831.205 2834.161 <o,f0,male> et saisie, qui saisit d'une chaîne de caractères.
* * 20140912 1 20140912_Locuteur_1 2834.161 2835.415 <o,f0,male> voilà, donc
* * 20140912 1 20140912_Locuteur_1 2835.415 2841.558 <o,f0,male> on distinguera ça en tp ; en td, on s'en moque en fait [pif] saisie c'est euh multi euh
* * 20140912 1 20140912_Locuteur_1 2841.558 2843.710 <o,f0,male> multi-usages
* * 20140912 1 20140912_Locuteur_1 2843.710 2847.191 <o,f0,male> et on supposera toujours que ça saisit quelque chose du bon type ;

deb_slide * 20140912 1 20140912_Locuteur_1 2847.191 2850.510 <o,f0,male> en tp, il faudra se poser un peu plus la question.
* gran_1 20140912 1 20140912_Locuteur_1 2850.510 2851.440 <o,f0,male> voilà
* * 20140912 1 20140912_Locuteur_1 2851.440 2855.923 <o,f0,male> dernière instruction de base, ce sont les affichages.
* * 20140912 1 20140912_Locuteur_1 2855.923 2860.389 <o,f0,male> donc ce sont les instructions qui permettent d'interagir en sortie avec l'utilisateur ;
* * 20140912 1 20140912_Locuteur_1 2860.389 2864.372 <o,f0,male> on lui restitue un résultat,
* * 20140912 1 20140912_Locuteur_1 2864.372 2870.710 <o,f0,male> et elle s'écrivent, ça on l'a déjà vu, écrire entre parenthèses une expression.
* * 20140912 1 20140912_Locuteur_1 2870.710 2873.985 <o,f0,male> donc une expression qui peut être une valeur,
* * 20140912 1 20140912_Locuteur_1 2873.985 2875.199 <o,f0,male> une variable,
* * 20140912 1 20140912_Locuteur_1 2875.199 2878.749 <o,f0,male> une concaténation de plusieurs choses
* * 20140912 1 20140912_Locuteur_1 2878.749 2883.335 <o,f0,male> et cetera, et cetera. donc une ex() euh écrire entre parenthèses une expression.
* * 20140912 1 20140912_Locuteur_1 2883.335 2888.549 <o,f0,male> par exemple, écrire bonjour le monde.
* * 20140912 1 20140912_Locuteur_1 2888.549 2893.745 <o,f0,male> là encore, je fais une petite différence entre ce qu'on verra en td et ce qu'on verra en tp. en td,
* * 20140912 1 20140912_Locuteur_1 2893.745 2899.788 <o,f0,male> ce sera jamais un enjeu d'écrire proprement les choses, d'avoir une fonction d'affichage qui fasse des choses très jolies.
* * 20140912 1 20140912_Locuteur_1 2899.788 2903.696 <o,f0,male> par contre, en tp on a souvent envie que ce soit un affichage joli
* * 20140912 1 20140912_Locuteur_1 2903.696 2905.370 <o,f0,male> donc
* * 20140912 1 20140912_Locuteur_1 2905.370 2911.583 <o,f0,male> en général, on se creusera la tête pour avoir une belle expression pour un bel affich() avoir un bel affichage
* * 20140912 1 20140912_Locuteur_1 2911.583 2913.191 <o,f0,male> ou voire même
* * 20140912 1 20140912_Locuteur_1 2913.191 2917.375 <o,f0,male> on utilisera d'autres méthodes pour restituer un résultat,
* * 20140912 1 20140912_Locuteur_1 2917.375 2920.387 <o,f0,male> comme des affichages graphiques
* * 20140912 1 20140912_Locuteur_1 2920.387 2926.702 <o,f0,male> calculer l'ensemble de mandelbrot, ça vous aurait servi à rien que j'écrive toutes les valeurs que je calcule mais par contre,
* * 20140912 1 20140912_Locuteur_1 2926.702 2930.791 <o,f0,male> ça vous sert de savoir que à tel point, j'ai mis () j'ai attribué telle couleur.
* * 20140912 1 20140912_Locuteur_1 2930.791 2932.489 <o,f0,male> et ça, c'est une restitution
* * 20140912 1 20140912_Locuteur_1 2932.489 2935.666 <o,f0,male> visuelle d'un résultat du calcul.
* * 20140912 1 20140912_Locuteur_1 2935.666 2939.763 <o,f0,male> on peut avoir une résus() une restitution sonore

deb_slide * 20140912 1 20140912_Locuteur_1 2939.763 2945.380 <o,f0,male> ou plein d'autres euh restitutions.
* gran_1 20140912 1 20140912_Locuteur_1 2945.380 2947.923 <o,f0,male> voilà, donc en javascript
* * 20140912 1 20140912_Locuteur_1 2947.923 2949.192 <o,f0,male> l'affectation
* * 20140912 1 20140912_Locuteur_1 2949.192 2954.317 <o,f0,male> s'écrit pas flèche mais s'écrit égal, ça on l'a déjà vu,
* * 20140912 1 20140912_Locuteur_1 2954.317 2957.263 <o,f0,male> la saisie s'écrit a égale saisie,
* * 20140912 1 20140912_Locuteur_1 2957.263 2959.111 <o,f0,male> ça on l'a déjà vu,
* defaut 20140912 1 20140912_Locuteur_1 2959.111 2970.349 <o,f0,male> et l'affichage s'écrit écrire entre parenthèses l'expression, ça on l'a déjà vu.
* * 20140912 1 20140912_Locuteur_1 2970.349 2971.871 <o,f0,male> c'est bon ?
* * 20140912 1 20140912_Locuteur_1 2971.871 2992.190 <o,f0,male> non ?
* * 20140912 1 20140912_Locuteur_1 2992.190 2993.826 <o,f0,male> c'est bon ?
* * 20140912 1 20140912_Locuteur_1 2993.826 2997.060 <o,f0,male> non ?
* * 20140912 1 20140912_Locuteur_1 2997.060 3004.770 <o,f0,male> ça va un petit peu vite je je s() j'en suis conscient.
* * 20140912 1 20140912_Locuteur_1 3004.770 3006.580 <o,f0,male> mais vous n'avez pas besoin de tout noter
* defaut_fin 20140912 1 20140912_Locuteur_1 3006.580 3016.251 <o,f0,male> hein, on vous donnera des choses

deb_slide gran_2 20140912 1 20140912_Locuteur_1 3016.251 3022.370 <o,f0,male> allez, on passe à la suite.
* * 20140912 1 20140912_Locuteur_1 3022.370 3024.397 <o,f0,male> le mot-clé important,
* * 20140912 1 20140912_Locuteur_1 3024.397 3029.187 <o,f0,male> ça va être le mot-clé séquentialité.
* * 20140912 1 20140912_Locuteur_1 3029.187 3034.975 <o,f0,male> donc un algorithme, c'est une suite d'instructions, je me () je je l'ai déjà écrit plusieurs fois ça, c'est une suite d'instructions
* * 20140912 1 20140912_Locuteur_1 3034.975 3039.699 <o,f0,male> qui s'exécutent par défaut les unes après les autres dans l'ordre d'écriture.
* * 20140912 1 20140912_Locuteur_1 3039.699 3050.194 <o,f0,male> le fait que ça s'exécute dans l'ordre d'écriture, on appelle ça la séquentialité.
* * 20140912 1 20140912_Locuteur_1 3050.194 3051.760 <o,f0,male> le fait euh
* * 20140912 1 20140912_Locuteur_1 3051.760 3054.337 <o,f0,male> on on ajoute un petit signe dans la syntaxe
* * 20140912 1 20140912_Locuteur_1 3054.337 3058.117 <o,f0,male> qui sépare les instructions
* * 20140912 1 20140912_Locuteur_1 3058.117 3059.986 <o,f0,male> donc en général,
* * 20140912 1 20140912_Locuteur_1 3059.986 3062.662 <o,f0,male> pour séparer deux instructions, on les écrit
* * 20140912 1 20140912_Locuteur_1 3062.662 3064.443 <o,f0,male> les unes à la suite des autres,
* * 20140912 1 20140912_Locuteur_1 3064.443 3070.420 <o,f0,male> séparées par un point-virgule et mises à la ligne les unes en dessous des autres.
* * 20140912 1 20140912_Locuteur_1 3070.420 3073.611 <o,f0,male> voilà la bonne manière d'écrire les les instructions.
* * 20140912 1 20140912_Locuteur_1 3073.611 3075.863 <o,f0,male> par exemple,
* * 20140912 1 20140912_Locuteur_1 3075.863 3080.229 <o,f0,male> le la suite d'instructions x reçoit cinq
* * 20140912 1 20140912_Locuteur_1 3080.229 3081.320 <o,f0,male> point-virgule
* * 20140912 1 20140912_Locuteur_1 3081.320 3084.741 <o,f0,male> y reçoit x plus dix point-virgule.
* * 20140912 1 20140912_Locuteur_1 3084.741 3089.998 <o,f0,male> et le fait d'avoir bien séparé les choses, s() on saura que cette instruction-là est exécutée avant
* * 20140912 1 20140912_Locuteur_1 3089.998 3091.002 <o,f0,male> celle-là
* * 20140912 1 20140912_Locuteur_1 3091.002 3093.360 <o,f0,male> donc on saura que quand on exécute celle-là,
* * 20140912 1 20140912_Locuteur_1 3093.360 3097.137 <o,f0,male> la valeur de x qui sera utilisée, ce sera cinq.
* * 20140912 1 20140912_Locuteur_1 3097.137 3098.006 <o,f0,male> voilà
* * 20140912 1 20140912_Locuteur_1 3098.006 3103.020 <o,f0,male> des instructions sont exécutées séquentiellement, et la mémoire est modifiée
* * 20140912 1 20140912_Locuteur_1 3103.020 3106.229 <o,f0,male> séquentiellement.

deb_slide * 20140912 1 20140912_Locuteur_1 3106.229 3108.707 <o,f0,male> *voilà, donc on parle de séquentialité.
* gran_1 20140912 1 20140912_Locuteur_1 3108.707 3111.222 <o,f0,male> euh pourquoi ça part euh si vite ? voilà
* * 20140912 1 20140912_Locuteur_1 3111.222 3115.661 <o,f0,male> donc on va prendre maintenant un exemple d'évaluation
* * 20140912 1 20140912_Locuteur_1 3115.661 3118.407 <o,f0,male> d'une expression
* * 20140912 1 20140912_Locuteur_1 3118.407 3122.600 <o,f0,male> parce que c'est important de savoir exactement comment ça s'évalue ; donc voilà un exemple
* * 20140912 1 20140912_Locuteur_1 3122.600 3127.710 <o,f0,male> j'ai cette expression y () j'ai cette instruction pardon y
* * 20140912 1 20140912_Locuteur_1 3127.710 3133.854 <o,f0,male> prend pour valeur cinq fois entre parenthèses x plus dix.
* * 20140912 1 20140912_Locuteur_1 3133.854 3136.249 <o,f0,male> comment ça marche ?
* * 20140912 1 20140912_Locuteur_1 3136.249 3137.801 <o,f0,male> ben déjà je ch()
* * 20140912 1 20140912_Locuteur_1 3137.801 3139.447 <o,f0,male> comment ça marche à l'exécution ?
* * 20140912 1 20140912_Locuteur_1 3139.447 3142.265 <o,f0,male> et là, je me mets à la place de l'ordinateur.
* * 20140912 1 20140912_Locuteur_1 3142.265 3144.067 <o,f0,male> l'ordinateur
* * 20140912 1 20140912_Locuteur_1 3144.067 3148.416 <o,f0,male> va chercher le séparateur d'instructions, il va chercher le point-virgule
* * 20140912 1 20140912_Locuteur_1 3148.416 3152.741 <o,f0,male> et quand il aura trouvé le point-virgule, il se dira : tiens, avant j'ai sans doute une instruction.
* * 20140912 1 20140912_Locuteur_1 3152.741 3156.304 <o,f0,male> est-ce que j'ai vraiment une instruction ?

deb_slide * 20140912 1 20140912_Locuteur_1 3156.304 3159.730 <o,f0,male> donc c'est la première question qu'il va se poser.
* * 20140912 1 20140912_Locuteur_1 3159.730 3165.633 <o,f0,male> il va chercher à reconnaître l'instruction ; s'il la reconnaît pas, il f() il produit une erreur, hein.
* * 20140912 1 20140912_Locuteur_1 3165.633 3167.951 <o,f0,male> donc c'est une une des sources d'erreur.
* * 20140912 1 20140912_Locuteur_1 3167.951 3172.643 <o,f0,male> ici, notre instruction est valide donc il la reconnaît
* * 20140912 1 20140912_Locuteur_1 3172.643 3176.197 <o,f0,male> et il reconnaît même que c'est une affectation.
* * 20140912 1 20140912_Locuteur_1 3176.197 3179.745 <o,f0,male> pourquoi il a reconnu que c'était une affectation ? bah parce qu'il avait une variable
* * 20140912 1 20140912_Locuteur_1 3179.745 3180.552 <o,f0,male> flèche
* * 20140912 1 20140912_Locuteur_1 3180.552 3185.550 <o,f0,male> une expression.
* * 20140912 1 20140912_Locuteur_1 3185.550 3187.214 <o,f0,male> donc comme il a

deb_slide * 20140912 1 20140912_Locuteur_1 3187.214 3193.131 <o,f0,male> cette euh instruction, il va se poser la question maintenant de comment il fait pour l'exécuter.
* * 20140912 1 20140912_Locuteur_1 3193.131 3198.073 <o,f0,male> ben pour l'exécuter, il faut d'abord évaluer l'expression
* * 20140912 1 20140912_Locuteur_1 3198.073 3201.830 <o,f0,male> euh l'expression cinq fois x plus dix.
* * 20140912 1 20140912_Locuteur_1 3201.830 3204.732 <o,f0,male> il faut avoir la valeur pour av() avant de pouvoir l'a()
* * 20140912 1 20140912_Locuteur_1 3204.732 3206.494 <o,f0,male> l'affecter à la *variable
* * 20140912 1 20140912_Locuteur_1 3206.494 3209.565 <o,f0,male> à la mémoire.
* * 20140912 1 20140912_Locuteur_1 3209.565 3211.929 <o,f0,male> donc il évalue ça, mais pour ça
* * 20140912 1 20140912_Locuteur_1 3211.929 3216.999 <o,f0,male> il doit chercher en mémoire la valeur associée à la variable x, sinon il peut pas évaluer l'expression.

deb_slide * 20140912 1 20140912_Locuteur_1 3216.999 3218.179 <o,f0,male> bah c'est ce qu'il fait
* * 20140912 1 20140912_Locuteur_1 3218.179 3218.860 <o,f0,male> voilà
* * 20140912 1 20140912_Locuteur_1 3218.860 3223.036 <o,f0,male> dans la mémoire, il y a un nombre () la mémoire on la () elle est représentée comme ça
* * 20140912 1 20140912_Locuteur_1 3223.036 3227.417 <o,f0,male> il y a un endroit dans la mémoire où x vaut par exemple douze ; j'aurais pu prendre cinq
* * 20140912 1 20140912_Locuteur_1 3227.417 3229.237 <o,f0,male> mais là j'ai pris douze
* * 20140912 1 20140912_Locuteur_1 3229.237 3231.050 <o,f0,male> donc
* * 20140912 1 20140912_Locuteur_1 3231.050 3232.949 <o,f0,male> il se dit voilà : douze
* * 20140912 1 20140912_Locuteur_1 3232.949 3235.080 <o,f0,male> je vais remplacer

deb_slide * 20140912 1 20140912_Locuteur_1 3235.080 3239.459 <o,f0,male> x par douze dans mon expression, et je vais calculer cette expression-là. je connais tout,
* * 20140912 1 20140912_Locuteur_1 3239.459 3242.601 <o,f0,male> je peux tout évaluer, l'expression est valide s()
* * 20140912 1 20140912_Locuteur_1 3242.601 3247.940 <o,f0,male> je la calcule : ça vaut cent dix.

deb_slide * 20140912 1 20140912_Locuteur_1 3247.940 3255.665 <o,f0,male> donc là, c'est euh compte tenu de toutes les priorités classiques des expressions, il est capable de le faire, parce que l'expression était bien construite.
* * 20140912 1 20140912_Locuteur_1 3255.665 3256.331 <o,f0,male> bon
* * 20140912 1 20140912_Locuteur_1 3256.331 3258.561 <o,f0,male> éta() dernière étape
* * 20140912 1 20140912_Locuteur_1 3258.561 3261.959 <o,f0,male> c'est la fin de l'instruction : on affecte la valeur cent dix à la variable
* * 20140912 1 20140912_Locuteur_1 3261.959 3263.626 <o,f0,male> y
* * 20140912 1 20140912_Locuteur_1 3263.626 3265.167 <o,f0,male> et c'est fini ;

deb_slide * 20140912 1 20140912_Locuteur_1 3265.167 3267.735 <o,f0,male> et c'est fini. une fois qu'on a ça
* * 20140912 1 20140912_Locuteur_1 3267.735 3271.278 <o,f0,male> dans *la mémoire, il y a une case associée à y
* * 20140912 1 20140912_Locuteur_1 3271.278 3274.560 <o,f0,male> qui a pour valeur cent dix.
* * 20140912 1 20140912_Locuteur_1 3274.560 3283.280 <o,f0,male> et cet état de mé() de la mémoire sera utilisé pour les instruc() l'instruction qui suit.

deb_slide gran_1 20140912 1 20140912_Locuteur_1 3283.280 3287.812 <o,f0,male> alors ça, c'était un peu fait à la main
* * 20140912 1 20140912_Locuteur_1 3287.812 3293.415 <o,f0,male> en td, vous construirez ce qu'on appelle un historique d'exécution ;
* * 20140912 1 20140912_Locuteur_1 3293.415 3298.547 <o,f0,male> un historique d'exécution qui sert à suivre l'exécution d'un algorithme.
* * 20140912 1 20140912_Locuteur_1 3298.547 3301.666 <o,f0,male> *alors ça se construit comme ça :
* * 20140912 1 20140912_Locuteur_1 3301.666 3305.313 <o,f0,male> on on veut suivre l'état d'un certain nombre de variables
* * 20140912 1 20140912_Locuteur_1 3305.313 3307.506 <o,f0,male> variable un, variable deux
* * 20140912 1 20140912_Locuteur_1 3307.506 3311.044 <o,f0,male> pendant l'exécution d'un certain nombre d'instructions.
* * 20140912 1 20140912_Locuteur_1 3311.044 3313.519 <o,f0,male> de quoi on a besoin pour suivre ça ?
* * 20140912 1 20140912_Locuteur_1 3313.519 3315.603 <o,f0,male> on a besoin de l'état
* * 20140912 1 20140912_Locuteur_1 3315.603 3318.242 <o,f0,male> l'état courant avant
* * 20140912 1 20140912_Locuteur_1 3318.242 3321.113 <o,f0,male> le l'exécution de la première instruction.
* * 20140912 1 20140912_Locuteur_1 3321.113 3322.869 <o,f0,male> en général, la mémoire est vide,
* * 20140912 1 20140912_Locuteur_1 3322.869 3325.406 <o,f0,male> mais si on a u() une fonction, la mémoire n'est pas vide.
* * 20140912 1 20140912_Locuteur_1 3325.406 3329.652 <o,f0,male> enfin si on a dans dans s() on peut imaginer que dans certains cas la mémoire n() n'est pas vide.
* * 20140912 1 20140912_Locuteur_1 3329.652 3334.745 <o,f0,male> et puis ensuite, on a besoin de suivre l() l'évolution de ces valeu() de ces variables-là

deb_slide * 20140912 1 20140912_Locuteur_1 3334.745 3342.873 <o,f0,male> au cours de l'exécution de l'algorithme, donc après l'exécution de l'instruction un, après l'exécution de l'instruction deux, après l'exécution de l'instruction trois.
* gran_1 20140912 1 20140912_Locuteur_1 3342.873 3346.053 <o,f0,male> voilà, *donc par exemple
* * 20140912 1 20140912_Locuteur_1 3346.053 3349.248 <o,f0,male> si j'avais cet algorithme-là,
* * 20140912 1 20140912_Locuteur_1 3349.248 3353.396 <o,f0,male> donc un algorithme que j'ai appelé voyage, qui a deux variables
* * 20140912 1 20140912_Locuteur_1 3353.396 3356.466 <o,f0,male> position et déplacement, qui sont des entiers,
* * 20140912 1 20140912_Locuteur_1 3356.466 3359.362 <o,f0,male> et puis quatre instructions :
* * 20140912 1 20140912_Locuteur_1 3359.362 3368.441 <o,f0,male> la première, c'est position reçoit vingt-cinq ; la deuxième, déplacement reçoit onze ; la troisième, position reçoit position plus déplacement ; et la dernière, écrire une position.
* * 20140912 1 20140912_Locuteur_1 3368.441 3378.083 <o,f0,male> je dois représenter mon histori() je représente mon historique d'exécution comme ça, donc ce que je vais vouloir suivre, c'est position et déplacement.
* * 20140912 1 20140912_Locuteur_1 3378.083 3382.443 <o,f0,male> pour les suivre convenablement, je dois donner leur valeur à l'origine.
* * 20140912 1 20140912_Locuteur_1 3382.443 3385.798 <o,f0,male> à l'origine, elles n'ont pas de valeur
* * 20140912 1 20140912_Locuteur_1 3385.798 3389.304 <o,f0,male> donc point d'interrogation. ça va être notre manière de noter
* * 20140912 1 20140912_Locuteur_1 3389.304 3393.176 <o,f0,male> qu'on ne connaît pas la valeur de la variable.
* * 20140912 1 20140912_Locuteur_1 3393.176 3394.464 <o,f0,male> en javascript,
* * 20140912 1 20140912_Locuteur_1 3394.464 3396.084 <o,f0,male> on aura
* * 20140912 1 20140912_Locuteur_1 3396.084 3397.937 <o,f0,male> une valeur non définie
* * 20140912 1 20140912_Locuteur_1 3397.937 3404.450 <o,f0,male> quand () tant qu'on n'a pas donné de valeur à une variable, elle est non définie ; et ce () s() c'est ce que nous donnera javascript.
* * 20140912 1 20140912_Locuteur_1 3404.450 3409.691 <o,f0,male> après l'exécution de la première instruction, position prend pour valeur vingt-cinq, ben
* * 20140912 1 20140912_Locuteur_1 3409.691 3413.509 <o,f0,male> je me retrouve dans cette position dans cette k() configuration-là :
* * 20140912 1 20140912_Locuteur_1 3413.509 3415.045 <o,f0,male> position
* * 20140912 1 20140912_Locuteur_1 3415.045 3419.648 <o,f0,male> vaut vingt-cinq, déplacement n'a pas été modifié, on ne sait toujours pas ce que ça vaut.
* * 20140912 1 20140912_Locuteur_1 3419.648 3423.056 <o,f0,male> deuxième ligne : on change la valeur de déplacement
* * 20140912 1 20140912_Locuteur_1 3423.056 3425.640 <o,f0,male> donc on met onze ici mais on ne change pas la valeur de position.
* * 20140912 1 20140912_Locuteur_1 3425.640 3428.490 <o,f0,male> donc l'état courant de la mémoire, c'est posit()
* * 20140912 1 20140912_Locuteur_1 3428.490 3432.351 <o,f0,male> position qui vaut vingt-cinq, déplacement qui vaut onze.
* * 20140912 1 20140912_Locuteur_1 3432.351 3435.247 <o,f0,male> ensuite je change la valeur de position
* * 20140912 1 20140912_Locuteur_1 3435.247 3438.305 <o,f0,male> ça vaut trente-six, mais je ne change pas déplacement,
* * 20140912 1 20140912_Locuteur_1 3438.305 3440.494 <o,f0,male> et une fonction d'affichage
* * 20140912 1 20140912_Locuteur_1 3440.494 3442.579 <o,f0,male> ne change pas l'état de la mémoire.
* * 20140912 1 20140912_Locuteur_1 3442.579 3445.319 <o,f0,male> donc ça lit éventuellement des valeurs en mémoire
* * 20140912 1 20140912_Locuteur_1 3445.319 3447.949 <o,f0,male> ici, ça lit la valeur de position
* * 20140912 1 20140912_Locuteur_1 3447.949 3451.502 <o,f0,male> mais ça n'affecte pas l'état de la mémoire.

deb_slide * 20140912 1 20140912_Locuteur_1 3451.502 3456.133 <o,f0,male> donc après l'exécution de cette instruction, la mémoire n'est pas chan() n'est pas modifiée.
* * 20140912 1 20140912_Locuteur_1 3456.133 3458.729 <o,f0,male> voilà
* gran_1 20140912 1 20140912_Locuteur_1 3458.729 3461.779 <o,f0,male> sur les historiques d'exécution, que vous construirez
* * 20140912 1 20140912_Locuteur_1 3461.779 3463.309 <o,f0,male> plusieurs fois en td,
* * 20140912 1 20140912_Locuteur_1 3463.309 3466.211 <o,f0,male> *enfin voilà une règle de construction d'historique d'exécution.
* * 20140912 1 20140912_Locuteur_1 3466.211 3469.799 <o,f0,male> donc première euh chose à faire : on numérote les instructions
* * 20140912 1 20140912_Locuteur_1 3469.799 3472.593 <o,f0,male> imaginons qu'il y en ait n ici ;
* * 20140912 1 20140912_Locuteur_1 3472.593 3476.655 <o,f0,male> deuxième chose à faire : on sélectionne les *variables qu'on va vouloir suivre,
* * 20140912 1 20140912_Locuteur_1 3476.655 3478.399 <o,f0,male> imaginons qu'il y en ait m ;
* * 20140912 1 20140912_Locuteur_1 3478.399 3483.027 <o,f0,male> eh ben on construit ensuite un tableau à
* * 20140912 1 20140912_Locuteur_1 3483.027 3488.369 <o,f0,male> n plus deux lignes. alors n plus deux parce que il y a cette ligne d'en-tête et puis il y a la ligne avant
* * 20140912 1 20140912_Locuteur_1 3488.369 3492.209 <o,f0,male> donc ça fait euh n instructions plus les deux lignes.
* * 20140912 1 20140912_Locuteur_1 3492.209 3496.966 <o,f0,male> et m plus une colonne : toutes les variables qu'on veut suivre plus la colonne d'en-tête.
* * 20140912 1 20140912_Locuteur_1 3496.966 3499.217 <o,f0,male> et ce qu'on met dans le tableau, c'est
* * 20140912 1 20140912_Locuteur_1 3499.217 3501.394 <o,f0,male> la valeur de la variable
* * 20140912 1 20140912_Locuteur_1 3501.394 3502.410 <o,f0,male> v i
* * 20140912 1 20140912_Locuteur_1 3502.410 3505.655 <o,f0,male> après l'exécution de toutes les instructions
* * 20140912 1 20140912_Locuteur_1 3505.655 3509.450 <o,f0,male> jusqu'à cette euh instruction-là.
* * 20140912 1 20140912_Locuteur_1 3509.450 3513.055 <o,f0,male> ok ?
* * 20140912 1 20140912_Locuteur_1 3513.055 3518.175 <o,f0,male> c'est facile à construire, hein.
* * 20140912 1 20140912_Locuteur_1 3518.175 3518.935 <o,f0,male> alors c'est
* * 20140912 1 20140912_Locuteur_1 3518.935 3521.384 <o,f0,male> d'autant plus facile à construire
* * 20140912 1 20140912_Locuteur_1 3521.384 3529.000 <o,f0,male> que euh il y a une méthode de construction automatique sur l'interface

deb_slide * 20140912 1 20140912_Locuteur_1 3529.000 3530.985 <o,f0,male> euh je reviendrai dessus après le bilan,
* * 20140912 1 20140912_Locuteur_1 3530.985 3533.144 <o,f0,male> ça m'évitera de
* * 20140912 1 20140912_Locuteur_1 3533.144 3533.967 <o,f0,male> de tout changer.
* * 20140912 1 20140912_Locuteur_1 3533.967 3535.244 <o,f0,male> donc bilan
* gran_1 20140912 1 20140912_Locuteur_1 3535.244 3538.094 <o,f0,male> de cette partie du cours : qu'est-ce qu'on a vu ?
* * 20140912 1 20140912_Locuteur_1 3538.094 3543.367 <o,f0,male> on a vu qu'un algorithme, c'est une suite de séquences d'instructions qui modifient l'état de la mémoire
* * 20140912 1 20140912_Locuteur_1 3543.367 3545.120 <o,f0,male> qu'on accède à la mémoire
* * 20140912 1 20140912_Locuteur_1 3545.120 3547.193 <o,f0,male> en utilisant des variables
* * 20140912 1 20140912_Locuteur_1 3547.193 3548.964 <o,f0,male> qui possèdent un nom,
* * 20140912 1 20140912_Locuteur_1 3548.964 3549.745 <o,f0,male> un type
* * 20140912 1 20140912_Locuteur_1 3549.745 3553.333 <o,f0,male> et une valeur courante.
* * 20140912 1 20140912_Locuteur_1 3553.333 3556.705 <o,f0,male> et on a vu que l'historique d'exécution, c'est un outil
* * 20140912 1 20140912_Locuteur_1 3556.705 3558.075 <o,f0,male> très important
* * 20140912 1 20140912_Locuteur_1 3558.075 3562.755 <o,f0,male> pour comprendre le comportement d'un algorithme, pour vérifier que cet algorithme
* * 20140912 1 20140912_Locuteur_1 3562.755 3564.276 <o,f0,male> donne le bon résultat
* * 20140912 1 20140912_Locuteur_1 3564.276 3570.872 <o,f0,male> et éventuellement pour trouver les endroits où s() où on a commis une erreur si l'algorithme ne fournit pas le bon résultat.
* * 20140912 1 20140912_Locuteur_1 3570.872 3576.521 <o,f0,male> donc c'est vraiment important, cette notion d'historique d'exécution.
* defaut 20140912 1 20140912_Locuteur_1 3576.521 3629.588 <o,f0,male> je vous laisse noter le bilan ?
* * 20140912 1 20140912_Locuteur_1 3629.588 3657.110 <o,f0,male> c'est bon ?
* * 20140912 1 20140912_Locuteur_1 3657.110 3658.199 <o,f0,male> c'est bon ?

deb_slide defaut_fin 20140912 1 20140912_Locuteur_1 3658.199 3659.382 <o,f0,male> alors
* * 20140912 1 20140912_Locuteur_1 3659.382 3672.670 <o,f0,male> comme c'est important
* * 20140912 1 20140912_Locuteur_1 3672.670 3676.961 <o,f0,male> comme c'est important d'avoir euh cette notion d'historique d'exécution,
* * 20140912 1 20140912_Locuteur_1 3676.961 3681.233 <o,f0,male> on a mis à disposition sur l'interface
* * 20140912 1 20140912_Locuteur_1 3681.233 3687.280 <o,f0,male> un outil pour construire les historiques d'exécution automatiquement.
* * 20140912 1 20140912_Locuteur_1 3687.280 3701.806 <o,f0,male> donc je vais vous montrer comment ça marche :
* * 20140912 1 20140912_Locuteur_1 3701.806 3703.504 <o,f0,male> donc déjà *je
* * 20140912 1 20140912_Locuteur_1 3703.504 3707.946 <o,f0,male> je transforme le
* * 20140912 1 20140912_Locuteur_1 3707.946 3709.980 <o,f0,male> l'algorithme
* * 20140912 1 20140912_Locuteur_1 3709.980 3712.851 <o,f0,male> euh du langage algorithmique au langage
* * 20140912 1 20140912_Locuteur_1 3712.851 3717.524 <o,f0,male> javascript
* * 20140912 1 20140912_Locuteur_1 3717.524 3719.129 <o,f0,male> est-ce que ça, vous sauriez le faire d'ailleurs ?
* * 20140912 1 inter_segment_gap 3719.129 3721.223 <o,f0,> inter_segment_gap
* * 20140912 1 20140912_Locuteur_1 3721.223 3722.265 <o,f0,male> avec tout ce qu'on a vu
* * 20140912 1 inter_segment_gap 3722.265 3723.343 <o,f0,> inter_segment_gap
* * 20140912 1 20140912_Locuteur_1 3723.343 3724.297 <o,f0,male> ouais
* * 20140912 1 20140912_Locuteur_1 3724.297 3731.000 <o,f0,male> oui ?
* * 20140912 1 20140912_Locuteur_1 3731.000 3735.590 <o,f0,male> transformer l'algorithme qu'on a vu
* * 20140912 1 20140912_Locuteur_1 3735.590 3740.200 <o,f0,male> en format algorithmique dans le format javascript, ça donne ça :
* * 20140912 1 20140912_Locuteur_1 3740.200 3748.055 <o,f0,male> bon si je l'exécute
* * 20140912 1 20140912_Locuteur_1 3748.055 3749.170 <o,f0,male> il y a assez de place, voilà
* * 20140912 1 20140912_Locuteur_1 3749.170 3751.360 <o,f0,male> si je l'exécute,
* * 20140912 1 20140912_Locuteur_1 3751.360 3754.704 <o,f0,male> j'ai bien trente-six qui est affiché
* * 20140912 1 20140912_Locuteur_1 3754.704 3758.242 <o,f0,male> s() si j'a() pour construire un historique d'exécution
* * 20140912 1 20140912_Locuteur_1 3758.242 3761.099 <o,f0,male> de cet algorithme,
* * 20140912 1 20140912_Locuteur_1 3761.099 3765.965 <o,f0,male> il suffit de prendre les va() les noms des variables qu'on veut suivre,
* * 20140912 1 20140912_Locuteur_1 3765.965 3768.674 <o,f0,male> et de les recopier dans inspect, là
* * 20140912 1 20140912_Locuteur_1 3768.674 3772.970 <o,f0,male> donc je mets position virgule déplacement
* * 20140912 1 20140912_Locuteur_1 3772.970 3777.002 <o,f0,male> et quand je fais ça, ça me fait la même chose quand j'exécute le programme
* * 20140912 1 20140912_Locuteur_1 3777.002 3778.739 <o,f0,male> sauf qu'en plus
* * 20140912 1 20140912_Locuteur_1 3778.739 3782.438 <o,f0,male> ça me construit un historique d'exécution.
* * 20140912 1 20140912_Locuteur_1 3782.438 3786.389 <o,f0,male> alors je sais pas pourquoi il y a ce signe bizarre
* * 20140912 1 20140912_Locuteur_1 3786.389 3787.414 <o,f0,male> mais
* * 20140912 1 20140912_Locuteur_1 3787.414 3788.434 <o,f0,male> après
* * 20140912 1 20140912_Locuteur_1 3788.434 3792.394 <o,f0,male> la première ins() [pi] l'instruction de déclaration
* * 20140912 1 20140912_Locuteur_1 3792.394 3794.874 <o,f0,male> donc avant la première instruction, autrement dit,
* * 20140912 1 20140912_Locuteur_1 3794.874 3797.755 <o,f0,male> position est non définie, donc c'est point d'interrogation
* * 20140912 1 20140912_Locuteur_1 3797.755 3801.495 <o,f0,male> déplacement est non défini, donc c'est point d'interrogation.
* * 20140912 1 20140912_Locuteur_1 3801.495 3804.035 <o,f0,male> c'est comme ça que javascript note, c'est
* * 20140912 1 20140912_Locuteur_1 3804.035 3806.406 <o,f0,male> point d'interrogation
* * 20140912 1 20140912_Locuteur_1 3806.406 3809.660 <o,f0,male> undefined
* * 20140912 1 20140912_Locuteur_1 3809.660 3812.135 <o,f0,male> deuxième ligne de l'historique d'exécution :
* * 20140912 1 20140912_Locuteur_1 3812.135 3815.691 <o,f0,male> après l'instruction position égale vingt-cinq,
* * 20140912 1 20140912_Locuteur_1 3815.691 3820.338 <o,f0,male> ben position vaut vingt-cinq et déplacement est non défini
* * 20140912 1 20140912_Locuteur_1 3820.338 3824.511 <o,f0,male> et cetera, et cetera. donc il faut le lire comme ça, cet historique d'exécution
* * 20140912 1 20140912_Locuteur_1 3824.511 3828.023 <o,f0,male> ça s() ça vous semble pas très, très clair parce que c'est pas un tableau
* * 20140912 1 20140912_Locuteur_1 3828.023 3832.686 <o,f0,male> mais ça () il y a exactement les mêmes instru() informations que dans le tableau.
* * 20140912 1 20140912_Locuteur_1 3832.686 3835.410 <o,f0,male> les instructions ligne par ligne
* * 20140912 1 20140912_Locuteur_1 3835.410 3836.234 <o,f0,male> et
* * 20140912 1 20140912_Locuteur_1 3836.234 3839.605 <o,f0,male> les valeurs des variables qu'on veut suivre
* * 20140912 1 20140912_Locuteur_1 3839.605 3845.596 <o,f0,male> avec éventuellement des points d'interrogation.
* * 20140912 1 20140912_Locuteur_1 3845.596 3847.617 <o,f0,male> donc il y a une manière automatique de
* * 20140912 1 20140912_Locuteur_1 3847.617 3853.356 <o,f0,male> construire le l'historique d'exécution.
* * 20140912 1 20140912_Locuteur_1 3853.356 3858.193 <o,f0,male> avec évidemment une limite, mais la même limite que quand vous aurez à le construire à la main, c'est que euh
* * 20140912 1 20140912_Locuteur_1 3858.193 3861.100 <o,f0,male> si vous voulez construire un historique d'exécution
* * 20140912 1 20140912_Locuteur_1 3861.100 3862.598 <o,f0,male> de mille lignes,
* * 20140912 1 20140912_Locuteur_1 3862.598 3867.195 <o,f0,male> eh ben vous allez avoir un problème pour le visualiser.
* * 20140912 1 20140912_Locuteur_1 3867.195 3872.553 <o,f0,male> c'est un détail.
* * 20140912 1 20140912_Locuteur_1 3872.553 3874.820 <o,f0,male> voilà

deb_slide defaut 20140912 1 20140912_Locuteur_1 3874.820 3879.370 <o,f0,male> est-ce que vous avez des questions sur cette deuxième partie du cours
* * 20140912 1 20140912_Locuteur_1 3879.370 3895.772 <o,f0,male> avant qu'on entame la troisième partie ? on aura juste le temps de de l'introduire
* * 20140912 1 20140912_Locuteur_1 3895.772 3918.357 <o,f1,male> vous êtes bien calmes.
* defaut_fin 20140912 1 20140912_Locuteur_1 3918.357 3918.805 <o,f1,male> oui ?
* * 20140912 1 inter_segment_gap 3918.805 3921.760 <o,f1,> inter_segment_gap
* * 20140912 1 20140912_Locuteur_1 3921.760 3922.986 <o,f0,male> les tables de vérité ?

deb_slide * 20140912 1 20140912_Locuteur_1 3922.986 3933.161 <o,f0,male> je peux rev() donc on me demande de revenir sur les tables de vérité
* * 20140912 1 20140912_Locuteur_1 3933.161 3936.020 <o,f0,male> voilà
* * 20140912 1 20140912_Locuteur_1 3936.020 3938.874 <o,f0,male> donc qu'est-ce que c'est qu'une table de vérité ?
* * 20140912 1 20140912_Locuteur_1 3938.874 3941.119 <o,f0,male> c'est juste un tableau
* * 20140912 1 20140912_Locuteur_1 3941.119 3945.568 <o,f0,male> qui représente toutes les valeurs possibles d'une expression
* * 20140912 1 20140912_Locuteur_1 3945.568 3949.241 <o,f0,male> donc euh l'expression a ou b
* * 20140912 1 20140912_Locuteur_1 3949.241 3951.033 <o,f0,male> a quatre valeurs possibles
* * 20140912 1 20140912_Locuteur_1 3951.033 3953.816 <o,f0,male> euh a deux euh a quatre résultats possibles
* * 20140912 1 20140912_Locuteur_1 3953.816 3956.977 <o,f0,male> selon les valeurs de a ou de b.
* * 20140912 1 20140912_Locuteur_1 3956.977 3957.690 <o,f0,male> et
* * 20140912 1 20140912_Locuteur_1 3957.690 3963.640 <o,f0,male> a a deux valeurs possibles, b a deux valeurs possibles. donc on fait tous les croisements possibles de valeurs possibles entre a et b
* * 20140912 1 20140912_Locuteur_1 3963.640 3964.952 <o,f0,male> et on calcule
* * 20140912 1 20140912_Locuteur_1 3964.952 3966.509 <o,f0,male> la valeur de l'expression.
* * 20140912 1 20140912_Locuteur_1 3966.509 3968.590 <o,f0,male> la table de vérité, c'est juste
* * 20140912 1 20140912_Locuteur_1 3968.590 3972.829 <o,f0,male> une table qui donne toutes les valeurs possibles selon toutes les entrées possibles d'une valeur.
* * 20140912 1 20140912_Locuteur_1 3972.829 3974.647 <o,f0,male> et on ne le fait que pour les booléens
* * 20140912 1 20140912_Locuteur_1 3974.647 3976.496 <o,f0,male> parce que euh
* * 20140912 1 20140912_Locuteur_1 3976.496 3979.977 <o,f0,male> les booléens, il y a que deux valeurs possibles donc euh quand les combine là il y en a
* * 20140912 1 20140912_Locuteur_1 3979.977 3982.550 <o,f0,male> il y en a quatre parce que il y a deux entrées possibles
* * 20140912 1 20140912_Locuteur_1 3982.550 3985.177 <o,f0,male> donc tu as quatre combinaisons de
* * 20140912 1 20140912_Locuteur_1 3985.177 3986.865 <o,f0,male> de deux valeurs
* * 20140912 1 inter_segment_gap 3986.865 3990.363 <o,f0,> inter_segment_gap
* * 20140912 1 20140912_Locuteur_1 3990.363 3990.983 <o,f0,male> pardon ?
* * 20140912 1 inter_segment_gap 3990.983 3994.740 <o,f0,> inter_segment_gap
* * 20140912 1 20140912_Locuteur_1 3994.740 4000.988 <o,f0,male> la deuxième ligne, quand a est vrai et b est faux, on se pose la question de : que vaut a ou b ?
* * 20140912 1 inter_segment_gap 4000.988 4003.379 <o,f0,> inter_segment_gap
* * 20140912 1 20140912_Locuteur_1 4003.379 4003.968 <o,f0,male> hein ?
* * 20140912 1 inter_segment_gap 4003.968 4006.773 <o,f0,> inter_segment_gap
* * 20140912 1 20140912_Locuteur_1 4006.773 4009.700 <o,f0,male> ben c'est une une opération logique
* * 20140912 1 20140912_Locuteur_1 4009.700 4012.511 <o,f0,male> donc s() l'expression a ou b
* * 20140912 1 20140912_Locuteur_1 4012.511 4014.265 <o,f0,male> quand a est vrai
* * 20140912 1 20140912_Locuteur_1 4014.265 4015.909 <o,f0,male> et b est faux
* * 20140912 1 20140912_Locuteur_1 4015.909 4017.280 <o,f0,male> c'est vrai.
* * 20140912 1 20140912_Locuteur_1 4017.280 4018.980 <o,f0,male> parce que il y en a un des deux qui est vrai
* * 20140912 1 20140912_Locuteur_1 4018.980 4020.680 <o,f0,male> ou, c'est un des deux est vrai.
* * 20140912 1 inter_segment_gap 4020.680 4022.417 <o,f0,> inter_segment_gap
* * 20140912 1 20140912_Locuteur_1 4022.417 4023.131 <o,f0,male> pardon ?
* * 20140912 1 inter_segment_gap 4023.131 4026.220 <o,f0,> inter_segment_gap
* * 20140912 1 20140912_Locuteur_1 4026.220 4032.011 <o,f0,male> bah s() quand tu écris a ou b, tu cherches à savoir si un des deux est vrai
* * 20140912 1 20140912_Locuteur_1 4032.011 4033.350 <o,f0,male> parmi les deux
* * 20140912 1 20140912_Locuteur_1 4033.350 4035.550 <o,f0,male> quand tu mets a et b
* * 20140912 1 20140912_Locuteur_1 4035.550 4039.993 <o,f0,male> tu cherches uniquement les cas où les deux sont vrais en même temps ;
* * 20140912 1 20140912_Locuteur_1 4039.993 4042.212 <o,f0,male> c'est () d'où d'où la table de vérité.
* * 20140912 1 20140912_Locuteur_1 4042.212 4044.584 <o,f0,male> d'accord ?
* * 20140912 1 20140912_Locuteur_1 4044.584 4048.800 <o,f0,male> voilà
* * 20140912 1 20140912_Locuteur_1 4048.800 4049.826 <o,f0,male> ok ?
* * 20140912 1 20140912_Locuteur_1 4049.826 4059.610 <o,f0,male> on peut passer ?

deb_slide gran_2 20140912 1 20140912_Locuteur_1 4059.610 4064.280 <o,f0,male> voilà, donc on passe à la troisième partie
* * 20140912 1 20140912_Locuteur_1 4064.280 4069.430 <o,f0,male> on a quelques minutes pour l'introduire,
* * 20140912 1 20140912_Locuteur_1 4069.430 4072.730 <o,f0,male> donc je vais conclure la deuxième partie comme ça :
* * 20140912 1 20140912_Locuteur_1 4072.730 4074.767 <o,f0,male> jusqu'à présent,
* * 20140912 1 20140912_Locuteur_1 4074.767 4075.904 <o,f0,male> en ne faisant
* * 20140912 1 20140912_Locuteur_1 4075.904 4080.171 <o,f0,male> que de la séquentialité avec des saisies, des calculs, des affichages
* * 20140912 1 20140912_Locuteur_1 4080.171 4085.023 <o,f0,male> croyez-moi, vous n'allez pas aller très très loin.
* * 20140912 1 20140912_Locuteur_1 4085.023 4088.534 <o,f0,male> je crois que même () on n'est même pas encore au niveau d'un langage de programmation ;
* * 20140912 1 20140912_Locuteur_1 4088.534 4090.091 <o,f0,male> il manque des choses pour
* * 20140912 1 20140912_Locuteur_1 4090.091 4093.404 <o,f0,male> parler de langage de programmation.
* * 20140912 1 20140912_Locuteur_1 4093.404 4095.099 <o,f0,male> et les choses qui manquent,
* * 20140912 1 20140912_Locuteur_1 4095.099 4099.896 <o,f0,male> c'est ce qu'on va voir maintenant dans cette partie, ce sont les structures de contrôle.
* * 20140912 1 20140912_Locuteur_1 4099.896 4102.491 <o,f0,male> autrement dit, ce qu'on va chercher à faire, c'est
* * 20140912 1 20140912_Locuteur_1 4102.491 4103.909 <o,f0,male> avoir des cas
* * 20140912 1 20140912_Locuteur_1 4103.909 4107.597 <o,f0,male> où certaines instructions, on les évite
* * 20140912 1 20140912_Locuteur_1 4107.597 4112.851 <o,f0,male> donc avoir des bifurcations dans le programme
* * 20140912 1 20140912_Locuteur_1 4112.851 4118.364 <o,f0,male> et il il va y avoir des cas où on va vouloir répéter un certain nombre d'instructions.
* * 20140912 1 20140912_Locuteur_1 4118.364 4122.486 <o,f0,male> donc ce qu'on va introduire dans cette partie, c'est les bifurcations et les répétitions,
* * 20140912 1 20140912_Locuteur_1 4122.486 4124.398 <o,f0,male> qu'on appelle conditionnelles

deb_slide * 20140912 1 20140912_Locuteur_1 4124.398 4131.621 <o,f0,male> et qu'on appelle répétitives.
* gran_1 20140912 1 20140912_Locuteur_1 4131.621 4133.920 <o,f0,male> alors petit rappel :
* * 20140912 1 20140912_Locuteur_1 4133.920 4137.552 <o,f0,male> donc le l'ordre logique d'organisation, c'est ça :
* * 20140912 1 20140912_Locuteur_1 4137.552 4144.238 <o,f0,male> une instruction a suivie d'une instruction b, ça s'écrit a point-virgule b
* * 20140912 1 20140912_Locuteur_1 4144.238 4146.261 <o,f0,male> et puis si on
* * 20140912 1 20140912_Locuteur_1 4146.261 4150.799 <o,f0,male> le l'effet, ce sera d'exécuter l'instruction a puis d'exécuter l'instruction b.
* * 20140912 1 20140912_Locuteur_1 4150.799 4153.989 <o,f0,male> c'est très mal choisi *parce que j'aurais pas dû appeler mes variables a et b.
* * 20140912 1 20140912_Locuteur_1 4153.989 4155.744 <o,f0,male> donc prenons euh deux exemples :
* * 20140912 1 20140912_Locuteur_1 4155.744 4157.596 <o,f0,male> les deux () dans les deux exemples,
* * 20140912 1 20140912_Locuteur_1 4157.596 4159.289 <o,f0,male> j'ai quatre instructions
* * 20140912 1 20140912_Locuteur_1 4159.289 4163.577 <o,f0,male> ce sont les quatre mêmes instructions, sauf que je change l'ordre des deux dernières
* * 20140912 1 20140912_Locuteur_1 4163.577 4167.145 <o,f0,male> entre le premier et le deuxième, bah s() c'est pas les mêmes algorithmes

deb_slide * 20140912 1 20140912_Locuteur_1 4167.145 4173.230 <o,f0,male> et pourquoi c'est pas les mêmes algorithmes ? eh bah si on construit les historiques d'exécution
* * 20140912 1 20140912_Locuteur_1 4173.230 4176.790 <o,f0,male> dans un cas, j'ai ça :
* * 20140912 1 20140912_Locuteur_1 4176.790 4181.817 <o,f0,male> donc avant un, j'ai () je ne sais pas ce que j'ai, après un j'ai sept dans a
* * 20140912 1 20140912_Locuteur_1 4181.817 4186.267 <o,f0,male> on ne sait pas dans b, après deux j'ai sept dans a, cinq dans b, ça ça changera pas ;
* * 20140912 1 20140912_Locuteur_1 4186.267 4189.862 <o,f0,male> après trois, je mets douze dans a, cinq dans b
* * 20140912 1 20140912_Locuteur_1 4189.862 4193.569 <o,f0,male> et je mets dix-sept dans b et douze () je garde douze en
* * 20140912 1 20140912_Locuteur_1 4193.569 4194.310 <o,f0,male> dans a.

deb_slide * 20140912 1 20140912_Locuteur_1 4194.310 4197.437 <o,f0,male> ça, c'est le premier historique d'exécution. le deuxième historique,
* * 20140912 1 20140912_Locuteur_1 4197.437 4201.980 <o,f0,male> c'est celui-là, et ce qu'on voit bien, c'est que à la fin
* * 20140912 1 20140912_Locuteur_1 4201.980 4205.007 <o,f0,male> les deux historiques d'exécution sont très () sont différents :
* * 20140912 1 20140912_Locuteur_1 4205.007 4207.443 <o,f0,male> dans un cas, a vaut dix-neuf
* * 20140912 1 20140912_Locuteur_1 4207.443 4209.940 <o,f0,male> et b vaut douze, et dans l'autre cas a vaut
* * 20140912 1 20140912_Locuteur_1 4209.940 4211.524 <o,f0,male> douze et b vaut dix-sept.
* * 20140912 1 20140912_Locuteur_1 4211.524 4214.451 <o,f0,male> c'est pas les mêmes chiffres, c'est pas les mêmes calculs,
* * 20140912 1 20140912_Locuteur_1 4214.451 4216.149 <o,f0,male> c'est pas les mêmes algorithmes ;
* * 20140912 1 20140912_Locuteur_1 4216.149 4218.285 <o,f0,male> ils résolvent pas le même problème.
* * 20140912 1 20140912_Locuteur_1 4218.285 4219.968 <o,f0,male> et pourtant
* * 20140912 1 20140912_Locuteur_1 4219.968 4222.568 <o,f0,male> c'est le même ensemble d'instructions,
* * 20140912 1 20140912_Locuteur_1 4222.568 4224.402 <o,f0,male> on a juste changé l'ordre.
* * 20140912 1 20140912_Locuteur_1 4224.402 4226.195 <o,f0,male> donc la séquentialité,
* * 20140912 1 20140912_Locuteur_1 4226.195 4228.740 <o,f0,male> l'ordre des instructions est important.

deb_slide * 20140912 1 20140912_Locuteur_1 4228.740 4233.127 <o,f0,male> ça, c'est le petit rappel.
* * 20140912 1 20140912_Locuteur_1 4233.127 4234.490 <o,f0,male> mais par contre
* * 20140912 1 20140912_Locuteur_1 4234.490 4237.320 <o,f0,male> on va pas très très loin
* * 20140912 1 20140912_Locuteur_1 4237.320 4240.644 <o,f0,male> en n'écrivant que ces choses-là.
* * 20140912 1 20140912_Locuteur_1 4240.644 4247.327 <o,f0,male> pourquoi ? ben tout simplement parce que dans certains cas, on aura plusieurs possibilités d'instructions, on aura plusieurs
* * 20140912 1 20140912_Locuteur_1 4247.327 4249.004 <o,f0,male> bifurcations
* * 20140912 1 20140912_Locuteur_1 4249.004 4255.602 <o,f0,male> imaginez : vous êtes dans un labyrinthe, vous avez trois choix possibles, [pi] vous voulez coder un algorithme qui résout ce problème de labyrinthe.
* * 20140912 1 20140912_Locuteur_1 4255.602 4259.770 <o,f0,male> avec ce qu'on a vu jusqu'à présent, vous n'êtes pas capable de le faire
* * 20140912 1 20140912_Locuteur_1 4259.770 4264.120 <o,f0,male> parce que il y a un choix à faire.
* * 20140912 1 20140912_Locuteur_1 4264.120 4267.392 <o,f0,male> on a aussi besoin de répéter les choses
* * 20140912 1 20140912_Locuteur_1 4267.392 4270.132 <o,f0,male> donc d'itérer plusieurs fois la même instruction
* * 20140912 1 20140912_Locuteur_1 4270.132 4272.096 <o,f0,male> avancer dans le labyrinthe
* * 20140912 1 20140912_Locuteur_1 4272.096 4275.456 <o,f0,male> avancer une fois, avancer deux fois, avancer trois fois jusqu'à tomber à un mur
* * 20140912 1 20140912_Locuteur_1 4275.456 4278.100 <o,f0,male> sur un mur
* * 20140912 1 20140912_Locuteur_1 4278.100 4281.591 <o,f0,male> ou jusqu'à tomber sur une bifurcation :
* * 20140912 1 20140912_Locuteur_1 4281.591 4284.642 <o,f0,male> si on a envie d'aller à droite, on va à droite ; si on a envie d'aller à gauche, on va à gauche ;
* * 20140912 1 20140912_Locuteur_1 4284.642 4286.875 <o,f0,male> si on est déjà passé par la droite,
* * 20140912 1 20140912_Locuteur_1 4286.875 4291.840 <o,f0,male> on va vers la gauche ; si on est déjà passé vers la gauche, on va vers la droite.
* * 20140912 1 20140912_Locuteur_1 4291.840 4294.330 <o,f0,male> donc vraiment, on a envie de pouvoir
* * 20140912 1 20140912_Locuteur_1 4294.330 4298.500 <o,f0,male> coder ces résolutions de problèmes-là en informatique.

deb_slide * 20140912 1 20140912_Locuteur_1 4298.500 4302.203 <o,f0,male> l'analogie, c'est vraiment des problèmes de labyrinthe.
* * 20140912 1 20140912_Locuteur_1 4302.203 4307.001 <o,f0,male> voilà, donc modifier l'ordre naturel les instructions se fait à l'aide de structures de contrôle
* * 20140912 1 20140912_Locuteur_1 4307.001 4313.836 <o,f0,male> qu'on appelle structures conditionnelles et qu'on appelle structures répétitives.
* gran_1 20140912 1 20140912_Locuteur_1 4313.836 4315.623 <o,f0,male> et dans cette partie,
* * 20140912 1 20140912_Locuteur_1 4315.623 4318.420 <o,f0,male> on verra une structure conditionnelle

deb_slide * 20140912 1 20140912_Locuteur_1 4318.420 4326.040 <o,f0,male> et deux structures répétitives.
* * 20140912 1 20140912_Locuteur_1 4326.040 4330.603 <o,f0,male> donc à quoi servent les conditionnelles ?
* * 20140912 1 20140912_Locuteur_1 4330.603 4335.342 <o,f0,male> bon on verra l() la syntaxe et l'usage des conditionnelles,
* * 20140912 1 20140912_Locuteur_1 4335.342 4338.863 <o,f0,male> on parlera de conditionnelles imbriquées, d'arbres de décision

deb_slide * 20140912 1 20140912_Locuteur_1 4338.863 4346.180 <o,f0,male> dans cette euh partie sur les conditionnelles
* * 20140912 1 20140912_Locuteur_1 4346.180 4350.924 <o,f0,male> mais je vais k() d'abord commencer par les motivations : pourquoi on a besoin de conditionnelles ?
* * 20140912 1 20140912_Locuteur_1 4350.924 4353.445 <o,f0,male> *parce qu'il y a des () *enfin voilà des cas concrets
* * 20140912 1 20140912_Locuteur_1 4353.445 4357.537 <o,f0,male> où on a besoin d'une conditionnelle.
* * 20140912 1 20140912_Locuteur_1 4357.537 4359.042 <o,f0,male> pour calculer la valeur
* * 20140912 1 20140912_Locuteur_1 4359.042 4362.460 <o,f0,male> absolue d'un nombre
* * 20140912 1 20140912_Locuteur_1 4362.460 4364.930 <o,f0,male> bah là j'ai deux choix :
* * 20140912 1 20140912_Locuteur_1 4364.930 4369.108 <o,f0,male> la valeur absolue d'un nombre, c'est ce nombre quand il est positif,
* * 20140912 1 20140912_Locuteur_1 4369.108 4371.577 <o,f0,male> mais c'est moins ce nombre quand il est négatif ;
* * 20140912 1 20140912_Locuteur_1 4371.577 4373.067 <o,f0,male> donc il y a un choix à faire,
* * 20140912 1 20140912_Locuteur_1 4373.067 4376.465 <o,f0,male> il y a une conditionnelle là, derrière.
* * 20140912 1 20140912_Locuteur_1 4376.465 4379.508 <o,f0,male> afficher l'inverse d'un nombre
* * 20140912 1 20140912_Locuteur_1 4379.508 4382.389 <o,f0,male> a priori, il y a pas de conditionnelle quand on fait un sur x
* * 20140912 1 20140912_Locuteur_1 4382.389 4386.160 <o,f0,male> sauf quand x est égal à zéro. donc il y a un cas particulier à traiter :
* * 20140912 1 20140912_Locuteur_1 4386.160 4387.187 <o,f0,male> il y a une conditionnelle
* * 20140912 1 20140912_Locuteur_1 4387.187 4390.370 <o,f0,male> derrière.
* * 20140912 1 20140912_Locuteur_1 4390.370 4395.870 <o,f0,male> jouer au jeu du plus ou moins, bah ça ça va nous occuper à la fin, *enfin on va programmer ça.
* * 20140912 1 20140912_Locuteur_1 4395.870 4401.304 <o,f0,male> il y a une conditionnelle parce que il y a un moment où faudra lui dire : c'est plus que la valeur proposée ou c'est moins que la valeur proposée ;
* * 20140912 1 20140912_Locuteur_1 4401.304 4404.252 <o,f0,male> il y a une conditionnelle.
* * 20140912 1 20140912_Locuteur_1 4404.252 4410.660 <o,f0,male> en gros, il y a des conditionnelles dans tous les cas où il y a des traitements alternatifs à faire.

deb_slide * 20140912 1 20140912_Locuteur_1 4410.660 4418.130 <o,f0,male> et d'ailleurs, la conditionnelle on l'appelle parfois une alternative.
* gran_1 20140912 1 20140912_Locuteur_1 4418.130 4422.184 <o,f0,male> donc voilà la syntaxe des alternatives,
* * 20140912 1 20140912_Locuteur_1 4422.184 4425.596 <o,f0,male> la syntaxe algorithmique
* * 20140912 1 20140912_Locuteur_1 4425.596 4427.446 <o,f0,male> ça s'écrira comme ça:
* * 20140912 1 20140912_Locuteur_1 4427.446 4429.312 <o,f0,male> si entre parenthèses
* * 20140912 1 20140912_Locuteur_1 4429.312 4431.849 <o,f0,male> une expression booléenne
* * 20140912 1 20140912_Locuteur_1 4431.849 4435.026 <o,f0,male> qui est une condition, en fait
* * 20140912 1 20140912_Locuteur_1 4435.026 4436.844 <o,f0,male> alors
* * 20140912 1 20140912_Locuteur_1 4436.844 4438.068 <o,f0,male> des instructions
* * 20140912 1 20140912_Locuteur_1 4438.068 4441.896 <o,f0,male> quand la condition est () qui seront exécutées quand la condition est vraie,
* * 20140912 1 20140912_Locuteur_1 4441.896 4447.861 <o,f0,male> sinon, des instructions qui seront exécutées quand le la condition est fausse.
* * 20140912 1 20140912_Locuteur_1 4447.861 4450.780 <o,f0,male> et là, je vous mets un exemple :
* * 20140912 1 20140912_Locuteur_1 4450.780 4454.578 <o,f0,male> si on a demandé à l'utilisateur de saisir son âge,
* * 20140912 1 20140912_Locuteur_1 4454.578 4460.849 <o,f0,male> si l'âge est inférieur à dix-huit alors on peut lui écrire : vous êtes euh mineur
* * 20140912 1 20140912_Locuteur_1 4460.849 4464.636 <o,f0,male> sinon, on peut lui écrire : vous êtes majeur
* * 20140912 1 20140912_Locuteur_1 4464.636 4467.689 <o,f0,male> et ne pas oublier le finsi.

deb_slide * 20140912 1 20140912_Locuteur_1 4467.689 4477.280 <o,f0,male> donc voilà la syntaxe des alternatives.
* * 20140912 1 20140912_Locuteur_1 4477.280 4478.050 <o,f0,male> alors
* * 20140912 1 20140912_Locuteur_1 4478.050 4481.999 <o,f0,male> la condition, c'est n'importe quelle expression dont la valeur est booléenne.
* * 20140912 1 20140912_Locuteur_1 4481.999 4482.801 <o,f0,male> donc
* * 20140912 1 20140912_Locuteur_1 4482.801 4484.812 <o,f0,male> âge inférieur à dix-huit
* * 20140912 1 20140912_Locuteur_1 4484.812 4486.770 <o,f0,male> ça, c'est une condition simple
* * 20140912 1 20140912_Locuteur_1 4486.770 4491.009 <o,f0,male> mais on verra qu'on peut en construire avec des opérateurs logiques,
* * 20140912 1 20140912_Locuteur_1 4491.009 4498.090 <o,f0,male> on peut construire des expressions booléennes qui peuvent être un peu compliquées.

deb_slide gran_1 20140912 1 20140912_Locuteur_1 4498.090 4504.249 <o,f0,male> donc pre() première chose : un petit cas particulier de cette euh alternative, c'est qu'en fait elle se p() elle peut se simplifier
* * 20140912 1 20140912_Locuteur_1 4504.249 4507.489 <o,f0,male> dans beaucoup de langages, elle peut se simplifier
* * 20140912 1 20140912_Locuteur_1 4507.489 4510.691 <o,f0,male> parce qu'il est () parfois on n'a pas une alternative,
* * 20140912 1 20140912_Locuteur_1 4510.691 4512.436 <o,f0,male> on a juste une expression
* * 20140912 1 20140912_Locuteur_1 4512.436 4516.311 <o,f0,male> qu'on ne veut faire que dans un certain cas.
* * 20140912 1 20140912_Locuteur_1 4516.311 4522.112 <o,f0,male> donc c'est pas une alternative entre deux expressions, c'est une expression qui apparaît ou qui n'est p() qui est là où qui n'est pas là.
* * 20140912 1 20140912_Locuteur_1 4522.112 4525.040 <o,f0,male> et dans ce cas-là, on utilise une conditionnelle simple
* * 20140912 1 20140912_Locuteur_1 4525.040 4527.687 <o,f0,male> qui est en fait un cas particulier de l'alternative,
* * 20140912 1 20140912_Locuteur_1 4527.687 4532.273 <o,f0,male> donc l'écriture est la même, sauf qu'il y a pas de sinon.
* * 20140912 1 20140912_Locuteur_1 4532.273 4536.070 <o,f0,male> donc même écriture sans le sinon,
* * 20140912 1 20140912_Locuteur_1 4536.070 4538.830 <o,f0,male> donc par exemple :
* * 20140912 1 20140912_Locuteur_1 4538.830 4541.622 <o,f0,male> pour calculer l'inverse de x,
* * 20140912 1 20140912_Locuteur_1 4541.622 4548.899 <o,f0,male> bah on a juste à exécuter l'instruction x reçoit moins x quand x est négatif.
* * 20140912 1 20140912_Locuteur_1 4548.899 4550.530 <o,f0,male> mais
* * 20140912 1 20140912_Locuteur_1 4550.530 4552.584 <o,f0,male> quand on sera ici, on aura toujours
* * 20140912 1 20140912_Locuteur_1 4552.584 4556.014 <o,f0,male> x qui vaut la valeur absolue de x.
* * 20140912 1 20140912_Locuteur_1 4556.014 4557.330 <o,f0,male> d'accord ?

deb_slide gran_1 20140912 1 20140912_Locuteur_1 4557.330 4565.130 <o,f0,male> donc il y a cette conditionnelle.
* * 20140912 1 20140912_Locuteur_1 4565.130 4570.542 <o,f0,male> on en arrive à sa traduction en javascript, et puis on s'arrêtera sur euh cette traduction en javascript
* * 20140912 1 20140912_Locuteur_1 4570.542 4575.193 <o,f0,male> donc la traduction de l'al() de l'alternative en javascript, cette alternative-là
* * 20140912 1 20140912_Locuteur_1 4575.193 4576.930 <o,f0,male> ça devient ça, donc
* * 20140912 1 20140912_Locuteur_1 4576.930 4579.670 <o,f0,male> la traduction elle est presque littérale :
* * 20140912 1 20140912_Locuteur_1 4579.670 4583.176 <o,f0,male> le si devient if,
* * 20140912 1 20140912_Locuteur_1 4583.176 4587.982 <o,f0,male> on limite le nombre de mots-clés dans le langage, donc il y a pas de alors parce que le alors il est toujours là
* * 20140912 1 20140912_Locuteur_1 4587.982 4591.472 <o,f0,male> donc en fait, comme il est toujours là, on s'en on s'en passe.
* * 20140912 1 20140912_Locuteur_1 4591.472 4595.753 <o,f0,male> par contre, ce est important, c'est d'avoir des accolades ici, ouvrantes et fermantes,
* * 20140912 1 20140912_Locuteur_1 4595.753 4601.578 <o,f0,male> parce que là on n'a mis qu'une instruction, mais on peut imaginer que il y ait une suite d'instructions, ben il y a bien un moment
* * 20140912 1 20140912_Locuteur_1 4601.578 4604.928 <o,f0,male> où faut délimiter cette suite d'instructions.
* * 20140912 1 20140912_Locuteur_1 4604.928 4610.623 <o,f0,male> dans le langage javascript, délimiter une suite d'instructions, ça se fait avec des accolades.
* * 20140912 1 20140912_Locuteur_1 4610.623 4614.006 <o,f0,male> le sinon, ben *comme celui-là il est pas toujours présent,
* * 20140912 1 20140912_Locuteur_1 4614.006 4616.409 <o,f0,male> on est obligé de le spécifier ici
* * 20140912 1 20140912_Locuteur_1 4616.409 4618.748 <o,f0,male> donc euh sinon en anglais, ça se dit else.

deb_slide * 20140912 1 20140912_Locuteur_1 4618.748 4622.114 <o,f0,male> et de la même manière, on met des accolades ouvrantes et fermantes,
* * 20140912 1 20140912_Locuteur_1 4622.114 4623.530 <o,f0,male> voilà.
* * 20140912 1 20140912_Locuteur_1 4623.530 4625.337 <o,f0,male> juste pour terminer
* * 20140912 1 20140912_Locuteur_1 4625.337 4627.080 <o,f0,male> quand il y a pas le sinon,
* * 20140912 1 20140912_Locuteur_1 4627.080 4628.575 <o,f0,male> bah il y a pas le else
* * 20140912 1 20140912_Locuteur_1 4628.575 4633.550 <o,f0,male> dans la syntaxe.

deb_slide * 20140912 1 20140912_Locuteur_1 4633.550 4638.859 <o,f0,male> voilà, bon on s'arrête là-dessus
* * 20140912 1 20140912_Locuteur_1 4638.859 4647.520 <o,f0,male> et on se revoit jeudi à onze heures.
