<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE Trans SYSTEM "trans-14.dtd">
<Trans audio_filename="20140912" version="3" version_date="170613">
<Speakers>
<Speaker id="spk40" name="Locuteur 1" check="no" type="male" dialect="native" accent="" scope="local"/>
</Speakers>
<Episode>
<Section type="report" startTime="0" endTime="4647.520">
<Turn startTime="0.0" endTime="0.552">
<Sync time="0.0"/>

</Turn>
<Turn speaker="spk40" mode="planned" fidelity="high" channel="studio" startTime="0.552" endTime="1994.471">
<Sync time="0.552"/>
alors maintenant on va passer à la
<Sync time="2.883"/>
à la *deuxième, donc on a on a nommé les variables
<Sync time="5.77"/>
on a vu que c'est () donner un nom, ça permettait d'accéder à un ensemble de cases mémoires
<Sync time="12.450"/>
mais là, je vous avais dit que le nombre de cases mémoires réservées et associées à chaque nom
<Sync time="17.482"/>
dépendait de ce qu'on stockait dans la variable.
<Sync time="20.834"/>
autrement dit, ça dépendait du type qu'on allait attribuer à la variable.
<Sync time="28.080"/>
donc c'est important de se poser ce genre de questions
<Sync time="30.592"/>
et là on va v() on va parler euh
<Sync time="32.846"/>
on va parler des différents types de bases.
<Sync time="35.120"/>
donc euh j'avais dit les n() les nombres
<Sync time="37.963"/>
les chaînes de caractères,
<Sync time="39.905"/>
les booléens,
<Sync time="43.360"/>
eh ben on va les faire tous un par un.
<Sync time="45.301"/>
et on va aller même un peu plus dans le détail, puisque là on va commencer par les nombres entiers.
<Sync time="49.600"/>
ou numériques entiers
<Sync time="52.792"/>
alors qu'est-ce que c'est qu'un numérique entier en informatique ?
<Sync time="56.181"/>
ben déjà, je vous rappelle ce que c'est qu'en maths :
<Sync time="59.094"/>
en maths, c'est un élément de z
<Sync time="61.412"/>
moins l'infini plus l'infini.
<Sync time="63.997"/>
c'est pas ça en informatique :
<Sync time="66.046"/>
en informatique, on est toujours limité au fait que votre machine, vous la posez sur un bureau, elle est () elle a une taille fixée.
<Sync time="73.978"/>
donc vous pourrez pas mettre un nombre infini, vous pourrez pas définir
<Sync time="77.527"/>
un nombre infini
<Sync time="79.495"/>
de valeurs
<Sync time="80.500"/>
dans un es() dans un ensemble fini,
<Sync time="82.82"/>
dans une boîte f() de taille finie.
<Sync time="87.170"/>
donc en informatique, c'est pas tous les entiers des maths
<Sync time="90.471"/>
mais c'est qu'un sous-ensemble de ces entiers
<Sync time="92.895"/>
autrement dit, c'est l'ensemble tous les entiers qu'on peut écrire selon une règle qu'on se fixe.
<Sync time="98.354"/>
la règle
<Sync time="99.627"/>
elle est fixée au niveau international, par une norme euh iso et cetera et cetera
<Sync time="104.816"/>
mais en tout cas
<Sync time="106.532"/>
elle est donnée, et elle est donnée pour chaque langage informatique. donc il y a une règle
<Sync time="110.251"/>
d'écriture,
<Sync time="112.211"/>
et en appliquant cette règle d écriture,
<Sync time="114.485"/>
on sait combien d'entiers on va pouvoir euh écrire.
<Sync time="119.782"/>
si on suit la règle d'écriture des entiers dans un langage euh c
<Sync time="124.133"/>
un langage euh c'est un langage informatique très connu et très très utilisé,
<Sync time="128.647"/>
en c et
<Sync time="129.893"/>
et sur mon mac,
<Sync time="131.743"/>
puisque le c sur euh
<Sync time="134.059"/>
une autre machine ça peut être différent,
<Sync time="136.354"/>
alors
<Sync time="137.481"/>
on ()
<Sync time="138.054"/>
un entier en informatique du c
<Sync time="141.416"/>
ce sera toutes les valeurs entre moins
<Sync time="146.430"/>
deux milliards cent quarante-sept millions et cetera, donc qui z() qui est en fait moins deux à la puissance trente et un
<Sync time="153.002"/>
et
<Sync time="154.216"/>
la même chose en positif
<Sync time="157.542"/>
ou aut() ou plutôt deux à la puissance trente et un moins un.
<Sync time="162.774"/>
donc c'est () les entiers en c, c'est tous ces nombres-là
<Sync time="165.985"/>
c'est pas
<Sync time="167.136"/>
c'est pas tous les nombres d() entre moins l'infini et plu() et plus l'infini, c'est tous ces nombres-là.
<Sync time="171.153"/>

<Event desc="pi" type="pronounce" extent="instantaneous"/>

<Sync time="172.056"/>
donc javascript, l'avantage du javascript c'est que c'est euh
<Sync time="176.464"/>
la même représentation
<Sync time="178.146"/>
des nombres quelle que que soit l'architecture
<Sync time="181.110"/>
et là, des nombres entiers on peut en représenter un petit peu plus
<Sync time="184.810"/>
donc on peut peut en représenter
<Sync time="187.167"/>
je sais pas lire ce nombre
<Sync time="188.929"/>
vous savez peut-être le lire vous
<Sync time="190.61"/>
mais ce nombre, c'est moins deux à la puissance cinquante-trois
<Sync time="193.585"/>
jusqu() d() on peut représenter tous les entiers entre moins deux à la puissance cinquante-trois
<Sync time="198.038"/>
et plus deux à la puissance cinquante-trois.
<Sync time="200.962"/>
donc on peut représenter tout ceux-là, et puis en fait on peut en représenter quelques-uns mais ils sont plus consécutifs
<Sync time="205.758"/>
quelques-uns supplémentaires, mais ils sont plus consécutifs.
<Sync time="210.430"/>
donc euh
<Sync time="212.93"/>
voilà. donc premier type de base, les entiers
<Sync time="215.508"/>
et c'est important de savoir utiliser des entiers
<Sync time="220.12"/>
et de ma() c'est important de savoir euh j() mu() manipuler des entiers parce que c'est vraiment un type de base.
<Sync time="226.532"/>
alors en réalité
<Sync time="229.161"/>
en informatique, on utilise pas vraiment des entiers. le type de base de l'informatique, c'est
<Sync time="233.890"/>
le nombre binaire : zéro ou un.
<Sync time="237.060"/>
mais c'est pas grave, parce que euh
<Sync time="239.209"/>
pour représenter un entier avec un nombre binaire, donc ça c'est un nombre binaire
<Sync time="243.655"/>
qui représente l'entier cent trente-cinq, il suffit de le réécrire comme ça
<Sync time="246.984"/>
donc qu'est-ce que c'est que cent trente-cinq ? c'est une fois
<Sync time="250.056"/>
cent vingt-huit
<Sync time="251.427"/>
cent vingt huit, c'est deux à la puissance sept
<Sync time="253.643"/>
et ça c'est une valeur fixée,
<Sync time="255.619"/>
plus zéro fois soixante-quatre ; soixante-quatre, c'est deux à la puissance six,
<Sync time="259.887"/>
plus zéro fois s() trente-deux, plus et cetera plus et cetera
<Sync time="263.779"/>
plus une fois quatre, plus une fois deux, plus une fois un.
<Sync time="266.162"/>
donc deux à la puissance zéro, deux à la puissance un, deux à la puissance deux, il manque deux à la puissance trois, et cetera.
<Sync time="270.682"/>
donc on on est capable de représenter
<Sync time="273.386"/>
le nombre cent trente-cinq
<Sync time="275.258"/>
par cette suite de uns et de zéros qui est utilisée pour reconstruire cent trente-cinq comme ça.
<Sync time="284.090"/>
si on utilise
<Event desc="mic" type="noise" extent="previous"/>

<Sync time="291.980"/>
si on utilise huit euh bits, donc huit zéros ou () des suites de huit zéros ou uns,
<Sync time="297.794"/>
on pourra écrire tous les nombres entre
<Sync time="300.829"/>
zéro et deux cent cinquante-cinq
<Sync time="304.986"/>
hein
<Sync time="306.519"/>
si on fait ce calcul-là, on () c'est c'est facile de s'en rendre compte.
<Sync time="311.610"/>
si on en utilise cinquante euh trois, on pourra représenter tous les nombres de
<Sync time="317.012"/>
tous les nombres consécutifs
<Sync time="318.713"/>
du javascript.
<Sync time="322.836"/>
mais vous avez vu qu'il y avait des nombres négatifs, *mais c'est pas grave.
<Sync time="325.746"/>
en fait, on se permet d'en représenter
<Sync time="327.490"/>
que la moitié
<Sync time="328.843"/>
de positifs
<Sync time="330.198"/>
et on se sert d'un bit
<Sync time="332.102"/>
qui définira le signe.
<Sync time="334.520"/>
donc euh si je réserve ce signe-là,
<Sync time="337.511"/>
ce bit-là
<Sync time="338.620"/>
comme signe, je peux représenter
<Sync time="340.880"/>
tous les nombres entre moins cent vingt-huit et plus cent vingt-sept, au lieu de tous les nombres entre zéro et deux cent cinquante.
<Sync time="345.52"/>
bon, bref, moralité :
<Sync time="347.405"/>
on peut coder les entiers avec uniquement des bits
<Sync time="350.028"/>
zéro un.
<Sync time="350.743"/>
et ça c'est bien, parce qu'en mémoire on ne peut représenter que des bits ; c'est () il y a que des interrupteurs en mémoire.
<Sync time="355.252"/>
donc le fait qu'on sache représenter des entiers
<Sync time="357.712"/>
par des interrupteurs, c'est bien.
<Sync time="361.485"/>
c'est la moralité.
<Sync time="362.653"/>
deuxième type de base : le nombre réel.
<Sync time="366.807"/>
alors les réels en mathématiques, je fais encore la même analogie, c'est tous les éléments de l'ensemble r.
<Sync time="371.915"/>
là j'invente rien
<Sync time="374.145"/>
par contre en informatique,
<Sync time="375.809"/>
pour la même raison
<Sync time="377.757"/>
c'est pas tous les nombres de r ; c'est qu'un sous-ensemble qu'on appelle les flottants.
<Sync time="383.371"/>
donc l() les flottants,
<Sync time="385.852"/>
ce sont ceux qu'on peut écrire *selon une règle d'écriture donnée et qui dépend du langage informatique.
<Sync time="393.970"/>
les flottants en c sont certains réels, donc pas tous les réels parce que évidemment entre deux
<Sync time="399.572"/>
réels, on peut mettre une infinité de réels
<Sync time="402.557"/>
r est un ensemble dense
<Sync time="404.731"/>
donc on n'a on n'a pas cette propriété pour euh dans les règles d'écriture
<Sync time="410.030"/>
mais ce sont d() voilà, ce qu'on dit c'est qu'en c, ce sont certains réels dont les posi() les nombres positifs sont compris entre un nombre très petit : trois point quatre à la () dix à la puissance moins trente-huit
<Sync time="420.147"/>
et un nombre très grand : trois point quatre fois dix à la puissance trente-huit.
<Sync time="424.887"/>
et puis la même chose pour les nombres négatifs
<Sync time="429.697"/>
voilà, donc on pourra se rapprocher très
<Sync time="431.716"/>
près de zéro
<Sync time="434.445"/>
au point qu'on pourra dire que c'est zéro
<Sync time="437.356"/>
on pourra avoir un très grand nombre
<Sync time="439.212"/>
et puis on aura un certain nombre de nombres réels
<Sync time="441.342"/>
codés
<Sync time="442.555"/>
entre les deux.
<Sync time="443.782"/>
euh en javascript, les nombres réels s'appellent les numbers.
<Sync time="451.653"/>
et ce sont ceux-là
<Sync time="454.338"/>
en javascript
<Sync time="456.206"/>
donc euh
<Sync time="457.740"/>
comment on fait pour les définir, ces numbers ? et puis c'est comment on fait pour définir les flottants aussi, c'est à peu près la même norme.
<Sync time="464.983"/>
eh ben on se souvient qu'un ordinateur ne sait nativement manipuler que des entiers
<Sync time="469.633"/>
même plus précisément, que des zéros et des uns, c'est ce qu'on a vu jusqu'à présent
<Sync time="472.435"/>
donc nativement, on ne sait manipuler que des entiers, donc on va essayer de s'en sortir avec des entiers.
<Sync time="477.410"/>
et l'astuce pour représenter un nombre réel,
<Sync time="480.429"/>
c'est de le noter sous une notation ingénieur
<Sync time="482.787"/>
vous connaissez la notation ingénieur, j'imagine ?
<Sync time="485.676"/>
on prend n'importe quel nombre réel
<Sync time="487.748"/>
qu'on écrit
<Sync time="488.838"/>
de toute façon il va falloir l'écrire un jour,
<Sync time="491.554"/>
zéro point zéro zéro zéro zéro un deux un un deux trois,
<Sync time="497.497"/>
qui s'écrit en notation ingénieur : un point cent vingt-trois
<Sync time="500.942"/>
e moins cinq
<Sync time="503.266"/>
ou qui s'écrit aussi
<Sync time="505.860"/>
euh mille cent vingt-trois e moins huit
<Sync time="510.351"/>
eh bah là on a gagné,
<Sync time="512.582"/>
parce qu'on a deux entiers :
<Sync time="514.250"/>
on a un premier entier, mille cent vingt-trois, et un deuxième entier, moins huit
<Sync time="519.431"/>
ouais, c'est comme ça qu'on fait pour représenter les réels.
<Sync time="522.057"/>
le nombre cent vingt-trois en informati()
<Sync time="524.291"/>
en informatique, on appellera ça la mantisse ;
<Sync time="527.186"/>
le moins huit, on appellera ça l'exposant.
<Sync time="529.364"/>
ce sont des entiers
<Sync time="530.580"/>
donc comme ce sont des entiers, on peut les coder en machine
<Sync time="533.37"/>
donc on peut coder les réels en machine.
<Sync time="537.540"/>
et en javascript
<Sync time="539.2"/>
si on peut coder
<Sync time="540.783"/>
les les nombres qu'on peut coder, ce sont ceux
<Sync time="543.065"/>
qu'on peut coder avec une mantisse
<Sync time="546.131"/>
comprise entre moins deux à la puissance cinquante-trois et plus deux à la puissance cinquante-trois moins un.
<Sync time="551.768"/>
ça, c'est les entiers qu'on peut représenter,
<Sync time="554.841"/>
tous les entiers qu'on peut représenter,
<Sync time="557.300"/>
et dont l'exposant est compris, alors là on a un peu moins d'exposants mais c'est quand même pas mal,
<Sync time="561.886"/>
moins deux à la puissance dix et plus deux à la puissance dix ; alors deux à la puissance dix, c'est mille vingt quatre.
<Sync time="567.987"/>
donc ça fait quand même beaucoup de nombres réels qu'on peut représenter.
<Sync time="572.167"/>
le plus grand nombre réel, c'est un nombre
<Sync time="575.496"/>
qui a trois cent huit chiffres
<Sync time="578.419"/>
il me semble à peu près
<Sync time="580.061"/>
ça se trouve euh enfin on peut le calculer facilement, dont trois cent huit chiffres.
<Sync time="585.137"/>
voilà, donc moralité : on peut coder les flottants avec deux entiers,
<Sync time="588.418"/>
et donc on peut les coder avec des zéros et des uns.
<Sync time="593.770"/>
le troisième
<Sync time="594.733"/>
type de base, ça va être le caractère
<Sync time="597.482"/>
parce que
<Sync time="599.141"/>
finalement on veut pas forcément faire que des calculs avec un ordinateur ;
<Sync time="603.3"/>
une autre finalité de l'informatique, c'est de communiquer
<Sync time="607.421"/>
fatalement : sciences de l'information, on veut communiquer.
<Sync time="611.960"/>
donc les caractères
<Sync time="613.376"/>
en informatique,
<Sync time="616.440"/>
ça va être tout ce qu'on souhaite écrire
<Sync time="620.116"/>
et tout ce qu'on souhaite écrire, en fait ça s()
<Sync time="622.317"/>
ça change
<Sync time="624.251"/>
ça change pas d'une année sur l'autre, mais ça change d'une décennie à l'autre finalement.
<Sync time="629.173"/>
parce que avant quatre-vingts,
<Sync time="631.990"/>
ce qu'on souhaitait écrire, c'était des messages en anglais
<Sync time="635.432"/>
l'informatique était plutôt un domaine dominé par la
<Sync time="638.896"/>
les américains.
<Sync time="640.863"/>
donc ce qu'ils *souhaitaient, c'était s'échanger des messages écrits en anglais.
<Sync time="645.004"/>
quel est l() l'avantage de l'anglais ? ben c'est un alphabet latin
<Sync time="648.059"/>
et il y a pas d'accents.
<Sync time="650.632"/>
donc euh par contre, on a
<Sync time="652.561"/>
on a besoin de mettre des virgules, on a besoin de mettre des x() de mettre des *points d'exclamation et cetera et cetera.
<Sync time="657.774"/>
donc on avait p() avant quatre-vingts, on souhaitait commu() envoyer des messages comme ça.
<Sync time="662.448"/>
après quatre-vingts,
<Sync time="665.503"/>
l'europe s'y est mis
<Sync time="667.590"/>
la norvège aussi 
<Sync time="669.436"/>
avec tous ses accents bizarres,
<Sync time="674.110"/>
et puis euh et puis aujourd'hui, c'est même plus que
<Sync time="678.348"/>
c'est même plus que les accents bizarres qu'on veut, c'est euh
<Sync time="681.223"/>
on veut écrire des choses dans des cara() on veut écrire des caractères
<Sync time="684.853"/>
dans des alphabets qui ne sont pas des alphabets latins
<Sync time="687.395"/>
à à la base latins.
<Sync time="689.219"/>
donc euh euh en alphabet chinois, en kanjis et cetera, donc on veut écrire des choses comme ça.
<Sync time="694.698"/>
donc
<Sync time="696.519"/>
comme pour coder les réels
<Sync time="700.244"/>
pour coder des caractères, il faut des normes.
<Sync time="702.726"/>
et ces normes, elles s'appellent normes ascii
<Sync time="705.409"/>
elles s'appelaient normes ascii dans les années quatre-vingts
<Sync time="708.216"/>
elles s'appellent normes unicode maintenant
<Sync time="710.938"/>
qu'est-ce que c'est que ces normes ?
<Sync time="712.578"/>
ben c'est tout simplement
<Sync time="715.723"/>
une euh une norme
<Sync time="718.264"/>
qui dit
<Sync time="719.564"/>
à tel caractère, j'associe tel entier.
<Sync time="724.006"/>
la norme ascii
<Sync time="728.640"/>
disait : au caractère
<Sync time="730.791"/>
soixante euh quatorze,
<Sync time="734.849"/>
j'associe le j majuscule.
<Sync time="737.620"/>
donc cette table le () la table que je vous ai mise ici, elle se lit comme ça : soixante-douze plus
<Sync time="742.716"/>
deux, ça fait soixante-quatorze, et le caractère donc à soixante-quatorze, c'est j majuscule.
<Sync time="749.070"/>
voilà. donc qu'est-ce que c'est qu'une norme ? k() comment on code un caractère ?
<Sync time="753.206"/>
ben c'est simple : on le code par un entier
<Sync time="755.426"/>
mais pour pouvoir le coder par un entier, il faut une une norme qui associe un caractère à un entier.
<Sync time="760.818"/>
et regardez bien dans la norme
<Sync time="763.126"/>
le j majuscule et le j minuscule, c'est pas () se sont pas associés au même nombre.
<Sync time="767.488"/>
donc ce sont deux caractères différents.
<Sync time="770.550"/>
il y a rien qui les distingue ; ils sont différents.
<Sync time="773.764"/>
voilà, donc ça c'est la norme ascii.
<Sync time="779.090"/>
cette norme ascii, vous pouvez la manipuler
<Sync time="781.056"/>
dans l'interface euh par le biais de deux fonctions :
<Sync time="785.560"/>
une fonction ascii vers caractère, qui prend en paramètre
<Sync time="789.433"/>
un entier et qui renvoie le caractère
<Sync time="791.852"/>
et la fonction inverse,
<Sync time="793.320"/>
qui prend un caractère, et qui va le transformer vers un caractère ascii.
<Sync time="798.850"/>
ok ?
<Sync time="799.546"/>
donc ces euh ces deux fonctions permettent de manipuler
<Sync time="802.408"/>
les caractères de la table ascii.
<Sync time="805.960"/>
alors on veut aller plus loin,
<Sync time="810.480"/>
mais c'est pas plus compliqué.
<Sync time="812.549"/>
la norme unicode,
<Sync time="814.579"/>
c'est juste une sorte de table ascii, mais très grande.
<Sync time="818.237"/>
donc au lieu de coder par des petits nombres euh entiers, entre zéro et cent vingt-sept, on va se permettre de prendre des plus grands nombres entiers
<Sync time="825.558"/>
donc là par exemple, c'est des nombres
<Sync time="827.970"/>
ça, c'est le nombre vingt mille
<Sync time="830.43"/>
vingt mille un, vingt mille deux, vingt mille trois
<Sync time="832.427"/>
et cetera, donc c'est toujours des nombres
<Sync time="834.069"/>
qui permettent d'associer
<Sync time="835.340"/>
un caractère
<Sync time="837.298"/>
à un code.
<Sync time="838.877"/>
donc pa()
<Sync time="839.592"/>
par exemple, le code
<Sync time="841.295"/>
le caractère
<Sync time="843.720"/>
associé au code vingt mille cent six,
<Sync time="847.854"/>
c'est celui-là.
<Sync time="850.525"/>
un code
<Sync time="851.364"/>
de de l'alphabet euh j() japonais.
<Sync time="856.280"/>
et comme on est () on peut se permettre d'avoir des très très grandes tables d'association, enfin c'est c'est c'est très extensible.
<Sync time="863.293"/>
dans le cours de traitement automatique des langues naturelles, vous reviendrez là-dessus.
<Sync time="866.331"/>
on vous pa() on vous dira pourquoi c'est utile d'avoir ce genre de de table.
<Sync time="871.500"/>
voilà
<Sync time="873.364"/>
euh à noter quand même
<Sync time="876.476"/>
que en javascript
<Sync time="878.680"/>
et dans le langage algorithmique qu'on utilisera,
<Sync time="881.32"/>
un caractère ça se notera :
<Sync time="884.254"/>
un quote,
<Sync time="887.59"/>
le () apostrophe,
<Sync time="889.374"/>
une apostrophe,
<Sync time="890.687"/>
un caractère,
<Sync time="892.018"/>
une apostrophe.
<Sync time="893.510"/>
c'est la manière de noter les caractères.
<Sync time="900.260"/>
voilà, donc moralité :
<Sync time="902.315"/>
on peut coder les caractères avec un entier,
<Sync time="904.653"/>
éventuellement un entier très grand,
<Sync time="908.138"/>
en utilisant une table de correspondance
<Sync time="910.284"/>
normalisée au niveau international ; c'est pas nous qui avons décidé de de créer cette table de correspondance, c'est des organismes qui les standardisent au niveau international,
<Sync time="921.960"/>
et comme on peut les coder par des entiers, on peut les coder uniquement par des bits.
<Sync time="926.513"/>
donc ça ça marche, on peut communiquer avec un ordinateur.
<Sync time="929.548"/>
si ça marchait pas, ça se saurait.
<Sync time="934.004"/>
mais ça marche comme ça.
<Sync time="937.770"/>
le type s()
<Sync time="939.594"/>
quatrième type de base, hein ici j'ai noté trois
<Sync time="941.844"/>
faudra que je corrige 
<Sync time="943.155"/>
ce sont les chaînes de caractères.
<Sync time="946.498"/>
qu'est-ce que c'est qu'une chaîne de caractères ? eh ben c'est un ensemble de caractères mis bout à bout.
<Sync time="950.211"/>
une suite de caractères
<Sync time="952.894"/>
alors la
<Sync time="955.285"/>
j'attire votre *attention sur le fait que ça peut aussi être : pas de caractère du tout
<Sync time="959.663"/>
une chaîne de caractères, ça peut être pas de caractère, un caractère, deux caractères, mille caractères
<Sync time="964.787"/>
cent mille caractères, ça dépend de ce qu'on veut envoyer.
<Sync time="968.007"/>
c'est un texte, en fait
<Sync time="971.296"/>
donc par exemple
<Sync time="973.758"/>
vous avez des exemples de textes ici : bonjour au revoir avec un espace, première ligne, un caractère bizarre qui permet de passer à la ligne, deuxième ligne,
<Sync time="981.673"/>
*et *cetera.
<Sync time="982.39"/>
donc en javascript et dans le langage algorithmique, les chaînes de caractères sont notées comme une suite de caractères entourés de deux quotes.
<Sync time="989.412"/>
ça ressemble beaucoup aux caractères
<Sync time="991.388"/>
de toute façon
<Sync time="992.74"/>
en javascript, il y a pas de distinction entre un caractère et une chaîne de caractères
<Sync time="999.908"/>
donc euh ça, c'est aussi une chaîne de caractères.
<Sync time="1005.120"/>
donc il y a pas de () donc c'est c'est c'est noté comme ça
<Sync time="1008.417"/>
ça
<Sync time="1010.285"/>
quote quote, avec rien au milieu, c'est aussi une chaîne de caractères
<Sync time="1014.795"/>
et on reviendra dessus euh bien souvent parce que s() elle joue un rôle très très important
<Sync time="1020.296"/>
en algorithmique.
<Sync time="1022.962"/>
quand on va chercher à coller deux chaînes de caractères, il y a une opération qui s'appelle la concaténation de chaînes de caractères
<Sync time="1028.64"/>
ben euh ça, c'est l'élément neutre de l'opération, si on parle de () en en termes mathématiques, c'est l'élément neutre de l'opération concaténation.
<Sync time="1036.053"/>
et c'est pour ça que c'est une chaîne de caractères importante.
<Sync time="1041.506"/>
voilà
<Sync time="1042.610"/>
donc moralité : comme on peut coder les chaînes de caractères par une suite de plusieurs enti() enfin par () de plusieurs caractères, donc une suite de plusieurs entiers
<Sync time="1052.089"/>
il suffit de les mettre bout à bout en mémoire
<Sync time="1054.996"/>
eh ben et que des entiers, on peut les coder par des zéros et des uns
<Sync time="1058.602"/>
pas de problème : une chaîne de caractères, ça se code en mémoire.
<Sync time="1065.360"/>
dernier type
<Sync time="1068.085"/>
c'est les booléens. alors un booléen, c'est vrai ou faux
<Sync time="1070.622"/>
zéro ou un
<Sync time="1074.250"/>
c'est un type qui est important,
<Sync time="1076.074"/>
parce que ça va être le résultat de toutes les comparaisons qu'on va avoir à faire
<Sync time="1079.358"/>
on va avoir à faire plein de comparaisons
<Sync time="1082.453"/>
donc
<Sync time="1083.047"/>
le type booléen, ce sont les valeurs vrai et faux, ou true ou false
<Sync time="1086.61"/>
et finalement
<Sync time="1087.962"/>
moralité :
<Sync time="1090.090"/>
on a mis tout ce temps pour arriver au type de base de l'informatique qui est le booléen.
<Sync time="1094.740"/>
celui-là, il se représente
<Sync time="1097.713"/>
naturellement
<Sync time="1099.148"/>
par des zéros et des uns
<Sync time="1100.747"/>
zéro quand c'est faux, un quand c'est vrai.
<Sync time="1104.969"/>
donc on peut le considérer comme le type de base unique de l'informatique
<Sync time="1108.101"/>
même si évidemment,
<Sync time="1110.77"/>
on en a () on a besoin d'un peu plus () d'aller un peu plus loin.
<Sync time="1114.17"/>
bon, bref
<Sync time="1116.193"/>
pourquoi on a porté autant d'attention
<Sync time="1118.750"/>
à () aux types
<Sync time="1121.220"/>
alors que tout peut se coder par des bits ?
<Sync time="1123.517"/>
alors là, je vais apporter un certain nombre de réponses
<Sync time="1127.332"/>
toutes bêtes : ben parce que
<Sync time="1129.588"/>
c'est plus pratique d'écrire la chaîne de caractères bonjour que d'écrire
<Sync time="1133.800"/>
euh zéro un zéro zéro zéro un zéro zéro un zéro enfin un un et cetera.
<Sync time="1138.500"/>
croyez-moi sur parole : ça, ça veut dire bonjour.
<Sync time="1142.058"/>
c'est
<Sync time="1142.612"/>
c'est la manière de coder bonjour en mémoire
<Sync time="1145.001"/>
avec des interrupteurs.
<Sync time="1147.663"/>
mais évidemment,
<Sync time="1149.447"/>
vous avez plutôt envie d'avoir ça
<Sync time="1151.958"/>
donc on a *apporté beaucoup d'attention aux types, parce que
<Sync time="1157.011"/>
on veut s'*abstraire du codage de ces noms () de ces de ces choses-là.
<Sync time="1162.395"/>
on se moque de comment javascript va coder ces ces caractères ou ces chaînes de caractères ; on veut juste savoir qu'il existe un type chaîne de caractères.
<Sync time="1172.700"/>
pourquoi le langage de programmation a besoin de savoir ce qu'il a en mémoire ? ben tout simplement parce que lui, il se préoccupe de
<Sync time="1178.748"/>
gérer la mémoire, justement.
<Sync time="1181.326"/>
donc savoir ce qu'il a () ce qu'il stocke dans une variable, ça lui permet de réserver la bonne quantité de mémoire
<Sync time="1187.57"/>
pour stocker euh s() le contenu de la variable.
<Sync time="1190.958"/>
donc c'est important pour lui d'avoir cette notion de type.
<Sync time="1193.706"/>
et c'est pour ça que dans
<Sync time="1196.537"/>
tous les langages, j'essaye de pas me tromper,
<Sync time="1198.623"/>
dans tous les langages il y a une notion de type
<Sync time="1202.270"/>
y compris en javascript : il y a une notion de type en javascript.
<Sync time="1208.560"/>
et puis euh dernier argument : c'est parce que euh
<Sync time="1212.28"/>
les calculs qu'on peut faire
<Sync time="1214.328"/>
sur quel() sur une valeur, sur euh
<Sync time="1217.277"/>
sur quelque chose, dépendent d'un type à l'autre.
<Sync time="1219.567"/>
on pourra pas faire les mêmes opérations
<Sync time="1222.391"/>
sur des entiers
<Sync time="1224.411"/>
et sur des chaînes de caractères.
<Sync time="1225.890"/>
ça vous s() s() ça vous semblera ça vous semble assez évident.
<Sync time="1230.057"/>
mais c'est important, justement d'avoir cette notion de type parce que c'est ce qui va nous différencier les opérations.
<Sync time="1237.138"/>
voilà
<Sync time="1238.050"/>
eh ben on en vient justement
<Sync time="1239.886"/>
aux opérations qu'on va pouvoir écrire,
<Sync time="1242.616"/>
qu'on appelle une expression.
<Sync time="1245.337"/>
donc l'expression, ça va être
<Sync time="1248.083"/>
obtenu en combinant des opérations de base sur les types
<Sync time="1252.789"/>
et il y aura des syntaxes
<Sync time="1256.193"/>
à utiliser.
<Sync time="1261.456"/>
voilà
<Sync time="1262.571"/>
eh ben je vais faire comme les types.
<Sync time="1265.396"/>
je vous ai dit : les opérations qu'on peut faire dépendent des types.
<Sync time="1268.359"/>
eh ben on va reprendre les types un par un, et puis on va voir quelles opérations on peut faire sur chacun de ces types.
<Sync time="1272.944"/>
sur les types entiers
<Sync time="1276.577"/>
bah dé() les entiers, ce sont des nombres.
<Sync time="1279.057"/>
on peut manipuler des nombres comme on le fe() on pourrait le faire en mathématiques
<Sync time="1282.645"/>
et des entiers, ça s'additionne,
<Sync time="1284.588"/>
ça se soustrait,
<Sync time="1286.343"/>
ça se multiplie,
<Sync time="1288.076"/>
ça se divise, mais quand on est en en() on parle d'entiers, on a la division entière
<Sync time="1292.986"/>
qu'on notera div
<Sync time="1295.910"/>
et puis la division entière, il y a il y a aussi le reste de la division entière, qu'on notera mod
<Sync time="1300.434"/>
modulo
<Sync time="1305.157"/>
donc par exemple, ça c'est une opération valide :
<Sync time="1308.127"/>
cinq plus trois qui vaut huit.
<Sync time="1312.440"/>
donc on aura le droit d'écrire des expressions comme ça : dix-sept div cinq
<Sync time="1317.807"/>
ça vaut trois, puisque dix-sept c'est trois fois cinq plus deux.
<Sync time="1321.079"/>
donc dix-sept mod cinq, ça vaut deux.
<Sync time="1323.713"/>
il y a ces opérations de calcul, et puis il faut pas oublier toutes les opérations de comparaison
<Sync time="1328.486"/>
entre deux nombres.
<Sync time="1330.241"/>
donc est-ce que euh
<Sync time="1332.786"/>
douze est égal à quatre fois trois ? ça va valoir vrai.
<Sync time="1336.07"/>
est-ce que douze est plus petit que sept ? ça va valoir faux. donc le résultat de ces comparaisons, ça va être un booléen.
<Sync time="1341.553"/>
donc on aura des opérations
<Sync time="1343.849"/>
additions
<Sync time="1345.131"/>
qui vont prendre deux nombres et qui vont donner un nombre,
<Sync time="1347.73"/>
et on aura des opérations de comparaisons qui vont prendre deux nombres et qui vont donner
<Sync time="1351.56"/>
un booléen.
<Sync time="1354.864"/>
donc ce sont les deux types d'opérations de base qu'on va avoir sur les nombres.
<Sync time="1361.070"/>
sur les réels, en fait ça change pas
<Sync time="1363.524"/>
c'est la même chose.
<Sync time="1364.647"/>
on aura
<Sync time="1366.172"/>
les opérations
<Sync time="1368.156"/>
entre deux réels qui donnent un réel :
<Sync time="1370.239"/>
addition, soustraction, multiplication, division réelles
<Sync time="1378.060"/>
et on aura les comparaisons.
<Sync time="1386.420"/>
alors attention :
<Sync time="1387.739"/>
j'ai parlé de réels, là
<Sync time="1389.456"/>
vous m'avez pas repris.
<Sync time="1390.738"/>
ce sont pas des réels ;
<Sync time="1392.771"/>
ce sont des flottants
<Sync time="1396.522"/>
eh ben mine de rien, ça joue p() s() c'est important de savoir que c'est () ce sont des flottants
<Sync time="1401.861"/>
est-ce que j'ai l'exemple ? j'espère que je vous ai mis l'exemple ; voilà
<Sync time="1406.065"/>
ce sont des flottants, la preuve :
<Sync time="1411.140"/>
on peut pas tout représenter avec des flottants
<Sync time="1414.483"/>
ça on l'a on l'a déjà vu
<Sync time="1417.155"/>
et
<Sync time="1417.61"/>
et notamment, il y a des nombres
<Sync time="1419.325"/>
qu'on ne peut pas représenter.
<Sync time="1423.620"/>
et si on écrit
<Sync time="1425.125"/>
ça en javascript
<Sync time="1428.035"/>
un point deux cent cinquante-sept multiplié par quarante-trois fois mille divisé par quarante-trois
<Sync time="1435.020"/>
est-ce que vous êtes d'accord avec moi ? ça vaut combien, ça ?
<Sync time="1439.920"/>
en maths
<Sync time="1442.607"/>
mille deux cent cinquante-sept
<Sync time="1444.206"/>
je multiplie par quarante-trois, je divise par quarante-trois
<Sync time="1446.807"/>
ça s'élimine
<Sync time="1447.964"/>
je multiplie par mille :
<Sync time="1449.128"/>
ça vaut mille deux cent cinquante-sept.
<Sync time="1451.749"/>
bon
<Sync time="1453.193"/>
je regarde si c'est égal à
<Sync time="1456.429"/>
un point deux cent cinquante-sept divisé par quarante-trois multiplié par quarante-trois fois mille
<Sync time="1461.522"/>
ça vaut combien ?
<Sync time="1464.992"/>
mille deux cent cinquante-sept ?
<Sync time="1469.725"/>
vous êtes d'accord, en maths ?
<Sync time="1473.871"/>
mille deux cent cinquante-sept
<Sync time="1477.640"/>
eh ben le résultat du de l'é() du calcul,
<Sync time="1480.486"/>
il dit : les deux nombres sont différents.
<Sync time="1484.270"/>
tout simplement parce que dans le
<Sync time="1487.144"/>
dans la suite d'opérations qui vont () qu'on fait,
<Sync time="1490.817"/>
il y a un nombre qu'il va se mettre à pas être capable de représenter ;
<Sync time="1493.767"/>
exactement, c'est celui-là.
<Sync time="1495.485"/>
celui-là
<Sync time="1496.807"/>
il est pas capable de le représenter en mémoire.
<Sync time="1499.749"/>
comme il est pas capable de le représenter en mémoire, il représente un nombre arrondi très proche.
<Sync time="1507.661"/>
mais
<Sync time="1508.660"/>
en f() en l'ayant arrondi, on a perdu quelque chose.
<Sync time="1513.372"/>
donc une fois qu'on remultiplie par quarante-trois et par mille, on a perdu quelque chose.
<Sync time="1517.307"/>
et ce qu'on a perdu, ben ça ()
<Sync time="1519.973"/>
ce qu'on a perdu, ça nous () ça fait en sorte que le 
<Event desc="pi" type="pronounce" extent="instantaneous"/>

<Sync time="1523.341"/>
où on a des nombres qu'on aurait dû
<Sync time="1525.538"/>
avoir euh égaux ben ils sont plus égaux.
<Sync time="1530.230"/>
donc on a perdu des choses dans la représentation.
<Sync time="1532.265"/>
ça, c'est très important de le savoir
<Sync time="1534.658"/>
c'est pas anodin de () c'est pas anodin ces erreurs-là hein.
<Sync time="1538.471"/>
vous les ferez, certainement, parce que ce sont ce sont des petits bugs
<Sync time="1542.32"/>
mais euh il y a des fusées qui se cassent la figure à cause de ça
<Sync time="1544.875"/>
hein donc euh
<Sync time="1548.194"/>
sur ces erreurs d'arrondis.
<Sync time="1550.622"/>
donc c'est vraiment pas anodin : attention à la représentation des nombres réels.
<Sync time="1556.244"/>
alors quelles opérations on peut faire sur les caractères, maintenant ?
<Sync time="1560.502"/>
alors des caractères, ça se compare
<Sync time="1564.962"/>
à votre avis, comment on va faire pour comparer des caractères ?
<Sync time="1568.24"/>
est-ce que
<Sync time="1569.989"/>
a minuscule est plus petit que b minuscule ? la réponse est
<Sync time="1577.645"/>
vrai.
<Sync time="1578.310"/>
a minuscule est plus petit que b minuscule
<Sync time="1582.67"/>
euh
<Sync time="1584.43"/>
a majuscule
<Sync time="1585.903"/>
est-ce que a majuscule est plus petit que b() a minuscule ?
<Sync time="1590.592"/>
ah là, c'est plus difficile.
<Sync time="1592.411"/>
en français, on se dirait : non c'est pa() c'est pareil
<Sync time="1595.292"/>
on s'en fout, de majuscule et minuscule. bah en informatique, on s'en moque pas
<Sync time="1599.185"/>
parce que ce sont deux caractères différents ;
<Sync time="1601.272"/>
ce sont deux caractères différents parce qu'ils ont un code ascii différent.
<Sync time="1606.109"/>
la comparaison de caractères, en informatique,
<Sync time="1609.149"/>
revient à comparer les codes ascii de ces caractères. on a deux nombres : c'est facile de comparer des nombres.
<Sync time="1615.748"/>
donc le résultat de : est-ce que a g() a majuscule est plus petit que a minuscule ? la réponse est vrai car le code ascii de a, c'est soixante-cinq ; celui de a minuscule, c'est quatre-vingt-dix-sept.
<Sync time="1628.867"/>
voilà.
<Sync time="1629.831"/>
si on cherche à comparer
<Sync time="1631.872"/>
e sans accent et e avec accent, ben le résultat est faux.
<Sync time="1637.550"/>
car le ()
<Sync time="1638.716"/>
ces deux lettres
<Sync time="1639.953"/>
ces deux caractères ont des codes
<Sync time="1642.607"/>
de représentation différents.
<Sync time="1646.800"/>
ok ?
<Sync time="1651.221"/>
donc euh
<Sync time="1654.870"/>
ça, ce sont les comparaisons et puis il y aura un certain nombre de fonctions, de manipulations des caractères que vous avez déjà vues.
<Sync time="1660.134"/>
caractères vers ascii, ascii vers caractères.
<Sync time="1662.264"/>
on peut pas faire grand-chose avec un caractère
<Sync time="1665.299"/>
mais c'est important de savoir comment on les compare.
<Sync time="1669.727"/>
allez, quatri() hop, je suis allé trop vite.
<Sync time="1672.700"/>
quatrième chose : les chaînes de caractères.
<Sync time="1679.496"/>
bon
<Sync time="1680.780"/>
là, il y a une opération qui est importante
<Sync time="1682.901"/>
dans les chaînes de caractères : l'opération, elle s'appelle la concaténation.
<Sync time="1686.986"/>
elle est importante et pourtant elle est simple.
<Sync time="1689.238"/>
concaténer deux chaînes de caractères, c'est juste construire une chaîne de caractères composée des deux chaînes mises bout à bout.
<Sync time="1697.718"/>
donc
<Sync time="1698.700"/>
la concaténation de la chaîne de caractères "bon"
<Sync time="1702.735"/>
et de la chaîne de caractères "jour"
<Sync time="1704.745"/>
qu'on notera bon plus jour dans le langage algorithmique et dans le langage javascript, et dans plein d'autres langages,
<Sync time="1712.293"/>
le résultat, c'est une chaîne de caractères
<Sync time="1714.540"/>
composée des caractères b, o, n, j, o, u, r.
<Sync time="1718.315"/>
bonjour
<Sync time="1722.100"/>
donc c'est l'opération la plus importante.
<Sync time="1727.900"/>
il y a d'autres fonctions qui permettent de manipuler
<Sync time="1730.565"/>
des chaînes de caractères.
<Sync time="1732.762"/>
ce qu'on a souvent envie de faire, c'est d'avoir la longueur de la chaîne de caractères.
<Sync time="1738.654"/>
donc il y a une o()
<Sync time="1739.677"/>
une opération qui prend en paramètres une chaîne et qui renvoie
<Sync time="1744.165"/>
un entier
<Sync time="1745.148"/>
qui s'appelle longueur ; longueur d'une chaîne de caractères,
<Sync time="1748.402"/>
ça renvoie à la longueur de la chaîne de caractères. donc pour longueur de bonjour, il y a sept lettres dans bonjour : ça vaut sept.
<Sync time="1755.602"/>
évidemment, on compte tous les caractères, même les espaces hein ;
<Sync time="1758.138"/>
même les virgules 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 la chaîne de caractères ne fait pas la distinction entre le contenu de la k()
<Sync time="1763.381"/>
de la chaîne 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 on se on se moque de ce que veut dire la chaîne.
<Sync time="1767.250"/>
avec une chaîne de caractères, on a aussi envie de travailler sur les caractères,
<Sync time="1771.850"/>
notamment extraire un caractère d'une chaîne de caractères.
<Sync time="1775.168"/>
ben ça, il y a une notation pour ça
<Sync time="1777.687"/>
ça s'écrit c h entre crochets.
<Sync time="1781.038"/>
donc si euh j'ai une variable qui contient
<Sync time="1785.157"/>
une chaîne de caractères,
<Sync time="1787.783"/>
alors si j'écris c h entre crochets
<Sync time="1790.59"/>
bah ici là, j'ai bonjour
<Sync time="1793.231"/>
c h contient () a pour valeur la chaîne de caractères bonjour
<Sync time="1797.603"/>
c h entre crochets trois
<Sync time="1800.657"/>
a pour valeur la
<Sync time="1804.402"/>
la lettre à l'indice trois dans bonjour.
<Sync time="1807.31"/>
*alors j'ai bien dit lettre à l'indice trois et pas troisième lettre
<Sync time="1810.18"/>
tout simplement parce que
<Sync time="1811.82"/>
le premier indice, c'est l'indice zéro.
<Sync time="1814.132"/>
donc la lettre à l'indice trois, c'est la quatrième lettre.
<Sync time="1817.459"/>

<Event desc="pi" type="pronounce" extent="instantaneous"/>
 retenir ça
<Sync time="1819.301"/>
première lettre étant à l'indice zéro,
<Sync time="1821.534"/>
la lettre à l'indice trois, c'est la quatrième lettre.
<Sync time="1824.139"/>
donc c j ;
<Sync time="1825.142"/>
ça, ça permet d'extraire les caractères d'une chaîne de caractères.
<Sync time="1831.717"/>
et enfin
<Sync time="1833.092"/>
il y a aussi des comparaisons entre deux chaînes de caractères,
<Sync time="1836.101"/>
des comparaisons automatiques entre deux chaînes de caractères.
<Sync time="1841.740"/>
et là, vous avez un
<Sync time="1843.525"/>
une idée de comment on compare les chaînes de caractères ?
<Sync time="1848.490"/>
donc qui a la réponse hein, c'est euh
<Sync time="1850.787"/>
l'ordre du dictionnaire ou l'ordre lexicographique.
<Sync time="1856.180"/>
autrement dit, je () si je veux comparer deux chaînes de caractères, je vous pose la question : et si je les mettais dans un dictionnaire, où elles seraient ?
<Sync time="1862.268"/>
est-ce que l'une serait avant l'autre ?
<Sync time="1864.463"/>
alors c'est pas tout à fait un dictionnaire ordinaire, c'est un dictionnaire qui tient compte de l'ordre des caractères eux-mêmes.
<Sync time="1870.447"/>
donc les l() les chaînes de caractères qui commencent par des a majuscules seront avant celles qui commencent par des a minuscules,
<Sync time="1878.887"/>
et les chaînes de caractères qui commencent par des z majuscules seront avant celles qui commencent par des a minuscules.
<Sync time="1884.151"/>
*voilà donc c'est un c'est un dictionnaire un peu bizarre
<Sync time="1887.226"/>
qui tient compte de l'ordre des caractères
<Sync time="1889.686"/>
donc l'ordre as() l'ordre ascii
<Sync time="1892.452"/>
mais
<Sync time="1893.149"/>
qui classe selon un ordre lexicographique, donc euh
<Sync time="1898.602"/>
l'ordre du dictionnaire. l'ordre *lexicographique, c'est : je compare les deux premières lettres ;
<Sync time="1902.371"/>
si elles sont différentes, c'est bon je trie mes mes deux chaînes. si n() si elles sont égales,
<Sync time="1906.946"/>
je suis obligé de regarder la lettre suivante
<Sync time="1908.728"/>
et cetera, et cetera.
<Sync time="1916.635"/>
voilà
<Sync time="1918.890"/>
et enfin
<Sync time="1920.2"/>
le dernier type qu'on a vu, c'était les booléens.
<Sync time="1922.564"/>
ben les opérations de base sur les booléens,
<Sync time="1925.228"/>
vous les connaissez probablement déjà : c'est les opérations logiques.
<Sync time="1929.429"/>
le et logique, le ou logique, le non logique
<Sync time="1934.013"/>
et puis euh
<Sync time="1935.834"/>
on on va faire ça très rapidement
<Sync time="1938.19"/>
mais les opérations de base sur les booléens, en général on les représente par des tables de vérité, qui sont ces tableaux, là
<Sync time="1945.801"/>
où on on on met la va() toutes les valeurs possibles pour euh
<Sync time="1950.287"/>
l'entrée
<Sync time="1951.826"/>
et là, on met toutes les valeurs possibles pour la sortie de non a ;
<Sync time="1956.21"/>
pour a et pour la sortie de non a.
<Sync time="1958.198"/>
on peut le faire pour les booléens, parce que ça fait ça fait jamais des tableaux très très grands.
<Sync time="1962.611"/>
comme il y a que deux valeurs,
<Sync time="1964.313"/>
au pire il y a deux variables, donc il y aura quatre ca() quatre lignes au tableau, mais il y en aura jamais beaucoup plus.
<Sync time="1969.671"/>
donc
<Sync time="1971.574"/>
si a vaut vrai, que vaut non a ?
<Sync time="1974.115"/>
faux
<Sync time="1974.894"/>
que vaut euh faux non faux ?
<Sync time="1977.610"/>
vrai
<Sync time="1979.123"/>
on va le faire, hein euh
<Sync time="1982.569"/>
a et b
<Sync time="1986.189"/>
vrai
<Sync time="1990.033"/>
faux
<Sync time="1991.345"/>
pour le ou ?
</Turn>
<Turn startTime="1994.471" endTime="1996.96">
<Sync time="1994.471"/>

<Event desc="conv" type="noise" extent="instantaneous"/>

</Turn>
<Turn speaker="spk40" mode="planned" fidelity="high" channel="studio" startTime="1996.96" endTime="2192.010">
<Sync time="1996.960"/>
ok
<Sync time="1998.022"/>
vous savez tout ça par coeur.
<Sync time="2001.189"/>
donc
<Sync time="2001.940"/>
il y a ces opérations euh de base, et puis vous savez très bien
<Sync time="2006.249"/>
que ces opérations-là, elles vont se combiner donc euh quand vous parlerez de réseaux sociaux
<Sync time="2010.729"/>

<Event desc="pi" type="pronounce" extent="instantaneous"/>
 vous reviendrez là-dessus, sur ces opérations logiques
<Sync time="2014.59"/>
et vous verrez la
<Sync time="2016.482"/>
l'implication
<Sync time="2018.37"/>
en opérations logiques, et des choses comme ça.
<Sync time="2021.197"/>
ce sont des opérations qui ne se notent pas dans le langage, donc c'est pour ça que je me limite à ça.
<Sync time="2026.487"/>
voilà
<Sync time="2028.650"/>
et on en vient aux é() on a vu les opérations de base, on en vient à une expression. qu'est-ce que c'est qu'une expression ?
<Sync time="2035.304"/>
bah une expression, c'est simple :
<Sync time="2037.336"/>
c'est soit une valeur
<Sync time="2040.420"/>
un, dix,
<Sync time="2041.956"/>
la valeur d'une variable,
<Sync time="2044.905"/>
autre-chose, une chaîne de caractères
<Sync time="2047.769"/>
donc c'est soit une valeur,
<Sync time="2050.803"/>
soit de la forme
<Sync time="2053.700"/>
entre parenthèses une expression
<Sync time="2056.422"/>
une opération
<Sync time="2057.609"/>
entre parenthèses une expression.
<Sync time="2059.592"/>
ça, c'est pour les opérations qui sont binaires. et puis il y a tout t() ce qu'on peut écrire pour les opérations de type longueur, 
<Event desc="pif" type="pronounce" extent="begin"/>
et des choses comme ça
<Event desc="pif" type="pronounce" extent="end"/>

<Sync time="2065.576"/>
qui sont pas les opérations binaires.
<Sync time="2067.455"/>
donc autrement dit, quand on a cette syntaxe-là
<Sync time="2069.852"/>
et que expression, là,
<Sync time="2071.939"/>
dans la parenthèse, ça peut aussi être une expression avec une opération,
<Sync time="2076.090"/>
cette syntaxe-là
<Sync time="2077.461"/>
permet de construire récursivement toutes les expressions possibles
<Sync time="2081.294"/>
et imaginables.
<Sync time="2084.680"/>
et vous savez, puisque vous avez fait des
<Sync time="2087.629"/>
vous avez déjà () s() s() c'est la syntaxe des opérations mathématiques, hein. je j'inv() on n'invente rien, en informatique
<Sync time="2093.587"/>
et vous savez très bien que là, j'ai mis les parenthèses
<Sync time="2097.132"/>
mais il y a plein de fois où on peut se passer des parenthèses :
<Sync time="2100.451"/>
quand il y a pas d'ambiguïté, on n'est pas obligé de mettre les parenthèses
<Sync time="2104.447"/>
ça vous le savez très bien.
<Sync time="2107.298"/>
donc tout ce qui suit
<Sync time="2109.927"/>
représente des expressions valides.
<Sync time="2113.450"/>
euh et dans ce qui suit, on suppose que x est une variable. donc quinze,
<Sync time="2116.958"/>
c'est une expression valide ;
<Sync time="2119.055"/>
trois plus huit, c'est une expression valide puisque trois est une expression, huit est une expression. on fait une opération entre deux expressions,
<Sync time="2125.797"/>
on se rend compte que les parenthèses sont pas utiles dans ce cas-là, donc on ne les écrit pas ;
<Sync time="2130.327"/>
c'est donc une expression.
<Sync time="2132.005"/>
un plus entre parenthèses deux fois x moins un,
<Sync time="2136.059"/>
ça c'est une expression parce que
<Sync time="2139.302"/>
d'une part, là on a une valeur,
<Sync time="2141.638"/>
là on a une expression sans les parenthèses, et puis là on a une expression dans les parenthèses avec une opération,
<Sync time="2146.557"/>
*donc on est bien dans la syntaxe.
<Sync time="2148.223"/>
mais pour que ce soit une ex() une expression valide, il faut que ça ce soit une expression valide, donc on est bien on a bien une opération avec une expression et une expression,
<Sync time="2156.0"/>
mais pour que ce soit une expression valide, ben il faut que ça ce soit une expression, donc deux fois x
<Sync time="2160.402"/>
c'est encore une expression. donc récursivement,
<Sync time="2163.046"/>
on est capable d'*analyser le fait que ce soit une expression valide ou pas.
<Sync time="2167.191"/>
et puis on peut avoir des expressions valides entre des chaînes de caractères,
<Sync time="2170.666"/>
entre des combinaisons comme ça,
<Sync time="2172.592"/>
là on peut avoir des longues suites,
<Sync time="2174.908"/>
mais c'est comme si on () on a juste enlevé les parenthèses ; si on peut rajouter les parenthèses dans cette expression, et cetera et cetera.
<Sync time="2181.118"/>
trois plus longueur de bonjour, c'est aussi une expression.
<Sync time="2185.639"/>
il y a des questions là-dessus ?
<Sync time="2189.109"/>
c'est s()
<Sync time="2190.201"/>
on n'invente rien
<Sync time="2191.369"/>
oui ?
</Turn>
<Turn startTime="2192.010" endTime="2194.539">
<Sync time="2192.010"/>

<Event desc="conv" type="noise" extent="instantaneous"/>

</Turn>
<Turn speaker="spk40" mode="planned" fidelity="high" channel="studio" startTime="2194.539" endTime="3719.129">
<Sync time="2194.539"/>
les priorités d'opérations,
<Sync time="2197.730"/>
c'est la multiplication qui est avant le plus.
<Sync time="2200.15"/>
il y a des petites subtilités, mais ça vous ve() vous travaillerez là-dessus en td, sur la concaténation parce que c'est le même signe entre le plus
<Sync time="2206.323"/>
quand il y a des ambiguïtés dans l'expression
<Sync time="2208.908"/>
et qu'on cherche à évaluer quand même l'expression, parce que c'est le but, mais je crois que j'ai un transparent là-dessus,
<Sync time="2212.902"/>
il y a des euh
<Sync time="2215.020"/>
changement de types
<Sync time="2216.454"/>
adaptés pour que () pour répondre euh pour évaluer l'expression. mais je crois que j'en parle là ; ben voilà, c'est là !
<Sync time="2223.592"/>
donc une expression
<Sync time="2224.968"/>
représente un calcul valide qu'on peut utiliser au sein des instructions de l'algorithme,
<Sync time="2230.718"/>
une expression possède une valeur
<Sync time="2234.056"/>
ce qu'on veut, c'est décrire un calcul qui amène à une valeur
<Sync time="2239.233"/>
qui est obtenue après l'évaluation de cette expression.
<Sync time="2244.065"/>
attention : il y a des ambiguïtés dans une express() quand il y a des ambiguïtés, elles sont levées en imposant les préférences ;
<Sync time="2251.177"/>
c'est ce qu'on disait tout à () tout de suite.
<Sync time="2253.930"/>
donc on préfère faire une concaténation plutôt qu'une addition
<Sync time="2258.107"/>
et pourtant, c'est le même signe. donc il y a un moment
<Sync time="2261.735"/>
s() surtout si on s'est trompé euh dans le l'écriture de l'expression () j'ai un exemple, là
<Sync time="2267.917"/>
dans le cas de l'expression douze plus bonjour,
<Sync time="2271.58"/>
le plus représente quoi ? représente une addition ou représente une concaténation ?
<Sync time="2275.575"/>
c'est le même signe.
<Sync time="2277.545"/>
on aura la même chose quand on cherchera à comparer
<Sync time="2281.413"/>
un nombre et une chaîne de caractères, c'est les mêmes signes.
<Sync time="2286.098"/>
eh bah le choix
<Sync time="2287.760"/>
qui est toujours fait
<Sync time="2289.562"/>
quand () dès qu'il y a une chaîne de caractères d'un côté ou de l'autre, ça va être de
<Sync time="2293.371"/>
choisir la concaténation, tout simplement parce que
<Sync time="2296.731"/>
on peut toujours transformer un entier en une chaîne de caractères,
<Sync time="2300.554"/>
alors qu'on peut pas toujours transformer une chaîne de caractères en un nombre.
<Sync time="2303.854"/>
bonjour, ça ne se transforme pas en un nombre ;
<Sync time="2306.130"/>
c'est pour ça que la concaténation est prioritaire.
<Sync time="2309.153"/>
donc il y a des priorités comme ça,
<Sync time="2310.805"/>
mais sinon c'est toujours les priorités des mathématiques.
<Sync time="2314.47"/>
mais vous reviendrez dessus en td, voilà c'est ce que je dis là : cf td pour plus de détails 
<Event desc="pi" type="pronounce" extent="instantaneous"/>

<Sync time="2318.802"/>
il est bien préparé mon cours finalement, il répond à vos questions.
<Sync time="2322.738"/>
alors
<Sync time="2325.062"/>
on va maintenant voir comment ça s'écrit en javascript, tout ça.
<Sync time="2332.901"/>
parce qu'attention, les notations en javascript sont des fois un petit peu bizarres.
<Sync time="2336.672"/>
pourquoi elles sont bizarres ? ben tout simplement parce qu'on n'a pas le droit
<Sync time="2339.684"/>
à tous les signes
<Sync time="2341.918"/>
qu'on écrit euh sur une feuille de papier
<Sync time="2345.085"/>
notamment, on s'est servi
<Sync time="2347.546"/>
de la flèche pour l'affectation
<Sync time="2352.319"/>
en algo() dans le langage algorithmique, c'est une flèche ;
<Sync time="2356.208"/>
dans le langage javascript, je vous ai dit c'est un égal
<Sync time="2360.354"/>
parce que sur le clavier, on trouvera pas la flèche.
<Sync time="2364.42"/>
bon ben mince, comme on a pris le égal pour l'affectation
<Sync time="2368.745"/>
eh ben
<Sync time="2369.790"/>
il faut trouver un autre signe pour la comparaison ;
<Sync time="2372.432"/>
on peut plus utiliser le égal.
<Sync time="2375.721"/>
voilà, donc attention : les notations en javascript
<Sync time="2378.341"/>
euh j'ai dit javascript, mais c'est commun à
<Sync time="2381.005"/>
à tous les langages de type c, c plus plus, java
<Sync time="2384.138"/>
il y a des difficultés pour écrire le égal.
<Sync time="2386.18"/>
et le é() test d'égalité s'écrit pas égal, mais s'écrit égal égal.
<Sync time="2390.932"/>
pour tester
<Sync time="2392.818"/>
si x est égal à cinq, on écrit x égal égal cinq.
<Sync time="2397.874"/>
le différent
<Sync time="2399.225"/>
ça, c'est un signe qui se trouve pas sur le clavier, donc il faut pas () on va pas chercher euh
<Sync time="2403.72"/>
à taper un signe compliqué
<Sync time="2405.84"/>
on va ra() écrire différent comme ça :
<Sync time="2407.888"/>
différent, c'est point d'exclamation égal.
<Sync time="2414.010"/>
les signes ou égal, donc inférieur ou égal et supérieur ou égal
<Sync time="2418.209"/>
là encore, on les trouve pas sur le clavier donc faut inventer
<Sync time="2421.857"/>
et les gens ont inventé ça :
<Sync time="2423.476"/>
on est inférieur égal
<Sync time="2425.667"/>
ou on écrit supérieur égal.
<Sync time="2429.875"/>
attention, le inférieur égal ça f() ça ressemble à une flèche, des fois c'est con()
<Sync time="2435.443"/>
ça rend les les choses un peu confuses.
<Sync time="2438.043"/>
et ça, c'est bien inférieur ou égal
<Sync time="2442.895"/>

<Event desc="pi" type="pronounce" extent="instantaneous"/>
 *donc attention
<Sync time="2445.499"/>
attention aux opérations de comparaison
<Sync time="2447.729"/>
attention aussi
<Sync time="2449.777"/>
aux opérations booléennes en javascript, où là le
<Sync time="2452.752"/>
le signe
<Sync time="2455.271"/>
euh est totalement contre-intuitif
<Sync time="2459.211"/>
tout simplement parce que et logique,
<Sync time="2462.666"/>
ça pourrait s'écrire and
<Sync time="2464.854"/>
puisqu'on est dans un langage euh anglais, mais ça ne s'écrit pas and
<Sync time="2469.708"/>
dans les langages de type c, javascript et cetera, ça s'écrit pas and, ça s'écrit
<Sync time="2474.48"/>
et commercial et commercial,
<Sync time="2476.519"/>
comme ça.
<Sync time="2478.189"/>
voilà, donc le et logique s'écrit et commercial et commercial
<Sync time="2482.731"/>
qu'on retrouvera ici.
<Sync time="2484.376"/>
le ou logique s'écrira
<Sync time="2486.730"/>
deux barres
<Sync time="2488.165"/>
alors les barres, vous les trouverez sur le clavier des pc sur euh
<Sync time="2493.302"/>
euh au cie
<Event desc="épelé" type="pronounce" extent="previous"/>

<Sync time="2494.488"/>
en faisant alt graphic plus
<Sync time="2498.03"/>
un des caractères, je crois que c'est le huit
<Sync time="2500.772"/>
mais j'en suis pas sûr.
<Sync time="2503.335"/>
on les retrouve sur le clavier, ceux-là.
<Sync time="2506.770"/>
le non logique s'écli() s'écrit point d'exclamation
<Sync time="2509.64"/>
donc non x inférieur à un,
<Sync time="2512.435"/>
ça s'écrit comme ça
<Sync time="2516.015"/>
ok ?
<Sync time="2518.368"/>
donc toutes les opérations logiques on peut les faire, voilà.
<Sync time="2521.364"/>
on peut les écrire en javascript et on peut les écrire avec le clavier,
<Sync time="2525.078"/>
ça c'était important.
<Sync time="2530.680"/>
voilà, donc on en a fini avec les instructions
<Sync time="2533.234"/>
euh avec les expressions.
<Sync time="2535.202"/>
à quoi elles nous servent, ces expressions ?
<Sync time="2539.114"/>
ben elles nous servent à écrire les instructions, les bases des instructions.
<Sync time="2543.851"/>
donc là on va parler de ça
<Sync time="2548.604"/>
on va parler de ça maintenant
<Sync time="2556.070"/>
donc ce qu'on a vu jusqu'à présent, c'est que un algorithme
<Sync time="2560.799"/>
c'était une suite d'instructions
<Sync time="2563.81"/>
et quand on a construit l'a() notre algorithme, on avait
<Sync time="2567.7"/>
une instruction pour la saisie,
<Sync time="2569.996"/>
une instruction pour l'affichage
<Sync time="2572.308"/>
et des instructions pour le calcul.
<Sync time="2575.869"/>
ben voilà
<Sync time="2576.544"/>
on a tout on a tout dit là, quand on a dit ça.
<Sync time="2579.25"/>
pour écrire un algorithme, il faut trois instructions de base :
<Sync time="2582.665"/>
les affectations qui permettent de faire les calculs
<Sync time="2585.289"/>
affectation d'une valeur à une variable,
<Sync time="2588.509"/>
les saisies,
<Sync time="2589.677"/>
les affichages.
<Sync time="2594.131"/>
un algorithme, ce sera une suite d'instructions
<Sync time="2599.251"/>
et chaque instruction
<Sync time="2602.823"/>
avant de s'exécuter, trouvera la mémoire dans un certain état,
<Sync time="2608.644"/>
*il fera son petit travail
<Sync time="2610.287"/>
modifi() elle modifiera éventuellement une variable
<Sync time="2613.46"/>
et donc elle laissera la mémoire dans un autre état.
<Sync time="2619.740"/>
et on réussira à résoudre un problème en écrivant une suite d'instructions qui modifient petit à petit l'état de la mémoire
<Sync time="2625.998"/>
en la trouvant dans un état et en la rendant dans un autre état.
<Sync time="2632.710"/>
donc ça c'est im() c'est important de retenir
<Sync time="2635.085"/>
cette phrase-là.
<Sync time="2640.350"/>
donc trois instructions de base : première instruction de base, ce sont les affectations.
<Sync time="2646.388"/>
donc qu'est-ce que je dois vous donner ? ben
<Sync time="2649.417"/>
je dois vous dire ce que ça fait. donc ce sont les instructions qui décrivent les changements de l'état de la mémoire,
<Sync time="2654.813"/>
elles s'écrivent comme ça, elles ont s() la syntaxe est la suivante :
<Sync time="2658.315"/>
nom de variable, flèche d'affectation,
<Sync time="2660.990"/>
expression.
<Sync time="2665.211"/>
donc
<Sync time="2666.906"/>
quand on exécute cette instruction,
<Sync time="2671.277"/>
il y a plusieurs étapes :
<Sync time="2673.200"/>
la première étape, ça va consister à évaluer
<Sync time="2676.495"/>
calculer la valeur de cette expression
<Sync time="2679.467"/>
et une fois qu'on connaît la valeur de cette expression,
<Sync time="2682.245"/>
on modifie la case mémoire portant ce nom-là :
<Sync time="2685.584"/>
nom de variable.
<Sync time="2688.112"/>
par exemple, x reçoit cinq,
<Sync time="2690.142"/>
c'est une instruction
<Sync time="2692.189"/>
valide qui va modifier la case mémoire
<Sync time="2695.692"/>
associée à la valeur x, et qui va lui mettre cinq.
<Sync time="2700.038"/>
nom reçoit bourdon,
<Sync time="2703.109"/>
ça va modifier la case mémoire correspondant à nom
<Sync time="2706.139"/>
enfin les cases mémoires correspondant à nom
<Sync time="2709.178"/>
et ça va leur ass() attribuer la valeur bourdon.
<Sync time="2713.128"/>
donc x
<Sync time="2714.369"/>
c'est une variable de type numérique et non est une variable de type chaîne de caractères. donc vraiment,
<Sync time="2720.870"/>
il faut retenir cette syntaxe :
<Sync time="2722.51"/>
on aura une instruction
<Sync time="2724.399"/>
quand on aura un nom de variable, une flèche qui va vers la droite
<Sync time="2728.227"/>
vers la gauche, pardon,
<Sync time="2730.072"/>
et une expression.
<Sync time="2733.379"/>
attention s() je vois très souvent,
<Sync time="2736.034"/>
donc c'est une confusion, des écritures de type : une expression,
<Sync time="2739.31"/>
la flèche qui va vers la droite, un nom de variable ; donc le contraire.
<Sync time="2744.148"/>
c'est pas la bonne écriture.
<Sync time="2747.104"/>
et
<Sync time="2748.353"/>
éventuellement, on peut le comprendre dans le langage algorithmique
<Sync time="2751.918"/>
si vous écrivez ça dans le langage ava() informatique,
<Sync time="2754.783"/>
s() il y aura il y aura probablement une erreur
<Sync time="2759.308"/>
parce qu'il comprendra pas pourquoi on met une expression
<Sync time="2763.571"/>
euh du côté euh
<Sync time="2765.823"/>
du côté euh gauche de l'express() de l'instruction d'affectation.
<Sync time="2770.298"/>
c'est 
<Event desc="pi" type="pronounce" extent="instantaneous"/>

<Sync time="2772.84"/>
alors
<Sync time="2773.810"/>
deuxième instruction de base, ce sont les saisies ;
<Sync time="2777.460"/>
donc ce sont les instructions qui permettent d'interagir en entrée avec l'utilisateur
<Sync time="2781.945"/>
qui va entrer des valeurs.
<Sync time="2785.100"/>
donc euh elles s'écrivent comme ça : un nom de variable reçoit
<Sync time="2789.030"/>
saisie.
<Sync time="2790.217"/>
c'est prè() ça ressemble beaucoup à une affectation, hein
<Sync time="2794.174"/>
en javascript ça ressemble beaucoup à une affectation, dans le langage algorithmique ça ressemble beaucoup à une affectation ; c'est une affectation d'une valeur saisie par l'utilisateur.
<Sync time="2801.062"/>
on les distingue
<Sync time="2802.515"/>
euh par exemple x reçoit saisie.
<Sync time="2807.605"/>
en tp
<Sync time="2809.169"/>
donc en javascript,
<Sync time="2810.99"/>
dans le langage () en javascript enrichi,
<Sync time="2813.406"/>
on fera la distinction entre les *différents types de valeurs qu'on peut saisir.
<Sync time="2821.220"/>
et euh pour les différencier, ces valeurs qu'on va saisir, 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 il y a trois varia() trois
<Sync time="2826.267"/>
trois manières de saisir, trois fonctions de saisie : il y a saisie entier, saisie réelle, saisie
<Sync time="2831.205"/>
et saisie, qui saisit d'une chaîne de caractères.
<Sync time="2834.161"/>
voilà, donc
<Sync time="2835.415"/>
on distinguera ça en tp ; en td, on s'en moque en fait 
<Event desc="pif" type="pronounce" extent="instantaneous"/>
 saisie c'est euh multi euh
<Sync time="2841.558"/>
multi-usages
<Sync time="2843.71"/>
et on supposera toujours que ça saisit quelque chose du bon type ;
<Sync time="2847.191"/>
en tp, il faudra se poser un peu plus la question.
<Sync time="2850.51"/>
voilà
<Sync time="2851.440"/>
dernière instruction de base, ce sont les affichages.
<Sync time="2855.923"/>
donc ce sont les instructions qui permettent d'interagir en sortie avec l'utilisateur ;
<Sync time="2860.389"/>
on lui restitue un résultat,
<Sync time="2864.372"/>
et elle s'écrivent, ça on l'a déjà vu, écrire entre parenthèses une expression.
<Sync time="2870.71"/>
donc une expression qui peut être une valeur,
<Sync time="2873.985"/>
une variable,
<Sync time="2875.199"/>
une concaténation de plusieurs choses
<Sync time="2878.749"/>
et cetera, et cetera. donc une ex() euh écrire entre parenthèses une expression.
<Sync time="2883.335"/>
par exemple, écrire bonjour le monde.
<Sync time="2888.549"/>
là encore, je fais une petite différence entre ce qu'on verra en td et ce qu'on verra en tp. en td,
<Sync time="2893.745"/>
ce sera jamais un enjeu d'écrire proprement les choses, d'avoir une fonction d'affichage qui fasse des choses très jolies.
<Sync time="2899.788"/>
par contre, en tp on a souvent envie que ce soit un affichage joli
<Sync time="2903.696"/>
donc
<Sync time="2905.370"/>
en général, on se creusera la tête pour avoir une belle expression pour un bel affich() avoir un bel affichage
<Sync time="2911.583"/>
ou voire même
<Sync time="2913.191"/>
on utilisera d'autres méthodes pour restituer un résultat,
<Sync time="2917.375"/>
comme des affichages graphiques
<Sync time="2920.387"/>
calculer l'ensemble de mandelbrot, ça vous aurait servi à rien que j'écrive toutes les valeurs que je calcule mais par contre,
<Sync time="2926.702"/>
ça vous sert de savoir que à tel point, j'ai mis () j'ai attribué telle couleur.
<Sync time="2930.791"/>
et ça, c'est une restitution
<Sync time="2932.489"/>
visuelle d'un résultat du calcul.
<Sync time="2935.666"/>
on peut avoir une résus() une restitution sonore
<Sync time="2939.763"/>
ou plein d'autres euh restitutions.
<Sync time="2945.380"/>
voilà, donc en javascript
<Sync time="2947.923"/>
l'affectation
<Sync time="2949.192"/>
s'écrit pas flèche mais s'écrit égal, ça on l'a déjà vu,
<Sync time="2954.317"/>
la saisie s'écrit a égale saisie,
<Sync time="2957.263"/>
ça on l'a déjà vu,
<Sync time="2959.111"/>
et l'affichage s'écrit écrire entre parenthèses l'expression, ça on l'a déjà vu.
<Sync time="2970.349"/>
c'est bon ?
<Sync time="2971.871"/>
non ?
<Sync time="2992.190"/>
c'est bon ?
<Sync time="2993.826"/>
non ?
<Sync time="2997.060"/>
ça va un petit peu vite je je s() j'en suis conscient.
<Sync time="3004.770"/>
mais vous n'avez pas besoin de tout noter
<Sync time="3006.580"/>
hein, on vous donnera des choses
<Sync time="3016.251"/>
allez, on passe à la suite.
<Sync time="3022.370"/>
le mot-clé important,
<Sync time="3024.397"/>
ça va être le mot-clé séquentialité.
<Sync time="3029.187"/>
donc un algorithme, c'est une suite d'instructions, je me () je je l'ai déjà écrit plusieurs fois ça, c'est une suite d'instructions
<Sync time="3034.975"/>
qui s'exécutent par défaut les unes après les autres dans l'ordre d'écriture.
<Sync time="3039.699"/>
le fait que ça s'exécute dans l'ordre d'écriture, on appelle ça la séquentialité.
<Sync time="3050.194"/>
le fait euh
<Sync time="3051.760"/>
on on ajoute un petit signe dans la syntaxe
<Sync time="3054.337"/>
qui sépare les instructions
<Sync time="3058.117"/>
donc en général,
<Sync time="3059.986"/>
pour séparer deux instructions, on les écrit
<Sync time="3062.662"/>
les unes à la suite des autres,
<Sync time="3064.443"/>
séparées par un point-virgule et mises à la ligne les unes en dessous des autres.
<Sync time="3070.420"/>
voilà la bonne manière d'écrire les les instructions.
<Sync time="3073.611"/>
par exemple,
<Sync time="3075.863"/>
le la suite d'instructions x reçoit cinq
<Sync time="3080.229"/>
point-virgule
<Sync time="3081.320"/>
y reçoit x plus dix point-virgule.
<Sync time="3084.741"/>
et le fait d'avoir bien séparé les choses, s() on saura que cette instruction-là est exécutée avant
<Sync time="3089.998"/>
celle-là
<Sync time="3091.002"/>
donc on saura que quand on exécute celle-là,
<Sync time="3093.36"/>
la valeur de x qui sera utilisée, ce sera cinq.
<Sync time="3097.137"/>
voilà
<Sync time="3098.006"/>
des instructions sont exécutées séquentiellement, et la mémoire est modifiée
<Sync time="3103.02"/>
séquentiellement.
<Sync time="3106.229"/>
*voilà, donc on parle de séquentialité.
<Sync time="3108.707"/>
euh pourquoi ça part euh si vite ? voilà
<Sync time="3111.222"/>
donc on va prendre maintenant un exemple d'évaluation
<Sync time="3115.661"/>
d'une expression
<Sync time="3118.407"/>
parce que c'est important de savoir exactement comment ça s'évalue ; donc voilà un exemple
<Sync time="3122.6"/>
j'ai cette expression y () j'ai cette instruction pardon y
<Sync time="3127.710"/>
prend pour valeur cinq fois entre parenthèses x plus dix.
<Sync time="3133.854"/>
comment ça marche ?
<Sync time="3136.249"/>
ben déjà je ch()
<Sync time="3137.801"/>
comment ça marche à l'exécution ?
<Sync time="3139.447"/>
et là, je me mets à la place de l'ordinateur.
<Sync time="3142.265"/>
l'ordinateur
<Sync time="3144.067"/>
va chercher le séparateur d'instructions, il va chercher le point-virgule
<Sync time="3148.416"/>
et quand il aura trouvé le point-virgule, il se dira : tiens, avant j'ai sans doute une instruction.
<Sync time="3152.741"/>
est-ce que j'ai vraiment une instruction ?
<Sync time="3156.304"/>
donc c'est la première question qu'il va se poser.
<Sync time="3159.730"/>
il va chercher à reconnaître l'instruction ; s'il la reconnaît pas, il f() il produit une erreur, hein.
<Sync time="3165.633"/>
donc c'est une une des sources d'erreur.
<Sync time="3167.951"/>
ici, notre instruction est valide donc il la reconnaît
<Sync time="3172.643"/>
et il reconnaît même que c'est une affectation.
<Sync time="3176.197"/>
pourquoi il a reconnu que c'était une affectation ? bah parce qu'il avait une variable
<Sync time="3179.745"/>
flèche
<Sync time="3180.552"/>
une expression.
<Sync time="3185.550"/>
donc comme il a
<Sync time="3187.214"/>
cette euh instruction, il va se poser la question maintenant de comment il fait pour l'exécuter.
<Sync time="3193.131"/>
ben pour l'exécuter, il faut d'abord évaluer l'expression
<Sync time="3198.073"/>
euh l'expression cinq fois x plus dix.
<Sync time="3201.830"/>
il faut avoir la valeur pour av() avant de pouvoir l'a()
<Sync time="3204.732"/>
l'affecter à la *variable
<Sync time="3206.494"/>
à la mémoire.
<Sync time="3209.565"/>
donc il évalue ça, mais pour ça
<Sync time="3211.929"/>
il doit chercher en mémoire la valeur associée à la variable x, sinon il peut pas évaluer l'expression.
<Sync time="3216.999"/>
bah c'est ce qu'il fait
<Sync time="3218.179"/>
voilà
<Sync time="3218.86"/>
dans la mémoire, il y a un nombre () la mémoire on la () elle est représentée comme ça
<Sync time="3223.036"/>
il y a un endroit dans la mémoire où x vaut par exemple douze ; j'aurais pu prendre cinq
<Sync time="3227.417"/>
mais là j'ai pris douze
<Sync time="3229.237"/>
donc
<Sync time="3231.050"/>
il se dit voilà : douze
<Sync time="3232.949"/>
je vais remplacer
<Sync time="3235.08"/>
x par douze dans mon expression, et je vais calculer cette expression-là. je connais tout,
<Sync time="3239.459"/>
je peux tout évaluer, l'expression est valide s()
<Sync time="3242.601"/>
je la calcule : ça vaut cent dix.
<Sync time="3247.940"/>
donc là, c'est euh compte tenu de toutes les priorités classiques des expressions, il est capable de le faire, parce que l'expression était bien construite.
<Sync time="3255.665"/>
bon
<Sync time="3256.331"/>
éta() dernière étape
<Sync time="3258.561"/>
c'est la fin de l'instruction : on affecte la valeur cent dix à la variable
<Sync time="3261.959"/>
y
<Sync time="3263.626"/>
et c'est fini ;
<Sync time="3265.167"/>
et c'est fini. une fois qu'on a ça
<Sync time="3267.735"/>
dans *la mémoire, il y a une case associée à y
<Sync time="3271.278"/>
qui a pour valeur cent dix.
<Sync time="3274.560"/>
et cet état de mé() de la mémoire sera utilisé pour les instruc() l'instruction qui suit.
<Sync time="3283.280"/>
alors ça, c'était un peu fait à la main
<Sync time="3287.812"/>
en td, vous construirez ce qu'on appelle un historique d'exécution ;
<Sync time="3293.415"/>
un historique d'exécution qui sert à suivre l'exécution d'un algorithme.
<Sync time="3298.547"/>
*alors ça se construit comme ça :
<Sync time="3301.666"/>
on on veut suivre l'état d'un certain nombre de variables
<Sync time="3305.313"/>
variable un, variable deux
<Sync time="3307.506"/>
pendant l'exécution d'un certain nombre d'instructions.
<Sync time="3311.044"/>
de quoi on a besoin pour suivre ça ?
<Sync time="3313.519"/>
on a besoin de l'état
<Sync time="3315.603"/>
l'état courant avant
<Sync time="3318.242"/>
le l'exécution de la première instruction.
<Sync time="3321.113"/>
en général, la mémoire est vide,
<Sync time="3322.869"/>
mais si on a u() une fonction, la mémoire n'est pas vide.
<Sync time="3325.406"/>
enfin si on a dans dans s() on peut imaginer que dans certains cas la mémoire n() n'est pas vide.
<Sync time="3329.652"/>
et puis ensuite, on a besoin de suivre l() l'évolution de ces valeu() de ces variables-là
<Sync time="3334.745"/>
au cours de l'exécution de l'algorithme, donc après l'exécution de l'instruction un, après l'exécution de l'instruction deux, après l'exécution de l'instruction trois.
<Sync time="3342.873"/>
voilà, *donc par exemple
<Sync time="3346.053"/>
si j'avais cet algorithme-là,
<Sync time="3349.248"/>
donc un algorithme que j'ai appelé voyage, qui a deux variables
<Sync time="3353.396"/>
position et déplacement, qui sont des entiers,
<Sync time="3356.466"/>
et puis quatre instructions :
<Sync time="3359.362"/>
la première, c'est position reçoit vingt-cinq ; la deuxième, déplacement reçoit onze ; la troisième, position reçoit position plus déplacement ; et la dernière, écrire une position.
<Sync time="3368.441"/>
je dois représenter mon histori() je représente mon historique d'exécution comme ça, donc ce que je vais vouloir suivre, c'est position et déplacement.
<Sync time="3378.083"/>
pour les suivre convenablement, je dois donner leur valeur à l'origine.
<Sync time="3382.443"/>
à l'origine, elles n'ont pas de valeur
<Sync time="3385.798"/>
donc point d'interrogation. ça va être notre manière de noter
<Sync time="3389.304"/>
qu'on ne connaît pas la valeur de la variable.
<Sync time="3393.176"/>
en javascript,
<Sync time="3394.464"/>
on aura
<Sync time="3396.084"/>
une valeur non définie 
<Sync time="3397.937"/>
quand () tant qu'on n'a pas donné de valeur à une variable, elle est non définie ; et ce () s() c'est ce que nous donnera javascript.
<Sync time="3404.450"/>
après l'exécution de la première instruction, position prend pour valeur vingt-cinq, ben
<Sync time="3409.691"/>
je me retrouve dans cette position dans cette k() configuration-là :
<Sync time="3413.509"/>
position
<Sync time="3415.045"/>
vaut vingt-cinq, déplacement n'a pas été modifié, on ne sait toujours pas ce que ça vaut.
<Sync time="3419.648"/>
deuxième ligne : on change la valeur de déplacement
<Sync time="3423.056"/>
donc on met onze ici mais on ne change pas la valeur de position.
<Sync time="3425.64"/>
donc l'état courant de la mémoire, c'est posit()
<Sync time="3428.49"/>
position qui vaut vingt-cinq, déplacement qui vaut onze.
<Sync time="3432.351"/>
ensuite je change la valeur de position
<Sync time="3435.247"/>
ça vaut trente-six, mais je ne change pas déplacement,
<Sync time="3438.305"/>
et une fonction d'affichage
<Sync time="3440.494"/>
ne change pas l'état de la mémoire.
<Sync time="3442.579"/>
donc ça lit éventuellement des valeurs en mémoire
<Sync time="3445.319"/>
ici, ça lit la valeur de position
<Sync time="3447.949"/>
mais ça n'affecte pas l'état de la mémoire.
<Sync time="3451.502"/>
donc après l'exécution de cette instruction, la mémoire n'est pas chan() n'est pas modifiée.
<Sync time="3456.133"/>
voilà
<Sync time="3458.729"/>
sur les historiques d'exécution, que vous construirez
<Sync time="3461.779"/>
plusieurs fois en td,
<Sync time="3463.309"/>
*enfin voilà une règle de construction d'historique d'exécution.
<Sync time="3466.211"/>
donc première euh chose à faire : on numérote les instructions
<Sync time="3469.799"/>
imaginons qu'il y en ait n ici ;
<Sync time="3472.593"/>
deuxième chose à faire : on sélectionne les *variables qu'on va vouloir suivre,
<Sync time="3476.655"/>
imaginons qu'il y en ait m ;
<Sync time="3478.399"/>
eh ben on construit ensuite un tableau à
<Sync time="3483.027"/>
n plus deux lignes. alors n plus deux parce que il y a cette ligne d'en-tête et puis il y a la ligne avant
<Sync time="3488.369"/>
donc ça fait euh n instructions plus les deux lignes.
<Sync time="3492.209"/>
et m plus une colonne : toutes les variables qu'on veut suivre plus la colonne d'en-tête.
<Sync time="3496.966"/>
et ce qu'on met dans le tableau, c'est
<Sync time="3499.217"/>
la valeur de la variable
<Sync time="3501.394"/>
v i
<Sync time="3502.41"/>
après l'exécution de toutes les instructions
<Sync time="3505.655"/>
jusqu'à cette euh instruction-là.
<Sync time="3509.450"/>
ok ?
<Sync time="3513.055"/>
c'est facile à construire, hein.
<Sync time="3518.175"/>
alors c'est
<Sync time="3518.935"/>
d'autant plus facile à construire
<Sync time="3521.384"/>
que euh il y a une méthode de construction automatique sur l'interface
<Sync time="3529.000"/>
euh je reviendrai dessus après le bilan,
<Sync time="3530.985"/>
ça m'évitera de
<Sync time="3533.144"/>
de tout changer.
<Sync time="3533.967"/>
donc bilan
<Sync time="3535.244"/>
de cette partie du cours : qu'est-ce qu'on a vu ?
<Sync time="3538.094"/>
on a vu qu'un algorithme, c'est une suite de séquences d'instructions qui modifient l'état de la mémoire
<Sync time="3543.367"/>
qu'on accède à la mémoire
<Sync time="3545.12"/>
en utilisant des variables
<Sync time="3547.193"/>
qui possèdent un nom,
<Sync time="3548.964"/>
un type
<Sync time="3549.745"/>
et une valeur courante.
<Sync time="3553.333"/>
et on a vu que l'historique d'exécution, c'est un outil
<Sync time="3556.705"/>
très important
<Sync time="3558.075"/>
pour comprendre le comportement d'un algorithme, pour vérifier que cet algorithme
<Sync time="3562.755"/>
donne le bon résultat
<Sync time="3564.276"/>
et éventuellement pour trouver les endroits où s() où on a commis une erreur si l'algorithme ne fournit pas le bon résultat.
<Sync time="3570.872"/>
donc c'est vraiment important, cette notion d'historique d'exécution.
<Sync time="3576.521"/>
je vous laisse noter le bilan ?
<Sync time="3629.588"/>
c'est bon ?
<Sync time="3657.110"/>
c'est bon ?
<Sync time="3658.199"/>
alors
<Sync time="3659.382"/>
comme c'est important
<Sync time="3672.670"/>
comme c'est important d'avoir euh cette notion d'historique d'exécution,
<Sync time="3676.961"/>
on a mis à disposition sur l'interface
<Sync time="3681.233"/>
un outil pour construire les historiques d'exécution automatiquement.
<Sync time="3687.280"/>
donc je vais vous montrer comment ça marche :
<Sync time="3701.806"/>
donc déjà *je
<Sync time="3703.504"/>
je transforme le
<Sync time="3707.946"/>
l'algorithme
<Sync time="3709.980"/>
euh du langage algorithmique au langage
<Sync time="3712.851"/>
javascript
<Sync time="3717.524"/>
est-ce que ça, vous sauriez le faire d'ailleurs ?
</Turn>
<Turn startTime="3719.129" endTime="3721.223">
<Sync time="3719.129"/>

<Event desc="conv" type="noise" extent="instantaneous"/>

</Turn>
<Turn speaker="spk40" mode="planned" fidelity="high" channel="studio" startTime="3721.223" endTime="3722.265">
<Sync time="3721.223"/>
avec tout ce qu'on a vu
</Turn>
<Turn mode="planned" fidelity="high" startTime="3722.265" endTime="3723.343">
<Sync time="3722.265"/>

<Event desc="conv" type="noise" extent="instantaneous"/>

</Turn>
<Turn speaker="spk40" mode="planned" fidelity="high" channel="studio" startTime="3723.343" endTime="3895.772">
<Sync time="3723.343"/>
ouais
<Sync time="3724.297"/>
oui ?
<Sync time="3731.000"/>
transformer l'algorithme qu'on a vu
<Sync time="3735.590"/>
en format algorithmique dans le format javascript, ça donne ça :
<Sync time="3740.200"/>
bon si je l'exécute
<Sync time="3748.055"/>
il y a assez de place, voilà
<Sync time="3749.17"/>
si je l'exécute,
<Sync time="3751.360"/>
j'ai bien trente-six qui est affiché
<Sync time="3754.704"/>
s() si j'a() pour construire un historique d'exécution
<Sync time="3758.242"/>
de cet algorithme,
<Sync time="3761.099"/>
il suffit de prendre les va() les noms des variables qu'on veut suivre,
<Sync time="3765.965"/>
et de les recopier dans inspect, là
<Sync time="3768.674"/>
donc je mets position virgule déplacement
<Sync time="3772.970"/>
et quand je fais ça, ça me fait la même chose quand j'exécute le programme
<Sync time="3777.002"/>
sauf qu'en plus
<Sync time="3778.739"/>
ça me construit un historique d'exécution.
<Sync time="3782.438"/>
alors je sais pas pourquoi il y a ce signe bizarre
<Sync time="3786.389"/>
mais
<Sync time="3787.414"/>
après
<Sync time="3788.434"/>
la première ins() 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 l'instruction de déclaration
<Sync time="3792.394"/>
donc avant la première instruction, autrement dit,
<Sync time="3794.874"/>
position est non définie, donc c'est point d'interrogation
<Sync time="3797.755"/>
déplacement est non défini, donc c'est point d'interrogation.
<Sync time="3801.495"/>
c'est comme ça que javascript note, c'est
<Sync time="3804.035"/>
point d'interrogation
<Sync time="3806.406"/>
undefined
<Event desc="en" type="language" extent="previous"/>

<Sync time="3809.660"/>
deuxième ligne de l'historique d'exécution :
<Sync time="3812.135"/>
après l'instruction position égale vingt-cinq,
<Sync time="3815.691"/>
ben position vaut vingt-cinq et déplacement est non défini
<Sync time="3820.338"/>
et cetera, et cetera. donc il faut le lire comme ça, cet historique d'exécution
<Sync time="3824.511"/>
ça s() ça vous semble pas très, très clair parce que c'est pas un tableau
<Sync time="3828.023"/>
mais ça () il y a exactement les mêmes instru() informations que dans le tableau.
<Sync time="3832.686"/>
les instructions ligne par ligne
<Sync time="3835.41"/>
et
<Sync time="3836.234"/>
les valeurs des variables qu'on veut suivre
<Sync time="3839.605"/>
avec éventuellement des points d'interrogation.
<Sync time="3845.596"/>
donc il y a une manière automatique de
<Sync time="3847.617"/>
construire le l'historique d'exécution.
<Sync time="3853.356"/>
avec évidemment une limite, mais la même limite que quand vous aurez à le construire à la main, c'est que euh
<Sync time="3858.193"/>
si vous voulez construire un historique d'exécution
<Sync time="3861.1"/>
de mille lignes,
<Sync time="3862.598"/>
eh ben vous allez avoir un problème pour le visualiser.
<Sync time="3867.195"/>
c'est un détail.
<Sync time="3872.553"/>
voilà
<Sync time="3874.820"/>
est-ce que vous avez des questions sur cette deuxième partie du cours
<Sync time="3879.370"/>
avant qu'on entame la troisième partie ? on aura juste le temps de de l'introduire
</Turn>
<Turn startTime="3895.772" speaker="spk40" endTime="3918.357" mode="spontaneous" fidelity="high" channel="studio">
<Sync time="3895.772"/>
vous êtes bien calmes.
</Turn>
<Turn speaker="spk40" mode="spontaneous" fidelity="high" channel="studio" startTime="3918.357" endTime="3918.805">
<Sync time="3918.357"/>
oui ?
</Turn>
<Turn mode="spontaneous" fidelity="high" startTime="3918.805" endTime="3921.760">
<Sync time="3918.805"/>

<Event desc="conv" type="noise" extent="instantaneous"/>

</Turn>
<Turn startTime="3921.760" speaker="spk40" endTime="3986.865" mode="planned" fidelity="high" channel="studio">
<Sync time="3921.760"/>
les tables de vérité ?
<Sync time="3922.986"/>
je peux rev() donc on me demande de revenir sur les tables de vérité
<Sync time="3933.161"/>
voilà
<Sync time="3936.020"/>
donc qu'est-ce que c'est qu'une table de vérité ?
<Sync time="3938.874"/>
c'est juste un tableau
<Sync time="3941.119"/>
qui représente toutes les valeurs possibles d'une expression
<Sync time="3945.568"/>
donc euh l'expression a ou b
<Sync time="3949.241"/>
a quatre valeurs possibles
<Sync time="3951.033"/>
euh a deux euh a quatre résultats possibles
<Sync time="3953.816"/>
selon les valeurs de a ou de b.
<Sync time="3956.977"/>
et
<Sync time="3957.690"/>
a a deux valeurs possibles, b a deux valeurs possibles. donc on fait tous les croisements possibles de valeurs possibles entre a et b
<Sync time="3963.640"/>
et on calcule
<Sync time="3964.952"/>
la valeur de l'expression.
<Sync time="3966.509"/>
la table de vérité, c'est juste
<Sync time="3968.590"/>
une table qui donne toutes les valeurs possibles selon toutes les entrées possibles d'une valeur.
<Sync time="3972.829"/>
et on ne le fait que pour les booléens
<Sync time="3974.647"/>
parce que euh
<Sync time="3976.496"/>
les booléens, il y a que deux valeurs possibles donc euh quand les combine là il y en a
<Sync time="3979.977"/>
il y en a quatre parce que il y a deux entrées possibles
<Sync time="3982.550"/>
donc tu as quatre combinaisons de
<Sync time="3985.177"/>
de deux valeurs
</Turn>
<Turn mode="planned" fidelity="high" startTime="3986.865" endTime="3990.363">
<Sync time="3986.865"/>

<Event desc="conv" type="noise" extent="instantaneous"/>

</Turn>
<Turn speaker="spk40" mode="planned" fidelity="high" channel="studio" startTime="3990.363" endTime="3990.983">
<Sync time="3990.363"/>
pardon ?
</Turn>
<Turn startTime="3990.983" endTime="3994.740">
<Sync time="3990.983"/>

<Event desc="conv" type="noise" extent="instantaneous"/>

</Turn>
<Turn startTime="3994.740" speaker="spk40" endTime="4000.988" mode="planned" fidelity="high" channel="studio">
<Sync time="3994.740"/>
la deuxième ligne, quand a est vrai et b est faux, on se pose la question de : que vaut a ou b ?
</Turn>
<Turn mode="planned" fidelity="high" startTime="4000.988" endTime="4003.379">
<Sync time="4000.988"/>

<Event desc="conv" type="noise" extent="instantaneous"/>

</Turn>
<Turn speaker="spk40" mode="planned" fidelity="high" channel="studio" startTime="4003.379" endTime="4003.968">
<Sync time="4003.379"/>
hein ?
</Turn>
<Turn mode="planned" fidelity="high" startTime="4003.968" endTime="4006.773">
<Sync time="4003.968"/>

<Event desc="conv" type="noise" extent="instantaneous"/>

</Turn>
<Turn speaker="spk40" mode="planned" fidelity="high" channel="studio" startTime="4006.773" endTime="4020.68">
<Sync time="4006.773"/>
ben c'est une une opération logique
<Sync time="4009.700"/>
donc s() l'expression a ou b
<Sync time="4012.511"/>
quand a est vrai
<Sync time="4014.265"/>
et b est faux
<Sync time="4015.909"/>
c'est vrai.
<Sync time="4017.280"/>
parce que il y en a un des deux qui est vrai
<Sync time="4018.980"/>
ou, c'est un des deux est vrai.
</Turn>
<Turn mode="planned" fidelity="high" startTime="4020.68" endTime="4022.417">
<Sync time="4020.680"/>

<Event desc="conv" type="noise" extent="instantaneous"/>

</Turn>
<Turn speaker="spk40" mode="planned" fidelity="high" channel="studio" startTime="4022.417" endTime="4023.131">
<Sync time="4022.417"/>
pardon ?
</Turn>
<Turn mode="planned" fidelity="high" channel="studio" startTime="4023.131" endTime="4026.22">
<Sync time="4023.131"/>

<Event desc="conv" type="noise" extent="instantaneous"/>

</Turn>
<Turn speaker="spk40" mode="planned" fidelity="high" channel="studio" startTime="4026.22" endTime="4647.520">
<Sync time="4026.220"/>
bah s() quand tu écris a ou b, tu cherches à savoir si un des deux est vrai
<Sync time="4032.011"/>
parmi les deux
<Sync time="4033.350"/>
quand tu mets a et b
<Sync time="4035.550"/>
tu cherches uniquement les cas où les deux sont vrais en même temps ;
<Sync time="4039.993"/>
c'est () d'où d'où la table de vérité.
<Sync time="4042.212"/>
d'accord ?
<Sync time="4044.584"/>
voilà
<Sync time="4048.800"/>
ok ?
<Sync time="4049.826"/>
on peut passer ?
<Sync time="4059.610"/>
voilà, donc on passe à la troisième partie
<Sync time="4064.280"/>
on a quelques minutes pour l'introduire,
<Sync time="4069.430"/>
donc je vais conclure la deuxième partie comme ça :
<Sync time="4072.730"/>
jusqu'à présent,
<Sync time="4074.767"/>
en ne faisant
<Sync time="4075.904"/>
que de la séquentialité avec des saisies, des calculs, des affichages
<Sync time="4080.171"/>
croyez-moi, vous n'allez pas aller très très loin.
<Sync time="4085.023"/>
je crois que même () on n'est même pas encore au niveau d'un langage de programmation ;
<Sync time="4088.534"/>
il manque des choses pour
<Sync time="4090.091"/>
parler de langage de programmation.
<Sync time="4093.404"/>
et les choses qui manquent,
<Sync time="4095.099"/>
c'est ce qu'on va voir maintenant dans cette partie, ce sont les structures de contrôle.
<Sync time="4099.896"/>
autrement dit, ce qu'on va chercher à faire, c'est
<Sync time="4102.491"/>
avoir des cas
<Sync time="4103.909"/>
où certaines instructions, on les évite
<Sync time="4107.597"/>
donc avoir des bifurcations dans le programme
<Sync time="4112.851"/>
et il il va y avoir des cas où on va vouloir répéter un certain nombre d'instructions.
<Sync time="4118.364"/>
donc ce qu'on va introduire dans cette partie, c'est les bifurcations et les répétitions,
<Sync time="4122.486"/>
qu'on appelle conditionnelles
<Sync time="4124.398"/>
et qu'on appelle répétitives.
<Sync time="4131.621"/>
alors petit rappel :
<Sync time="4133.920"/>
donc le l'ordre logique d'organisation, c'est ça :
<Sync time="4137.552"/>
une instruction a suivie d'une instruction b, ça s'écrit a point-virgule b
<Sync time="4144.238"/>
et puis si on
<Sync time="4146.261"/>
le l'effet, ce sera d'exécuter l'instruction a puis d'exécuter l'instruction b.
<Sync time="4150.799"/>
c'est très mal choisi *parce que j'aurais pas dû appeler mes variables a et b.
<Sync time="4153.989"/>
donc prenons euh deux exemples :
<Sync time="4155.744"/>
les deux () dans les deux exemples,
<Sync time="4157.596"/>
j'ai quatre instructions
<Sync time="4159.289"/>
ce sont les quatre mêmes instructions, sauf que je change l'ordre des deux dernières
<Sync time="4163.577"/>
entre le premier et le deuxième, bah s() c'est pas les mêmes algorithmes
<Sync time="4167.145"/>
et pourquoi c'est pas les mêmes algorithmes ? eh bah si on construit les historiques d'exécution
<Sync time="4173.230"/>
dans un cas, j'ai ça :
<Sync time="4176.790"/>
donc avant un, j'ai () je ne sais pas ce que j'ai, après un j'ai sept dans a
<Sync time="4181.817"/>
on ne sait pas dans b, après deux j'ai sept dans a, cinq dans b, ça ça changera pas ;
<Sync time="4186.267"/>
après trois, je mets douze dans a, cinq dans b
<Sync time="4189.862"/>
et je mets dix-sept dans b et douze () je garde douze en
<Sync time="4193.569"/>
dans a.
<Sync time="4194.310"/>
ça, c'est le premier historique d'exécution. le deuxième historique,
<Sync time="4197.437"/>
c'est celui-là, et ce qu'on voit bien, c'est que à la fin
<Sync time="4201.980"/>
les deux historiques d'exécution sont très () sont différents :
<Sync time="4205.007"/>
dans un cas, a vaut dix-neuf
<Sync time="4207.443"/>
et b vaut douze, et dans l'autre cas a vaut
<Sync time="4209.940"/>
douze et b vaut dix-sept.
<Sync time="4211.524"/>
c'est pas les mêmes chiffres, c'est pas les mêmes calculs,
<Sync time="4214.451"/>
c'est pas les mêmes algorithmes ;
<Sync time="4216.149"/>
ils résolvent pas le même problème.
<Sync time="4218.285"/>
et pourtant
<Sync time="4219.968"/>
c'est le même ensemble d'instructions,
<Sync time="4222.568"/>
on a juste changé l'ordre.
<Sync time="4224.402"/>
donc la séquentialité,
<Sync time="4226.195"/>
l'ordre des instructions est important.
<Sync time="4228.740"/>
ça, c'est le petit rappel.
<Sync time="4233.127"/>
mais par contre
<Sync time="4234.490"/>
on va pas très très loin
<Sync time="4237.320"/>
en n'écrivant que ces choses-là.
<Sync time="4240.644"/>
pourquoi ? ben tout simplement parce que dans certains cas, on aura plusieurs possibilités d'instructions, on aura plusieurs
<Sync time="4247.327"/>
bifurcations
<Sync time="4249.004"/>
imaginez : vous êtes dans un labyrinthe, vous avez trois choix possibles, 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 vous voulez coder un algorithme qui résout ce problème de labyrinthe.
<Sync time="4255.602"/>
avec ce qu'on a vu jusqu'à présent, vous n'êtes pas capable de le faire
<Sync time="4259.770"/>
parce que il y a un choix à faire.
<Sync time="4264.120"/>
on a aussi besoin de répéter les choses
<Sync time="4267.392"/>
donc d'itérer plusieurs fois la même instruction
<Sync time="4270.132"/>
avancer dans le labyrinthe
<Sync time="4272.096"/>
avancer une fois, avancer deux fois, avancer trois fois jusqu'à tomber à un mur
<Sync time="4275.456"/>
sur un mur
<Sync time="4278.100"/>
ou jusqu'à tomber sur une bifurcation :
<Sync time="4281.591"/>
si on a envie d'aller à droite, on va à droite ; si on a envie d'aller à gauche, on va à gauche ;
<Sync time="4284.642"/>
si on est déjà passé par la droite,
<Sync time="4286.875"/>
on va vers la gauche ; si on est déjà passé vers la gauche, on va vers la droite.
<Sync time="4291.840"/>
donc vraiment, on a envie de pouvoir
<Sync time="4294.330"/>
coder ces résolutions de problèmes-là en informatique.
<Sync time="4298.500"/>
l'analogie, c'est vraiment des problèmes de labyrinthe.
<Sync time="4302.203"/>
voilà, donc modifier l'ordre naturel les instructions se fait à l'aide de structures de contrôle
<Sync time="4307.001"/>
qu'on appelle structures conditionnelles et qu'on appelle structures répétitives.
<Sync time="4313.836"/>
et dans cette partie,
<Sync time="4315.623"/>
on verra une structure conditionnelle
<Sync time="4318.42"/>
et deux structures répétitives.
<Sync time="4326.040"/>
donc à quoi servent les conditionnelles ?
<Sync time="4330.603"/>
bon on verra l() la syntaxe et l'usage des conditionnelles,
<Sync time="4335.342"/>
on parlera de conditionnelles imbriquées, d'arbres de décision
<Sync time="4338.863"/>
dans cette euh partie sur les conditionnelles
<Sync time="4346.180"/>
mais je vais k() d'abord commencer par les motivations : pourquoi on a besoin de conditionnelles ?
<Sync time="4350.924"/>
*parce qu'il y a des () *enfin voilà des cas concrets
<Sync time="4353.445"/>
où on a besoin d'une conditionnelle.
<Sync time="4357.537"/>
pour calculer la valeur
<Sync time="4359.042"/>
absolue d'un nombre
<Sync time="4362.460"/>
bah là j'ai deux choix :
<Sync time="4364.930"/>
la valeur absolue d'un nombre, c'est ce nombre quand il est positif,
<Sync time="4369.108"/>
mais c'est moins ce nombre quand il est négatif ;
<Sync time="4371.577"/>
donc il y a un choix à faire,
<Sync time="4373.067"/>
il y a une conditionnelle là, derrière.
<Sync time="4376.465"/>
afficher l'inverse d'un nombre
<Sync time="4379.508"/>
a priori, il y a pas de conditionnelle quand on fait un sur x
<Sync time="4382.389"/>
sauf quand x est égal à zéro. donc il y a un cas particulier à traiter :
<Sync time="4386.16"/>
il y a une conditionnelle
<Sync time="4387.187"/>
derrière.
<Sync time="4390.370"/>
jouer au jeu du plus ou moins, bah ça ça va nous occuper à la fin, *enfin on va programmer ça.
<Sync time="4395.870"/>
il y a une conditionnelle parce que il y a un moment où faudra lui dire : c'est plus que la valeur proposée ou c'est moins que la valeur proposée ;
<Sync time="4401.304"/>
il y a une conditionnelle.
<Sync time="4404.252"/>
en gros, il y a des conditionnelles dans tous les cas où il y a des traitements alternatifs à faire.
<Sync time="4410.660"/>
et d'ailleurs, la conditionnelle on l'appelle parfois une alternative.
<Sync time="4418.130"/>
donc voilà la syntaxe des alternatives,
<Sync time="4422.184"/>
la syntaxe algorithmique
<Sync time="4425.596"/>
ça s'écrira comme ça:
<Sync time="4427.446"/>
si entre parenthèses
<Sync time="4429.312"/>
une expression booléenne
<Sync time="4431.849"/>
qui est une condition, en fait
<Sync time="4435.026"/>
alors
<Sync time="4436.844"/>
des instructions
<Sync time="4438.068"/>
quand la condition est () qui seront exécutées quand la condition est vraie,
<Sync time="4441.896"/>
sinon, des instructions qui seront exécutées quand le la condition est fausse.
<Sync time="4447.861"/>
et là, je vous mets un exemple :
<Sync time="4450.780"/>
si on a demandé à l'utilisateur de saisir son âge,
<Sync time="4454.578"/>
si l'âge est inférieur à dix-huit alors on peut lui écrire : vous êtes euh mineur
<Sync time="4460.849"/>
sinon, on peut lui écrire : vous êtes majeur
<Sync time="4464.636"/>
et ne pas oublier le finsi.
<Sync time="4467.689"/>
donc voilà la syntaxe des alternatives.
<Sync time="4477.280"/>
alors
<Sync time="4478.05"/>
la condition, c'est n'importe quelle expression dont la valeur est booléenne.
<Sync time="4481.999"/>
donc
<Sync time="4482.801"/>
âge inférieur à dix-huit
<Sync time="4484.812"/>
ça, c'est une condition simple
<Sync time="4486.770"/>
mais on verra qu'on peut en construire avec des opérateurs logiques,
<Sync time="4491.009"/>
on peut construire des expressions booléennes qui peuvent être un peu compliquées.
<Sync time="4498.090"/>
donc pre() première chose : un petit cas particulier de cette euh alternative, c'est qu'en fait elle se p() elle peut se simplifier
<Sync time="4504.249"/>
dans beaucoup de langages, elle peut se simplifier
<Sync time="4507.489"/>
parce qu'il est () parfois on n'a pas une alternative,
<Sync time="4510.691"/>
on a juste une expression
<Sync time="4512.436"/>
qu'on ne veut faire que dans un certain cas.
<Sync time="4516.311"/>
donc c'est pas une alternative entre deux expressions, c'est une expression qui apparaît ou qui n'est p() qui est là où qui n'est pas là.
<Sync time="4522.112"/>
et dans ce cas-là, on utilise une conditionnelle simple
<Sync time="4525.04"/>
qui est en fait un cas particulier de l'alternative,
<Sync time="4527.687"/>
donc l'écriture est la même, sauf qu'il y a pas de sinon.
<Sync time="4532.273"/>
donc même écriture sans le sinon,
<Sync time="4536.070"/>
donc par exemple :
<Sync time="4538.830"/>
pour calculer l'inverse de x,
<Sync time="4541.622"/>
bah on a juste à exécuter l'instruction x reçoit moins x quand x est négatif.
<Sync time="4548.899"/>
mais
<Sync time="4550.530"/>
quand on sera ici, on aura toujours
<Sync time="4552.584"/>
x qui vaut la valeur absolue de x.
<Sync time="4556.014"/>
d'accord ?
<Sync time="4557.330"/>
donc il y a cette conditionnelle.
<Sync time="4565.130"/>
on en arrive à sa traduction en javascript, et puis on s'arrêtera sur euh cette traduction en javascript
<Sync time="4570.542"/>
donc la traduction de l'al() de l'alternative en javascript, cette alternative-là
<Sync time="4575.193"/>
ça devient ça, donc
<Sync time="4576.930"/>
la traduction elle est presque littérale :
<Sync time="4579.670"/>
le si devient if,
<Sync time="4583.176"/>
on limite le nombre de mots-clés dans le langage, donc il y a pas de alors parce que le alors il est toujours là
<Sync time="4587.982"/>
donc en fait, comme il est toujours là, on s'en on s'en passe.
<Sync time="4591.472"/>
par contre, ce est important, c'est d'avoir des accolades ici, ouvrantes et fermantes,
<Sync time="4595.753"/>
parce que là on n'a mis qu'une instruction, mais on peut imaginer que il y ait une suite d'instructions, ben il y a bien un moment
<Sync time="4601.578"/>
où faut délimiter cette suite d'instructions.
<Sync time="4604.928"/>
dans le langage javascript, délimiter une suite d'instructions, ça se fait avec des accolades.
<Sync time="4610.623"/>
le sinon, ben *comme celui-là il est pas toujours présent,
<Sync time="4614.006"/>
on est obligé de le spécifier ici
<Sync time="4616.409"/>
donc euh sinon en anglais, ça se dit else.
<Sync time="4618.748"/>
et de la même manière, on met des accolades ouvrantes et fermantes,
<Sync time="4622.114"/>
voilà.
<Sync time="4623.530"/>
juste pour terminer
<Sync time="4625.337"/>
quand il y a pas le sinon,
<Sync time="4627.080"/>
bah il y a pas le else
<Sync time="4628.575"/>
dans la syntaxe.
<Sync time="4633.550"/>
voilà, bon on s'arrête là-dessus
<Sync time="4638.859"/>
et on se revoit jeudi à onze heures.
</Turn>
</Section>
</Episode>
</Trans>
