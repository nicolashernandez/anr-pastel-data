<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE Trans SYSTEM "trans-14.dtd">
<Trans audio_filename="20131115" version="2" version_date="170619">
<Speakers>
<Speaker id="spk1" name="Béatrice Daille" type="female" dialect="native" accent="" scope="local" check="yes"/>
</Speakers>
<Episode>
<Section type="report" startTime="0" endTime="4336.512">
<Turn startTime="0.0" speaker="spk1" endTime="1687.920" mode="planned" fidelity="high" channel="studio">
<Sync time="0.0"/>

<Event desc="pi" type="pronounce" extent="instantaneous"/>
 donc on est parti euh un petit voyage euh dans le traitement automatique du langage naturel.
<Sync time="7.239"/>
donc qui est une application euh de l'informatique.
<Sync time="11.681"/>
alors première définition : qu'est-ce que c'est que le langage naturel ? en particulier : qu'est-ce que c'est que la langue ?
<Sync time="19.742"/>
pas pas 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 pas l'organe hein mais euh
<Sync time="22.966"/>
le système complexe hein de communication qui est propre
<Event desc="b" type="noise" extent="previous"/>
 aux communautés humaines.
<Sync time="30.520"/>
alors la langue naturelle, c'est un système *complexe et c'est le fruit de beaucoup de choses, en particulier de la culture, de l'histoire
<Sync time="40.312"/>
et de l'expérience
<Sync time="42.596"/>
des
<Sync time="45.153"/>
sociétés humaines
<Sync time="47.829"/>
et depuis environ
<Sync time="49.954"/>
euh soixante ans,
<Sync time="53.004"/>
on essaye
<Sync time="54.311"/>
de traiter euh la langue, les langues d'un point de vue informatique.
<Sync time="59.076"/>
ça pose
<Sync time="60.159"/>
un certain nombre de problèmes
<Sync time="62.277"/>
donc il est pas question de tout aborder euh dans ce cours d'une heure quinze, mais de vous donner
<Sync time="68.230"/>
euh une première idée de ce que c'est que des applications en langage naturel,
<Sync time="72.280"/>
de voir des des premiers algorithmes assez simples
<Sync time="75.728"/>
que même en étant euh informaticiens débutants
<Sync time="79.330"/>
vous êtes capable de faire. et si ça vous intéresse, ben après vous pourrez continuer
<Sync time="85.030"/>
plus tard hein, il y a des mastères spécialisés en traitement de la langue,
<Sync time="88.534"/>
en tout cas il y en a un ici euh à l'université de Nantes.
<Sync time="93.508"/>
alors ce cours
<Sync time="96.464"/>
on va essayer de de positionner
<Sync time="100.338"/>
euh le langage naturel euh dans dans un espace-temps, hein.
<Sync time="105.000"/>
et euh si on prend par exemple le film deux mille un l'odyssée de l'espace,
<Sync time="110.345"/>
vous êtes en face d'un ordinateur, hal
<Sync time="114.256"/>
qui comprend l'homme,
<Sync time="115.901"/>
qui dialogue
<Sync time="117.060"/>
avec lui dans sa langue,
<Sync time="119.800"/>
qui exécute ses commandes et qui ressent même des émotions,
<Sync time="123.161"/>
hein.
<Sync time="123.919"/>
donc c'est un in() un ordinateur qui a beaucoup de caractéristiques humaines.
<Sync time="129.879"/>

<Event desc="pi" type="pronounce" extent="instantaneous"/>

<Sync time="131.434"/>
on va laisser euh la partie euh ressenti des émotions, qui est plus sur le côté cognition
<Sync time="137.520"/>
et ce qui nous intéresse, c'est la partie dialogue homme machine
<Sync time="141.999"/>
dans la langue, et en par()
<Sync time="144.040"/>
et voir où on en est aujourd'hui.
<Sync time="147.485"/>
donc ça fait euh douze ans que l'on prédisait qu'en deux mille un, on aurait un tel ordinateur qui euh soit capable de faire ces choses-là
<Sync time="156.287"/>
hein, d'avoir un vrai dialogue avec euh l'homme ; alors, on en est où ?
<Sync time="162.992"/>
alors on en est euh on a beaucoup avancé hein sur euh sur les applications de traitement automatique des langues, parce que le langage a pris une place dans votre quotidien,
<Sync time="172.718"/>
hein.
<Sync time="173.635"/>
donc maintenant les voitures parlent :
<Sync time="176.338"/>
elles vous demandent de mettre votre euh
<Sync time="178.298"/>
ceinture par exemple.
<Sync time="180.842"/>
les machines à café,
<Sync time="183.210"/>
les touches disparaissent peu à peu,
<Sync time="185.958"/>
hein
<Sync time="186.801"/>
maintenant euh elles comprennent votre commande.
<Sync time="190.610"/>
vous lui demandez un expresso euh,
<Sync time="194.623"/>
un café allongé ou un cappuccino, que vous soyez chinois euh arabe euh espagnol ou français,
<Sync time="202.174"/>
ces machines comprennent votre commande.
<Sync time="204.703"/>
hein c'est on en trouve euh un petit peu partout, peut-être pas trop encore ici mais euh
<Sync time="209.840"/>
en tous cas dans les universités allemandes, il y en a déjà.
<Sync time="212.410"/>
euh
<Sync time="214.444"/>
la dictée automatique
<Sync time="216.700"/>
c'est quelque chose aussi euh qui fonctionne hein,
<Sync time="220.197"/>
chez les professionnels de santé en particulier.
<Sync time="223.047"/>
vous avez les médecins qui dictent leurs comptes-rendus médicaux
<Sync time="227.351"/>
à l'ordinateur
<Sync time="228.886"/>
et cet ordinat() enfin
<Sync time="230.874"/>
ce logiciel retranscrit
<Sync time="233.348"/>
en traitement de texte
<Sync time="234.745"/>
le signal vocal qu'il entend.
<Sync time="237.58"/>
hein, la voix c'est un signal
<Sync time="239.674"/>
ce n'est pas
<Sync time="242.370"/>
ce n'est pas euh ju() du texte directement.
<Sync time="246.787"/>
d'autres applications qui font partie de votre existence : les correcteurs orthographiques
<Sync time="251.340"/>
hein je pense que vous pouvez plus vous en passer
<Sync time="254.110"/>
dans les traitements de textes, et les
<Sync time="256.443"/>
et euh les correcteurs grammaticaux qui vous aident à accorder les participes passés par exemple, hein.
<Sync time="262.656"/>
et puis euh quelque chose qui date euh qui a été les premières recherches euh en traitement automatique des langues, c'était la traduction automatique dans le cadre de la guerre froide
<Sync time="273.74"/>
états-unis europe hein, c'est là où on a où on a proposé les premiers systèmes de traduction automatique
<Sync time="281.190"/>
qui sont maintenant disponibles pour le grand public, en particulier sur le web avec euh en particulier euh le
<Sync time="288.460"/>
euh le traducteur automatique statistique de de google, mais vous avez aussi des grandes compagnies françaises comme reverso
<Sync time="295.992"/>
qui font euh des traducteurs au() automatiques extrêmement performants.
<Sync time="300.970"/>
et ensuite euh l'avenir ben c'est quoi ? ben ça va être la traduction incorporée
<Sync time="306.584"/>
dans
<Sync time="307.643"/>
des euh outils de votre vie commune,
<Sync time="310.396"/>
en particulier sur votre téléphone
<Sync time="312.960"/>
hein vous
<Sync time="314.471"/>
ça () la traduction sera une touche que vous appuierez
<Sync time="317.482"/>
si vous appelez quelqu'un par exemple en italie
<Sync time="320.478"/>
eh ben il retrans() enfin il transc() euh
<Sync time="323.290"/>
il traduira votre () ce que vous dites en italien.
<Sync time="326.073"/>
hein, ça on peut imaginer que ça va arriver bientôt, comme le
<Sync time="331.196"/>
le photocopieur qui, en même temps qu'il photocopie, traduit votre texte.
<Sync time="338.908"/>
alors ça, c'est des applications qui sont centrales
<Sync time="342.013"/>
euh où la langue est vraiment au coeur
<Sync time="346.202"/>
mais vous en avez d'autres où elle intervient fortement, en particulier je vais pas toutes vous les détailler, mais vous avez
<Sync time="353.366"/>
euh les moteurs de recherche hein, ce qu'ils indexent c'est du texte
<Sync time="357.060"/>
le texte, c'est une expression de la langue
<Sync time="359.431"/>
donc tout ça, c'est
<Sync time="361.730"/>
des choses qui euh font intervenir du langage
<Sync time="366.071"/>
et puis euh dans les choses euh un petit peu nouvelles, par exemple euh le scanner
<Sync time="372.852"/>
bon, le scanner c'est quelque chose qu'existe depuis assez longtemps. scanner, ça veut dire quoi ? c'est transcrire un document papier
<Sync time="380.903"/>
sous format numérique.
<Sync time="382.421"/>
hein
<Sync time="383.337"/>
pas forcément image, mais traitement de texte hein aussi hein
<Sync time="387.794"/>
donc euh
<Sync time="389.777"/>
ça existe depuis les années quatre-vingts, ce genre de logiciels
<Sync time="394.148"/>
mais on a des gros chantiers
<Sync time="396.583"/>
euh de numérisation des productions humaines
<Sync time="399.597"/>
avec euh
<Sync time="401.119"/>
l'objectif de numériser à l'horizon euh deux mille vingt toutes les productions humaines qui ont existé
<Sync time="407.165"/>
depuis
<Sync time="408.550"/>
bah depuis qu'il y a des textes écrits.
<Sync time="410.921"/>
hein euh à mon avis ça va durer plus de deux mille vingt
<Sync time="413.936"/>
et c'est pas simplement la bnf qui fait ça, c'est toutes les bibliothèques au monde.
<Sync time="417.953"/>
donc il y a des gros
<Sync time="419.252"/>
euh z() difficultés parce que c'est pas simplement copier : après, il y a des langues qui ont disparu,
<Sync time="425.589"/>
il y a des langues qui sont écrites avec des écritures enluminées,
<Sync time="429.620"/>
avec des dessins, donc il faut arriver à dissocier ce qui est un dessin de ce que () est de l'écriture
<Sync time="436.560"/>
il y a beaucoup de recherches et beaucoup de travaux encore euh sur ces choses-là.
<Sync time="440.210"/>
et puis bien entendu, des choses comme l'analyse des opinions :
<Sync time="444.280"/>
tout le monde est féru de pouvoir euh analyser ce que vous dites sur les réseaux, sur les tweets ou sur
<Sync time="452.294"/>
les blogs.
<Sync time="455.123"/>
alors cet exposé
<Sync time="457.178"/>
euh va se décliner en trois parties, j'arrive jamais à finir, je vous préviens mais au moins on va essayer de
<Sync time="462.692"/>
de faire euh la première partie () on va faire la première partie : les bases
<Sync time="466.660"/>
on va vai() faire une petite pause
<Sync time="470.263"/>
une petite respiration
<Sync time="472.571"/>
c'est pas au début la respiration, hein
<Sync time="479.860"/>
une petite respiration
<Sync time="481.980"/>
au milieu, et après on verra un premier outil informatique
<Sync time="486.214"/>
qui permet
<Sync time="487.260"/>
de traiter la langue, qui sont les expressions rationnelles.
<Sync time="494.180"/>
alors les bases :
<Sync time="495.236"/>
les bases, on va voir euh quatre objets : les caractères,
<Sync time="498.909"/>
les mots,
<Sync time="500.100"/>
les phrases et les textes.
<Sync time="502.100"/>
hein quatre objets, quatre unités
<Sync time="504.724"/>
qui sont disons de base lorsqu'on
<Sync time="508.122"/>
euh lorsqu'on fait de la linguistique, lorsqu'on s'intéresse
<Sync time="511.089"/>
aux langues.
<Sync time="514.533"/>
et donc on va commencer par
<Sync time="516.99"/>
le caractère. alors je parle ici des caractères alphabétiques
<Sync time="522.379"/>
hein, bien entendu il existe d'autres caractères
<Sync time="525.161"/>
et d'autres types d'écritures comme l'écriture
<Sync time="528.027"/>
logographique
<Sync time="530.576"/>
où un symbole représente un mot, hein vous pouvez en avoir plusieurs milliers ; l'écriture syllabique
<Sync time="536.200"/>
où un symbole représente une syllabe ;
<Sync time="538.661"/>
nous, on a de la chance : on a une écriture alphabétique
<Sync time="542.620"/>
et un symbole représente un son.
<Sync time="549.140"/>
qu'est-ce que c'est qu'un caractère au point de vue informatique ?
<Sync time="552.180"/>
donc l'ordinateur il est resté euh à la nuit des temps, hein il ne manipule toujours que *des uns et des zéros
<Sync time="559.216"/>
donc pour lui
<Sync time="562.409"/>
une lettre c'est un chiffre,
<Sync time="564.355"/>
d'accord ?
<Sync time="565.465"/>
et pour arriver
<Sync time="569.318"/>
à lui faire comprendre
<Sync time="572.253"/>
une lettre ()
<Sync time="576.905"/>
on va arrêter tout de suite, hein
<Sync time="591.036"/>
pour lui faire arriver à comprendre une lettre, on lui donne une table de correspondance
<Sync time="596.481"/>
entre un chiffre et une lettre. donc ça peut être un tableau simplement à un d() à une dimension
<Sync time="602.005"/>
comme ceci
<Sync time="604.418"/>
où on va dire que la lettre a, c'est le chiffre un ; la lettre b, c'est le chiffre deux, et cetera ; donc quelque chose d'assez simple.
<Sync time="613.073"/>
bon, tout n'est pas des codes, hein. donc les codes, vous avez des caractéristiques
<Sync time="618.424"/>
pour le code, en particulier
<Sync time="620.776"/>
vous () un code doit répondre à quatre propriétés :
<Sync time="625.208"/>
le code doit avoir un nom,
<Sync time="628.956"/>
il doit avoir une taille, et comme on travaille avec l'ordi, on lui indique le nombre de bits qui sont nécessaires pour
<Sync time="635.893"/>
coder les symboles.
<Sync time="637.774"/>
donc ça va être
<Sync time="639.166"/>
exprimé en deux puissance quelque chose
<Sync time="642.294"/>
vous allez ensuite décrire les symboles
<Sync time="644.665"/>
et vous devez faire attention à la manière dont
<Sync time="648.360"/>
les symboles sont définis
<Sync time="651.031"/>
euh s() cette manière doit respecter
<Sync time="654.670"/>
des applications, en particulier doivent permettre de faire des tris
<Sync time="657.820"/>
hein on () et des tris alphabétiques.
<Sync time="662.730"/>
dans les symboles, on a besoin des chiffres
<Sync time="665.762"/>
au minimum, et des lettres de l'alphabet, et des lettres de ponctuation
<Sync time="669.499"/>
et normalement, on devrait pas avoir de caractères de contrôle qui relèvent
<Sync time="673.902"/>
de l'ordinateur
<Sync time="675.214"/>
hein
<Sync time="677.253"/>
on va voir trois exemples de codes, il y en a beaucoup d'autres, il y en a des milliers
<Sync time="682.295"/>
mais on va voir les trois plus importants.
<Sync time="686.579"/>
le premier code, c'est le code ascii
<Sync time="689.0"/>
donc c'est la première norme
<Sync time="691.089"/>
qui a existé
<Sync time="692.538"/>
hein, qui date de mille neuf cent soixante-trois, c'est une norme iso.
<Sync time="696.613"/>
à cette époque
<Sync time="698.340"/>
on était aux rudiments de l'informatique,
<Sync time="701.240"/>
on n'avait pas beaucoup de place mémoire, donc un caractère va être codé sur
<Sync time="705.420"/>
sept bits.
<Sync time="708.581"/>
sept bits, ça veut dire quoi ? ça veut dire on a de la place pour cent vingt-huit caractères.
<Sync time="715.651"/>
donc
<Sync time="716.702"/>
c'est pas beaucoup, hein.
<Sync time="718.050"/>
donc c'est un code universel, c'est le premier, on l'a gardé
<Sync time="722.602"/>
et
<Sync time="723.519"/>
il est inclus dans tous les autres codes qui ont été créés
<Sync time="726.95"/>
par la suite.
<Sync time="728.310"/>
alors le codage il il est connu :
<Sync time="731.738"/>
de zéro à trente et un, vous allez avoir des caractères de contrôle
<Sync time="735.800"/>
qui ne sont pratiquement plus utilisés maintenant ;
<Sync time="738.280"/>
de trente-deux à quarante-sept,
<Sync time="740.070"/>
des signes de ponctuation ;
<Sync time="742.391"/>
de quarante-huit à cinquante-sept, les chiffres ;
<Sync time="745.460"/>
de soixante-cinq à quatre-vingt-dix, les lettres majuscules et de quatre-vingt-dix sept à cent vingt-deux,
<Sync time="750.738"/>
les lettres minuscules.
<Sync time="754.088"/>
ce premier codage
<Sync time="756.838"/>
traite uniquement les textes de la langue anglaise.
<Sync time="761.570"/>
il a été d'ailleurs euh en partie
<Sync time="764.590"/>
proposé par les américains
<Sync time="768.980"/>
et évidemment
<Sync time="770.670"/>
si
<Sync time="772.239"/>
il convient
<Sync time="774.452"/>
aux
<Sync time="775.600"/>
anglais euh de langue () aux aux aux personnes de langue anglaise, il convient euh il convient juste à eux.
<Sync time="781.880"/>
*c'est-à-dire qu'il y a des problèmes pour tous les autres langues.
<Sync time="784.962"/>
donc à peine a-t-il été proposé que l'on a cherché
<Sync time="789.110"/>
à en avoir un autre un peu plus complet.
<Sync time="792.880"/>
avant de voi() ah oui faut euh j'oublie toujours euh cette table ascii, donc voilà un exemple de table ascii
<Sync time="799.520"/>
donc
<Sync time="800.829"/>
pour euh
<Sync time="802.514"/>
présenter les euh
<Sync time="805.700"/>
les tables de caractères, on utilise souvent le code hexa
<Sync time="809.825"/>
hein, hexa c'est avec seize caractères
<Sync time="813.120"/>
donc s() il y a une équivalence entre les deux puissance quelque chose, deux puissance huit
<Sync time="817.869"/>
et euh les caractères.
<Sync time="820.284"/>
donc par exemple,
<Sync time="821.782"/>
c'est toujours présenté de cette manière-là : ici, vous avez les décimales en hexa
<Sync time="829.068"/>
donc là c'est quatre
<Sync time="830.580"/>
euh dizaines d'hexa et ici, vous avez les unités en hexa donc quarante-trois,
<Sync time="835.970"/>
ça vous donne
<Sync time="837.480"/>
la lettre c, et vous avez l'équivalent en décimal
<Sync time="841.496"/>
en multipliant
<Sync time="842.890"/>
quatre par seize, et en *ajoutant
<Sync time="845.720"/>
les trois.
<Sync time="846.418"/>
hein, ce qui vous donne
<Sync time="847.69"/>
soixante-sept.
<Sync time="850.717"/>
donc toutes ces tables, quand vous regardez les codes de caractères, se présentent
<Sync time="854.865"/>
toujours de cette manière-là,
<Sync time="856.730"/>
ce qui permet
<Sync time="860.185"/>
qu'est-ce que je fais ?
<Sync time="865.511"/>
excusez-moi
<Sync time="867.480"/>
ce qui permet de de les représenter d'une manière concise.
<Sync time="874.205"/>
donc le deuxième euh
<Sync time="876.908"/>
code qui est apparu, il est apparu en mille neuf cent quatre-vingt-sept, c'est la famille des isos latins.
<Sync time="883.799"/>
cette fois-ci, on augmente la taille
<Sync time="886.690"/>
euh de caractères, on passe à huit bits
<Sync time="889.615"/>
hein, donc on a deux cent cinquante-six caractères ; on double.
<Sync time="894.474"/>
on garde les cent vingt-huit premiers caractères, qui sont les caractères d'ascii
<Sync time="898.870"/>
et il nous en reste donc cent vingt-huit pour coder toutes les autres lettres
<Sync time="903.460"/>
des langues.
<Sync time="904.980"/>
bon il y en a il y en a pas assez, clairement
<Sync time="907.507"/>
donc comment on fait ? on fait des familles
<Sync time="910.199"/>
et on va créer dix groupes de famille, donc vous allez avoir
<Sync time="914.396"/>
l'euro() les langues de l'europe de l'ouest, les langues de l'europe de l'est,
<Sync time="918.630"/>
les langues de l'europe du sud,
<Sync time="920.825"/>
du nord, et cetera.
<Sync time="923.141"/>
et ce qui nous intéresse, bon on va regarder le iso latin un, ou le quatre-vingt-huit cinquante-neuf un, c'est celui euh
<Sync time="929.528"/>
où on apparaît, où le français apparaît
<Sync time="933.249"/>
et vous voyez que dedans, il y a l'allemand, l'anglais, le danois, l'espagnol, le féroïen, le finnois, le français, l'islandais, l'italien,
<Sync time="942.308"/>
néerlandais, norvégien, portugais et suédois.
<Sync time="945.846"/>
c'est déjà très hétérogène d'un point de vue famille de langues linguistiques, c'est-à-dire qu'on n'a pas essayé de faire () de regrouper les langues d'un point de vue caractéristiques
<Sync time="954.732"/>
linguistiques,
<Sync time="955.653"/>
mais on a fait des partitions géopolitiques
<Sync time="959.221"/>
hein qui sont pas forcément toujours heureuses.
<Sync time="964.490"/>
en particulier, pourquoi est-ce qu'on trouve le norvégien dans les europe de l'ouest et pas dans dans l'europe du nord ?
<Sync time="970.595"/>
bon voilà, il y a des il y a des choses comme ça qui sont un peu bizarres
<Sync time="974.072"/>
et l'apparition de langues telles que le féroïen,
<Sync time="977.890"/>
qui est euh une langue qui est en fait une langue germanique
<Sync time="981.587"/>
hein, qui relève euh
<Sync time="983.561"/>
euh du territoire danois
<Sync time="986.730"/>
et qui est parlée environ par vingt mille personnes, donc beaucoup moins que des langues comme le breton
<Sync time="992.365"/>
ou l'occitan ou euh
<Sync time="994.680"/>
ou autres langues euh qui n'ont pas de de statut euh
<Sync time="998.836"/>
euh en france, mais qui peuvent l'avoir dans d'autres pays.
<Sync time="1005.434"/>
le problème surtout
<Sync time="1007.361"/>
euh avec le codage de l'iso latin, c'est qu'il manque des lettres.
<Sync time="1012.676"/>
*c'est-à-dire que comme on n'avait pas beaucoup de place, des compromis ont dû être faits
<Sync time="1017.380"/>
entre les langues, et en particulier pour le français, il nous en manque trois.
<Sync time="1024.042"/>
donc les trois lettres qui manquent,
<Sync time="1028.424"/>
je pense que vous les connaissez hein
<Sync time="1039.030"/>
c'est la ligature,
<Sync time="1040.614"/>
et la ligature elle est absolument pas anecdotique en français
<Sync time="1044.753"/>
hein
<Sync time="1045.601"/>
elle est () elle apparaît dans soeur, dans voeu, euh dans dans plein de mots
<Sync time="1049.840"/>
et e()( donc
<Sync time="1051.781"/>
là elle est en majuscules, en minuscules et puis le le i grec tréma qui lui est un peu plus euh
<Sync time="1056.596"/>
un peu plus rare, mais qui existe dans certains noms propres
<Sync time="1060.433"/>
alors pourquoi
<Sync time="1062.080"/>
pourquoi on n'a pas eu euh on n'a pas eu droit
<Sync time="1065.535"/>
à euh
<Sync time="1071.722"/>
à la ligature ? je vais vous lire
<Sync time="1075.186"/>
ce qui s'est passé
<Sync time="1089.720"/>
alors selon une *légende urbaine, le représentant français était malade le jour où la norme a été votée
<Sync time="1097.202"/>
et il a dû se faire remplacer par son homologue belge.
<Sync time="1101.263"/>
alors euh c'est euh
<Sync time="1102.918"/>
évidemment, c'est faux
<Sync time="1104.360"/>
hein, parce que les belges euh ils ont aussi la ligature, je vois pas pourquoi
<Sync time="1107.918"/>
ils l'auraient pas plus défendue euh que ça.
<Sync time="1110.900"/>
en réalité, le représentant français était un ingénieur
<Sync time="1113.940"/>
persuadé de l'inutilité de cette ligature
<Sync time="1118.208"/>
et les représentants suisses et allemands ont mis toute la pression pour faire insérer
<Sync time="1122.581"/>
les symboles mathématiques
<Sync time="1124.190"/>
multiplier et diviser à la place.
<Sync time="1127.286"/>
donc vous voyez, rien que pour *les lettres, c'était déjà
<Sync time="1130.990"/>
des euh des jeux de pression euh sur
<Sync time="1135.905"/>
les choix qui devaient être faits.
<Sync time="1139.350"/>
bon
<Sync time="1140.089"/>
il manque des lettres, et en plus
<Sync time="1142.056"/>
dès que vous vous changez de famille, vous avez des problèmes de compatibilité dans les textes.
<Sync time="1147.015"/>
hein, vous êtes incapables
<Sync time="1148.929"/>
de lire euh d'autres textes.
<Sync time="1151.870"/>
donc aussitôt que cette norme est apparue, on a vu ses limites et ses problèmes, et on a essayé de faire beaucoup mieux avec la suivante, et c'est celle qui est actuelle, c'est unicode.
<Sync time="1163.980"/>
donc unicode, avant de décider quels symboles on allait mettre, de manière à pas s'écharper
<Sync time="1170.516"/>
on s'est donné des principes
<Sync time="1172.545"/>
et
<Sync time="1173.920"/>
on a travaillé en consortium.
<Sync time="1176.340"/>
c'est-à-dire qu'on a réuni ce qu'on appelle le consortium unicode,
<Sync time="1180.237"/>
qui contient les organismes d'organisation,
<Sync time="1183.372"/>
les constructeurs d'ordinateurs, les développeurs de logiciels
<Sync time="1187.957"/>
et on s'est donné dix principes :
<Sync time="1190.739"/>
je vais pas tous vous les donner, mais le () par exemple, le premier il est très intéressant, c'est le principe d'universalité :
<Sync time="1198.469"/>
unicode s'intéresse à toutes les écritures vivantes
<Sync time="1201.870"/>
et à la plupart des écritures historiques.
<Sync time="1204.679"/>
donc on ne porte pas de jugement sur la langue,
<Sync time="1207.647"/>
on accepte toutes les langues
<Sync time="1209.838"/>
qu'elles soient vivantes, mortes
<Sync time="1212.320"/>
de n'importe quelle partie du monde ;
<Sync time="1216.700"/>
après, vous avez efficacité euh et cetera.
<Sync time="1220.839"/>
et on est quand même beaucoup plus confortable :
<Sync time="1224.549"/>
on a maintenant seize bits.
<Sync time="1227.605"/>
donc seize bits, ça fait soixante cinq mille cinq cent trente-six caractères.
<Sync time="1231.635"/>
donc on peut penser que
<Sync time="1234.304"/>
on a de la place.
<Sync time="1237.230"/>
malheureusement, on n'en a pas tant que ça parce que si on prend une langue comme le japonais
<Sync time="1243.72"/>
donc je vous rappelle le japonais :
<Sync time="1246.190"/>
c'est () niveau baccalauréat, c'est six mille caractères qui doivent être connus.
<Sync time="1253.500"/>
niveau
<Sync time="1254.791"/>
universitaire, c'est vingt mille.
<Sync time="1258.806"/>
donc
<Sync time="1260.283"/>
rien qu'avec le japonais, on prend vingt mille caractères
<Sync time="1263.728"/>
et on n'a pas encore mis le chinois,
<Sync time="1265.902"/>
on n'a pas mis toutes les langues indiennes hein, il y en a pratiquement une cinquantaine
<Sync time="1270.086"/>
et cetera, hein.
<Sync time="1272.056"/>
donc
<Sync time="1273.805"/>
la dernière norme, c'est le iso iec
<Event desc="épelé" type="pronounce" extent="previous"/>
 dix mille six cent quarante-six, et on est sur trente-deux bits
<Sync time="1280.470"/>
et donc là, on a droit à quaran() quatre milliards de caractères
<Sync time="1285.470"/>
et on peut donc espérer que nous sommes tranquilles
<Sync time="1289.975"/>
jusqu'à
<Sync time="1293.340"/>
jusqu'à euh bon, on verra.
<Sync time="1295.286"/>
en tout cas, pour l'instant c'est bon pour la
<Sync time="1297.350"/>
pour la terre.
<Sync time="1300.280"/>
alors le problème, c'est que maintenant on a d'autres soucis.
<Sync time="1303.617"/>
on on arrive à caser tous les caractères, mais vous voyez : trente-deux bits pour coder un caractère,
<Sync time="1309.479"/>
c'est euh c'est énorme.
<Sync time="1311.708"/>
hein, même si la puissance des ordinateurs a augmenté, c'est euh
<Sync time="1315.051"/>
ce n'est pas viable d'un point de vue euh technique, quoi.
<Sync time="1318.929"/>
donc on a créé utf huit,
<Sync time="1321.61"/>
qui est un un codage, un logiciel de codage des caractères
<Sync time="1326.052"/>
de un
<Sync time="1328.011"/>
à quatre octets.
<Sync time="1330.019"/>
donc c'est un codage de longueur variable
<Sync time="1335.710"/>
c'est ce qu'on appelle euh utf huit hein, on va utiliser huit bits à chaque fois
<Sync time="1340.672"/>
donc
<Sync time="1342.148"/>
sur euh le premier octet, on va mettre le code ascii
<Sync time="1347.140"/>
en particulier toutes les les carac() enfin les caractères euh ascii originaux et partagés par l'anglais ;
<Sync time="1353.815"/>
sur deux octets, on est seize bits,
<Sync time="1356.202"/>
on va mettre le iso car() quatre-vingt-huit cinquante-neuf un
<Sync time="1360.230"/>
plus des caractères alphabétiques accentués d'autres langues ;
<Sync time="1365.272"/>
sur trois octets, on va insérer le chinois, le japonais et le coréen ;
<Sync time="1371.134"/>
et quatre octets, tous les autres caractères.
<Sync time="1374.437"/>
hein
<Sync time="1375.630"/>
donc comme ça, on réduit la place mémoire
<Sync time="1378.450"/>
hein en fonction du caractère.
<Sync time="1382.218"/>
donc voilà un exemple : le le a, il fait partie du code ascii
<Sync time="1387.037"/>
donc il sera () il aura le chiffre quarante et un
<Sync time="1391.626"/>
le a
<Sync time="1393.665"/>
avec l'accent grave, qui est une lettre accentuée, on aura besoin de deux octets.
<Sync time="1398.249"/>
hein, donc ça sera le c trois a zéro.
<Sync time="1402.595"/>
le é
<Sync time="1403.824"/>
qui fait partie du code ascii, le vingt-six, et si on arrive sur les caractères japonais
<Sync time="1411.505"/>
donc ça ça veu() va() veut dire quatre, je crois, en japonais.
<Sync time="1416.279"/>
c'est codé sur trois
<Sync time="1418.660"/>
octets.
<Sync time="1420.194"/>
hein, vous avez trois octets, donc vous avez un chiffre hexa
<Sync time="1424.743"/>
par octet.
<Sync time="1426.606"/>
voilà
<Sync time="1432.381"/>
alors comment est-ce qu'on sait
<Sync time="1434.625"/>
quel encodage vous avez sur votre ordinateur ?
<Sync time="1440.260"/>
normalement, vous devez tous être sur utf huit
<Sync time="1443.796"/>
en gros, les systèmes d'exploitation y sont passés il y a environ trois quatre ans, hein.
<Sync time="1448.183"/>
mais des fois, ils traînent un petit peu, il y a encore des réminiscences du quatre-vingt-huit euh
<Sync time="1453.632"/>
de iso latin un.
<Sync time="1455.402"/>
donc pour vérifier, vous avez la commande echo ;
<Sync time="1459.100"/>
donc vous tapez par exemple : echo tiret l,
<Sync time="1462.072"/>
vous tapez une lettre accentuée,
<Sync time="1463.96"/>
soit le a, soit le é
<Sync time="1466.166"/>
et vous faites euh vous pipez
<Event desc="en" type="language" extent="previous"/>
 ça avec la commande li() euh linux w c tiret c
<Sync time="1472.274"/>
qui permet de compter.
<Sync time="1473.749"/>
hein, w () w c
<Sync time="1475.988"/>
ça permet de compter les mots, les lettres
<Sync time="1479.496"/>
euh dans un texte
<Sync time="1481.608"/>
et si vous rajoutez euh l'option tiret c, ça compte le nombre
<Sync time="1485.603"/>
d'octets
<Sync time="1487.336"/>
qui sont utilisés pour coder *la lettre.
<Sync time="1489.940"/>
donc si ça vous répond
<Sync time="1492.000"/>
un
<Sync time="1492.740"/>
ça veut dire que vous êtes en iso quatre-vingt-huit
<Sync time="1495.587"/>
cinquante-neuf un ;
<Sync time="1497.470"/>
et si ça vous répond deux
<Sync time="1499.420"/>
ça veut dire que vous êtes en utf huit.
<Sync time="1503.047"/>
hein
<Sync time="1503.710"/>
donc ceux qui ont des ordis, vous pouvez vérifier
<Sync time="1506.460"/>
vous êtes bien en utf huit.
<Sync time="1508.815"/>
et puis si vous avez un fichier texte, vous avez la commande file
<Event desc="en" type="language" extent="previous"/>
 tiret i
<Sync time="1514.537"/>
qui vous indique l'encodage qui a été utilisé.
<Sync time="1517.458"/>
je parle de fichier texte hein, pas de fichier de traitement de texte.
<Sync time="1521.286"/>
et vous avez les fors() les fonctions de conversion
<Sync time="1524.684"/>
i conv
<Sync time="1525.749"/>
qui indique euh
<Sync time="1529.091"/>
vous pouvez partir d'un codage et partir () et arriver à un autre.
<Sync time="1536.394"/>
alors ça c'est les lettres,
<Sync time="1538.520"/>
et donc on va passer aux mots.
<Sync time="1541.500"/>
alors les mots
<Sync time="1543.238"/>
il y a les dictionnaires hein, quand on travaille euh sur la langue, il y a des dictionnaires mais pour l'ordinateur euh il n'a pas de compréhension
<Sync time="1550.809"/>
du mot, hein.
<Sync time="1552.030"/>
donc on va donner une définition
<Sync time="1555.108"/>
opérationnelle du mot
<Sync time="1557.448"/>
opérationnelle pour faire des traitements,
<Sync time="1559.650"/>
pas pour les expliquer hein, on est d'accord.
<Sync time="1562.788"/>
donc on va définir une chaîne de caractères, qui est donc une séquence euh de caractères,
<Sync time="1568.858"/>
on va définir un séparateur de mots
<Sync time="1571.767"/>
qui est un caractère particulier de l'alphabet avec permet de délimiter le mot.
<Sync time="1576.630"/>
eh ben on va dire qu'un mot, c'est une séquence
<Sync time="1580.784"/>
de caractères comprise entre
<Sync time="1584.419"/>
deux séparateurs de mots consécutifs.
<Sync time="1588.270"/>
alors en français
<Sync time="1592.060"/>
on on euh j'exemplifie ça sur le français hein, parce que les séparateurs de mots sont bien sûr dépendants des langues, hein
<Sync time="1599.790"/>
on a quoi comme séparateurs pour le français ?
<Sync time="1602.56"/>
on va avoir l'espace,
<Sync time="1605.790"/>
on va avoir la virgule,
<Sync time="1608.709"/>
on va avoir le point-virgule
<Sync time="1612.486"/>
tout cela ne pose pas de problèmes, et puis il y en a d'autres qui sont un peu plus
<Sync time="1616.317"/>
délicats.
<Sync time="1617.610"/>
alors les plus délicats, c'est
<Sync time="1621.415"/>
apostrophe
<Sync time="1624.955"/>
à votre avis, l'*apostrophe en français
<Sync time="1628.299"/>
est-il
<Sync time="1631.025"/>
un séparateur
<Sync time="1632.272"/>
de mots ?
<Sync time="1642.670"/>
les scientifiques et la langue
<Sync time="1645.355"/>
alors
<Sync time="1650.550"/>
comme disait ti() disait 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
, il *disait : mettez-y la langue, un peu
<Sync time="1656.317"/>
qu'est-ce que vous en pensez ?
<Sync time="1661.520"/>
bah oui, c'est un séparateur de mots, il y a pas de
<Sync time="1664.810"/>
quand vous avez euh l'avion,
<Sync time="1669.680"/>
vous avez bien un mot ici puis là c'est un un autre mot, même si c'est un mot élidé hein,
<Sync time="1675.016"/>
donc l'apostrophe est un séparateur de mots.
<Sync time="1681.863"/>
mais il y a des exceptions
<Sync time="1684.202"/>
et en particulier, il y a deux mots en français où c'est une exception
</Turn>
<Turn startTime="1687.920" endTime="1688.910">
<Sync time="1687.920"/>

<Event desc="conv" type="noise" extent="instantaneous"/>

</Turn>
<Turn startTime="1688.910" speaker="spk1" endTime="4336.512" mode="planned" fidelity="high" channel="studio">
<Sync time="1688.910"/>
oui, très bien
<Sync time="1691.574"/>
aujourd'hui
<Sync time="1698.477"/>
non
<Sync time="1699.155"/>
et puis il y en a un autre avec prud'hommes, mais bon euh c'est euh c'est pas
<Sync time="1703.944"/>
deuxième cas : vous avez le tiret.
<Sync time="1708.417"/>
le tiret est-il un *séparateur de mots ou pas ?
<Sync time="1717.030"/>
eh ben non, hein
<Sync time="1719.639"/>
si on prend par exemple deltaplane
<Sync time="1724.824"/>
ou homme-grenouille,
<Sync time="1731.236"/>
c'est pas un séparateur de mots,
<Sync time="1733.265"/>
mais dans certains cas
<Sync time="1739.842"/>
là, c'en est un.
<Sync time="1743.204"/>
alors
<Sync time="1744.433"/>
le tiret il est un peu embêtant
<Sync time="1746.630"/>
il peut être soit considéré comme un séparateur de mots
<Sync time="1750.735"/>
soit
<Sync time="1752.494"/>
non
<Sync time="1755.385"/>
en particulier, généralement les traitement de texte
<Sync time="1758.945"/>
l() considèrent que le
<Sync time="1761.765"/>
tiret n'est pas un séparateur de mots.
<Sync time="1764.310"/>
alors derrière,
<Sync time="1765.744"/>
il y a pas des considérations linguistiques du tout.
<Sync time="1768.736"/>
derrière, il y a des conditions économiques
<Sync time="1772.039"/>
parce que
<Sync time="1773.130"/>
les traducteurs par exemple sont payés au nombre de mots
<Sync time="1777.610"/>
et vous voyez bien que si on rajoute des séparateurs de mots dans le logiciel, ils vont vous rajouter des mots
<Sync time="1783.024"/>
donc ils auront à payer plus.
<Sync time="1785.672"/>
hein donc on considère généralement le tiret
<Sync time="1789.432"/>
même si des fois, ça peut être euh un petit peu
<Sync time="1792.692"/>
exagéré, comme un non-séparateur de mots.
<Sync time="1795.529"/>
hein
<Sync time="1798.583"/>
alors même chose pour la phrase, hein
<Sync time="1800.590"/>
on reste sur des définitions opérationnelles
<Sync time="1803.530"/>
la phrase
<Sync time="1804.990"/>
on va définir un délimiteur de phrases, qui est donc un texte particulier d'alphabet
<Sync time="1809.853"/>
qui permet de délimiter la phrase, et une phrase va être une séquence
<Sync time="1814.927"/>
de caractères entre
<Sync time="1818.246"/>
deux séparateurs de phrases consécutifs.
<Sync time="1821.249"/>
donc de la même manière que l'on a défini
<Sync time="1825.343"/>
les mots,
<Sync time="1827.300"/>
on va définir
<Sync time="1830.512"/>
les séparateurs
<Sync time="1832.282"/>
de phrases, et donc on a quoi là ?
<Sync time="1835.108"/>
pour le français, bah on va avoir le point-virgule,
<Sync time="1839.000"/>
le point, les deux points, le point d'exclamation, le point d'interrogation
<Sync time="1845.275"/>
et là aussi, on va de nouveau avoir des petits problèmes avec le point, par exemple parce que là aussi, s() on parle d'ambiguïté.
<Sync time="1852.913"/>
le point
<Sync time="1854.063"/>
peut être
<Sync time="1855.559"/>
un signe
<Sync time="1857.047"/>
de marque de fin de phrase,
<Sync time="1858.738"/>
mais il peut aussi dire autre chose.
<Sync time="1861.615"/>
donc vous pouvez l'utiliser dans les abréviations,
<Sync time="1866.578"/>
par exemple
<Sync time="1867.880"/>
et dans les chiffres euh décimaux, quand ils sont exprimés en langue anglaise on n'utilise pas la virgule, on utilise le point.
<Sync time="1875.603"/>
hein, donc euh
<Sync time="1877.100"/>
si jamais il y a des chiffres qui sont mal
<Sync time="1880.392"/>
imprimés, on aura des choses comme ça
<Sync time="1883.580"/>
et les traitements informatiques ne font pas la différence, hein
<Sync time="1888.380"/>
sauf s'ils sont sophistiqués.
<Sync time="1897.103"/>
on passe au texte
<Sync time="1898.816"/>
et je vais vous définir
<Sync time="1902.072"/>
trois
<Sync time="1903.203"/>
termes.
<Sync time="1904.775"/>
la notion d'occurrence :
<Sync time="1907.170"/>
donc une occurrence, c'est l'apparition d'une chaîne de caractères dans un texte.
<Sync time="1913.199"/>
la fréquence, ça va être le nombre d'occurrences
<Sync time="1917.754"/>
on va distinguer une fréquence
<Sync time="1920.930"/>
particulière, qui est la fréquence une.
<Sync time="1924.327"/>
on va voir
<Sync time="1925.860"/>
une chaîne de caractères une seule fois dans un texte, ça va être ce qu'on appelle les hapax.
<Sync time="1931.867"/>
et dès qu'on a des textes, on peut faire des tris.
<Sync time="1935.549"/>
hein, donc des tris sur les phrases, sur les mots, sur les lettres.
<Sync time="1939.840"/>
je vais vous proposer
<Sync time="1941.831"/>
quelques tris sur les mots.
<Sync time="1945.309"/>
le ()
<Sync time="1946.708"/>
quelque chose qui est très utilisé,
<Sync time="1948.776"/>
et en particulier qui va me permettre d'introduire la seule loi mathématique que l'on va voir,
<Sync time="1955.200"/>
c'est les listes de fréquences.
<Sync time="1958.711"/>
alors qu'est-ce que c'est qu'une liste de de fréquences ? c'est une liste des occurrences
<Sync time="1962.860"/>
accompagnées de leur de leur fréquence. donc on va en faire une toute petite
<Sync time="1984.925"/>
vous voyez, c'est bon ?
<Sync time="1986.154"/>
oui
<Sync time="2008.680"/>
donc une liste de *fréquences, on repère les mots avec notre définition préalable, à savoir :
<Sync time="2014.405"/>
est un mot tout ce qui est entre deux séparateurs de mots.
<Sync time="2017.799"/>
et après, on construit une liste qu'on met dans un tableau
<Sync time="2020.802"/>
hein, ça vous devez faire () savoir faire en algorithmique
<Sync time="2024.450"/>
et on les trie par ordre alphabétique, enfin on on les trie, on va les trier
<Sync time="2029.840"/>
en fonction de leur fréquence.
<Sync time="2032.670"/>
donc je je prépare euh donc on met tous les mots, et je les mets tout de suite dans le bon ordre
<Sync time="2050.894"/>
et je mets euh la fréquence : donc le "la" il apparaît une fois
<Sync time="2055.320"/>
et deux fois ici, on va mettre deux. le "de",
<Sync time="2058.023"/>
deux fois, la lettre, une fois
<Sync time="2060.212"/>
"métropole", une fois
<Sync time="2062.035"/>
et "nantes", une fois.
<Sync time="2063.222"/>
donc ça c'est une lettre
<Sync time="2064.590"/>
euh c'est une liste alphabétique
<Sync time="2072.375"/>
c'est une liste de fréquences
<Sync time="2080.733"/>
et c'est aussi une liste alphabétique ; c'est les deux à la fois dans cet exemple, hein.
<Sync time="2095.657"/>
c'est simple ?
<Sync time="2096.926"/>
bon, alors maintenant je vais définir le rang.
<Sync time="2107.638"/>
le rang, c'est l'inverse de la fréquence
<Sync time="2110.752"/>
c'est-à-dire que le mot qui va avoir la plus haute fréquence,
<Sync time="2114.688"/>
on va lui donner le rang un.
<Sync time="2120.050"/>
le mot qui a la deuxième
<Sync time="2122.607"/>
moins grande fréquence, il va avoir le rang deux
<Sync time="2130.530"/>
et cetera.
<Sync time="2133.180"/>
d'accord ?
<Sync time="2134.224"/>
donc si vous comprenez ça, vous allez comprendre la loi mathématique.
<Sync time="2146.066"/>
donc la loi de zipf
<Sync time="2149.907"/>
vous vous concentrez là, hein
<Sync time="2152.157"/>
dans les années trente, un scientifique donc de l'université de harvard qui s'appelle
<Sync time="2158.454"/>
zipf
<Sync time="2159.457"/>
a montré k() qu'en classant les mots d'un texte
<Sync time="2162.918"/>
par fréquence décroissante,
<Sync time="2166.52"/>
on observe que la fréquence d'utilisation d'un mot
<Sync time="2169.968"/>
est inversement proportionnelle à son rang.
<Sync time="2174.030"/>
et que donc cette loi peut s'*exprimer de la manière suivante :
<Sync time="2178.756"/>
la fréquence d'un mot de rang r, c'est la fréquence du mot de rang un
<Sync time="2184.51"/>
divisé par r.
<Sync time="2187.750"/>
qu'est-ce que ça veut dire ? ça veut dire que
<Sync time="2190.389"/>
la fréquence du second mot le plus fréquent,
<Sync time="2194.151"/>
c'est la moitié du premier,
<Sync time="2197.002"/>
d'accord ?
<Sync time="2198.071"/>
la fréquence du troisième mot
<Sync time="2200.16"/>
le plus fréquent, c'est son tiers
<Sync time="2202.815"/>
et cetera.
<Sync time="2204.450"/>
et donc vous voyez ici que si on veut la fréquence de rang deux,
<Sync time="2209.411"/>
on va prendre la valeur de la fréquence
<Sync time="2212.095"/>
du premier mot, c'est-à-dire deux
<Sync time="2214.462"/>
que l'on divise par le rang deux et on obtient bien
<Sync time="2218.255"/>
la fréquence de un.
<Sync time="2221.520"/>
bon, ça fonctionne sur ce petit exemple
<Sync time="2224.571"/>
mais ce qui est intéressant, c'est que cette loi elle a été démontrée de manière empirique
<Sync time="2230.498"/>
toujours hein
<Sync time="2231.829"/>
et on a démontré qu'elle était indépendante des locuteurs,
<Sync time="2237.010"/>
indépendante des types de textes
<Sync time="2239.344"/>
et indépendante des langues.
<Sync time="2241.480"/>
c'est donc une loi
<Sync time="2243.36"/>
universelle,
<Sync time="2245.273"/>
c'est pas une constatation qui est isolée, mais ça va être la première de toute une série d'autres
<Sync time="2250.760"/>
et
<Sync time="2251.93"/>
voici par exemple la démonstration de cette courbe, on va toujours obtenir une courbe comme ça
<Sync time="2259.040"/>
où ici
<Sync time="2265.670"/>
vous avez
<Sync time="2267.860"/>
la fréquence du mot
<Sync time="2269.690"/>
donc on va voir que le mot le plus fréquent par exemple,
<Sync time="2273.183"/>
c'est euh cent mille
<Sync time="2275.842"/>
et le rang deux
<Sync time="2278.015"/>
ça va être la moitié de cent mille, ça va être cinquante mille.
<Sync time="2280.960"/>
donc on va le trouver
<Sync time="2283.173"/>
par ici, enfin là on les voit pas trop les points
<Sync time="2285.781"/>
mais
<Sync time="2286.530"/>
en gros, vous aurez toujours cette courbe-là
<Sync time="2289.200"/>
quel que que soit le *texte, *quelle que que soit la langue,
<Sync time="2292.200"/>
quelle que soit la taille du texte.
<Sync time="2294.853"/>

<Event desc="pi" type="pronounce" extent="instantaneous"/>

<Sync time="2298.970"/>
et
<Sync time="2299.749"/>
autre chose très intéressante, c'est que
<Sync time="2303.227"/>
dans les rangs un,
<Sync time="2305.320"/>
c'est-à-dire les mots les plus fréquents d'une langue,
<Sync time="2308.294"/>
là aussi quel que soit le type de texte, vous allez toujours trouver les mêmes mots.
<Sync time="2312.320"/>
donc par exemple, si je prends un texte qui est assez court comme le cid
<Sync time="2316.466"/>
de corneille, qui est même assez vieux hein
<Sync time="2318.832"/>
et si je prends
<Sync time="2320.144"/>
euh le journal le monde
<Sync time="2321.885"/>
donc il y a une différence de style, il y a une différence d'époque, il y a une différence
<Sync time="2325.970"/>
de quantité de s() de texte,
<Sync time="2328.346"/>
on voit que
<Sync time="2330.070"/>
dans les deux cas, c'est toujours le mot le plus fréquent en français, c'est le mot "de".
<Sync time="2336.235"/>
et le rang deux, on va avoir le "la", et cetera.
<Sync time="2339.033"/>
hein, même si "la" il est un peu plus euh éloigné pour le pour le cid,
<Sync time="2342.640"/>
il y a un peu moins de féminin euh dans le cid
<Sync time="2345.653"/>
que
<Sync time="2346.515"/>
dans le monde.
<Sync time="2349.567"/>
alors cette loi elle est très importante hein, parce que
<Sync time="2352.314"/>
euh e()
<Sync time="2353.727"/>
tous les logiciels se basent
<Sync time="2355.980"/>
sur cette prédiction
<Sync time="2358.585"/>
du comportement du vocabulaire
<Sync time="2361.037"/>
dans les textes.
<Sync time="2364.827"/>
alors la respiration
<Sync time="2366.730"/>
là euh vous pouvez euh
<Sync time="2369.348"/>
vous détendre cinq minutes
<Sync time="2374.074"/>
et euh pour vous détendre, je vous présente la première application
<Sync time="2378.231"/>
de dialogue homme machine qui a existé sur la langue
<Sync time="2382.040"/>
donc qui est très connue hein, c'est un classique qui s'appelle eliza
<Sync time="2385.960"/>
qui a été faite
<Sync time="2387.193"/>
euh par le mit
<Event desc="épelé" type="pronounce" extent="previous"/>
 
<Event desc="en" type="language" extent="previous"/>

<Sync time="2389.241"/>
dans les années soixante
<Sync time="2392.260"/>
entre
<Sync time="2394.065"/>
un psychothérapeute, qui est l'ordinateur
<Sync time="2397.190"/>
et le patient, ben c'est vous.
<Sync time="2399.937"/>
hein
<Sync time="2400.9"/>
et
<Sync time="2401.861"/>
je vous montre
<Sync time="2402.930"/>
les exemples de dialogues que vous pouvez
<Sync time="2406.310"/>
obtenir avec ce logiciel, donc c'est le premier, il faut être euh
<Sync time="2413.022"/>
comment on peut dire ?
<Sync time="2414.109"/>
patient
<Sync time="2415.093"/>
hein euh avec lui.
<Sync time="2416.980"/>
donc bonjour, je suis votre psychothérapeute, parlez-moi de votre problème.
<Sync time="2421.090"/>
donc ça c'est l'ordi qui parle, hein. *enfin qui parle, qui écrit
<Sync time="2424.55"/>
donc vous lui répondez ce que vous voulez, en particulier vous êtes très an() très angoissé.
<Sync time="2430.099"/>
pourquoi dites-vous que vous êtes très angoissé ?
<Sync time="2433.300"/>
c'est à cause de ma femme
<Sync time="2436.120"/>
donc l'ordi vous répond : parlez-moi de votre famille,
<Sync time="2440.700"/>
vous lui répondez : j'adore mes enfants.
<Sync time="2442.934"/>
j'aimerais que vous me parliez de vos relations avec vos enfants
<Sync time="2448.450"/>
bon là ça va pas du tout, donc vous lui répondez : personne ne m'aime.
<Sync time="2453.513"/>
est-ce que ça vous ennuie que personne ne vous aime ?
<Sync time="2458.420"/>
oui, je me sens seul
<Sync time="2461.506"/>
don() votre vie sexuelle y est peut-être pour quelque chose,
<Sync time="2465.015"/>
continuez sans crainte.
<Sync time="2466.3"/>
bon
<Sync time="2466.750"/>
voilà un exemple
<Sync time="2471.318"/>
de dialogue homme machine
<Sync time="2474.083"/>
le premier, hein
<Sync time="2477.080"/>
et euh si on regarde ce qui se passe euh je pense que vous avez un peu compris qui se passait :
<Sync time="2484.085"/>
il y a pas beaucoup de compréhension derrière, hein.
<Sync time="2486.579"/>
bon, bonjour je suis votre psychothérapeute, parlez-moi de votre problème, c'est un texte figé qui commence tout dialogue
<Sync time="2492.214"/>
donc quelle que soit
<Sync time="2493.768"/>
la personne en face, i() il il met ça pour commencer.
<Sync time="2497.843"/>
je suis très angoissé, là vous lui répondez ce que vous voulez donc c'est stocké dans une variable r un.
<Sync time="2504.850"/>
et pourquoi dites-vous que vous êtes très angoissé ? c'est : pourquoi dites-vous
<Sync time="2509.081"/>
que r un,
<Sync time="2510.662"/>
avec la transformation de je suis en vous êtes.
<Sync time="2517.300"/>
c'est à cause de ma femme :
<Sync time="2520.000"/>
réponse libre du patient qui contient le mot femme
<Sync time="2524.650"/>
qui a repé() alors l'ordi a repéré femme, le logiciel a repéré *femme.
<Sync time="2529.274"/>
et dès qu'il repère femme, homme, mari,
<Sync time="2532.39"/>
tante, cousin, enfant,
<Sync time="2535.822"/>
ça va être une famille sémantique de mots
<Sync time="2538.348"/>
et on va avoir euh un ordre systématique du psy
<Sync time="2542.010"/>
qui
<Sync time="2542.786"/>
va répondre : parlez-moi de votre famille dès qu'il a repéré
<Sync time="2546.580"/>
un mot comme ça.
<Sync time="2549.898"/>
oui je me sens seul, alors là
<Sync time="2552.583"/>
c'est une réponse libre
<Sync time="2554.613"/>
du patient qui ne contient rien de spécial
<Sync time="2558.776"/>
et
<Sync time="2560.436"/>
vous avez le s() le psy qui répond ça quand il sait plus
<Sync time="2563.948"/>
trop quoi dire.
<Sync time="2565.257"/>
hein
<Sync time="2568.070"/>
alors dans ce logiciel, c'est le premier, il y a du traitement de la langue
<Sync time="2573.855"/>
avec des recherches des motifs, mais il y a aussi du travail avec les
<Sync time="2577.443"/>
psychothérapeutes
<Sync time="2579.703"/>
et les psychanalystes
<Sync time="2581.189"/>
parce que il y a il y a des ordres, il y a des injonctions, il y a des il y a des il y a des tournures particulières
<Sync time="2587.219"/>
et le traitement automatique des langues, c'est aussi des collaborations
<Sync time="2591.000"/>
avec d'autres métiers
<Sync time="2593.116"/>
comme les linguistes, comme les traducteurs comme euh
<Sync time="2597.367"/>
euh des gens qui ne sont pas forcément
<Sync time="2600.196"/>
des informaticiens, donc c'est important aussi de vous dire que quand on travaille en informatique, on ne fait pas que
<Sync time="2606.850"/>
de l'informatique pure et dure ; on s'intéresse à d'autres choses.
<Sync time="2611.708"/>
donc bilan sur euh eliza : c'est une application bluffante.
<Sync time="2617.050"/>
l'ordinateur, vous avez bien compris, ne comprend rien
<Sync time="2620.130"/>
aux interventions du patient.
<Sync time="2622.200"/>
les réponses, c'est simplement une activation d'une des centaines de milliers de réponses préenregistrées
<Sync time="2630.76"/>
et
<Sync time="2632.020"/>
on () que l'on va rechercher
<Sync time="2634.558"/>
dans une base de données
<Sync time="2636.417"/>
avec
<Sync time="2637.966"/>
une technique
<Sync time="2639.728"/>
que l'on appelle la recherche de motifs.
<Sync time="2643.132"/>
et
<Sync time="2643.924"/>
c'est ce que je vais voir
<Sync time="2646.248"/>
maintenant.
<Sync time="2649.931"/>
alors la recherche de motifs, il y a deux manières de la de la présenter :
<Sync time="2654.957"/>
il y a une manière opérationnelle
<Sync time="2659.351"/>
euh qui est la présentation des expressions rationnelles
<Sync time="2663.492"/>
et
<Sync time="2664.394"/>
une manière disons euh plus euh
<Sync time="2668.970"/>
plus informatique, qui est
<Sync time="2671.160"/>
l'automate à état fini.
<Sync time="2673.654"/>
bon
<Sync time="2674.968"/>
j() je commence par euh la partie opérationnelle
<Sync time="2679.569"/>
puisque c'est quelque chose que vous pouvez utiliser
<Sync time="2682.793"/>
euh
<Sync time="2684.535"/>
assez facilement
<Sync time="2686.400"/>
et qui est disponible dans tous les langages de programmation.
<Sync time="2692.560"/>
alors, qu'est-ce que c'est que les expressions euh
<Sync time="2695.737"/>
rationnelles, c'est donc un langage formel
<Sync time="2700.860"/>
pour décrire les chaînes de caractères.
<Sync time="2702.907"/>
donc c'est vraiment dédié
<Sync time="2704.591"/>
au traitement sur les chaînes de caractères.
<Sync time="2707.119"/>
ça vous permet de faire des recherches,
<Sync time="2710.343"/>
des remplacements
<Sync time="2712.044"/>
de chaînes de caractères.
<Sync time="2715.500"/>
et donc, les notions importantes qu'on () que l'on va voir, c'est les notions de
<Sync time="2720.697"/>
caractère littéral
<Sync time="2722.828"/>
et métacaractère,
<Sync time="2726.300"/>
les notions de classe de caractères,
<Sync time="2729.549"/>
de quantificateur
<Sync time="2731.844"/>
d'ancre
<Sync time="2732.660"/>
et d'alternative.
<Sync time="2734.157"/>
hein, donc oui, il faut qu'on voie ces
<Sync time="2736.0"/>
ces cinq choses-là.
<Sync time="2743.602"/>
alors comment est-ce que euh le programme
<Sync time="2747.591"/>
le langage de programmation,
<Sync time="2749.619"/>
il sait que vous voulez faire une expression régulière
<Sync time="2753.096"/>
eh ben vous allez l'exprimer entre deux slash.
<Sync time="2757.064"/>
dès qu'il y aura deux slash, il interprète ça comme une expression régulière.
<Sync time="2761.837"/>
je vous donne une syntaxe
<Sync time="2770.148"/>
une syntaxe
<Sync time="2771.380"/>
particulière
<Sync time="2776.955"/>
messieurs !
<Sync time="2792.750"/>
donc la syntaxe euh particulière, je vous donne celle de perl, du langage perl mais
<Sync time="2797.839"/>
elle est auss() c'est la même dans java et dans javascript.
<Sync time="2801.130"/>
hein, je pense que vous faites vos tp en javascript,
<Sync time="2804.310"/>
donc vous pouvez directement l'utiliser telle quelle.
<Sync time="2808.335"/>
on commence par la définition de classe de caractères.
<Sync time="2812.176"/>
la les classes de de caractères vont être exprimées entre crochets.
<Sync time="2818.056"/>
donc si je veux définir une classe de caractères, je mets mes caractères entre deux crochets.
<Sync time="2823.570"/>
donc ici,
<Sync time="2825.850"/>
je définis une classe de caractères qui est constituée de deux lettres :
<Sync time="2830.306"/>
le petit v et le grand v.
<Sync time="2833.246"/>

<Event desc="bb" type="noise" extent="instantaneous"/>

<Sync time="2835.050"/>
je peux définir une classe de caractères avec trois lettres
<Sync time="2838.250"/>
ou avec par exemple tous les chiffres
<Sync time="2841.616"/>

<Event desc="bb" type="noise" extent="instantaneous"/>

<Sync time="2846.081"/>
quand il y a beaucoup de lettres, c'est un peu fastidieux de donner toutes les lettres.
<Sync time="2851.107"/>
alors rappelez-vous que les lettres sont toujours définies par rapport à un code ;
<Sync time="2856.845"/>
que toutes vos lettres correspondent à des chiffres, donc il y a un ordre
<Sync time="2861.650"/>
donc vous pouvez utiliser des intervalles.
<Sync time="2865.728"/>
donc par exemple, si vous indiquez a tiret z, ça veut dire je définis un ensemble
<Sync time="2871.652"/>
qui va de la lettre a
<Sync time="2873.908"/>
jusqu'à la lettre z.
<Sync time="2876.950"/>
et on peut faire la même chose
<Sync time="2878.920"/>
avec les lettres majuscules : je vais
<Sync time="2882.467"/>
de la lettre
<Sync time="2883.913"/>
grand a
<Sync time="2885.409"/>
jusqu'à la lettre grand z ;
<Sync time="2887.800"/>
et la même chose pour les chiffres.
<Sync time="2892.211"/>
quand vous définissez ça, vous ne définissez
<Sync time="2895.404"/>
un ensemble de lettres hein, uniquement.
<Sync time="2900.450"/>
comme vous travaillez sur un code, vous pouvez définir des complémentaires d'ensemble
<Sync time="2905.567"/>
hein
<Sync time="2906.400"/>
donc le complémentaire d'ensemble, il est défini avec le symbole chapeau,
<Sync time="2912.020"/>
le chapeau qui apparaît juste après le crochet ouvrant.
<Sync time="2916.150"/>
donc ici, première expression régulière, je définis
<Sync time="2920.073"/>
un ensemble de lettres qui correspond aux lettres majuscules,
<Sync time="2924.093"/>
je mets le chapeau devant, et ça veut donc dire : tout ce qui n'est pas une lettre
<Sync time="2928.590"/>
en majuscules.
<Sync time="2930.293"/>
donc par rapport à notre code
<Sync time="2932.291"/>
que l'on emploie,
<Sync time="2933.431"/>
c'est les lettres minuscules, c'est les chiffres, *enfin c'est tout ce qu'il y a dans le code hein.
<Sync time="2938.190"/>
bon, on peut définir un ensemble avec un intervalle, en donnant toutes les lettres
<Sync time="2943.940"/>
faites attention si vous utilisez le chapeau
<Sync time="2946.650"/>
ailleurs que
<Sync time="2948.275"/>
en première position
<Sync time="2950.199"/>
suivant
<Sync time="2952.001"/>
le
<Sync time="2952.839"/>
crochet ouvrant, s() ça n'a plus cette vertu-là de métacaractères, hein
<Sync time="2957.135"/>
c'est littéral.
<Sync time="2958.719"/>
voilà
<Sync time="2959.360"/>
et si vous utilisez le chapeau
<Sync time="2962.291"/>
hors
<Sync time="2963.572"/>
ensemble,
<Sync time="2964.630"/>
il est littéral aussi
<Sync time="2966.099"/>
hein ça a plus la notion de complémentaire d'ensemble.
<Sync time="2972.950"/>
donc, on a la possibilité de définir des ensembles de lettres,
<Sync time="2976.270"/>
on a aussi
<Sync time="2978.200"/>
à notre disposition des quantificateurs.
<Sync time="2981.091"/>
on en a quatre :
<Sync time="2984.198"/>
donc le premier quantificateur, c'est
<Sync time="2987.807"/>
le point d'interrogation ;
<Sync time="2990.338"/>
ça signifie zéro ou une fois
<Sync time="2994.160"/>
et il s'applique toujours à ce qui précède.
<Sync time="2997.120"/>
donc dans l'exemple suivant, j'ai une expression régulière où je recherche une chaîne qui s'appelle
<Sync time="3004.026"/>
v, o, i, l, e
<Sync time="3006.040"/>
je mets le point d'interrogation derrière le i
<Sync time="3009.635"/>
et ça signifie
<Sync time="3011.595"/>
que
<Sync time="3012.496"/>
soit le i est là, soit il n'est pas là.
<Sync time="3015.246"/>
donc ça permet de rechercher
<Sync time="3017.34"/>
des chaînes comme vol ou voile.
<Sync time="3023.341"/>
vous avez l'étoile
<Sync time="3026.169"/>
donc même principe, ça s'applique
<Sync time="3028.368"/>
sur la lettre
<Sync time="3029.777"/>
précédente
<Sync time="3031.190"/>
et ça veut dire que cette lettre
<Sync time="3032.924"/>
soit elle apparaît pas,
<Sync time="3034.260"/>
soit elle apparaît n fois.
<Sync time="3036.998"/>
hein, on appelle ça aussi l'étoile de 
<Event desc="pi" type="pronounce" extent="instantaneous"/>

<Sync time="3040.349"/>
et donc ça vous permet de
<Sync time="3042.400"/>
rechercher des chaînes
<Sync time="3044.82"/>
comme o
<Sync time="3046.390"/>
donc ici, le premier o n'appar() euh le deuxième o n'est pas là
<Sync time="3050.740"/>
valeur zéro, il apparaît une fois
<Sync time="3053.029"/>
il apparaît deux fois, il apparaît trois fois, et cetera
<Sync time="3057.691"/>
vous avez
<Sync time="3059.067"/>
le plus
<Sync time="3062.000"/>
où là, on demande
<Sync time="3064.314"/>
que ça apparaisse une fois
<Sync time="3066.643"/>
au minimum une fois, et autant de fois que l'on veut.
<Sync time="3070.210"/>
hein
<Sync time="3071.790"/>
et puis vous en avez un troisième euh quatrième opérateur qui sont l'accolade,
<Sync time="3076.432"/>
qui permet de spécifier exactement le nombre de fois
<Sync time="3080.022"/>
où vous voulez que la lettre apparaît. mais je je vais passer
<Sync time="3083.958"/>
euh ce quantificateur-là.
<Sync time="3088.928"/>
alors vous avez des métacaractères ; on a déjà vu un métacaractère c'est le chapeau
<Sync time="3093.841"/>
il a une signification particulière. vous avez un deuxième métacaractère, c'est le point.
<Sync time="3099.274"/>
le point
<Sync time="3100.349"/>
il signifie n'importe quel symbole
<Sync time="3102.553"/>
sauf la fin de la ligne.
<Sync time="3104.150"/>
donc si vous écrivez dans une expression régulière b point l
<Sync time="3108.884"/>
ça vous permet de reconnaître bol, bel euh b huit l
<Sync time="3112.790"/>
n'importe quel caractère dans
<Sync time="3115.578"/>
votre code.
<Sync time="3117.760"/>
et vous pouvez en mettre autant que vous voulez dans une expression régulière
<Sync time="3123.030"/>
hein donc c'est c'est assez pratique le point.
<Sync time="3126.563"/>
et les deux derniers euh spécificités, c'est les ancres.
<Sync time="3131.158"/>
alors je vous rappelle que
<Sync time="3133.336"/>
quand on traite sur la langue, il y a des *caractéristiques
<Sync time="3136.007"/>
en particulier, il y a un ordre
<Sync time="3138.457"/>
hein euh les caractères ne
<Sync time="3140.907"/>
n'arrivent pas n'importe comment, ils suivent un ordre, ce qu'on appelle l'ordre linéaire
<Sync time="3147.119"/>
et ça peut être important de dire : je veux que tel symbole, il apparaisse par exemple en début de mot
<Sync time="3153.015"/>
hein
<Sync time="3153.647"/>
donc euh ça, c'est des ancres.
<Sync time="3156.128"/>
donc le début de mot, ça veut dire
<Sync time="3159.100"/>
chapeau, et le fin de mot c'est dollar.
<Sync time="3162.277"/>
hein
<Sync time="3163.289"/>
en gros, qu'est-ce qu'il y a derrière ? c'est simplement les délimiteurs de mots
<Sync time="3166.759"/>
hein que l'on a définis.
<Sync time="3168.299"/>
hein
<Sync time="3169.911"/>
donc qu'est-ce que j'ai indiqué ici ? là je j'indique dans mon expression régulière : recherchez-moi
<Sync time="3175.647"/>
une lettre en majuscule
<Sync time="3177.720"/>
qui apparaît
<Sync time="3178.889"/>
en début
<Sync time="3180.375"/>
de mot
<Sync time="3181.719"/>
hein ou de texte.
<Sync time="3182.719"/>
donc ça permet de reconnaître le r
<Sync time="3184.950"/>
dans par exemple dans ramallah.
<Sync time="3187.450"/>
ici il y a deux chapeaux
<Sync time="3190.330"/>
donc j'ai défini
<Sync time="3193.658"/>
un ensemble
<Sync time="3195.312"/>
qui est constitué
<Sync time="3197.3"/>
de lettres majuscules,
<Sync time="3200.520"/>
j'ai le chapeau devant, c'est le complémentaire, donc ça *veut dire tout ce qui n'est pas en lettres majuscules
<Sync time="3206.044"/>
et qui doit apparaître en première position.
<Sync time="3209.316"/>
donc euh là,
<Sync time="3210.441"/>
ça va me permettre de repérer par exemple
<Sync time="3212.750"/>
le point d'interrogation inversé en espagnol,
<Sync time="3216.533"/>
comme dans 
<Event desc="pi" type="pronounce" extent="instantaneous"/>

<Sync time="3218.460"/>
et puis on a la même chose avec euh le dollar, qui nous permet de repérer des fins de mots
<Sync time="3224.380"/>
et si on veut repérer le point, qui est un marqueur de fin de chaîne,
<Sync time="3228.197"/>
comme c'est un métacaractère, on utilise le slash pour dire :
<Sync time="3231.854"/>
recherchez-le-moi d'un point de vue littéral.
<Sync time="3234.536"/>
hein
<Sync time="3236.560"/>
sinon ça prend n'importe quoi.
<Sync time="3239.881"/>
enfin le dernier, c'est l'alternative, c'est le ou
<Sync time="3244.386"/>
donc
<Sync time="3245.460"/>
euh quand vous mettez une barre trans() euh verticale, ça veut dire recherchez-moi
<Sync time="3251.000"/>
vous
<Sync time="3252.542"/>
ou moi
<Sync time="3253.571"/>
et
<Sync time="3254.369"/>
il reconnaîtra la première chaîne qui apparaît.
<Sync time="3257.37"/>
hein
<Sync time="3258.558"/>
donc
<Sync time="3259.291"/>
avec cet exemple-là
<Sync time="3262.761"/>
il reconnaîtra vous ;
<Sync time="3264.820"/>
avec cet exemple-là, il reconnaîtra
<Sync time="3267.599"/>
moi.
<Sync time="3268.473"/>
hein
<Sync time="3269.211"/>
et puis si vous voulez en mettre plus, d'alternatives, plus de () plus d'une,
<Sync time="3273.404"/>
vous mettez des parenthèses
<Sync time="3274.870"/>
et vous vous mettez autant d'alternatives que vous voulez.
<Sync time="3279.510"/>
alors on va faire un petit exemple : on fait notre première expression régulière
<Sync time="3283.611"/>
et euh qui nous permet de faire des recherches dans un texte, d'accord ?
<Sync time="3287.950"/>
donc on prend () on fait une recherche simple hein, puisqu'on est débutants en expressions régulières,
<Sync time="3294.046"/>
donc on recherche "les".
<Sync time="3297.023"/>
première expression régulière, donc on on sait pas trop comment faire, donc on met deux slash et puis on met "les"
<Sync time="3303.219"/>
et puis
<Sync time="3303.974"/>
on l'exécute sur le texte hein, ça prend toujours en entrée une chaîne ou un texte hein.
<Sync time="3309.431"/>
et puis on s'aperçoit que on loupe
<Sync time="3312.76"/>
les "les"
<Sync time="3314.615"/>
où le l est en majuscule.
<Sync time="3317.034"/>
d'accord ? donc on corrige notre expression régulière,
<Sync time="3320.242"/>
on définit un ensemble
<Sync time="3322.800"/>
qui est constitué du l minuscule et du l majuscule,
<Sync time="3327.059"/>
on l'exécute
<Sync time="3329.95"/>
et on s'aperçoit
<Sync time="3331.638"/>
que
<Sync time="3332.841"/>
on
<Sync time="3334.011"/>
on trouve les en minuscules, les,
<Sync time="3336.933"/>
mais on trouve aussi lessive et faiblesse.
<Sync time="3341.044"/>
donc ça, ça nous intéresse pas, "les"
<Sync time="3343.122"/>
quand ça apparaît dans lessive et et faiblesse, donc on corrige
<Sync time="3347.660"/>
et on dit que "les"
<Sync time="3351.614"/>
doit être en fait un mot
<Sync time="3353.168"/>
*c'est-à-dire *que on doit avoir une marque de début de mot ici, et une marque de fin de mot là.
<Sync time="3359.858"/>
on exécute
<Sync time="3361.593"/>
et puis on s'aperçoit que on perd on on loupe encore des occurrences de "les", en particulier par exemple pensez "prends-les"
<Sync time="3369.832"/>
hein euh p, r, e, n euh le verbe prendre tiret l, e, s
<Sync time="3373.831"/>
donc quand c'est précédé d'un tiret, ça ne fonctionne pas
<Sync time="3377.071"/>
puisque le tiret n'est pas considéré comme un séparateur de mots.
<Sync time="3381.323"/>
donc on corrige notre expression régulière
<Sync time="3383.994"/>
il faut que je je m'achète un truc
<Sync time="3386.740"/>
et on dit que ce qui *précède le "les",
<Sync time="3390.696"/>
c'est tout sauf une lettre.
<Sync time="3395.140"/>
et ce qui suit le "les", c'est tout
<Sync time="3397.235"/>
sauf une lettre.
<Sync time="3399.430"/>
d'accord ?
<Sync time="3401.001"/>
on exécute, et on s'aperçoit encore qu'on en loupe
<Sync time="3404.750"/>
en particulier quand le "les" apparaît en début de texte.
<Sync time="3408.114"/>
donc il y a aucune euh il y a aucun symbole qui précède dans ces cas-là.
<Sync time="3411.940"/>
donc on corrige encore, on met une alternative, on dit
<Sync time="3415.814"/>
que
<Sync time="3416.990"/>
soit il apparaît en début de texte,
<Sync time="3419.346"/>
soit il est précédé par quelque chose qui n'est pas une lettre,
<Sync time="3423.464"/>
*ce que l'on cherche est suivi par quelque chose qui n'est pas une lettre.
<Sync time="3427.184"/>
donc vous voyez, on peut faire des () fai() rien *peut rechercher quelque chose
<Sync time="3432.953"/>
ça prend un certain temps, *parce qu'il faut le raffiner
<Sync time="3435.703"/>
de manière à obtenir vraiment ce que l'on veut obtenir
<Sync time="3439.485"/>
et on obtient des choses qui sont quand même relativement complexes
<Sync time="3442.735"/>
pour une recherche assez simple au départ.
<Sync time="3445.205"/>
hein
<Sync time="3446.611"/>
donc le problème, il est là :
<Sync time="3448.346"/>
c'est que quand vous faites des expressions régulières, vous allez avoir
<Sync time="3453.378"/>
vous êtes en face de deux types d'erreur :
<Sync time="3456.736"/>
la première erreur, c'est les chaînes trouvées
<Sync time="3459.643"/>
que l'on n'aurait pas dû trouver
<Sync time="3461.704"/>
*c'est-à-dire
<Sync time="3462.373"/>
s() les chaînes que vous
<Sync time="3464.301"/>
retourne votre expression régulière, et dont vous ne voulez pas
<Sync time="3467.589"/>
comme lessive 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 faiblesse,
<Sync time="3470.201"/>
ça, c'est ce qu'on appelle les faux positifs
<Sync time="3474.014"/>
et d'autre part
<Sync time="3475.499"/>
vous n'allez pas trouver des chaînes que vous auriez bien voulu trouver
<Sync time="3479.891"/>
hein, et ça c'est ce qu'on appelle les faux négatifs.
<Sync time="3486.830"/>
et
<Sync time="3488.347"/>
faire une bonne application de recherche
<Sync time="3492.051"/>
dans les textes,
<Sync time="3493.342"/>
avec les expression régulières
<Sync time="3496.472"/>
c'est
<Sync time="3497.191"/>
avoir le moins d'erreurs possibles
<Sync time="3501.070"/>
mais avoir le moins d'erreurs possibles, ça veut dire prendre en en compte deux aspects qui sont totalement antagonistes.
<Sync time="3508.497"/>
d'un côté,
<Sync time="3509.621"/>
vous voulez améliorer l'exactitude,
<Sync time="3512.606"/>
c'est-à-dire être le plus précis possible, ne pas retourner
<Sync time="3516.81"/>
de mauvaises chaînes, *c'est-à-dire réduire les faux positifs
<Sync time="3520.480"/>
et d'un autre côté,
<Sync time="3521.839"/>
améliorer la couverture
<Sync time="3524.100"/>
c'est-à-dire réduire les faux négatifs
<Sync time="3528.841"/>
c'est-à-dire récupérer le plus possible les chaînes qui vous intéressent.
<Sync time="3533.378"/>
et c'est un compromis :
<Sync time="3534.911"/>
vous n'arriverez jamais, en traitement de la langue,
<Sync time="3538.041"/>
à tout avoir
<Sync time="3540.187"/>
d'un point de vue correct ;
<Sync time="3542.182"/>
ça sera toujours une balance entre les deux.
<Sync time="3545.550"/>
entre : est-ce que vous voulez avoir le plus de couverture possible,
<Sync time="3549.035"/>
ou le plus de précision possible ?
<Sync time="3551.192"/>
et ça dépendra des applications.
<Sync time="3553.627"/>

<Event desc="bb" type="noise" extent="instantaneous"/>

<Sync time="3556.897"/>
alors
<Sync time="3558.163"/>
jusqu'à présent on n'a fait que rechercher, maintenant on peut rechercher et remplacer.
<Sync time="3563.810"/>
ça se fait d'une manière très simple :
<Sync time="3567.860"/>
on utilise un s devant
<Sync time="3571.000"/>
l'expression régulière, donc on met ce que l'on cherche
<Sync time="3574.205"/>
ici,
<Sync time="3575.473"/>
et dans la deuxième, on indique par quoi on veut le remplacer.
<Sync time="3580.658"/>
et puis il y a des petites subtilités euh comme euh si on rajoute un g à l'avant, ça le fait globalement, ça le fait pas une fois, ça le fait
<Sync time="3587.769"/>
pour toutes les occurrences,
<Sync time="3589.410"/>
et on rajoute le i : quelle que soit la casse, et cetera.
<Sync time="3595.484"/>
et puis
<Sync time="3596.300"/>
dans les expressions régulières, vous avez aussi la possibilité d'utiliser des variables
<Sync time="3601.960"/>
alors vous *avez le droit jusqu'à neuf variables
<Sync time="3605.695"/>
et les variables
<Sync time="3607.330"/>
dès que vous mettez une parenthèse au sein d'une expression *régulière, vous avez une variable.
<Sync time="3612.570"/>
*d'accord ?
<Sync time="3613.368"/>
donc ici
<Sync time="3614.688"/>
j'ai une parenthèse ici
<Sync time="3616.759"/>
donc ça veut dire : j'ai déclaré
<Sync time="3618.482"/>
une variable un.
<Sync time="3621.874"/>
alors qu'est-ce que j'indique ?
<Sync time="3623.439"/>
je recherche dans un texte une chaîne de caractères qui est une petite
<Sync time="3628.149"/>
espace suivi de n'importe quoi
<Sync time="3630.645"/>
qui est constitué au moins d'une lettre ;
<Sync time="3632.770"/>
un point, c'est n'importe quelle lettre
<Sync time="3634.849"/>
qui apparaît au moins une fois et puis autant de fois qu'on veut.
<Sync time="3638.130"/>
et cette chaîne de caractères, je vais la remplacer par une
<Sync time="3642.643"/>
ce que j'ai trouvé ici,
<Sync time="3644.581"/>
et le deux t e.
<Sync time="3647.590"/>
et donc ce genre euh de d'expression régulière avec remplacement,
<Sync time="3652.753"/>
ça vous permet de générer à partir de "une petite fille"
<Sync time="3656.860"/>
une fillette.
<Sync time="3659.913"/>
hein
<Sync time="3660.868"/>
*une chose toute simple.
<Sync time="3664.623"/>
alors reprenons eliza, maintenant qu'on sait faire des expressions régulières.
<Sync time="3669.310"/>
vous allez voir, on s'en sort
<Sync time="3671.523"/>
avec des choses assez simples.
<Sync time="3673.920"/>
je suis très angoissé, pourquoi dites-vous que vous êtes très angoissé,
<Sync time="3678.190"/>
comment est-ce qu'on fait ça avec une expression régulière ?
<Sync time="3682.768"/>
première étape : je remplace dans le texte
<Sync time="3686.222"/>
que je () l'utilisateur, enfin le patient
<Sync time="3689.850"/>
vient de saisir, je remplace les pronoms de la première personne du singulier
<Sync time="3694.570"/>
par les pronoms de la deuxième personne du pluriel, et ça ça se fait
<Sync time="3698.379"/>
avec une expression régulière, donc je mets
<Sync time="3701.730"/>
je dis : remplacez-moi la chaîne "je suis"
<Sync time="3705.096"/>
donc ça, c'est un autre type d'ancre mais euh c'est
<Sync time="3708.768"/>
c'est c'est c'est comme le chapeau et et dollar
<Sync time="3711.625"/>
par "vous êtes"
<Sync time="3713.000"/>
et faites-le autant de fois que j'ai rencontré "je suis" dans le texte.
<Sync time="3716.060"/>
deuxième expression régulière : je remplace tout ce qui est "ma"
<Sync time="3721.630"/>
par "votre"
<Sync time="3722.770"/>
et je le fais autant de fois
<Sync time="3726.309"/>
que j'ai rencontré ça dans le texte.
<Sync time="3728.140"/>
donc je remp() je stocke le texte, je fais mes remplacements
<Sync time="3732.805"/>
et deuxième étape, je génère la réponse à l'aide encore d'une expression régulière.
<Sync time="3738.190"/>
donc par exemple, si j'ai rencontré vous êtes
<Sync time="3741.825"/>
angoissé
<Sync time="3743.580"/>
ou vous êtes triste, alors ça je peux mettre ça avec une euh alternative
<Sync time="3749.144"/>
entre parenthèses
<Sync time="3750.566"/>
éventuellement très angoissé ou très triste hein
<Sync time="3753.786"/>
ça c'est optionnel
<Sync time="3756.003"/>
donc tout ça, c'est stocké dans une variable :
<Sync time="3758.532"/>
première parenthèse, je stocke tout ça
<Sync time="3761.640"/>
hein, donc 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 variable 
<Event desc="pi" type="pronounce" extent="instantaneous"/>

<Sync time="3763.859"/>
et donc
<Sync time="3764.871"/>
suivi
<Sync time="3765.683"/>
précédé de n'importe quoi et précédé de n'importe quoi
<Sync time="3768.927"/>
et donc je génère : pourquoi dites-vous que
<Sync time="3772.200"/>
tout ce que j'ai rencontré
<Sync time="3773.825"/>
précédemment.
<Sync time="3774.856"/>
et ça vous génère : pourquoi dites-vous que vous êtes triste ?
<Sync time="3779.216"/>
et la troisième étape, c'est l'utilisation de probabilités pour choisir parmi plusieurs remplacements possibles
<Sync time="3785.202"/>
hein, *parce que
<Sync time="3786.171"/>
évidemment, il y aura toujours euh plusieurs possibilités.
<Sync time="3790.549"/>
et vous voyez qu'avec cet outil relativement simple,
<Sync time="3793.534"/>
on peut faire déjà des premiers dialogues homme machine, rudimentaires certes
<Sync time="3797.832"/>
mais un peu bluffants
<Sync time="3800.096"/>
et
<Sync time="3800.841"/>
euh eliza
<Sync time="3806.010"/>
c'est simplement des expressions régulières derrière.
<Sync time="3809.343"/>
hein
<Sync time="3810.054"/>
et donc vous pouvez faire beaucoup de choses avec les expression régulières
<Sync time="3813.540"/>
pour manipuler du texte.
<Sync time="3821.463"/>
alors
<Sync time="3822.51"/>
on va voir rapidement les automates euh finis
<Sync time="3827.511"/>
c'est
<Sync time="3828.793"/>

<Event desc="bb" type="noise" extent="instantaneous"/>

<Sync time="3830.355"/>
c'est défini
<Sync time="3831.747"/>
c'est une autre manière euh
<Sync time="3833.857"/>
d'exprimer les expressions régulières ; c'est exactement la même chose, hein,
<Sync time="3837.770"/>
mais c'est exprimé d'une autre manière.
<Sync time="3840.748"/>
alors les automates finis, on les utilise en traitement de la langue, mais on les utilise partout en informatique hein.
<Sync time="3847.484"/>
si vous êtes informaticiens, c'est euh la structure de base
<Sync time="3851.797"/>
euh
<Sync time="3855.720"/>
une des structures de base en informatique
<Sync time="3858.799"/>
donc vous allez en faire tout le temps, hein
<Sync time="3861.770"/>
pas seulement traitement de la langue euh partout, quoi.
<Sync time="3865.240"/>
alors qu'est-ce que c'est que un automate
<Sync time="3867.991"/>
à état fini ? bah c'est une machine de turing
<Sync time="3871.321"/>
un peu différente
<Sync time="3872.508"/>
hein
<Sync time="3873.600"/>
alors je vous montre comment ça fonctionne :
<Sync time="3879.728"/>
donc vous avez des états dans une machine
<Sync time="3883.01"/>
donc les états, c'est des ronds
<Sync time="3884.724"/>
d'accord ? donc là, dans mon état
<Sync time="3887.648"/>
j'ai trois états.
<Sync time="3891.227"/>
vous avez un état initial
<Sync time="3893.212"/>
par lequel on rentre dans la machine
<Sync time="3895.203"/>
qui est indiqué par la flèche,
<Sync time="3898.047"/>
et un état final
<Sync time="3900.22"/>
dans lequel on va s'arrêter, la machine va s'arrêter.
<Sync time="3903.705"/>
et pour passer d'un état à l'autre,
<Sync time="3906.568"/>
on prend des transitions.
<Sync time="3908.909"/>
d'accord ?
<Sync time="3910.471"/>
bon
<Sync time="3911.018"/>
alors nous, on va se donner un langage assez simple, on prend le langage du mouton
<Sync time="3915.608"/>
hein
<Sync time="3916.220"/>
donc le langage du mouton, c'est bêh
<Sync time="3918.770"/>
bêh deux fois, bêh trois fois, bêh quatre fois hein
<Sync time="3922.193"/>
donc on peut
<Sync time="3923.315"/>
faire une expression régulière pour décrire le
<Sync time="3925.94"/>
le langage du mouton
<Sync time="3927.860"/>
qui se dit bah début de chaîne
<Sync time="3930.049"/>
j'ai un bêh
<Sync time="3931.565"/>
un plus, donc ça apparaît au moins une fois, et autant de fois qu'on veut
<Sync time="3934.925"/>
et une fin de chaîne.
<Sync time="3936.270"/>
d'accord ?
<Sync time="3937.503"/>
expression régulière très simple.
<Sync time="3939.580"/>
alors comment se lit l'automate ?
<Sync time="3942.054"/>
je rentre ici :
<Sync time="3943.740"/>
si je lis un bêh, je passe dans q un ;
<Sync time="3946.906"/>
si je lis un êh
<Sync time="3949.482"/>
je passe dans q deux.
<Sync time="3951.107"/>
le q deux
<Sync time="3952.560"/>
est un état final, donc ma chaîne est acceptée.
<Sync time="3956.720"/>
si je relis un bêh, je passe en q un
<Sync time="3960.500"/>
et si je relis un
<Sync time="3962.230"/>
de nouveau
<Sync time="3963.183"/>
un êh, je passe en q deux, ma chaîne est acceptée
<Sync time="3965.637"/>
et je peux recontinuer.
<Sync time="3967.434"/>
d'accord ? c'est une machine assez simple
<Event desc="mic" type="noise" extent="previous"/>
.
<Sync time="3971.248"/>
alors
<Sync time="3973.329"/>
qu'est-ce que c'est qu'un automate à état fini ? ben ça va être quelque chose, c'est un objet
<Sync time="3977.587"/>
formel
<Sync time="3979.642"/>
où vous allez avoir un ensemble d'états q
<Sync time="3983.261"/>
un alphabet *fini qu'on appelle sigma
<Sync time="3986.834"/>
qui peut être par exemple euh
<Sync time="3989.037"/>
euh votre code hein
<Sync time="3990.975"/>
un état initial
<Sync time="3992.800"/>
un ensemble d'états finaux, et puis une fonction de transition
<Sync time="3997.120"/>
qui prend en entrée un état et une lettre
<Sync time="4000.063"/>
et qui vous emmène vers un autre état.
<Sync time="4003.923"/>
donc
<Sync time="4004.767"/>
on peut définir
<Sync time="4009.390"/>

<Event desc="pif" type="pronounce" extent="instantaneous"/>
 on peut définir un automate, l'automate du mouton
<Sync time="4013.950"/>
du langage du mouton
<Sync time="4016.078"/>
avec une table comme ça
<Sync time="4018.101"/>
donc ici on met les états :
<Sync time="4020.133"/>
q zéro, q un, q deux.
<Sync time="4022.720"/>
on indique
<Sync time="4026.150"/>
que q deux est terminal
<Sync time="4029.039"/>
avec les deux points
<Sync time="4031.946"/>
et ici on indique les lettres qui vont être lues
<Sync time="4034.932"/>
par l'automate.
<Sync time="4036.970"/>
alors comment ça marche ?
<Sync time="4038.409"/>
si je suis en q zéro
<Sync time="4041.350"/>
état initial
<Sync time="4043.533"/>
et que je lis un bêh, je vais en q un ;
<Sync time="4047.595"/>
si je suis en q zéro,
<Sync time="4049.680"/>
état initial, et que je lis un êh, je vais nulle part
<Sync time="4056.463"/>
et je reste () je mets un zéro.
<Sync time="4059.385"/>
une fois que je suis en un,
<Sync time="4061.487"/>
si je lis un bêh
<Sync time="4063.670"/>
je vais nulle part donc je mets un zéro ;
<Sync time="4067.420"/>
si je lis un êh,
<Sync time="4069.659"/>
je passe en q deux.
<Sync time="4072.093"/>
et le dernier état qui est l'état final
<Sync time="4074.780"/>
q deux
<Sync time="4075.630"/>
si je lis un bêh, je retourne en q, un et si je lis un êh,
<Sync time="4079.753"/>
je vais nulle part.
<Sync time="4083.925"/>
donc la reconnaissance de chaînes, qui est la même manière de reconnaître une chaîne que dans l'expression régulière,
<Sync time="4091.297"/>
elle est acceptée par l'automate
<Sync time="4093.910"/>
si je commence à l'état initial,
<Sync time="4097.846"/>
j'examine la chaîne en entrée,
<Sync time="4100.259"/>
je consulte la table des transitions
<Sync time="4103.847"/>
si jamais je trouve une transition, je vais à l'état suivant
<Sync time="4107.208"/>
et j'avance le curseur sur la chaîne
<Sync time="4109.400"/>
et ça
<Sync time="4110.588"/>
jusqu'à la fin de la chaîne.
<Sync time="4114.011"/>
alors voilà un exemple :
<Sync time="4116.682"/>
je démarre () la chaîne elle est représentée sur un espèce de ruban, je démarre en q zéro
<Sync time="4122.261"/>
et si jamais je me trouve dans un état
<Sync time="4124.84"/>
à la fin de ma chaîne
<Sync time="4126.653"/>
qui n'est pas
<Sync time="4127.830"/>
l'état final,
<Sync time="4129.283"/>
je refuse la chaîne.
<Sync time="4131.924"/>
d'accord ?
<Sync time="4133.862"/>
si à l'inverse,
<Sync time="4136.210"/>
en examinant tout ma chaîne, quand j'arrive à la fin de la chaîne, je me retrouve dans un état final,
<Sync time="4143.455"/>
j'accepte la chaîne.
<Sync time="4145.877"/>
ça va ?
<Sync time="4149.010"/>
alors vous êtes prêts pour l'algo ?
<Sync time="4154.386"/>
hop
<Sync time="4156.281"/>
alors
<Sync time="4158.051"/>
l'algo
<Sync time="4160.067"/>
c'est une fonction
<Sync time="4162.050"/>
qui prend en entrée une chaîne de caractères
<Sync time="4165.989"/>
et un automate
<Sync time="4167.851"/>
l'automate étant défini par
<Sync time="4169.890"/>
le cinquplet
<Sync time="4171.156"/>
hein
<Sync time="4172.760"/>
et qui renvoie
<Sync time="4174.292"/>
soit vrai, soit faux
<Sync time="4176.160"/>
soit on reconnaît la chaîne, soit on la reconnaît pas.
<Sync time="4181.320"/>
on a () on va manipuler deux tableaux :
<Sync time="4185.490"/>
le premier tableau, ça va être
<Sync time="4188.632"/>
chaîne
<Sync time="4190.476"/>
qui stocke la chaîne de caractères.
<Sync time="4193.481"/>
donc la position zéro de la chaîne, ça va être la première lettre ; la position un, ça va être la deuxième lettre, et cetera.
<Sync time="4201.161"/>
et on va avoir un deuxième tableau
<Sync time="4204.067"/>
qui est la table des transitions
<Sync time="4206.755"/>
qui prend
<Sync time="4209.459"/>
à deux dimensions, vous avez vu les tableaux à deux dimensions hein ?
<Sync time="4213.031"/>
qui prend
<Sync time="4214.150"/>
en première dimension les états,
<Sync time="4216.398"/>
et en deuxième dimension
<Sync time="4219.607"/>
les lettres qui sont dans la chaîne
<Sync time="4223.920"/>
et qui indiquent, pour chaque dimension,
<Sync time="4227.225"/>
l'état final ; c'est notre fameuse
<Sync time="4230.6"/>
table des transitions ici
<Sync time="4232.741"/>
hein,
<Sync time="4233.570"/>
que l'on exprime sous forme de tableau à deux dimensions.
<Sync time="4237.958"/>
alors notre algo, on y va :
<Sync time="4240.028"/>
on démarre
<Sync time="4241.965"/>
avec un index et un état.
<Sync time="4244.842"/>
l'index et l'état vont changer à chaque fois ;
<Sync time="4249.394"/>
et on a une boucle
<Sync time="4251.923"/>
donc on répète ces opérations tant qu'on n'est pas ()
<Sync time="4256.933"/>
tant qu'on n'a pas rencontré la condition d'arrêt.
<Sync time="4259.84"/>
la condition d'arrêt, c'est la fin de chaîne.
<Sync time="4263.240"/>
donc si on arrive en fin de chaîne,
<Sync time="4265.532"/>
si notre état courant est un état final, alors on renvoie accepter ;
<Sync time="4270.174"/>
si notre état courant
<Sync time="4271.979"/>
n'est pas un état final, alors on envoie refuser.
<Sync time="4277.258"/>
et si on n'est pas
<Sync time="4278.868"/>
à la fin de chaîne, on examine
<Sync time="4281.4"/>
la table des transitions.
<Sync time="4283.200"/>
donc on a notre table des *transitions, avec l'état courant
<Sync time="4287.280"/>
et l'index de la chaîne où on 
<Event desc="pi" type="pronounce" extent="instantaneous"/>
 trouve
<Sync time="4290.610"/>
si on trouve zéro, il y a pas de *transition
<Sync time="4293.880"/>
on renvoie refuser ;
<Sync time="4296.337"/>
et si on trouve
<Sync time="4297.899"/>
une transition
<Sync time="4299.149"/>
eh ben cette transition devient l'*état courant
<Sync time="4302.011"/>
et on incrémente
<Sync time="4303.828"/>
l'index.
<Sync time="4307.485"/>
ça va ?
<Sync time="4310.094"/>
donc
<Sync time="4310.767"/>
je vous recommande d'essayer de faire tourner
<Sync time="4314.336"/>
cet algo
<Sync time="4315.940"/>
sur euh le langage du mouton
<Sync time="4318.610"/>
qui est assez simple
<Sync time="4319.782"/>
hein, en prenant deux bêh
<Sync time="4321.638"/>
ça devrait aller
<Sync time="4323.451"/>
et
<Sync time="4324.358"/>
vous verrez
<Sync time="4325.546"/>
que
<Sync time="4327.408"/>
ça fait exactement ce que je vous ai présenté ici
<Sync time="4331.003"/>
sur ces
<Sync time="4332.316"/>
deux exemples.
<Sync time="4334.457"/>
voilà
<Sync time="4335.225"/>
donc on s'arrête ici.
</Turn>
</Section>
</Episode>
</Trans>
